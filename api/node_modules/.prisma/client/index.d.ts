
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Obra
 * 
 */
export type Obra = $Result.DefaultSelection<Prisma.$ObraPayload>
/**
 * Model Material
 * 
 */
export type Material = $Result.DefaultSelection<Prisma.$MaterialPayload>
/**
 * Model Proveedor
 * 
 */
export type Proveedor = $Result.DefaultSelection<Prisma.$ProveedorPayload>
/**
 * Model Frente
 * 
 */
export type Frente = $Result.DefaultSelection<Prisma.$FrentePayload>
/**
 * Model MaterialGroup
 * 
 */
export type MaterialGroup = $Result.DefaultSelection<Prisma.$MaterialGroupPayload>
/**
 * Model Move
 * 
 */
export type Move = $Result.DefaultSelection<Prisma.$MovePayload>
/**
 * Model ExpenseCategory
 * 
 */
export type ExpenseCategory = $Result.DefaultSelection<Prisma.$ExpenseCategoryPayload>
/**
 * Model Income
 * 
 */
export type Income = $Result.DefaultSelection<Prisma.$IncomePayload>
/**
 * Model Expense
 * 
 */
export type Expense = $Result.DefaultSelection<Prisma.$ExpensePayload>
/**
 * Model DailyCashRendition
 * 
 */
export type DailyCashRendition = $Result.DefaultSelection<Prisma.$DailyCashRenditionPayload>
/**
 * Model DailyCashExpense
 * 
 */
export type DailyCashExpense = $Result.DefaultSelection<Prisma.$DailyCashExpensePayload>
/**
 * Model AdminSetting
 * 
 */
export type AdminSetting = $Result.DefaultSelection<Prisma.$AdminSettingPayload>
/**
 * Model Employee
 * 
 */
export type Employee = $Result.DefaultSelection<Prisma.$EmployeePayload>
/**
 * Model EmployeeAccumulationPayment
 * 
 */
export type EmployeeAccumulationPayment = $Result.DefaultSelection<Prisma.$EmployeeAccumulationPaymentPayload>
/**
 * Model AttendanceRecord
 * 
 */
export type AttendanceRecord = $Result.DefaultSelection<Prisma.$AttendanceRecordPayload>
/**
 * Model PayrollPeriod
 * 
 */
export type PayrollPeriod = $Result.DefaultSelection<Prisma.$PayrollPeriodPayload>
/**
 * Model PayrollEntry
 * 
 */
export type PayrollEntry = $Result.DefaultSelection<Prisma.$PayrollEntryPayload>
/**
 * Model PayrollAdjustment
 * 
 */
export type PayrollAdjustment = $Result.DefaultSelection<Prisma.$PayrollAdjustmentPayload>
/**
 * Model Partner
 * 
 */
export type Partner = $Result.DefaultSelection<Prisma.$PartnerPayload>
/**
 * Model PartnerLoan
 * 
 */
export type PartnerLoan = $Result.DefaultSelection<Prisma.$PartnerLoanPayload>
/**
 * Model FoodIngredient
 * 
 */
export type FoodIngredient = $Result.DefaultSelection<Prisma.$FoodIngredientPayload>
/**
 * Model FoodIngredientCost
 * 
 */
export type FoodIngredientCost = $Result.DefaultSelection<Prisma.$FoodIngredientCostPayload>
/**
 * Model FoodRecipe
 * 
 */
export type FoodRecipe = $Result.DefaultSelection<Prisma.$FoodRecipePayload>
/**
 * Model FoodRecipeItem
 * 
 */
export type FoodRecipeItem = $Result.DefaultSelection<Prisma.$FoodRecipeItemPayload>
/**
 * Model FoodRecipeCost
 * 
 */
export type FoodRecipeCost = $Result.DefaultSelection<Prisma.$FoodRecipeCostPayload>
/**
 * Model FoodCostPool
 * 
 */
export type FoodCostPool = $Result.DefaultSelection<Prisma.$FoodCostPoolPayload>
/**
 * Model FoodMealPlan
 * 
 */
export type FoodMealPlan = $Result.DefaultSelection<Prisma.$FoodMealPlanPayload>
/**
 * Model FoodMealPlanEntry
 * 
 */
export type FoodMealPlanEntry = $Result.DefaultSelection<Prisma.$FoodMealPlanEntryPayload>
/**
 * Model QuotationProcess
 * 
 */
export type QuotationProcess = $Result.DefaultSelection<Prisma.$QuotationProcessPayload>
/**
 * Model QuotationBaselineItem
 * 
 */
export type QuotationBaselineItem = $Result.DefaultSelection<Prisma.$QuotationBaselineItemPayload>
/**
 * Model Quotation
 * 
 */
export type Quotation = $Result.DefaultSelection<Prisma.$QuotationPayload>
/**
 * Model QuotationItem
 * 
 */
export type QuotationItem = $Result.DefaultSelection<Prisma.$QuotationItemPayload>
/**
 * Model QuotationAttachment
 * 
 */
export type QuotationAttachment = $Result.DefaultSelection<Prisma.$QuotationAttachmentPayload>
/**
 * Model PurchaseOrderLog
 * 
 */
export type PurchaseOrderLog = $Result.DefaultSelection<Prisma.$PurchaseOrderLogPayload>
/**
 * Model PurchaseOrderLine
 * 
 */
export type PurchaseOrderLine = $Result.DefaultSelection<Prisma.$PurchaseOrderLinePayload>
/**
 * Model PurchaseDeliveryLog
 * 
 */
export type PurchaseDeliveryLog = $Result.DefaultSelection<Prisma.$PurchaseDeliveryLogPayload>
/**
 * Model PurchaseDeliveryItem
 * 
 */
export type PurchaseDeliveryItem = $Result.DefaultSelection<Prisma.$PurchaseDeliveryItemPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const AssetStatus: {
  IN_WAREHOUSE: 'IN_WAREHOUSE',
  OUT_ON_FIELD: 'OUT_ON_FIELD'
};

export type AssetStatus = (typeof AssetStatus)[keyof typeof AssetStatus]


export const QuotationProcessStatus: {
  DRAFT: 'DRAFT',
  ACTIVE: 'ACTIVE',
  CLOSED: 'CLOSED',
  ARCHIVED: 'ARCHIVED'
};

export type QuotationProcessStatus = (typeof QuotationProcessStatus)[keyof typeof QuotationProcessStatus]


export const QuotationStatus: {
  DRAFT: 'DRAFT',
  RECEIVED: 'RECEIVED',
  SHORTLISTED: 'SHORTLISTED',
  AWARDED: 'AWARDED',
  DISCARDED: 'DISCARDED'
};

export type QuotationStatus = (typeof QuotationStatus)[keyof typeof QuotationStatus]


export const QuotationAttachmentType: {
  BASE_FILE: 'BASE_FILE',
  SUPPLIER_FILE: 'SUPPLIER_FILE',
  PARSED_SNAPSHOT: 'PARSED_SNAPSHOT'
};

export type QuotationAttachmentType = (typeof QuotationAttachmentType)[keyof typeof QuotationAttachmentType]


export const MoveType: {
  IN: 'IN',
  OUT: 'OUT'
};

export type MoveType = (typeof MoveType)[keyof typeof MoveType]


export const DocType: {
  FACTURA: 'FACTURA',
  BOLETA: 'BOLETA',
  RECIBO: 'RECIBO',
  OTRO: 'OTRO'
};

export type DocType = (typeof DocType)[keyof typeof DocType]


export const IncomeStatus: {
  EMITIDO: 'EMITIDO',
  COBRADO: 'COBRADO',
  ANULADO: 'ANULADO'
};

export type IncomeStatus = (typeof IncomeStatus)[keyof typeof IncomeStatus]


export const ExpenseType: {
  DIRECTO: 'DIRECTO',
  INDIRECTO: 'INDIRECTO'
};

export type ExpenseType = (typeof ExpenseType)[keyof typeof ExpenseType]


export const VariableType: {
  FIJO: 'FIJO',
  VARIABLE: 'VARIABLE'
};

export type VariableType = (typeof VariableType)[keyof typeof VariableType]


export const PaymentMethod: {
  EFECTIVO: 'EFECTIVO',
  TRANSFERENCIA: 'TRANSFERENCIA',
  TARJETA: 'TARJETA',
  YAPE: 'YAPE',
  PLIN: 'PLIN',
  OTRO: 'OTRO'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const ExpenseKind: {
  OPERATIVO: 'OPERATIVO',
  ADMINISTRATIVO: 'ADMINISTRATIVO',
  MATERIAL_COMPRA: 'MATERIAL_COMPRA',
  MATERIAL_CONSUMO: 'MATERIAL_CONSUMO',
  FINANCIERO: 'FINANCIERO',
  OTROS: 'OTROS'
};

export type ExpenseKind = (typeof ExpenseKind)[keyof typeof ExpenseKind]


export const DocumentType: {
  DNI: 'DNI',
  CE: 'CE',
  PASS: 'PASS',
  OTRO: 'OTRO'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]


export const PensionSystem: {
  NINGUNO: 'NINGUNO',
  ONP: 'ONP',
  AFP: 'AFP',
  SNP: 'SNP',
  EXONERADO: 'EXONERADO'
};

export type PensionSystem = (typeof PensionSystem)[keyof typeof PensionSystem]


export const AttendanceStatus: {
  PRESENT: 'PRESENT',
  TARDY: 'TARDY',
  ABSENT: 'ABSENT',
  PERMISSION: 'PERMISSION'
};

export type AttendanceStatus = (typeof AttendanceStatus)[keyof typeof AttendanceStatus]


export const EmployeeArea: {
  OPERATIVE: 'OPERATIVE',
  ADMINISTRATIVE: 'ADMINISTRATIVE'
};

export type EmployeeArea = (typeof EmployeeArea)[keyof typeof EmployeeArea]


export const BankType: {
  BCP: 'BCP',
  INTERBANK: 'INTERBANK',
  SCOTIABANK: 'SCOTIABANK',
  BANCO_NACION: 'BANCO_NACION',
  YAPE_PLIN: 'YAPE_PLIN',
  OTROS: 'OTROS'
};

export type BankType = (typeof BankType)[keyof typeof BankType]


export const PayrollPeriodStatus: {
  OPEN: 'OPEN',
  PROCESSED: 'PROCESSED',
  CLOSED: 'CLOSED'
};

export type PayrollPeriodStatus = (typeof PayrollPeriodStatus)[keyof typeof PayrollPeriodStatus]


export const PayrollAdjustmentType: {
  BONUS: 'BONUS',
  DEDUCTION: 'DEDUCTION',
  ADVANCE: 'ADVANCE'
};

export type PayrollAdjustmentType = (typeof PayrollAdjustmentType)[keyof typeof PayrollAdjustmentType]


export const PartnerLoanStatus: {
  PENDING: 'PENDING',
  RENDIDO: 'RENDIDO',
  DEVUELTO: 'DEVUELTO'
};

export type PartnerLoanStatus = (typeof PartnerLoanStatus)[keyof typeof PartnerLoanStatus]


export const FoodMealType: {
  DESAYUNO: 'DESAYUNO',
  ALMUERZO: 'ALMUERZO',
  CENA: 'CENA',
  REFRIGERIO: 'REFRIGERIO',
  COMPONENTE: 'COMPONENTE'
};

export type FoodMealType = (typeof FoodMealType)[keyof typeof FoodMealType]


export const FoodCostPeriod: {
  POR_RACION: 'POR_RACION',
  POR_SERVICIO: 'POR_SERVICIO',
  DIARIO: 'DIARIO',
  SEMANAL: 'SEMANAL',
  MENSUAL: 'MENSUAL'
};

export type FoodCostPeriod = (typeof FoodCostPeriod)[keyof typeof FoodCostPeriod]


export const FoodCostPoolType: {
  MANO_OBRA: 'MANO_OBRA',
  ALQUILER: 'ALQUILER',
  SERVICIOS_BASICOS: 'SERVICIOS_BASICOS',
  LOGISTICA: 'LOGISTICA',
  TRANSPORTE: 'TRANSPORTE',
  COMBUSTIBLE: 'COMBUSTIBLE',
  SUMINISTROS: 'SUMINISTROS',
  OTROS: 'OTROS'
};

export type FoodCostPoolType = (typeof FoodCostPoolType)[keyof typeof FoodCostPoolType]


export const FoodCostLineType: {
  MANO_OBRA: 'MANO_OBRA',
  INDIRECTO: 'INDIRECTO',
  TRANSPORTE: 'TRANSPORTE',
  LOGISTICA: 'LOGISTICA',
  SUMINISTROS: 'SUMINISTROS',
  OTROS: 'OTROS'
};

export type FoodCostLineType = (typeof FoodCostLineType)[keyof typeof FoodCostLineType]


export const PoolAllocationMethod: {
  RACIONES: 'RACIONES',
  BLOQUES: 'BLOQUES',
  MINUTOS: 'MINUTOS'
};

export type PoolAllocationMethod = (typeof PoolAllocationMethod)[keyof typeof PoolAllocationMethod]

}

export type AssetStatus = $Enums.AssetStatus

export const AssetStatus: typeof $Enums.AssetStatus

export type QuotationProcessStatus = $Enums.QuotationProcessStatus

export const QuotationProcessStatus: typeof $Enums.QuotationProcessStatus

export type QuotationStatus = $Enums.QuotationStatus

export const QuotationStatus: typeof $Enums.QuotationStatus

export type QuotationAttachmentType = $Enums.QuotationAttachmentType

export const QuotationAttachmentType: typeof $Enums.QuotationAttachmentType

export type MoveType = $Enums.MoveType

export const MoveType: typeof $Enums.MoveType

export type DocType = $Enums.DocType

export const DocType: typeof $Enums.DocType

export type IncomeStatus = $Enums.IncomeStatus

export const IncomeStatus: typeof $Enums.IncomeStatus

export type ExpenseType = $Enums.ExpenseType

export const ExpenseType: typeof $Enums.ExpenseType

export type VariableType = $Enums.VariableType

export const VariableType: typeof $Enums.VariableType

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type ExpenseKind = $Enums.ExpenseKind

export const ExpenseKind: typeof $Enums.ExpenseKind

export type DocumentType = $Enums.DocumentType

export const DocumentType: typeof $Enums.DocumentType

export type PensionSystem = $Enums.PensionSystem

export const PensionSystem: typeof $Enums.PensionSystem

export type AttendanceStatus = $Enums.AttendanceStatus

export const AttendanceStatus: typeof $Enums.AttendanceStatus

export type EmployeeArea = $Enums.EmployeeArea

export const EmployeeArea: typeof $Enums.EmployeeArea

export type BankType = $Enums.BankType

export const BankType: typeof $Enums.BankType

export type PayrollPeriodStatus = $Enums.PayrollPeriodStatus

export const PayrollPeriodStatus: typeof $Enums.PayrollPeriodStatus

export type PayrollAdjustmentType = $Enums.PayrollAdjustmentType

export const PayrollAdjustmentType: typeof $Enums.PayrollAdjustmentType

export type PartnerLoanStatus = $Enums.PartnerLoanStatus

export const PartnerLoanStatus: typeof $Enums.PartnerLoanStatus

export type FoodMealType = $Enums.FoodMealType

export const FoodMealType: typeof $Enums.FoodMealType

export type FoodCostPeriod = $Enums.FoodCostPeriod

export const FoodCostPeriod: typeof $Enums.FoodCostPeriod

export type FoodCostPoolType = $Enums.FoodCostPoolType

export const FoodCostPoolType: typeof $Enums.FoodCostPoolType

export type FoodCostLineType = $Enums.FoodCostLineType

export const FoodCostLineType: typeof $Enums.FoodCostLineType

export type PoolAllocationMethod = $Enums.PoolAllocationMethod

export const PoolAllocationMethod: typeof $Enums.PoolAllocationMethod

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Obras
 * const obras = await prisma.obra.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Obras
   * const obras = await prisma.obra.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.obra`: Exposes CRUD operations for the **Obra** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Obras
    * const obras = await prisma.obra.findMany()
    * ```
    */
  get obra(): Prisma.ObraDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.material`: Exposes CRUD operations for the **Material** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Materials
    * const materials = await prisma.material.findMany()
    * ```
    */
  get material(): Prisma.MaterialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.proveedor`: Exposes CRUD operations for the **Proveedor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Proveedors
    * const proveedors = await prisma.proveedor.findMany()
    * ```
    */
  get proveedor(): Prisma.ProveedorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.frente`: Exposes CRUD operations for the **Frente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Frentes
    * const frentes = await prisma.frente.findMany()
    * ```
    */
  get frente(): Prisma.FrenteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.materialGroup`: Exposes CRUD operations for the **MaterialGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaterialGroups
    * const materialGroups = await prisma.materialGroup.findMany()
    * ```
    */
  get materialGroup(): Prisma.MaterialGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.move`: Exposes CRUD operations for the **Move** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Moves
    * const moves = await prisma.move.findMany()
    * ```
    */
  get move(): Prisma.MoveDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.expenseCategory`: Exposes CRUD operations for the **ExpenseCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExpenseCategories
    * const expenseCategories = await prisma.expenseCategory.findMany()
    * ```
    */
  get expenseCategory(): Prisma.ExpenseCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.income`: Exposes CRUD operations for the **Income** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Incomes
    * const incomes = await prisma.income.findMany()
    * ```
    */
  get income(): Prisma.IncomeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.expense`: Exposes CRUD operations for the **Expense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Expenses
    * const expenses = await prisma.expense.findMany()
    * ```
    */
  get expense(): Prisma.ExpenseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dailyCashRendition`: Exposes CRUD operations for the **DailyCashRendition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyCashRenditions
    * const dailyCashRenditions = await prisma.dailyCashRendition.findMany()
    * ```
    */
  get dailyCashRendition(): Prisma.DailyCashRenditionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dailyCashExpense`: Exposes CRUD operations for the **DailyCashExpense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyCashExpenses
    * const dailyCashExpenses = await prisma.dailyCashExpense.findMany()
    * ```
    */
  get dailyCashExpense(): Prisma.DailyCashExpenseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminSetting`: Exposes CRUD operations for the **AdminSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminSettings
    * const adminSettings = await prisma.adminSetting.findMany()
    * ```
    */
  get adminSetting(): Prisma.AdminSettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employeeAccumulationPayment`: Exposes CRUD operations for the **EmployeeAccumulationPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeAccumulationPayments
    * const employeeAccumulationPayments = await prisma.employeeAccumulationPayment.findMany()
    * ```
    */
  get employeeAccumulationPayment(): Prisma.EmployeeAccumulationPaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendanceRecord`: Exposes CRUD operations for the **AttendanceRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttendanceRecords
    * const attendanceRecords = await prisma.attendanceRecord.findMany()
    * ```
    */
  get attendanceRecord(): Prisma.AttendanceRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payrollPeriod`: Exposes CRUD operations for the **PayrollPeriod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PayrollPeriods
    * const payrollPeriods = await prisma.payrollPeriod.findMany()
    * ```
    */
  get payrollPeriod(): Prisma.PayrollPeriodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payrollEntry`: Exposes CRUD operations for the **PayrollEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PayrollEntries
    * const payrollEntries = await prisma.payrollEntry.findMany()
    * ```
    */
  get payrollEntry(): Prisma.PayrollEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payrollAdjustment`: Exposes CRUD operations for the **PayrollAdjustment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PayrollAdjustments
    * const payrollAdjustments = await prisma.payrollAdjustment.findMany()
    * ```
    */
  get payrollAdjustment(): Prisma.PayrollAdjustmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.partner`: Exposes CRUD operations for the **Partner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Partners
    * const partners = await prisma.partner.findMany()
    * ```
    */
  get partner(): Prisma.PartnerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.partnerLoan`: Exposes CRUD operations for the **PartnerLoan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PartnerLoans
    * const partnerLoans = await prisma.partnerLoan.findMany()
    * ```
    */
  get partnerLoan(): Prisma.PartnerLoanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.foodIngredient`: Exposes CRUD operations for the **FoodIngredient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FoodIngredients
    * const foodIngredients = await prisma.foodIngredient.findMany()
    * ```
    */
  get foodIngredient(): Prisma.FoodIngredientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.foodIngredientCost`: Exposes CRUD operations for the **FoodIngredientCost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FoodIngredientCosts
    * const foodIngredientCosts = await prisma.foodIngredientCost.findMany()
    * ```
    */
  get foodIngredientCost(): Prisma.FoodIngredientCostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.foodRecipe`: Exposes CRUD operations for the **FoodRecipe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FoodRecipes
    * const foodRecipes = await prisma.foodRecipe.findMany()
    * ```
    */
  get foodRecipe(): Prisma.FoodRecipeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.foodRecipeItem`: Exposes CRUD operations for the **FoodRecipeItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FoodRecipeItems
    * const foodRecipeItems = await prisma.foodRecipeItem.findMany()
    * ```
    */
  get foodRecipeItem(): Prisma.FoodRecipeItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.foodRecipeCost`: Exposes CRUD operations for the **FoodRecipeCost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FoodRecipeCosts
    * const foodRecipeCosts = await prisma.foodRecipeCost.findMany()
    * ```
    */
  get foodRecipeCost(): Prisma.FoodRecipeCostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.foodCostPool`: Exposes CRUD operations for the **FoodCostPool** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FoodCostPools
    * const foodCostPools = await prisma.foodCostPool.findMany()
    * ```
    */
  get foodCostPool(): Prisma.FoodCostPoolDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.foodMealPlan`: Exposes CRUD operations for the **FoodMealPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FoodMealPlans
    * const foodMealPlans = await prisma.foodMealPlan.findMany()
    * ```
    */
  get foodMealPlan(): Prisma.FoodMealPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.foodMealPlanEntry`: Exposes CRUD operations for the **FoodMealPlanEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FoodMealPlanEntries
    * const foodMealPlanEntries = await prisma.foodMealPlanEntry.findMany()
    * ```
    */
  get foodMealPlanEntry(): Prisma.FoodMealPlanEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quotationProcess`: Exposes CRUD operations for the **QuotationProcess** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuotationProcesses
    * const quotationProcesses = await prisma.quotationProcess.findMany()
    * ```
    */
  get quotationProcess(): Prisma.QuotationProcessDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quotationBaselineItem`: Exposes CRUD operations for the **QuotationBaselineItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuotationBaselineItems
    * const quotationBaselineItems = await prisma.quotationBaselineItem.findMany()
    * ```
    */
  get quotationBaselineItem(): Prisma.QuotationBaselineItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quotation`: Exposes CRUD operations for the **Quotation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quotations
    * const quotations = await prisma.quotation.findMany()
    * ```
    */
  get quotation(): Prisma.QuotationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quotationItem`: Exposes CRUD operations for the **QuotationItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuotationItems
    * const quotationItems = await prisma.quotationItem.findMany()
    * ```
    */
  get quotationItem(): Prisma.QuotationItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quotationAttachment`: Exposes CRUD operations for the **QuotationAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuotationAttachments
    * const quotationAttachments = await prisma.quotationAttachment.findMany()
    * ```
    */
  get quotationAttachment(): Prisma.QuotationAttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseOrderLog`: Exposes CRUD operations for the **PurchaseOrderLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseOrderLogs
    * const purchaseOrderLogs = await prisma.purchaseOrderLog.findMany()
    * ```
    */
  get purchaseOrderLog(): Prisma.PurchaseOrderLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseOrderLine`: Exposes CRUD operations for the **PurchaseOrderLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseOrderLines
    * const purchaseOrderLines = await prisma.purchaseOrderLine.findMany()
    * ```
    */
  get purchaseOrderLine(): Prisma.PurchaseOrderLineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseDeliveryLog`: Exposes CRUD operations for the **PurchaseDeliveryLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseDeliveryLogs
    * const purchaseDeliveryLogs = await prisma.purchaseDeliveryLog.findMany()
    * ```
    */
  get purchaseDeliveryLog(): Prisma.PurchaseDeliveryLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseDeliveryItem`: Exposes CRUD operations for the **PurchaseDeliveryItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseDeliveryItems
    * const purchaseDeliveryItems = await prisma.purchaseDeliveryItem.findMany()
    * ```
    */
  get purchaseDeliveryItem(): Prisma.PurchaseDeliveryItemDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.18.0
   * Query Engine version: 34b5a692b7bd79939a9a2c3ef97d816e749cda2f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Obra: 'Obra',
    Material: 'Material',
    Proveedor: 'Proveedor',
    Frente: 'Frente',
    MaterialGroup: 'MaterialGroup',
    Move: 'Move',
    ExpenseCategory: 'ExpenseCategory',
    Income: 'Income',
    Expense: 'Expense',
    DailyCashRendition: 'DailyCashRendition',
    DailyCashExpense: 'DailyCashExpense',
    AdminSetting: 'AdminSetting',
    Employee: 'Employee',
    EmployeeAccumulationPayment: 'EmployeeAccumulationPayment',
    AttendanceRecord: 'AttendanceRecord',
    PayrollPeriod: 'PayrollPeriod',
    PayrollEntry: 'PayrollEntry',
    PayrollAdjustment: 'PayrollAdjustment',
    Partner: 'Partner',
    PartnerLoan: 'PartnerLoan',
    FoodIngredient: 'FoodIngredient',
    FoodIngredientCost: 'FoodIngredientCost',
    FoodRecipe: 'FoodRecipe',
    FoodRecipeItem: 'FoodRecipeItem',
    FoodRecipeCost: 'FoodRecipeCost',
    FoodCostPool: 'FoodCostPool',
    FoodMealPlan: 'FoodMealPlan',
    FoodMealPlanEntry: 'FoodMealPlanEntry',
    QuotationProcess: 'QuotationProcess',
    QuotationBaselineItem: 'QuotationBaselineItem',
    Quotation: 'Quotation',
    QuotationItem: 'QuotationItem',
    QuotationAttachment: 'QuotationAttachment',
    PurchaseOrderLog: 'PurchaseOrderLog',
    PurchaseOrderLine: 'PurchaseOrderLine',
    PurchaseDeliveryLog: 'PurchaseDeliveryLog',
    PurchaseDeliveryItem: 'PurchaseDeliveryItem'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "obra" | "material" | "proveedor" | "frente" | "materialGroup" | "move" | "expenseCategory" | "income" | "expense" | "dailyCashRendition" | "dailyCashExpense" | "adminSetting" | "employee" | "employeeAccumulationPayment" | "attendanceRecord" | "payrollPeriod" | "payrollEntry" | "payrollAdjustment" | "partner" | "partnerLoan" | "foodIngredient" | "foodIngredientCost" | "foodRecipe" | "foodRecipeItem" | "foodRecipeCost" | "foodCostPool" | "foodMealPlan" | "foodMealPlanEntry" | "quotationProcess" | "quotationBaselineItem" | "quotation" | "quotationItem" | "quotationAttachment" | "purchaseOrderLog" | "purchaseOrderLine" | "purchaseDeliveryLog" | "purchaseDeliveryItem"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Obra: {
        payload: Prisma.$ObraPayload<ExtArgs>
        fields: Prisma.ObraFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ObraFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObraPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ObraFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObraPayload>
          }
          findFirst: {
            args: Prisma.ObraFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObraPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ObraFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObraPayload>
          }
          findMany: {
            args: Prisma.ObraFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObraPayload>[]
          }
          create: {
            args: Prisma.ObraCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObraPayload>
          }
          createMany: {
            args: Prisma.ObraCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ObraCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObraPayload>[]
          }
          delete: {
            args: Prisma.ObraDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObraPayload>
          }
          update: {
            args: Prisma.ObraUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObraPayload>
          }
          deleteMany: {
            args: Prisma.ObraDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ObraUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ObraUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObraPayload>[]
          }
          upsert: {
            args: Prisma.ObraUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObraPayload>
          }
          aggregate: {
            args: Prisma.ObraAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateObra>
          }
          groupBy: {
            args: Prisma.ObraGroupByArgs<ExtArgs>
            result: $Utils.Optional<ObraGroupByOutputType>[]
          }
          count: {
            args: Prisma.ObraCountArgs<ExtArgs>
            result: $Utils.Optional<ObraCountAggregateOutputType> | number
          }
        }
      }
      Material: {
        payload: Prisma.$MaterialPayload<ExtArgs>
        fields: Prisma.MaterialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaterialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaterialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          findFirst: {
            args: Prisma.MaterialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaterialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          findMany: {
            args: Prisma.MaterialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          create: {
            args: Prisma.MaterialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          createMany: {
            args: Prisma.MaterialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaterialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          delete: {
            args: Prisma.MaterialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          update: {
            args: Prisma.MaterialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          deleteMany: {
            args: Prisma.MaterialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaterialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MaterialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          upsert: {
            args: Prisma.MaterialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          aggregate: {
            args: Prisma.MaterialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaterial>
          }
          groupBy: {
            args: Prisma.MaterialGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaterialGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaterialCountArgs<ExtArgs>
            result: $Utils.Optional<MaterialCountAggregateOutputType> | number
          }
        }
      }
      Proveedor: {
        payload: Prisma.$ProveedorPayload<ExtArgs>
        fields: Prisma.ProveedorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProveedorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProveedorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProveedorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProveedorPayload>
          }
          findFirst: {
            args: Prisma.ProveedorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProveedorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProveedorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProveedorPayload>
          }
          findMany: {
            args: Prisma.ProveedorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProveedorPayload>[]
          }
          create: {
            args: Prisma.ProveedorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProveedorPayload>
          }
          createMany: {
            args: Prisma.ProveedorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProveedorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProveedorPayload>[]
          }
          delete: {
            args: Prisma.ProveedorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProveedorPayload>
          }
          update: {
            args: Prisma.ProveedorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProveedorPayload>
          }
          deleteMany: {
            args: Prisma.ProveedorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProveedorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProveedorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProveedorPayload>[]
          }
          upsert: {
            args: Prisma.ProveedorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProveedorPayload>
          }
          aggregate: {
            args: Prisma.ProveedorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProveedor>
          }
          groupBy: {
            args: Prisma.ProveedorGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProveedorGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProveedorCountArgs<ExtArgs>
            result: $Utils.Optional<ProveedorCountAggregateOutputType> | number
          }
        }
      }
      Frente: {
        payload: Prisma.$FrentePayload<ExtArgs>
        fields: Prisma.FrenteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FrenteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FrentePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FrenteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FrentePayload>
          }
          findFirst: {
            args: Prisma.FrenteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FrentePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FrenteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FrentePayload>
          }
          findMany: {
            args: Prisma.FrenteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FrentePayload>[]
          }
          create: {
            args: Prisma.FrenteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FrentePayload>
          }
          createMany: {
            args: Prisma.FrenteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FrenteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FrentePayload>[]
          }
          delete: {
            args: Prisma.FrenteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FrentePayload>
          }
          update: {
            args: Prisma.FrenteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FrentePayload>
          }
          deleteMany: {
            args: Prisma.FrenteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FrenteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FrenteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FrentePayload>[]
          }
          upsert: {
            args: Prisma.FrenteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FrentePayload>
          }
          aggregate: {
            args: Prisma.FrenteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFrente>
          }
          groupBy: {
            args: Prisma.FrenteGroupByArgs<ExtArgs>
            result: $Utils.Optional<FrenteGroupByOutputType>[]
          }
          count: {
            args: Prisma.FrenteCountArgs<ExtArgs>
            result: $Utils.Optional<FrenteCountAggregateOutputType> | number
          }
        }
      }
      MaterialGroup: {
        payload: Prisma.$MaterialGroupPayload<ExtArgs>
        fields: Prisma.MaterialGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaterialGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaterialGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialGroupPayload>
          }
          findFirst: {
            args: Prisma.MaterialGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaterialGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialGroupPayload>
          }
          findMany: {
            args: Prisma.MaterialGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialGroupPayload>[]
          }
          create: {
            args: Prisma.MaterialGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialGroupPayload>
          }
          createMany: {
            args: Prisma.MaterialGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaterialGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialGroupPayload>[]
          }
          delete: {
            args: Prisma.MaterialGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialGroupPayload>
          }
          update: {
            args: Prisma.MaterialGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialGroupPayload>
          }
          deleteMany: {
            args: Prisma.MaterialGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaterialGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MaterialGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialGroupPayload>[]
          }
          upsert: {
            args: Prisma.MaterialGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialGroupPayload>
          }
          aggregate: {
            args: Prisma.MaterialGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaterialGroup>
          }
          groupBy: {
            args: Prisma.MaterialGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaterialGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaterialGroupCountArgs<ExtArgs>
            result: $Utils.Optional<MaterialGroupCountAggregateOutputType> | number
          }
        }
      }
      Move: {
        payload: Prisma.$MovePayload<ExtArgs>
        fields: Prisma.MoveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MoveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MoveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovePayload>
          }
          findFirst: {
            args: Prisma.MoveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MoveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovePayload>
          }
          findMany: {
            args: Prisma.MoveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovePayload>[]
          }
          create: {
            args: Prisma.MoveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovePayload>
          }
          createMany: {
            args: Prisma.MoveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MoveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovePayload>[]
          }
          delete: {
            args: Prisma.MoveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovePayload>
          }
          update: {
            args: Prisma.MoveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovePayload>
          }
          deleteMany: {
            args: Prisma.MoveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MoveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MoveUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovePayload>[]
          }
          upsert: {
            args: Prisma.MoveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovePayload>
          }
          aggregate: {
            args: Prisma.MoveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMove>
          }
          groupBy: {
            args: Prisma.MoveGroupByArgs<ExtArgs>
            result: $Utils.Optional<MoveGroupByOutputType>[]
          }
          count: {
            args: Prisma.MoveCountArgs<ExtArgs>
            result: $Utils.Optional<MoveCountAggregateOutputType> | number
          }
        }
      }
      ExpenseCategory: {
        payload: Prisma.$ExpenseCategoryPayload<ExtArgs>
        fields: Prisma.ExpenseCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          findFirst: {
            args: Prisma.ExpenseCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          findMany: {
            args: Prisma.ExpenseCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>[]
          }
          create: {
            args: Prisma.ExpenseCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          createMany: {
            args: Prisma.ExpenseCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpenseCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>[]
          }
          delete: {
            args: Prisma.ExpenseCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          update: {
            args: Prisma.ExpenseCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ExpenseCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExpenseCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>[]
          }
          upsert: {
            args: Prisma.ExpenseCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          aggregate: {
            args: Prisma.ExpenseCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpenseCategory>
          }
          groupBy: {
            args: Prisma.ExpenseCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseCategoryCountAggregateOutputType> | number
          }
        }
      }
      Income: {
        payload: Prisma.$IncomePayload<ExtArgs>
        fields: Prisma.IncomeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IncomeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IncomeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomePayload>
          }
          findFirst: {
            args: Prisma.IncomeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IncomeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomePayload>
          }
          findMany: {
            args: Prisma.IncomeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomePayload>[]
          }
          create: {
            args: Prisma.IncomeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomePayload>
          }
          createMany: {
            args: Prisma.IncomeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IncomeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomePayload>[]
          }
          delete: {
            args: Prisma.IncomeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomePayload>
          }
          update: {
            args: Prisma.IncomeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomePayload>
          }
          deleteMany: {
            args: Prisma.IncomeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IncomeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IncomeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomePayload>[]
          }
          upsert: {
            args: Prisma.IncomeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomePayload>
          }
          aggregate: {
            args: Prisma.IncomeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIncome>
          }
          groupBy: {
            args: Prisma.IncomeGroupByArgs<ExtArgs>
            result: $Utils.Optional<IncomeGroupByOutputType>[]
          }
          count: {
            args: Prisma.IncomeCountArgs<ExtArgs>
            result: $Utils.Optional<IncomeCountAggregateOutputType> | number
          }
        }
      }
      Expense: {
        payload: Prisma.$ExpensePayload<ExtArgs>
        fields: Prisma.ExpenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findFirst: {
            args: Prisma.ExpenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findMany: {
            args: Prisma.ExpenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          create: {
            args: Prisma.ExpenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          createMany: {
            args: Prisma.ExpenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpenseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          delete: {
            args: Prisma.ExpenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          update: {
            args: Prisma.ExpenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          deleteMany: {
            args: Prisma.ExpenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExpenseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          upsert: {
            args: Prisma.ExpenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          aggregate: {
            args: Prisma.ExpenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpense>
          }
          groupBy: {
            args: Prisma.ExpenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseCountAggregateOutputType> | number
          }
        }
      }
      DailyCashRendition: {
        payload: Prisma.$DailyCashRenditionPayload<ExtArgs>
        fields: Prisma.DailyCashRenditionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DailyCashRenditionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyCashRenditionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DailyCashRenditionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyCashRenditionPayload>
          }
          findFirst: {
            args: Prisma.DailyCashRenditionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyCashRenditionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DailyCashRenditionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyCashRenditionPayload>
          }
          findMany: {
            args: Prisma.DailyCashRenditionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyCashRenditionPayload>[]
          }
          create: {
            args: Prisma.DailyCashRenditionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyCashRenditionPayload>
          }
          createMany: {
            args: Prisma.DailyCashRenditionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DailyCashRenditionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyCashRenditionPayload>[]
          }
          delete: {
            args: Prisma.DailyCashRenditionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyCashRenditionPayload>
          }
          update: {
            args: Prisma.DailyCashRenditionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyCashRenditionPayload>
          }
          deleteMany: {
            args: Prisma.DailyCashRenditionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DailyCashRenditionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DailyCashRenditionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyCashRenditionPayload>[]
          }
          upsert: {
            args: Prisma.DailyCashRenditionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyCashRenditionPayload>
          }
          aggregate: {
            args: Prisma.DailyCashRenditionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDailyCashRendition>
          }
          groupBy: {
            args: Prisma.DailyCashRenditionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DailyCashRenditionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DailyCashRenditionCountArgs<ExtArgs>
            result: $Utils.Optional<DailyCashRenditionCountAggregateOutputType> | number
          }
        }
      }
      DailyCashExpense: {
        payload: Prisma.$DailyCashExpensePayload<ExtArgs>
        fields: Prisma.DailyCashExpenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DailyCashExpenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyCashExpensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DailyCashExpenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyCashExpensePayload>
          }
          findFirst: {
            args: Prisma.DailyCashExpenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyCashExpensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DailyCashExpenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyCashExpensePayload>
          }
          findMany: {
            args: Prisma.DailyCashExpenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyCashExpensePayload>[]
          }
          create: {
            args: Prisma.DailyCashExpenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyCashExpensePayload>
          }
          createMany: {
            args: Prisma.DailyCashExpenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DailyCashExpenseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyCashExpensePayload>[]
          }
          delete: {
            args: Prisma.DailyCashExpenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyCashExpensePayload>
          }
          update: {
            args: Prisma.DailyCashExpenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyCashExpensePayload>
          }
          deleteMany: {
            args: Prisma.DailyCashExpenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DailyCashExpenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DailyCashExpenseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyCashExpensePayload>[]
          }
          upsert: {
            args: Prisma.DailyCashExpenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyCashExpensePayload>
          }
          aggregate: {
            args: Prisma.DailyCashExpenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDailyCashExpense>
          }
          groupBy: {
            args: Prisma.DailyCashExpenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<DailyCashExpenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.DailyCashExpenseCountArgs<ExtArgs>
            result: $Utils.Optional<DailyCashExpenseCountAggregateOutputType> | number
          }
        }
      }
      AdminSetting: {
        payload: Prisma.$AdminSettingPayload<ExtArgs>
        fields: Prisma.AdminSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSettingPayload>
          }
          findFirst: {
            args: Prisma.AdminSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSettingPayload>
          }
          findMany: {
            args: Prisma.AdminSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSettingPayload>[]
          }
          create: {
            args: Prisma.AdminSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSettingPayload>
          }
          createMany: {
            args: Prisma.AdminSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminSettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSettingPayload>[]
          }
          delete: {
            args: Prisma.AdminSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSettingPayload>
          }
          update: {
            args: Prisma.AdminSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSettingPayload>
          }
          deleteMany: {
            args: Prisma.AdminSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminSettingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSettingPayload>[]
          }
          upsert: {
            args: Prisma.AdminSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSettingPayload>
          }
          aggregate: {
            args: Prisma.AdminSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminSetting>
          }
          groupBy: {
            args: Prisma.AdminSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminSettingCountArgs<ExtArgs>
            result: $Utils.Optional<AdminSettingCountAggregateOutputType> | number
          }
        }
      }
      Employee: {
        payload: Prisma.$EmployeePayload<ExtArgs>
        fields: Prisma.EmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findFirst: {
            args: Prisma.EmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findMany: {
            args: Prisma.EmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          create: {
            args: Prisma.EmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          createMany: {
            args: Prisma.EmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          delete: {
            args: Prisma.EmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          update: {
            args: Prisma.EmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          upsert: {
            args: Prisma.EmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.EmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      EmployeeAccumulationPayment: {
        payload: Prisma.$EmployeeAccumulationPaymentPayload<ExtArgs>
        fields: Prisma.EmployeeAccumulationPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeAccumulationPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAccumulationPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeAccumulationPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAccumulationPaymentPayload>
          }
          findFirst: {
            args: Prisma.EmployeeAccumulationPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAccumulationPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeAccumulationPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAccumulationPaymentPayload>
          }
          findMany: {
            args: Prisma.EmployeeAccumulationPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAccumulationPaymentPayload>[]
          }
          create: {
            args: Prisma.EmployeeAccumulationPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAccumulationPaymentPayload>
          }
          createMany: {
            args: Prisma.EmployeeAccumulationPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeAccumulationPaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAccumulationPaymentPayload>[]
          }
          delete: {
            args: Prisma.EmployeeAccumulationPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAccumulationPaymentPayload>
          }
          update: {
            args: Prisma.EmployeeAccumulationPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAccumulationPaymentPayload>
          }
          deleteMany: {
            args: Prisma.EmployeeAccumulationPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeAccumulationPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeAccumulationPaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAccumulationPaymentPayload>[]
          }
          upsert: {
            args: Prisma.EmployeeAccumulationPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeAccumulationPaymentPayload>
          }
          aggregate: {
            args: Prisma.EmployeeAccumulationPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeAccumulationPayment>
          }
          groupBy: {
            args: Prisma.EmployeeAccumulationPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeAccumulationPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeAccumulationPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeAccumulationPaymentCountAggregateOutputType> | number
          }
        }
      }
      AttendanceRecord: {
        payload: Prisma.$AttendanceRecordPayload<ExtArgs>
        fields: Prisma.AttendanceRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          findFirst: {
            args: Prisma.AttendanceRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          findMany: {
            args: Prisma.AttendanceRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>[]
          }
          create: {
            args: Prisma.AttendanceRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          createMany: {
            args: Prisma.AttendanceRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>[]
          }
          delete: {
            args: Prisma.AttendanceRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          update: {
            args: Prisma.AttendanceRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          deleteMany: {
            args: Prisma.AttendanceRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>[]
          }
          upsert: {
            args: Prisma.AttendanceRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          aggregate: {
            args: Prisma.AttendanceRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendanceRecord>
          }
          groupBy: {
            args: Prisma.AttendanceRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceRecordCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceRecordCountAggregateOutputType> | number
          }
        }
      }
      PayrollPeriod: {
        payload: Prisma.$PayrollPeriodPayload<ExtArgs>
        fields: Prisma.PayrollPeriodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PayrollPeriodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPeriodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PayrollPeriodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPeriodPayload>
          }
          findFirst: {
            args: Prisma.PayrollPeriodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPeriodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PayrollPeriodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPeriodPayload>
          }
          findMany: {
            args: Prisma.PayrollPeriodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPeriodPayload>[]
          }
          create: {
            args: Prisma.PayrollPeriodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPeriodPayload>
          }
          createMany: {
            args: Prisma.PayrollPeriodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PayrollPeriodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPeriodPayload>[]
          }
          delete: {
            args: Prisma.PayrollPeriodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPeriodPayload>
          }
          update: {
            args: Prisma.PayrollPeriodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPeriodPayload>
          }
          deleteMany: {
            args: Prisma.PayrollPeriodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PayrollPeriodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PayrollPeriodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPeriodPayload>[]
          }
          upsert: {
            args: Prisma.PayrollPeriodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPeriodPayload>
          }
          aggregate: {
            args: Prisma.PayrollPeriodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayrollPeriod>
          }
          groupBy: {
            args: Prisma.PayrollPeriodGroupByArgs<ExtArgs>
            result: $Utils.Optional<PayrollPeriodGroupByOutputType>[]
          }
          count: {
            args: Prisma.PayrollPeriodCountArgs<ExtArgs>
            result: $Utils.Optional<PayrollPeriodCountAggregateOutputType> | number
          }
        }
      }
      PayrollEntry: {
        payload: Prisma.$PayrollEntryPayload<ExtArgs>
        fields: Prisma.PayrollEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PayrollEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PayrollEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollEntryPayload>
          }
          findFirst: {
            args: Prisma.PayrollEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PayrollEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollEntryPayload>
          }
          findMany: {
            args: Prisma.PayrollEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollEntryPayload>[]
          }
          create: {
            args: Prisma.PayrollEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollEntryPayload>
          }
          createMany: {
            args: Prisma.PayrollEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PayrollEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollEntryPayload>[]
          }
          delete: {
            args: Prisma.PayrollEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollEntryPayload>
          }
          update: {
            args: Prisma.PayrollEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollEntryPayload>
          }
          deleteMany: {
            args: Prisma.PayrollEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PayrollEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PayrollEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollEntryPayload>[]
          }
          upsert: {
            args: Prisma.PayrollEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollEntryPayload>
          }
          aggregate: {
            args: Prisma.PayrollEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayrollEntry>
          }
          groupBy: {
            args: Prisma.PayrollEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<PayrollEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.PayrollEntryCountArgs<ExtArgs>
            result: $Utils.Optional<PayrollEntryCountAggregateOutputType> | number
          }
        }
      }
      PayrollAdjustment: {
        payload: Prisma.$PayrollAdjustmentPayload<ExtArgs>
        fields: Prisma.PayrollAdjustmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PayrollAdjustmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollAdjustmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PayrollAdjustmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollAdjustmentPayload>
          }
          findFirst: {
            args: Prisma.PayrollAdjustmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollAdjustmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PayrollAdjustmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollAdjustmentPayload>
          }
          findMany: {
            args: Prisma.PayrollAdjustmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollAdjustmentPayload>[]
          }
          create: {
            args: Prisma.PayrollAdjustmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollAdjustmentPayload>
          }
          createMany: {
            args: Prisma.PayrollAdjustmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PayrollAdjustmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollAdjustmentPayload>[]
          }
          delete: {
            args: Prisma.PayrollAdjustmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollAdjustmentPayload>
          }
          update: {
            args: Prisma.PayrollAdjustmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollAdjustmentPayload>
          }
          deleteMany: {
            args: Prisma.PayrollAdjustmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PayrollAdjustmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PayrollAdjustmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollAdjustmentPayload>[]
          }
          upsert: {
            args: Prisma.PayrollAdjustmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollAdjustmentPayload>
          }
          aggregate: {
            args: Prisma.PayrollAdjustmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayrollAdjustment>
          }
          groupBy: {
            args: Prisma.PayrollAdjustmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PayrollAdjustmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PayrollAdjustmentCountArgs<ExtArgs>
            result: $Utils.Optional<PayrollAdjustmentCountAggregateOutputType> | number
          }
        }
      }
      Partner: {
        payload: Prisma.$PartnerPayload<ExtArgs>
        fields: Prisma.PartnerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PartnerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PartnerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          findFirst: {
            args: Prisma.PartnerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PartnerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          findMany: {
            args: Prisma.PartnerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>[]
          }
          create: {
            args: Prisma.PartnerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          createMany: {
            args: Prisma.PartnerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PartnerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>[]
          }
          delete: {
            args: Prisma.PartnerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          update: {
            args: Prisma.PartnerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          deleteMany: {
            args: Prisma.PartnerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PartnerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PartnerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>[]
          }
          upsert: {
            args: Prisma.PartnerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          aggregate: {
            args: Prisma.PartnerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePartner>
          }
          groupBy: {
            args: Prisma.PartnerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PartnerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PartnerCountArgs<ExtArgs>
            result: $Utils.Optional<PartnerCountAggregateOutputType> | number
          }
        }
      }
      PartnerLoan: {
        payload: Prisma.$PartnerLoanPayload<ExtArgs>
        fields: Prisma.PartnerLoanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PartnerLoanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerLoanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PartnerLoanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerLoanPayload>
          }
          findFirst: {
            args: Prisma.PartnerLoanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerLoanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PartnerLoanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerLoanPayload>
          }
          findMany: {
            args: Prisma.PartnerLoanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerLoanPayload>[]
          }
          create: {
            args: Prisma.PartnerLoanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerLoanPayload>
          }
          createMany: {
            args: Prisma.PartnerLoanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PartnerLoanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerLoanPayload>[]
          }
          delete: {
            args: Prisma.PartnerLoanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerLoanPayload>
          }
          update: {
            args: Prisma.PartnerLoanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerLoanPayload>
          }
          deleteMany: {
            args: Prisma.PartnerLoanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PartnerLoanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PartnerLoanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerLoanPayload>[]
          }
          upsert: {
            args: Prisma.PartnerLoanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerLoanPayload>
          }
          aggregate: {
            args: Prisma.PartnerLoanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePartnerLoan>
          }
          groupBy: {
            args: Prisma.PartnerLoanGroupByArgs<ExtArgs>
            result: $Utils.Optional<PartnerLoanGroupByOutputType>[]
          }
          count: {
            args: Prisma.PartnerLoanCountArgs<ExtArgs>
            result: $Utils.Optional<PartnerLoanCountAggregateOutputType> | number
          }
        }
      }
      FoodIngredient: {
        payload: Prisma.$FoodIngredientPayload<ExtArgs>
        fields: Prisma.FoodIngredientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoodIngredientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodIngredientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoodIngredientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodIngredientPayload>
          }
          findFirst: {
            args: Prisma.FoodIngredientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodIngredientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoodIngredientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodIngredientPayload>
          }
          findMany: {
            args: Prisma.FoodIngredientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodIngredientPayload>[]
          }
          create: {
            args: Prisma.FoodIngredientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodIngredientPayload>
          }
          createMany: {
            args: Prisma.FoodIngredientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FoodIngredientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodIngredientPayload>[]
          }
          delete: {
            args: Prisma.FoodIngredientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodIngredientPayload>
          }
          update: {
            args: Prisma.FoodIngredientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodIngredientPayload>
          }
          deleteMany: {
            args: Prisma.FoodIngredientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoodIngredientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FoodIngredientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodIngredientPayload>[]
          }
          upsert: {
            args: Prisma.FoodIngredientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodIngredientPayload>
          }
          aggregate: {
            args: Prisma.FoodIngredientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoodIngredient>
          }
          groupBy: {
            args: Prisma.FoodIngredientGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoodIngredientGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoodIngredientCountArgs<ExtArgs>
            result: $Utils.Optional<FoodIngredientCountAggregateOutputType> | number
          }
        }
      }
      FoodIngredientCost: {
        payload: Prisma.$FoodIngredientCostPayload<ExtArgs>
        fields: Prisma.FoodIngredientCostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoodIngredientCostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodIngredientCostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoodIngredientCostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodIngredientCostPayload>
          }
          findFirst: {
            args: Prisma.FoodIngredientCostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodIngredientCostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoodIngredientCostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodIngredientCostPayload>
          }
          findMany: {
            args: Prisma.FoodIngredientCostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodIngredientCostPayload>[]
          }
          create: {
            args: Prisma.FoodIngredientCostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodIngredientCostPayload>
          }
          createMany: {
            args: Prisma.FoodIngredientCostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FoodIngredientCostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodIngredientCostPayload>[]
          }
          delete: {
            args: Prisma.FoodIngredientCostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodIngredientCostPayload>
          }
          update: {
            args: Prisma.FoodIngredientCostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodIngredientCostPayload>
          }
          deleteMany: {
            args: Prisma.FoodIngredientCostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoodIngredientCostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FoodIngredientCostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodIngredientCostPayload>[]
          }
          upsert: {
            args: Prisma.FoodIngredientCostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodIngredientCostPayload>
          }
          aggregate: {
            args: Prisma.FoodIngredientCostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoodIngredientCost>
          }
          groupBy: {
            args: Prisma.FoodIngredientCostGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoodIngredientCostGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoodIngredientCostCountArgs<ExtArgs>
            result: $Utils.Optional<FoodIngredientCostCountAggregateOutputType> | number
          }
        }
      }
      FoodRecipe: {
        payload: Prisma.$FoodRecipePayload<ExtArgs>
        fields: Prisma.FoodRecipeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoodRecipeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRecipePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoodRecipeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRecipePayload>
          }
          findFirst: {
            args: Prisma.FoodRecipeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRecipePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoodRecipeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRecipePayload>
          }
          findMany: {
            args: Prisma.FoodRecipeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRecipePayload>[]
          }
          create: {
            args: Prisma.FoodRecipeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRecipePayload>
          }
          createMany: {
            args: Prisma.FoodRecipeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FoodRecipeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRecipePayload>[]
          }
          delete: {
            args: Prisma.FoodRecipeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRecipePayload>
          }
          update: {
            args: Prisma.FoodRecipeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRecipePayload>
          }
          deleteMany: {
            args: Prisma.FoodRecipeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoodRecipeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FoodRecipeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRecipePayload>[]
          }
          upsert: {
            args: Prisma.FoodRecipeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRecipePayload>
          }
          aggregate: {
            args: Prisma.FoodRecipeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoodRecipe>
          }
          groupBy: {
            args: Prisma.FoodRecipeGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoodRecipeGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoodRecipeCountArgs<ExtArgs>
            result: $Utils.Optional<FoodRecipeCountAggregateOutputType> | number
          }
        }
      }
      FoodRecipeItem: {
        payload: Prisma.$FoodRecipeItemPayload<ExtArgs>
        fields: Prisma.FoodRecipeItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoodRecipeItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRecipeItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoodRecipeItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRecipeItemPayload>
          }
          findFirst: {
            args: Prisma.FoodRecipeItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRecipeItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoodRecipeItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRecipeItemPayload>
          }
          findMany: {
            args: Prisma.FoodRecipeItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRecipeItemPayload>[]
          }
          create: {
            args: Prisma.FoodRecipeItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRecipeItemPayload>
          }
          createMany: {
            args: Prisma.FoodRecipeItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FoodRecipeItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRecipeItemPayload>[]
          }
          delete: {
            args: Prisma.FoodRecipeItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRecipeItemPayload>
          }
          update: {
            args: Prisma.FoodRecipeItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRecipeItemPayload>
          }
          deleteMany: {
            args: Prisma.FoodRecipeItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoodRecipeItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FoodRecipeItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRecipeItemPayload>[]
          }
          upsert: {
            args: Prisma.FoodRecipeItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRecipeItemPayload>
          }
          aggregate: {
            args: Prisma.FoodRecipeItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoodRecipeItem>
          }
          groupBy: {
            args: Prisma.FoodRecipeItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoodRecipeItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoodRecipeItemCountArgs<ExtArgs>
            result: $Utils.Optional<FoodRecipeItemCountAggregateOutputType> | number
          }
        }
      }
      FoodRecipeCost: {
        payload: Prisma.$FoodRecipeCostPayload<ExtArgs>
        fields: Prisma.FoodRecipeCostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoodRecipeCostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRecipeCostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoodRecipeCostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRecipeCostPayload>
          }
          findFirst: {
            args: Prisma.FoodRecipeCostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRecipeCostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoodRecipeCostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRecipeCostPayload>
          }
          findMany: {
            args: Prisma.FoodRecipeCostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRecipeCostPayload>[]
          }
          create: {
            args: Prisma.FoodRecipeCostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRecipeCostPayload>
          }
          createMany: {
            args: Prisma.FoodRecipeCostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FoodRecipeCostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRecipeCostPayload>[]
          }
          delete: {
            args: Prisma.FoodRecipeCostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRecipeCostPayload>
          }
          update: {
            args: Prisma.FoodRecipeCostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRecipeCostPayload>
          }
          deleteMany: {
            args: Prisma.FoodRecipeCostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoodRecipeCostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FoodRecipeCostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRecipeCostPayload>[]
          }
          upsert: {
            args: Prisma.FoodRecipeCostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodRecipeCostPayload>
          }
          aggregate: {
            args: Prisma.FoodRecipeCostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoodRecipeCost>
          }
          groupBy: {
            args: Prisma.FoodRecipeCostGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoodRecipeCostGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoodRecipeCostCountArgs<ExtArgs>
            result: $Utils.Optional<FoodRecipeCostCountAggregateOutputType> | number
          }
        }
      }
      FoodCostPool: {
        payload: Prisma.$FoodCostPoolPayload<ExtArgs>
        fields: Prisma.FoodCostPoolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoodCostPoolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodCostPoolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoodCostPoolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodCostPoolPayload>
          }
          findFirst: {
            args: Prisma.FoodCostPoolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodCostPoolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoodCostPoolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodCostPoolPayload>
          }
          findMany: {
            args: Prisma.FoodCostPoolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodCostPoolPayload>[]
          }
          create: {
            args: Prisma.FoodCostPoolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodCostPoolPayload>
          }
          createMany: {
            args: Prisma.FoodCostPoolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FoodCostPoolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodCostPoolPayload>[]
          }
          delete: {
            args: Prisma.FoodCostPoolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodCostPoolPayload>
          }
          update: {
            args: Prisma.FoodCostPoolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodCostPoolPayload>
          }
          deleteMany: {
            args: Prisma.FoodCostPoolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoodCostPoolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FoodCostPoolUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodCostPoolPayload>[]
          }
          upsert: {
            args: Prisma.FoodCostPoolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodCostPoolPayload>
          }
          aggregate: {
            args: Prisma.FoodCostPoolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoodCostPool>
          }
          groupBy: {
            args: Prisma.FoodCostPoolGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoodCostPoolGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoodCostPoolCountArgs<ExtArgs>
            result: $Utils.Optional<FoodCostPoolCountAggregateOutputType> | number
          }
        }
      }
      FoodMealPlan: {
        payload: Prisma.$FoodMealPlanPayload<ExtArgs>
        fields: Prisma.FoodMealPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoodMealPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodMealPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoodMealPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodMealPlanPayload>
          }
          findFirst: {
            args: Prisma.FoodMealPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodMealPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoodMealPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodMealPlanPayload>
          }
          findMany: {
            args: Prisma.FoodMealPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodMealPlanPayload>[]
          }
          create: {
            args: Prisma.FoodMealPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodMealPlanPayload>
          }
          createMany: {
            args: Prisma.FoodMealPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FoodMealPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodMealPlanPayload>[]
          }
          delete: {
            args: Prisma.FoodMealPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodMealPlanPayload>
          }
          update: {
            args: Prisma.FoodMealPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodMealPlanPayload>
          }
          deleteMany: {
            args: Prisma.FoodMealPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoodMealPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FoodMealPlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodMealPlanPayload>[]
          }
          upsert: {
            args: Prisma.FoodMealPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodMealPlanPayload>
          }
          aggregate: {
            args: Prisma.FoodMealPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoodMealPlan>
          }
          groupBy: {
            args: Prisma.FoodMealPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoodMealPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoodMealPlanCountArgs<ExtArgs>
            result: $Utils.Optional<FoodMealPlanCountAggregateOutputType> | number
          }
        }
      }
      FoodMealPlanEntry: {
        payload: Prisma.$FoodMealPlanEntryPayload<ExtArgs>
        fields: Prisma.FoodMealPlanEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoodMealPlanEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodMealPlanEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoodMealPlanEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodMealPlanEntryPayload>
          }
          findFirst: {
            args: Prisma.FoodMealPlanEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodMealPlanEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoodMealPlanEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodMealPlanEntryPayload>
          }
          findMany: {
            args: Prisma.FoodMealPlanEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodMealPlanEntryPayload>[]
          }
          create: {
            args: Prisma.FoodMealPlanEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodMealPlanEntryPayload>
          }
          createMany: {
            args: Prisma.FoodMealPlanEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FoodMealPlanEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodMealPlanEntryPayload>[]
          }
          delete: {
            args: Prisma.FoodMealPlanEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodMealPlanEntryPayload>
          }
          update: {
            args: Prisma.FoodMealPlanEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodMealPlanEntryPayload>
          }
          deleteMany: {
            args: Prisma.FoodMealPlanEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoodMealPlanEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FoodMealPlanEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodMealPlanEntryPayload>[]
          }
          upsert: {
            args: Prisma.FoodMealPlanEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodMealPlanEntryPayload>
          }
          aggregate: {
            args: Prisma.FoodMealPlanEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoodMealPlanEntry>
          }
          groupBy: {
            args: Prisma.FoodMealPlanEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoodMealPlanEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoodMealPlanEntryCountArgs<ExtArgs>
            result: $Utils.Optional<FoodMealPlanEntryCountAggregateOutputType> | number
          }
        }
      }
      QuotationProcess: {
        payload: Prisma.$QuotationProcessPayload<ExtArgs>
        fields: Prisma.QuotationProcessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuotationProcessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationProcessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuotationProcessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationProcessPayload>
          }
          findFirst: {
            args: Prisma.QuotationProcessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationProcessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuotationProcessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationProcessPayload>
          }
          findMany: {
            args: Prisma.QuotationProcessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationProcessPayload>[]
          }
          create: {
            args: Prisma.QuotationProcessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationProcessPayload>
          }
          createMany: {
            args: Prisma.QuotationProcessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuotationProcessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationProcessPayload>[]
          }
          delete: {
            args: Prisma.QuotationProcessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationProcessPayload>
          }
          update: {
            args: Prisma.QuotationProcessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationProcessPayload>
          }
          deleteMany: {
            args: Prisma.QuotationProcessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuotationProcessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuotationProcessUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationProcessPayload>[]
          }
          upsert: {
            args: Prisma.QuotationProcessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationProcessPayload>
          }
          aggregate: {
            args: Prisma.QuotationProcessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuotationProcess>
          }
          groupBy: {
            args: Prisma.QuotationProcessGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuotationProcessGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuotationProcessCountArgs<ExtArgs>
            result: $Utils.Optional<QuotationProcessCountAggregateOutputType> | number
          }
        }
      }
      QuotationBaselineItem: {
        payload: Prisma.$QuotationBaselineItemPayload<ExtArgs>
        fields: Prisma.QuotationBaselineItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuotationBaselineItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationBaselineItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuotationBaselineItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationBaselineItemPayload>
          }
          findFirst: {
            args: Prisma.QuotationBaselineItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationBaselineItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuotationBaselineItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationBaselineItemPayload>
          }
          findMany: {
            args: Prisma.QuotationBaselineItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationBaselineItemPayload>[]
          }
          create: {
            args: Prisma.QuotationBaselineItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationBaselineItemPayload>
          }
          createMany: {
            args: Prisma.QuotationBaselineItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuotationBaselineItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationBaselineItemPayload>[]
          }
          delete: {
            args: Prisma.QuotationBaselineItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationBaselineItemPayload>
          }
          update: {
            args: Prisma.QuotationBaselineItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationBaselineItemPayload>
          }
          deleteMany: {
            args: Prisma.QuotationBaselineItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuotationBaselineItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuotationBaselineItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationBaselineItemPayload>[]
          }
          upsert: {
            args: Prisma.QuotationBaselineItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationBaselineItemPayload>
          }
          aggregate: {
            args: Prisma.QuotationBaselineItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuotationBaselineItem>
          }
          groupBy: {
            args: Prisma.QuotationBaselineItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuotationBaselineItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuotationBaselineItemCountArgs<ExtArgs>
            result: $Utils.Optional<QuotationBaselineItemCountAggregateOutputType> | number
          }
        }
      }
      Quotation: {
        payload: Prisma.$QuotationPayload<ExtArgs>
        fields: Prisma.QuotationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuotationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuotationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>
          }
          findFirst: {
            args: Prisma.QuotationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuotationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>
          }
          findMany: {
            args: Prisma.QuotationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>[]
          }
          create: {
            args: Prisma.QuotationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>
          }
          createMany: {
            args: Prisma.QuotationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuotationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>[]
          }
          delete: {
            args: Prisma.QuotationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>
          }
          update: {
            args: Prisma.QuotationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>
          }
          deleteMany: {
            args: Prisma.QuotationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuotationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuotationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>[]
          }
          upsert: {
            args: Prisma.QuotationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>
          }
          aggregate: {
            args: Prisma.QuotationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuotation>
          }
          groupBy: {
            args: Prisma.QuotationGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuotationGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuotationCountArgs<ExtArgs>
            result: $Utils.Optional<QuotationCountAggregateOutputType> | number
          }
        }
      }
      QuotationItem: {
        payload: Prisma.$QuotationItemPayload<ExtArgs>
        fields: Prisma.QuotationItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuotationItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuotationItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationItemPayload>
          }
          findFirst: {
            args: Prisma.QuotationItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuotationItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationItemPayload>
          }
          findMany: {
            args: Prisma.QuotationItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationItemPayload>[]
          }
          create: {
            args: Prisma.QuotationItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationItemPayload>
          }
          createMany: {
            args: Prisma.QuotationItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuotationItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationItemPayload>[]
          }
          delete: {
            args: Prisma.QuotationItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationItemPayload>
          }
          update: {
            args: Prisma.QuotationItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationItemPayload>
          }
          deleteMany: {
            args: Prisma.QuotationItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuotationItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuotationItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationItemPayload>[]
          }
          upsert: {
            args: Prisma.QuotationItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationItemPayload>
          }
          aggregate: {
            args: Prisma.QuotationItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuotationItem>
          }
          groupBy: {
            args: Prisma.QuotationItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuotationItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuotationItemCountArgs<ExtArgs>
            result: $Utils.Optional<QuotationItemCountAggregateOutputType> | number
          }
        }
      }
      QuotationAttachment: {
        payload: Prisma.$QuotationAttachmentPayload<ExtArgs>
        fields: Prisma.QuotationAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuotationAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuotationAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationAttachmentPayload>
          }
          findFirst: {
            args: Prisma.QuotationAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuotationAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationAttachmentPayload>
          }
          findMany: {
            args: Prisma.QuotationAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationAttachmentPayload>[]
          }
          create: {
            args: Prisma.QuotationAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationAttachmentPayload>
          }
          createMany: {
            args: Prisma.QuotationAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuotationAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationAttachmentPayload>[]
          }
          delete: {
            args: Prisma.QuotationAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationAttachmentPayload>
          }
          update: {
            args: Prisma.QuotationAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.QuotationAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuotationAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuotationAttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationAttachmentPayload>[]
          }
          upsert: {
            args: Prisma.QuotationAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationAttachmentPayload>
          }
          aggregate: {
            args: Prisma.QuotationAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuotationAttachment>
          }
          groupBy: {
            args: Prisma.QuotationAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuotationAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuotationAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<QuotationAttachmentCountAggregateOutputType> | number
          }
        }
      }
      PurchaseOrderLog: {
        payload: Prisma.$PurchaseOrderLogPayload<ExtArgs>
        fields: Prisma.PurchaseOrderLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseOrderLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseOrderLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLogPayload>
          }
          findFirst: {
            args: Prisma.PurchaseOrderLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseOrderLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLogPayload>
          }
          findMany: {
            args: Prisma.PurchaseOrderLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLogPayload>[]
          }
          create: {
            args: Prisma.PurchaseOrderLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLogPayload>
          }
          createMany: {
            args: Prisma.PurchaseOrderLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseOrderLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLogPayload>[]
          }
          delete: {
            args: Prisma.PurchaseOrderLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLogPayload>
          }
          update: {
            args: Prisma.PurchaseOrderLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLogPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseOrderLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseOrderLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseOrderLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLogPayload>[]
          }
          upsert: {
            args: Prisma.PurchaseOrderLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLogPayload>
          }
          aggregate: {
            args: Prisma.PurchaseOrderLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseOrderLog>
          }
          groupBy: {
            args: Prisma.PurchaseOrderLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseOrderLogCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderLogCountAggregateOutputType> | number
          }
        }
      }
      PurchaseOrderLine: {
        payload: Prisma.$PurchaseOrderLinePayload<ExtArgs>
        fields: Prisma.PurchaseOrderLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseOrderLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseOrderLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload>
          }
          findFirst: {
            args: Prisma.PurchaseOrderLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseOrderLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload>
          }
          findMany: {
            args: Prisma.PurchaseOrderLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload>[]
          }
          create: {
            args: Prisma.PurchaseOrderLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload>
          }
          createMany: {
            args: Prisma.PurchaseOrderLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseOrderLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload>[]
          }
          delete: {
            args: Prisma.PurchaseOrderLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload>
          }
          update: {
            args: Prisma.PurchaseOrderLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload>
          }
          deleteMany: {
            args: Prisma.PurchaseOrderLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseOrderLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseOrderLineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload>[]
          }
          upsert: {
            args: Prisma.PurchaseOrderLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload>
          }
          aggregate: {
            args: Prisma.PurchaseOrderLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseOrderLine>
          }
          groupBy: {
            args: Prisma.PurchaseOrderLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseOrderLineCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderLineCountAggregateOutputType> | number
          }
        }
      }
      PurchaseDeliveryLog: {
        payload: Prisma.$PurchaseDeliveryLogPayload<ExtArgs>
        fields: Prisma.PurchaseDeliveryLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseDeliveryLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseDeliveryLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseDeliveryLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseDeliveryLogPayload>
          }
          findFirst: {
            args: Prisma.PurchaseDeliveryLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseDeliveryLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseDeliveryLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseDeliveryLogPayload>
          }
          findMany: {
            args: Prisma.PurchaseDeliveryLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseDeliveryLogPayload>[]
          }
          create: {
            args: Prisma.PurchaseDeliveryLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseDeliveryLogPayload>
          }
          createMany: {
            args: Prisma.PurchaseDeliveryLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseDeliveryLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseDeliveryLogPayload>[]
          }
          delete: {
            args: Prisma.PurchaseDeliveryLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseDeliveryLogPayload>
          }
          update: {
            args: Prisma.PurchaseDeliveryLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseDeliveryLogPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseDeliveryLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseDeliveryLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseDeliveryLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseDeliveryLogPayload>[]
          }
          upsert: {
            args: Prisma.PurchaseDeliveryLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseDeliveryLogPayload>
          }
          aggregate: {
            args: Prisma.PurchaseDeliveryLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseDeliveryLog>
          }
          groupBy: {
            args: Prisma.PurchaseDeliveryLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseDeliveryLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseDeliveryLogCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseDeliveryLogCountAggregateOutputType> | number
          }
        }
      }
      PurchaseDeliveryItem: {
        payload: Prisma.$PurchaseDeliveryItemPayload<ExtArgs>
        fields: Prisma.PurchaseDeliveryItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseDeliveryItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseDeliveryItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseDeliveryItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseDeliveryItemPayload>
          }
          findFirst: {
            args: Prisma.PurchaseDeliveryItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseDeliveryItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseDeliveryItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseDeliveryItemPayload>
          }
          findMany: {
            args: Prisma.PurchaseDeliveryItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseDeliveryItemPayload>[]
          }
          create: {
            args: Prisma.PurchaseDeliveryItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseDeliveryItemPayload>
          }
          createMany: {
            args: Prisma.PurchaseDeliveryItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseDeliveryItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseDeliveryItemPayload>[]
          }
          delete: {
            args: Prisma.PurchaseDeliveryItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseDeliveryItemPayload>
          }
          update: {
            args: Prisma.PurchaseDeliveryItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseDeliveryItemPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseDeliveryItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseDeliveryItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseDeliveryItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseDeliveryItemPayload>[]
          }
          upsert: {
            args: Prisma.PurchaseDeliveryItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseDeliveryItemPayload>
          }
          aggregate: {
            args: Prisma.PurchaseDeliveryItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseDeliveryItem>
          }
          groupBy: {
            args: Prisma.PurchaseDeliveryItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseDeliveryItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseDeliveryItemCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseDeliveryItemCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    obra?: ObraOmit
    material?: MaterialOmit
    proveedor?: ProveedorOmit
    frente?: FrenteOmit
    materialGroup?: MaterialGroupOmit
    move?: MoveOmit
    expenseCategory?: ExpenseCategoryOmit
    income?: IncomeOmit
    expense?: ExpenseOmit
    dailyCashRendition?: DailyCashRenditionOmit
    dailyCashExpense?: DailyCashExpenseOmit
    adminSetting?: AdminSettingOmit
    employee?: EmployeeOmit
    employeeAccumulationPayment?: EmployeeAccumulationPaymentOmit
    attendanceRecord?: AttendanceRecordOmit
    payrollPeriod?: PayrollPeriodOmit
    payrollEntry?: PayrollEntryOmit
    payrollAdjustment?: PayrollAdjustmentOmit
    partner?: PartnerOmit
    partnerLoan?: PartnerLoanOmit
    foodIngredient?: FoodIngredientOmit
    foodIngredientCost?: FoodIngredientCostOmit
    foodRecipe?: FoodRecipeOmit
    foodRecipeItem?: FoodRecipeItemOmit
    foodRecipeCost?: FoodRecipeCostOmit
    foodCostPool?: FoodCostPoolOmit
    foodMealPlan?: FoodMealPlanOmit
    foodMealPlanEntry?: FoodMealPlanEntryOmit
    quotationProcess?: QuotationProcessOmit
    quotationBaselineItem?: QuotationBaselineItemOmit
    quotation?: QuotationOmit
    quotationItem?: QuotationItemOmit
    quotationAttachment?: QuotationAttachmentOmit
    purchaseOrderLog?: PurchaseOrderLogOmit
    purchaseOrderLine?: PurchaseOrderLineOmit
    purchaseDeliveryLog?: PurchaseDeliveryLogOmit
    purchaseDeliveryItem?: PurchaseDeliveryItemOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ObraCountOutputType
   */

  export type ObraCountOutputType = {
    frentes: number
    moves: number
    incomes: number
    expenses: number
    employees: number
    payrollPeriods: number
    dailyCashRenditions: number
  }

  export type ObraCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    frentes?: boolean | ObraCountOutputTypeCountFrentesArgs
    moves?: boolean | ObraCountOutputTypeCountMovesArgs
    incomes?: boolean | ObraCountOutputTypeCountIncomesArgs
    expenses?: boolean | ObraCountOutputTypeCountExpensesArgs
    employees?: boolean | ObraCountOutputTypeCountEmployeesArgs
    payrollPeriods?: boolean | ObraCountOutputTypeCountPayrollPeriodsArgs
    dailyCashRenditions?: boolean | ObraCountOutputTypeCountDailyCashRenditionsArgs
  }

  // Custom InputTypes
  /**
   * ObraCountOutputType without action
   */
  export type ObraCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObraCountOutputType
     */
    select?: ObraCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ObraCountOutputType without action
   */
  export type ObraCountOutputTypeCountFrentesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FrenteWhereInput
  }

  /**
   * ObraCountOutputType without action
   */
  export type ObraCountOutputTypeCountMovesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MoveWhereInput
  }

  /**
   * ObraCountOutputType without action
   */
  export type ObraCountOutputTypeCountIncomesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncomeWhereInput
  }

  /**
   * ObraCountOutputType without action
   */
  export type ObraCountOutputTypeCountExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }

  /**
   * ObraCountOutputType without action
   */
  export type ObraCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }

  /**
   * ObraCountOutputType without action
   */
  export type ObraCountOutputTypeCountPayrollPeriodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollPeriodWhereInput
  }

  /**
   * ObraCountOutputType without action
   */
  export type ObraCountOutputTypeCountDailyCashRenditionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyCashRenditionWhereInput
  }


  /**
   * Count Type MaterialCountOutputType
   */

  export type MaterialCountOutputType = {
    moves: number
    expenses: number
    baseQuotes: number
    quoteItems: number
  }

  export type MaterialCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    moves?: boolean | MaterialCountOutputTypeCountMovesArgs
    expenses?: boolean | MaterialCountOutputTypeCountExpensesArgs
    baseQuotes?: boolean | MaterialCountOutputTypeCountBaseQuotesArgs
    quoteItems?: boolean | MaterialCountOutputTypeCountQuoteItemsArgs
  }

  // Custom InputTypes
  /**
   * MaterialCountOutputType without action
   */
  export type MaterialCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialCountOutputType
     */
    select?: MaterialCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MaterialCountOutputType without action
   */
  export type MaterialCountOutputTypeCountMovesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MoveWhereInput
  }

  /**
   * MaterialCountOutputType without action
   */
  export type MaterialCountOutputTypeCountExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }

  /**
   * MaterialCountOutputType without action
   */
  export type MaterialCountOutputTypeCountBaseQuotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotationBaselineItemWhereInput
  }

  /**
   * MaterialCountOutputType without action
   */
  export type MaterialCountOutputTypeCountQuoteItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotationItemWhereInput
  }


  /**
   * Count Type ProveedorCountOutputType
   */

  export type ProveedorCountOutputType = {
    moves: number
    expenses: number
    quotations: number
    deliveries: number
  }

  export type ProveedorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    moves?: boolean | ProveedorCountOutputTypeCountMovesArgs
    expenses?: boolean | ProveedorCountOutputTypeCountExpensesArgs
    quotations?: boolean | ProveedorCountOutputTypeCountQuotationsArgs
    deliveries?: boolean | ProveedorCountOutputTypeCountDeliveriesArgs
  }

  // Custom InputTypes
  /**
   * ProveedorCountOutputType without action
   */
  export type ProveedorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProveedorCountOutputType
     */
    select?: ProveedorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProveedorCountOutputType without action
   */
  export type ProveedorCountOutputTypeCountMovesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MoveWhereInput
  }

  /**
   * ProveedorCountOutputType without action
   */
  export type ProveedorCountOutputTypeCountExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }

  /**
   * ProveedorCountOutputType without action
   */
  export type ProveedorCountOutputTypeCountQuotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotationWhereInput
  }

  /**
   * ProveedorCountOutputType without action
   */
  export type ProveedorCountOutputTypeCountDeliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseDeliveryLogWhereInput
  }


  /**
   * Count Type FrenteCountOutputType
   */

  export type FrenteCountOutputType = {
    moves: number
    incomes: number
    expenses: number
  }

  export type FrenteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    moves?: boolean | FrenteCountOutputTypeCountMovesArgs
    incomes?: boolean | FrenteCountOutputTypeCountIncomesArgs
    expenses?: boolean | FrenteCountOutputTypeCountExpensesArgs
  }

  // Custom InputTypes
  /**
   * FrenteCountOutputType without action
   */
  export type FrenteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FrenteCountOutputType
     */
    select?: FrenteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FrenteCountOutputType without action
   */
  export type FrenteCountOutputTypeCountMovesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MoveWhereInput
  }

  /**
   * FrenteCountOutputType without action
   */
  export type FrenteCountOutputTypeCountIncomesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncomeWhereInput
  }

  /**
   * FrenteCountOutputType without action
   */
  export type FrenteCountOutputTypeCountExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }


  /**
   * Count Type MaterialGroupCountOutputType
   */

  export type MaterialGroupCountOutputType = {
    children: number
    materials: number
  }

  export type MaterialGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | MaterialGroupCountOutputTypeCountChildrenArgs
    materials?: boolean | MaterialGroupCountOutputTypeCountMaterialsArgs
  }

  // Custom InputTypes
  /**
   * MaterialGroupCountOutputType without action
   */
  export type MaterialGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialGroupCountOutputType
     */
    select?: MaterialGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MaterialGroupCountOutputType without action
   */
  export type MaterialGroupCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialGroupWhereInput
  }

  /**
   * MaterialGroupCountOutputType without action
   */
  export type MaterialGroupCountOutputTypeCountMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialWhereInput
  }


  /**
   * Count Type ExpenseCategoryCountOutputType
   */

  export type ExpenseCategoryCountOutputType = {
    expenses: number
  }

  export type ExpenseCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expenses?: boolean | ExpenseCategoryCountOutputTypeCountExpensesArgs
  }

  // Custom InputTypes
  /**
   * ExpenseCategoryCountOutputType without action
   */
  export type ExpenseCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategoryCountOutputType
     */
    select?: ExpenseCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExpenseCategoryCountOutputType without action
   */
  export type ExpenseCategoryCountOutputTypeCountExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }


  /**
   * Count Type DailyCashRenditionCountOutputType
   */

  export type DailyCashRenditionCountOutputType = {
    expenses: number
  }

  export type DailyCashRenditionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expenses?: boolean | DailyCashRenditionCountOutputTypeCountExpensesArgs
  }

  // Custom InputTypes
  /**
   * DailyCashRenditionCountOutputType without action
   */
  export type DailyCashRenditionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyCashRenditionCountOutputType
     */
    select?: DailyCashRenditionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DailyCashRenditionCountOutputType without action
   */
  export type DailyCashRenditionCountOutputTypeCountExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyCashExpenseWhereInput
  }


  /**
   * Count Type EmployeeCountOutputType
   */

  export type EmployeeCountOutputType = {
    attendances: number
    payrollEntries: number
  }

  export type EmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendances?: boolean | EmployeeCountOutputTypeCountAttendancesArgs
    payrollEntries?: boolean | EmployeeCountOutputTypeCountPayrollEntriesArgs
  }

  // Custom InputTypes
  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     */
    select?: EmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceRecordWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountPayrollEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollEntryWhereInput
  }


  /**
   * Count Type PayrollPeriodCountOutputType
   */

  export type PayrollPeriodCountOutputType = {
    entries: number
  }

  export type PayrollPeriodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entries?: boolean | PayrollPeriodCountOutputTypeCountEntriesArgs
  }

  // Custom InputTypes
  /**
   * PayrollPeriodCountOutputType without action
   */
  export type PayrollPeriodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriodCountOutputType
     */
    select?: PayrollPeriodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PayrollPeriodCountOutputType without action
   */
  export type PayrollPeriodCountOutputTypeCountEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollEntryWhereInput
  }


  /**
   * Count Type PayrollEntryCountOutputType
   */

  export type PayrollEntryCountOutputType = {
    adjustments: number
  }

  export type PayrollEntryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adjustments?: boolean | PayrollEntryCountOutputTypeCountAdjustmentsArgs
  }

  // Custom InputTypes
  /**
   * PayrollEntryCountOutputType without action
   */
  export type PayrollEntryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntryCountOutputType
     */
    select?: PayrollEntryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PayrollEntryCountOutputType without action
   */
  export type PayrollEntryCountOutputTypeCountAdjustmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollAdjustmentWhereInput
  }


  /**
   * Count Type PartnerCountOutputType
   */

  export type PartnerCountOutputType = {
    loansGiven: number
    loansReceived: number
  }

  export type PartnerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loansGiven?: boolean | PartnerCountOutputTypeCountLoansGivenArgs
    loansReceived?: boolean | PartnerCountOutputTypeCountLoansReceivedArgs
  }

  // Custom InputTypes
  /**
   * PartnerCountOutputType without action
   */
  export type PartnerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerCountOutputType
     */
    select?: PartnerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PartnerCountOutputType without action
   */
  export type PartnerCountOutputTypeCountLoansGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartnerLoanWhereInput
  }

  /**
   * PartnerCountOutputType without action
   */
  export type PartnerCountOutputTypeCountLoansReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartnerLoanWhereInput
  }


  /**
   * Count Type FoodIngredientCountOutputType
   */

  export type FoodIngredientCountOutputType = {
    costs: number
    items: number
  }

  export type FoodIngredientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    costs?: boolean | FoodIngredientCountOutputTypeCountCostsArgs
    items?: boolean | FoodIngredientCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * FoodIngredientCountOutputType without action
   */
  export type FoodIngredientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodIngredientCountOutputType
     */
    select?: FoodIngredientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FoodIngredientCountOutputType without action
   */
  export type FoodIngredientCountOutputTypeCountCostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodIngredientCostWhereInput
  }

  /**
   * FoodIngredientCountOutputType without action
   */
  export type FoodIngredientCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodRecipeItemWhereInput
  }


  /**
   * Count Type FoodRecipeCountOutputType
   */

  export type FoodRecipeCountOutputType = {
    items: number
    childItems: number
    extraCosts: number
    mealPlanEntries: number
  }

  export type FoodRecipeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | FoodRecipeCountOutputTypeCountItemsArgs
    childItems?: boolean | FoodRecipeCountOutputTypeCountChildItemsArgs
    extraCosts?: boolean | FoodRecipeCountOutputTypeCountExtraCostsArgs
    mealPlanEntries?: boolean | FoodRecipeCountOutputTypeCountMealPlanEntriesArgs
  }

  // Custom InputTypes
  /**
   * FoodRecipeCountOutputType without action
   */
  export type FoodRecipeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipeCountOutputType
     */
    select?: FoodRecipeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FoodRecipeCountOutputType without action
   */
  export type FoodRecipeCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodRecipeItemWhereInput
  }

  /**
   * FoodRecipeCountOutputType without action
   */
  export type FoodRecipeCountOutputTypeCountChildItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodRecipeItemWhereInput
  }

  /**
   * FoodRecipeCountOutputType without action
   */
  export type FoodRecipeCountOutputTypeCountExtraCostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodRecipeCostWhereInput
  }

  /**
   * FoodRecipeCountOutputType without action
   */
  export type FoodRecipeCountOutputTypeCountMealPlanEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodMealPlanEntryWhereInput
  }


  /**
   * Count Type FoodMealPlanCountOutputType
   */

  export type FoodMealPlanCountOutputType = {
    entries: number
  }

  export type FoodMealPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entries?: boolean | FoodMealPlanCountOutputTypeCountEntriesArgs
  }

  // Custom InputTypes
  /**
   * FoodMealPlanCountOutputType without action
   */
  export type FoodMealPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodMealPlanCountOutputType
     */
    select?: FoodMealPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FoodMealPlanCountOutputType without action
   */
  export type FoodMealPlanCountOutputTypeCountEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodMealPlanEntryWhereInput
  }


  /**
   * Count Type QuotationProcessCountOutputType
   */

  export type QuotationProcessCountOutputType = {
    baselines: number
    quotations: number
    purchaseOrders: number
    deliveryLogs: number
  }

  export type QuotationProcessCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    baselines?: boolean | QuotationProcessCountOutputTypeCountBaselinesArgs
    quotations?: boolean | QuotationProcessCountOutputTypeCountQuotationsArgs
    purchaseOrders?: boolean | QuotationProcessCountOutputTypeCountPurchaseOrdersArgs
    deliveryLogs?: boolean | QuotationProcessCountOutputTypeCountDeliveryLogsArgs
  }

  // Custom InputTypes
  /**
   * QuotationProcessCountOutputType without action
   */
  export type QuotationProcessCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationProcessCountOutputType
     */
    select?: QuotationProcessCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuotationProcessCountOutputType without action
   */
  export type QuotationProcessCountOutputTypeCountBaselinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotationBaselineItemWhereInput
  }

  /**
   * QuotationProcessCountOutputType without action
   */
  export type QuotationProcessCountOutputTypeCountQuotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotationWhereInput
  }

  /**
   * QuotationProcessCountOutputType without action
   */
  export type QuotationProcessCountOutputTypeCountPurchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderLogWhereInput
  }

  /**
   * QuotationProcessCountOutputType without action
   */
  export type QuotationProcessCountOutputTypeCountDeliveryLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseDeliveryLogWhereInput
  }


  /**
   * Count Type QuotationBaselineItemCountOutputType
   */

  export type QuotationBaselineItemCountOutputType = {
    quoteItems: number
    orderLines: number
    deliveryItems: number
  }

  export type QuotationBaselineItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quoteItems?: boolean | QuotationBaselineItemCountOutputTypeCountQuoteItemsArgs
    orderLines?: boolean | QuotationBaselineItemCountOutputTypeCountOrderLinesArgs
    deliveryItems?: boolean | QuotationBaselineItemCountOutputTypeCountDeliveryItemsArgs
  }

  // Custom InputTypes
  /**
   * QuotationBaselineItemCountOutputType without action
   */
  export type QuotationBaselineItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationBaselineItemCountOutputType
     */
    select?: QuotationBaselineItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuotationBaselineItemCountOutputType without action
   */
  export type QuotationBaselineItemCountOutputTypeCountQuoteItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotationItemWhereInput
  }

  /**
   * QuotationBaselineItemCountOutputType without action
   */
  export type QuotationBaselineItemCountOutputTypeCountOrderLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderLineWhereInput
  }

  /**
   * QuotationBaselineItemCountOutputType without action
   */
  export type QuotationBaselineItemCountOutputTypeCountDeliveryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseDeliveryItemWhereInput
  }


  /**
   * Count Type QuotationCountOutputType
   */

  export type QuotationCountOutputType = {
    items: number
    attachments: number
    purchaseOrders: number
  }

  export type QuotationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | QuotationCountOutputTypeCountItemsArgs
    attachments?: boolean | QuotationCountOutputTypeCountAttachmentsArgs
    purchaseOrders?: boolean | QuotationCountOutputTypeCountPurchaseOrdersArgs
  }

  // Custom InputTypes
  /**
   * QuotationCountOutputType without action
   */
  export type QuotationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationCountOutputType
     */
    select?: QuotationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuotationCountOutputType without action
   */
  export type QuotationCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotationItemWhereInput
  }

  /**
   * QuotationCountOutputType without action
   */
  export type QuotationCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotationAttachmentWhereInput
  }

  /**
   * QuotationCountOutputType without action
   */
  export type QuotationCountOutputTypeCountPurchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderLogWhereInput
  }


  /**
   * Count Type PurchaseOrderLogCountOutputType
   */

  export type PurchaseOrderLogCountOutputType = {
    lines: number
    deliveries: number
  }

  export type PurchaseOrderLogCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | PurchaseOrderLogCountOutputTypeCountLinesArgs
    deliveries?: boolean | PurchaseOrderLogCountOutputTypeCountDeliveriesArgs
  }

  // Custom InputTypes
  /**
   * PurchaseOrderLogCountOutputType without action
   */
  export type PurchaseOrderLogCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLogCountOutputType
     */
    select?: PurchaseOrderLogCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseOrderLogCountOutputType without action
   */
  export type PurchaseOrderLogCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderLineWhereInput
  }

  /**
   * PurchaseOrderLogCountOutputType without action
   */
  export type PurchaseOrderLogCountOutputTypeCountDeliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseDeliveryLogWhereInput
  }


  /**
   * Count Type PurchaseOrderLineCountOutputType
   */

  export type PurchaseOrderLineCountOutputType = {
    deliveries: number
  }

  export type PurchaseOrderLineCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deliveries?: boolean | PurchaseOrderLineCountOutputTypeCountDeliveriesArgs
  }

  // Custom InputTypes
  /**
   * PurchaseOrderLineCountOutputType without action
   */
  export type PurchaseOrderLineCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLineCountOutputType
     */
    select?: PurchaseOrderLineCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseOrderLineCountOutputType without action
   */
  export type PurchaseOrderLineCountOutputTypeCountDeliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseDeliveryItemWhereInput
  }


  /**
   * Count Type PurchaseDeliveryLogCountOutputType
   */

  export type PurchaseDeliveryLogCountOutputType = {
    items: number
  }

  export type PurchaseDeliveryLogCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | PurchaseDeliveryLogCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * PurchaseDeliveryLogCountOutputType without action
   */
  export type PurchaseDeliveryLogCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseDeliveryLogCountOutputType
     */
    select?: PurchaseDeliveryLogCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseDeliveryLogCountOutputType without action
   */
  export type PurchaseDeliveryLogCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseDeliveryItemWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Obra
   */

  export type AggregateObra = {
    _count: ObraCountAggregateOutputType | null
    _avg: ObraAvgAggregateOutputType | null
    _sum: ObraSumAggregateOutputType | null
    _min: ObraMinAggregateOutputType | null
    _max: ObraMaxAggregateOutputType | null
  }

  export type ObraAvgAggregateOutputType = {
    id: number | null
  }

  export type ObraSumAggregateOutputType = {
    id: number | null
  }

  export type ObraMinAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
  }

  export type ObraMaxAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
  }

  export type ObraCountAggregateOutputType = {
    id: number
    name: number
    code: number
    _all: number
  }


  export type ObraAvgAggregateInputType = {
    id?: true
  }

  export type ObraSumAggregateInputType = {
    id?: true
  }

  export type ObraMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
  }

  export type ObraMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
  }

  export type ObraCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    _all?: true
  }

  export type ObraAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Obra to aggregate.
     */
    where?: ObraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Obras to fetch.
     */
    orderBy?: ObraOrderByWithRelationInput | ObraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ObraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Obras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Obras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Obras
    **/
    _count?: true | ObraCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ObraAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ObraSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ObraMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ObraMaxAggregateInputType
  }

  export type GetObraAggregateType<T extends ObraAggregateArgs> = {
        [P in keyof T & keyof AggregateObra]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateObra[P]>
      : GetScalarType<T[P], AggregateObra[P]>
  }




  export type ObraGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObraWhereInput
    orderBy?: ObraOrderByWithAggregationInput | ObraOrderByWithAggregationInput[]
    by: ObraScalarFieldEnum[] | ObraScalarFieldEnum
    having?: ObraScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ObraCountAggregateInputType | true
    _avg?: ObraAvgAggregateInputType
    _sum?: ObraSumAggregateInputType
    _min?: ObraMinAggregateInputType
    _max?: ObraMaxAggregateInputType
  }

  export type ObraGroupByOutputType = {
    id: number
    name: string
    code: string | null
    _count: ObraCountAggregateOutputType | null
    _avg: ObraAvgAggregateOutputType | null
    _sum: ObraSumAggregateOutputType | null
    _min: ObraMinAggregateOutputType | null
    _max: ObraMaxAggregateOutputType | null
  }

  type GetObraGroupByPayload<T extends ObraGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ObraGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ObraGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ObraGroupByOutputType[P]>
            : GetScalarType<T[P], ObraGroupByOutputType[P]>
        }
      >
    >


  export type ObraSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    frentes?: boolean | Obra$frentesArgs<ExtArgs>
    moves?: boolean | Obra$movesArgs<ExtArgs>
    incomes?: boolean | Obra$incomesArgs<ExtArgs>
    expenses?: boolean | Obra$expensesArgs<ExtArgs>
    employees?: boolean | Obra$employeesArgs<ExtArgs>
    payrollPeriods?: boolean | Obra$payrollPeriodsArgs<ExtArgs>
    dailyCashRenditions?: boolean | Obra$dailyCashRenditionsArgs<ExtArgs>
    _count?: boolean | ObraCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["obra"]>

  export type ObraSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
  }, ExtArgs["result"]["obra"]>

  export type ObraSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
  }, ExtArgs["result"]["obra"]>

  export type ObraSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
  }

  export type ObraOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code", ExtArgs["result"]["obra"]>
  export type ObraInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    frentes?: boolean | Obra$frentesArgs<ExtArgs>
    moves?: boolean | Obra$movesArgs<ExtArgs>
    incomes?: boolean | Obra$incomesArgs<ExtArgs>
    expenses?: boolean | Obra$expensesArgs<ExtArgs>
    employees?: boolean | Obra$employeesArgs<ExtArgs>
    payrollPeriods?: boolean | Obra$payrollPeriodsArgs<ExtArgs>
    dailyCashRenditions?: boolean | Obra$dailyCashRenditionsArgs<ExtArgs>
    _count?: boolean | ObraCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ObraIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ObraIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ObraPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Obra"
    objects: {
      frentes: Prisma.$FrentePayload<ExtArgs>[]
      moves: Prisma.$MovePayload<ExtArgs>[]
      incomes: Prisma.$IncomePayload<ExtArgs>[]
      expenses: Prisma.$ExpensePayload<ExtArgs>[]
      employees: Prisma.$EmployeePayload<ExtArgs>[]
      payrollPeriods: Prisma.$PayrollPeriodPayload<ExtArgs>[]
      dailyCashRenditions: Prisma.$DailyCashRenditionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      code: string | null
    }, ExtArgs["result"]["obra"]>
    composites: {}
  }

  type ObraGetPayload<S extends boolean | null | undefined | ObraDefaultArgs> = $Result.GetResult<Prisma.$ObraPayload, S>

  type ObraCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ObraFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ObraCountAggregateInputType | true
    }

  export interface ObraDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Obra'], meta: { name: 'Obra' } }
    /**
     * Find zero or one Obra that matches the filter.
     * @param {ObraFindUniqueArgs} args - Arguments to find a Obra
     * @example
     * // Get one Obra
     * const obra = await prisma.obra.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ObraFindUniqueArgs>(args: SelectSubset<T, ObraFindUniqueArgs<ExtArgs>>): Prisma__ObraClient<$Result.GetResult<Prisma.$ObraPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Obra that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ObraFindUniqueOrThrowArgs} args - Arguments to find a Obra
     * @example
     * // Get one Obra
     * const obra = await prisma.obra.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ObraFindUniqueOrThrowArgs>(args: SelectSubset<T, ObraFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ObraClient<$Result.GetResult<Prisma.$ObraPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Obra that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObraFindFirstArgs} args - Arguments to find a Obra
     * @example
     * // Get one Obra
     * const obra = await prisma.obra.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ObraFindFirstArgs>(args?: SelectSubset<T, ObraFindFirstArgs<ExtArgs>>): Prisma__ObraClient<$Result.GetResult<Prisma.$ObraPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Obra that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObraFindFirstOrThrowArgs} args - Arguments to find a Obra
     * @example
     * // Get one Obra
     * const obra = await prisma.obra.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ObraFindFirstOrThrowArgs>(args?: SelectSubset<T, ObraFindFirstOrThrowArgs<ExtArgs>>): Prisma__ObraClient<$Result.GetResult<Prisma.$ObraPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Obras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObraFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Obras
     * const obras = await prisma.obra.findMany()
     * 
     * // Get first 10 Obras
     * const obras = await prisma.obra.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const obraWithIdOnly = await prisma.obra.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ObraFindManyArgs>(args?: SelectSubset<T, ObraFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObraPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Obra.
     * @param {ObraCreateArgs} args - Arguments to create a Obra.
     * @example
     * // Create one Obra
     * const Obra = await prisma.obra.create({
     *   data: {
     *     // ... data to create a Obra
     *   }
     * })
     * 
     */
    create<T extends ObraCreateArgs>(args: SelectSubset<T, ObraCreateArgs<ExtArgs>>): Prisma__ObraClient<$Result.GetResult<Prisma.$ObraPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Obras.
     * @param {ObraCreateManyArgs} args - Arguments to create many Obras.
     * @example
     * // Create many Obras
     * const obra = await prisma.obra.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ObraCreateManyArgs>(args?: SelectSubset<T, ObraCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Obras and returns the data saved in the database.
     * @param {ObraCreateManyAndReturnArgs} args - Arguments to create many Obras.
     * @example
     * // Create many Obras
     * const obra = await prisma.obra.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Obras and only return the `id`
     * const obraWithIdOnly = await prisma.obra.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ObraCreateManyAndReturnArgs>(args?: SelectSubset<T, ObraCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObraPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Obra.
     * @param {ObraDeleteArgs} args - Arguments to delete one Obra.
     * @example
     * // Delete one Obra
     * const Obra = await prisma.obra.delete({
     *   where: {
     *     // ... filter to delete one Obra
     *   }
     * })
     * 
     */
    delete<T extends ObraDeleteArgs>(args: SelectSubset<T, ObraDeleteArgs<ExtArgs>>): Prisma__ObraClient<$Result.GetResult<Prisma.$ObraPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Obra.
     * @param {ObraUpdateArgs} args - Arguments to update one Obra.
     * @example
     * // Update one Obra
     * const obra = await prisma.obra.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ObraUpdateArgs>(args: SelectSubset<T, ObraUpdateArgs<ExtArgs>>): Prisma__ObraClient<$Result.GetResult<Prisma.$ObraPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Obras.
     * @param {ObraDeleteManyArgs} args - Arguments to filter Obras to delete.
     * @example
     * // Delete a few Obras
     * const { count } = await prisma.obra.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ObraDeleteManyArgs>(args?: SelectSubset<T, ObraDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Obras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObraUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Obras
     * const obra = await prisma.obra.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ObraUpdateManyArgs>(args: SelectSubset<T, ObraUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Obras and returns the data updated in the database.
     * @param {ObraUpdateManyAndReturnArgs} args - Arguments to update many Obras.
     * @example
     * // Update many Obras
     * const obra = await prisma.obra.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Obras and only return the `id`
     * const obraWithIdOnly = await prisma.obra.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ObraUpdateManyAndReturnArgs>(args: SelectSubset<T, ObraUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObraPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Obra.
     * @param {ObraUpsertArgs} args - Arguments to update or create a Obra.
     * @example
     * // Update or create a Obra
     * const obra = await prisma.obra.upsert({
     *   create: {
     *     // ... data to create a Obra
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Obra we want to update
     *   }
     * })
     */
    upsert<T extends ObraUpsertArgs>(args: SelectSubset<T, ObraUpsertArgs<ExtArgs>>): Prisma__ObraClient<$Result.GetResult<Prisma.$ObraPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Obras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObraCountArgs} args - Arguments to filter Obras to count.
     * @example
     * // Count the number of Obras
     * const count = await prisma.obra.count({
     *   where: {
     *     // ... the filter for the Obras we want to count
     *   }
     * })
    **/
    count<T extends ObraCountArgs>(
      args?: Subset<T, ObraCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ObraCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Obra.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObraAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ObraAggregateArgs>(args: Subset<T, ObraAggregateArgs>): Prisma.PrismaPromise<GetObraAggregateType<T>>

    /**
     * Group by Obra.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObraGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ObraGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ObraGroupByArgs['orderBy'] }
        : { orderBy?: ObraGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ObraGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetObraGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Obra model
   */
  readonly fields: ObraFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Obra.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ObraClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    frentes<T extends Obra$frentesArgs<ExtArgs> = {}>(args?: Subset<T, Obra$frentesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FrentePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    moves<T extends Obra$movesArgs<ExtArgs> = {}>(args?: Subset<T, Obra$movesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    incomes<T extends Obra$incomesArgs<ExtArgs> = {}>(args?: Subset<T, Obra$incomesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncomePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    expenses<T extends Obra$expensesArgs<ExtArgs> = {}>(args?: Subset<T, Obra$expensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employees<T extends Obra$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Obra$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payrollPeriods<T extends Obra$payrollPeriodsArgs<ExtArgs> = {}>(args?: Subset<T, Obra$payrollPeriodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPeriodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dailyCashRenditions<T extends Obra$dailyCashRenditionsArgs<ExtArgs> = {}>(args?: Subset<T, Obra$dailyCashRenditionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyCashRenditionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Obra model
   */
  interface ObraFieldRefs {
    readonly id: FieldRef<"Obra", 'Int'>
    readonly name: FieldRef<"Obra", 'String'>
    readonly code: FieldRef<"Obra", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Obra findUnique
   */
  export type ObraFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obra
     */
    select?: ObraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Obra
     */
    omit?: ObraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObraInclude<ExtArgs> | null
    /**
     * Filter, which Obra to fetch.
     */
    where: ObraWhereUniqueInput
  }

  /**
   * Obra findUniqueOrThrow
   */
  export type ObraFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obra
     */
    select?: ObraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Obra
     */
    omit?: ObraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObraInclude<ExtArgs> | null
    /**
     * Filter, which Obra to fetch.
     */
    where: ObraWhereUniqueInput
  }

  /**
   * Obra findFirst
   */
  export type ObraFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obra
     */
    select?: ObraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Obra
     */
    omit?: ObraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObraInclude<ExtArgs> | null
    /**
     * Filter, which Obra to fetch.
     */
    where?: ObraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Obras to fetch.
     */
    orderBy?: ObraOrderByWithRelationInput | ObraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Obras.
     */
    cursor?: ObraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Obras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Obras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Obras.
     */
    distinct?: ObraScalarFieldEnum | ObraScalarFieldEnum[]
  }

  /**
   * Obra findFirstOrThrow
   */
  export type ObraFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obra
     */
    select?: ObraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Obra
     */
    omit?: ObraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObraInclude<ExtArgs> | null
    /**
     * Filter, which Obra to fetch.
     */
    where?: ObraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Obras to fetch.
     */
    orderBy?: ObraOrderByWithRelationInput | ObraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Obras.
     */
    cursor?: ObraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Obras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Obras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Obras.
     */
    distinct?: ObraScalarFieldEnum | ObraScalarFieldEnum[]
  }

  /**
   * Obra findMany
   */
  export type ObraFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obra
     */
    select?: ObraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Obra
     */
    omit?: ObraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObraInclude<ExtArgs> | null
    /**
     * Filter, which Obras to fetch.
     */
    where?: ObraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Obras to fetch.
     */
    orderBy?: ObraOrderByWithRelationInput | ObraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Obras.
     */
    cursor?: ObraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Obras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Obras.
     */
    skip?: number
    distinct?: ObraScalarFieldEnum | ObraScalarFieldEnum[]
  }

  /**
   * Obra create
   */
  export type ObraCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obra
     */
    select?: ObraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Obra
     */
    omit?: ObraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObraInclude<ExtArgs> | null
    /**
     * The data needed to create a Obra.
     */
    data: XOR<ObraCreateInput, ObraUncheckedCreateInput>
  }

  /**
   * Obra createMany
   */
  export type ObraCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Obras.
     */
    data: ObraCreateManyInput | ObraCreateManyInput[]
  }

  /**
   * Obra createManyAndReturn
   */
  export type ObraCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obra
     */
    select?: ObraSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Obra
     */
    omit?: ObraOmit<ExtArgs> | null
    /**
     * The data used to create many Obras.
     */
    data: ObraCreateManyInput | ObraCreateManyInput[]
  }

  /**
   * Obra update
   */
  export type ObraUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obra
     */
    select?: ObraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Obra
     */
    omit?: ObraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObraInclude<ExtArgs> | null
    /**
     * The data needed to update a Obra.
     */
    data: XOR<ObraUpdateInput, ObraUncheckedUpdateInput>
    /**
     * Choose, which Obra to update.
     */
    where: ObraWhereUniqueInput
  }

  /**
   * Obra updateMany
   */
  export type ObraUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Obras.
     */
    data: XOR<ObraUpdateManyMutationInput, ObraUncheckedUpdateManyInput>
    /**
     * Filter which Obras to update
     */
    where?: ObraWhereInput
    /**
     * Limit how many Obras to update.
     */
    limit?: number
  }

  /**
   * Obra updateManyAndReturn
   */
  export type ObraUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obra
     */
    select?: ObraSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Obra
     */
    omit?: ObraOmit<ExtArgs> | null
    /**
     * The data used to update Obras.
     */
    data: XOR<ObraUpdateManyMutationInput, ObraUncheckedUpdateManyInput>
    /**
     * Filter which Obras to update
     */
    where?: ObraWhereInput
    /**
     * Limit how many Obras to update.
     */
    limit?: number
  }

  /**
   * Obra upsert
   */
  export type ObraUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obra
     */
    select?: ObraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Obra
     */
    omit?: ObraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObraInclude<ExtArgs> | null
    /**
     * The filter to search for the Obra to update in case it exists.
     */
    where: ObraWhereUniqueInput
    /**
     * In case the Obra found by the `where` argument doesn't exist, create a new Obra with this data.
     */
    create: XOR<ObraCreateInput, ObraUncheckedCreateInput>
    /**
     * In case the Obra was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ObraUpdateInput, ObraUncheckedUpdateInput>
  }

  /**
   * Obra delete
   */
  export type ObraDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obra
     */
    select?: ObraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Obra
     */
    omit?: ObraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObraInclude<ExtArgs> | null
    /**
     * Filter which Obra to delete.
     */
    where: ObraWhereUniqueInput
  }

  /**
   * Obra deleteMany
   */
  export type ObraDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Obras to delete
     */
    where?: ObraWhereInput
    /**
     * Limit how many Obras to delete.
     */
    limit?: number
  }

  /**
   * Obra.frentes
   */
  export type Obra$frentesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Frente
     */
    select?: FrenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Frente
     */
    omit?: FrenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FrenteInclude<ExtArgs> | null
    where?: FrenteWhereInput
    orderBy?: FrenteOrderByWithRelationInput | FrenteOrderByWithRelationInput[]
    cursor?: FrenteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FrenteScalarFieldEnum | FrenteScalarFieldEnum[]
  }

  /**
   * Obra.moves
   */
  export type Obra$movesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Move
     */
    select?: MoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Move
     */
    omit?: MoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveInclude<ExtArgs> | null
    where?: MoveWhereInput
    orderBy?: MoveOrderByWithRelationInput | MoveOrderByWithRelationInput[]
    cursor?: MoveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MoveScalarFieldEnum | MoveScalarFieldEnum[]
  }

  /**
   * Obra.incomes
   */
  export type Obra$incomesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Income
     */
    select?: IncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Income
     */
    omit?: IncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeInclude<ExtArgs> | null
    where?: IncomeWhereInput
    orderBy?: IncomeOrderByWithRelationInput | IncomeOrderByWithRelationInput[]
    cursor?: IncomeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncomeScalarFieldEnum | IncomeScalarFieldEnum[]
  }

  /**
   * Obra.expenses
   */
  export type Obra$expensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Obra.employees
   */
  export type Obra$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Obra.payrollPeriods
   */
  export type Obra$payrollPeriodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriod
     */
    select?: PayrollPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollPeriod
     */
    omit?: PayrollPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollPeriodInclude<ExtArgs> | null
    where?: PayrollPeriodWhereInput
    orderBy?: PayrollPeriodOrderByWithRelationInput | PayrollPeriodOrderByWithRelationInput[]
    cursor?: PayrollPeriodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayrollPeriodScalarFieldEnum | PayrollPeriodScalarFieldEnum[]
  }

  /**
   * Obra.dailyCashRenditions
   */
  export type Obra$dailyCashRenditionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyCashRendition
     */
    select?: DailyCashRenditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyCashRendition
     */
    omit?: DailyCashRenditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyCashRenditionInclude<ExtArgs> | null
    where?: DailyCashRenditionWhereInput
    orderBy?: DailyCashRenditionOrderByWithRelationInput | DailyCashRenditionOrderByWithRelationInput[]
    cursor?: DailyCashRenditionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyCashRenditionScalarFieldEnum | DailyCashRenditionScalarFieldEnum[]
  }

  /**
   * Obra without action
   */
  export type ObraDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obra
     */
    select?: ObraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Obra
     */
    omit?: ObraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObraInclude<ExtArgs> | null
  }


  /**
   * Model Material
   */

  export type AggregateMaterial = {
    _count: MaterialCountAggregateOutputType | null
    _avg: MaterialAvgAggregateOutputType | null
    _sum: MaterialSumAggregateOutputType | null
    _min: MaterialMinAggregateOutputType | null
    _max: MaterialMaxAggregateOutputType | null
  }

  export type MaterialAvgAggregateOutputType = {
    id: number | null
    groupId: number | null
    minStock: Decimal | null
    reorderQuantity: Decimal | null
  }

  export type MaterialSumAggregateOutputType = {
    id: number | null
    groupId: number | null
    minStock: Decimal | null
    reorderQuantity: Decimal | null
  }

  export type MaterialMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    unit: string | null
    groupId: number | null
    minStock: Decimal | null
    reorderQuantity: Decimal | null
    allowNegative: boolean | null
    isCompanyAsset: boolean | null
    assetStatus: $Enums.AssetStatus | null
    assetResponsible: string | null
  }

  export type MaterialMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    unit: string | null
    groupId: number | null
    minStock: Decimal | null
    reorderQuantity: Decimal | null
    allowNegative: boolean | null
    isCompanyAsset: boolean | null
    assetStatus: $Enums.AssetStatus | null
    assetResponsible: string | null
  }

  export type MaterialCountAggregateOutputType = {
    id: number
    code: number
    name: number
    unit: number
    groupId: number
    minStock: number
    reorderQuantity: number
    allowNegative: number
    isCompanyAsset: number
    assetStatus: number
    assetResponsible: number
    _all: number
  }


  export type MaterialAvgAggregateInputType = {
    id?: true
    groupId?: true
    minStock?: true
    reorderQuantity?: true
  }

  export type MaterialSumAggregateInputType = {
    id?: true
    groupId?: true
    minStock?: true
    reorderQuantity?: true
  }

  export type MaterialMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    unit?: true
    groupId?: true
    minStock?: true
    reorderQuantity?: true
    allowNegative?: true
    isCompanyAsset?: true
    assetStatus?: true
    assetResponsible?: true
  }

  export type MaterialMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    unit?: true
    groupId?: true
    minStock?: true
    reorderQuantity?: true
    allowNegative?: true
    isCompanyAsset?: true
    assetStatus?: true
    assetResponsible?: true
  }

  export type MaterialCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    unit?: true
    groupId?: true
    minStock?: true
    reorderQuantity?: true
    allowNegative?: true
    isCompanyAsset?: true
    assetStatus?: true
    assetResponsible?: true
    _all?: true
  }

  export type MaterialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Material to aggregate.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Materials
    **/
    _count?: true | MaterialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialMaxAggregateInputType
  }

  export type GetMaterialAggregateType<T extends MaterialAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterial[P]>
      : GetScalarType<T[P], AggregateMaterial[P]>
  }




  export type MaterialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialWhereInput
    orderBy?: MaterialOrderByWithAggregationInput | MaterialOrderByWithAggregationInput[]
    by: MaterialScalarFieldEnum[] | MaterialScalarFieldEnum
    having?: MaterialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialCountAggregateInputType | true
    _avg?: MaterialAvgAggregateInputType
    _sum?: MaterialSumAggregateInputType
    _min?: MaterialMinAggregateInputType
    _max?: MaterialMaxAggregateInputType
  }

  export type MaterialGroupByOutputType = {
    id: number
    code: string | null
    name: string
    unit: string | null
    groupId: number | null
    minStock: Decimal
    reorderQuantity: Decimal
    allowNegative: boolean
    isCompanyAsset: boolean
    assetStatus: $Enums.AssetStatus
    assetResponsible: string | null
    _count: MaterialCountAggregateOutputType | null
    _avg: MaterialAvgAggregateOutputType | null
    _sum: MaterialSumAggregateOutputType | null
    _min: MaterialMinAggregateOutputType | null
    _max: MaterialMaxAggregateOutputType | null
  }

  type GetMaterialGroupByPayload<T extends MaterialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialGroupByOutputType[P]>
        }
      >
    >


  export type MaterialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    unit?: boolean
    groupId?: boolean
    minStock?: boolean
    reorderQuantity?: boolean
    allowNegative?: boolean
    isCompanyAsset?: boolean
    assetStatus?: boolean
    assetResponsible?: boolean
    group?: boolean | Material$groupArgs<ExtArgs>
    moves?: boolean | Material$movesArgs<ExtArgs>
    expenses?: boolean | Material$expensesArgs<ExtArgs>
    baseQuotes?: boolean | Material$baseQuotesArgs<ExtArgs>
    quoteItems?: boolean | Material$quoteItemsArgs<ExtArgs>
    _count?: boolean | MaterialCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    unit?: boolean
    groupId?: boolean
    minStock?: boolean
    reorderQuantity?: boolean
    allowNegative?: boolean
    isCompanyAsset?: boolean
    assetStatus?: boolean
    assetResponsible?: boolean
    group?: boolean | Material$groupArgs<ExtArgs>
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    unit?: boolean
    groupId?: boolean
    minStock?: boolean
    reorderQuantity?: boolean
    allowNegative?: boolean
    isCompanyAsset?: boolean
    assetStatus?: boolean
    assetResponsible?: boolean
    group?: boolean | Material$groupArgs<ExtArgs>
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    unit?: boolean
    groupId?: boolean
    minStock?: boolean
    reorderQuantity?: boolean
    allowNegative?: boolean
    isCompanyAsset?: boolean
    assetStatus?: boolean
    assetResponsible?: boolean
  }

  export type MaterialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "unit" | "groupId" | "minStock" | "reorderQuantity" | "allowNegative" | "isCompanyAsset" | "assetStatus" | "assetResponsible", ExtArgs["result"]["material"]>
  export type MaterialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | Material$groupArgs<ExtArgs>
    moves?: boolean | Material$movesArgs<ExtArgs>
    expenses?: boolean | Material$expensesArgs<ExtArgs>
    baseQuotes?: boolean | Material$baseQuotesArgs<ExtArgs>
    quoteItems?: boolean | Material$quoteItemsArgs<ExtArgs>
    _count?: boolean | MaterialCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MaterialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | Material$groupArgs<ExtArgs>
  }
  export type MaterialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | Material$groupArgs<ExtArgs>
  }

  export type $MaterialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Material"
    objects: {
      group: Prisma.$MaterialGroupPayload<ExtArgs> | null
      moves: Prisma.$MovePayload<ExtArgs>[]
      expenses: Prisma.$ExpensePayload<ExtArgs>[]
      baseQuotes: Prisma.$QuotationBaselineItemPayload<ExtArgs>[]
      quoteItems: Prisma.$QuotationItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string | null
      name: string
      unit: string | null
      groupId: number | null
      minStock: Prisma.Decimal
      reorderQuantity: Prisma.Decimal
      allowNegative: boolean
      isCompanyAsset: boolean
      assetStatus: $Enums.AssetStatus
      assetResponsible: string | null
    }, ExtArgs["result"]["material"]>
    composites: {}
  }

  type MaterialGetPayload<S extends boolean | null | undefined | MaterialDefaultArgs> = $Result.GetResult<Prisma.$MaterialPayload, S>

  type MaterialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaterialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaterialCountAggregateInputType | true
    }

  export interface MaterialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Material'], meta: { name: 'Material' } }
    /**
     * Find zero or one Material that matches the filter.
     * @param {MaterialFindUniqueArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaterialFindUniqueArgs>(args: SelectSubset<T, MaterialFindUniqueArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Material that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaterialFindUniqueOrThrowArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaterialFindUniqueOrThrowArgs>(args: SelectSubset<T, MaterialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Material that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindFirstArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaterialFindFirstArgs>(args?: SelectSubset<T, MaterialFindFirstArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Material that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindFirstOrThrowArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaterialFindFirstOrThrowArgs>(args?: SelectSubset<T, MaterialFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Materials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Materials
     * const materials = await prisma.material.findMany()
     * 
     * // Get first 10 Materials
     * const materials = await prisma.material.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialWithIdOnly = await prisma.material.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaterialFindManyArgs>(args?: SelectSubset<T, MaterialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Material.
     * @param {MaterialCreateArgs} args - Arguments to create a Material.
     * @example
     * // Create one Material
     * const Material = await prisma.material.create({
     *   data: {
     *     // ... data to create a Material
     *   }
     * })
     * 
     */
    create<T extends MaterialCreateArgs>(args: SelectSubset<T, MaterialCreateArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Materials.
     * @param {MaterialCreateManyArgs} args - Arguments to create many Materials.
     * @example
     * // Create many Materials
     * const material = await prisma.material.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaterialCreateManyArgs>(args?: SelectSubset<T, MaterialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Materials and returns the data saved in the database.
     * @param {MaterialCreateManyAndReturnArgs} args - Arguments to create many Materials.
     * @example
     * // Create many Materials
     * const material = await prisma.material.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Materials and only return the `id`
     * const materialWithIdOnly = await prisma.material.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaterialCreateManyAndReturnArgs>(args?: SelectSubset<T, MaterialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Material.
     * @param {MaterialDeleteArgs} args - Arguments to delete one Material.
     * @example
     * // Delete one Material
     * const Material = await prisma.material.delete({
     *   where: {
     *     // ... filter to delete one Material
     *   }
     * })
     * 
     */
    delete<T extends MaterialDeleteArgs>(args: SelectSubset<T, MaterialDeleteArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Material.
     * @param {MaterialUpdateArgs} args - Arguments to update one Material.
     * @example
     * // Update one Material
     * const material = await prisma.material.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaterialUpdateArgs>(args: SelectSubset<T, MaterialUpdateArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Materials.
     * @param {MaterialDeleteManyArgs} args - Arguments to filter Materials to delete.
     * @example
     * // Delete a few Materials
     * const { count } = await prisma.material.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaterialDeleteManyArgs>(args?: SelectSubset<T, MaterialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Materials
     * const material = await prisma.material.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaterialUpdateManyArgs>(args: SelectSubset<T, MaterialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materials and returns the data updated in the database.
     * @param {MaterialUpdateManyAndReturnArgs} args - Arguments to update many Materials.
     * @example
     * // Update many Materials
     * const material = await prisma.material.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Materials and only return the `id`
     * const materialWithIdOnly = await prisma.material.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MaterialUpdateManyAndReturnArgs>(args: SelectSubset<T, MaterialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Material.
     * @param {MaterialUpsertArgs} args - Arguments to update or create a Material.
     * @example
     * // Update or create a Material
     * const material = await prisma.material.upsert({
     *   create: {
     *     // ... data to create a Material
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Material we want to update
     *   }
     * })
     */
    upsert<T extends MaterialUpsertArgs>(args: SelectSubset<T, MaterialUpsertArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialCountArgs} args - Arguments to filter Materials to count.
     * @example
     * // Count the number of Materials
     * const count = await prisma.material.count({
     *   where: {
     *     // ... the filter for the Materials we want to count
     *   }
     * })
    **/
    count<T extends MaterialCountArgs>(
      args?: Subset<T, MaterialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialAggregateArgs>(args: Subset<T, MaterialAggregateArgs>): Prisma.PrismaPromise<GetMaterialAggregateType<T>>

    /**
     * Group by Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialGroupByArgs['orderBy'] }
        : { orderBy?: MaterialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Material model
   */
  readonly fields: MaterialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Material.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaterialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group<T extends Material$groupArgs<ExtArgs> = {}>(args?: Subset<T, Material$groupArgs<ExtArgs>>): Prisma__MaterialGroupClient<$Result.GetResult<Prisma.$MaterialGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    moves<T extends Material$movesArgs<ExtArgs> = {}>(args?: Subset<T, Material$movesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    expenses<T extends Material$expensesArgs<ExtArgs> = {}>(args?: Subset<T, Material$expensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    baseQuotes<T extends Material$baseQuotesArgs<ExtArgs> = {}>(args?: Subset<T, Material$baseQuotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationBaselineItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quoteItems<T extends Material$quoteItemsArgs<ExtArgs> = {}>(args?: Subset<T, Material$quoteItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Material model
   */
  interface MaterialFieldRefs {
    readonly id: FieldRef<"Material", 'Int'>
    readonly code: FieldRef<"Material", 'String'>
    readonly name: FieldRef<"Material", 'String'>
    readonly unit: FieldRef<"Material", 'String'>
    readonly groupId: FieldRef<"Material", 'Int'>
    readonly minStock: FieldRef<"Material", 'Decimal'>
    readonly reorderQuantity: FieldRef<"Material", 'Decimal'>
    readonly allowNegative: FieldRef<"Material", 'Boolean'>
    readonly isCompanyAsset: FieldRef<"Material", 'Boolean'>
    readonly assetStatus: FieldRef<"Material", 'AssetStatus'>
    readonly assetResponsible: FieldRef<"Material", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Material findUnique
   */
  export type MaterialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material findUniqueOrThrow
   */
  export type MaterialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material findFirst
   */
  export type MaterialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material findFirstOrThrow
   */
  export type MaterialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material findMany
   */
  export type MaterialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Materials to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material create
   */
  export type MaterialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The data needed to create a Material.
     */
    data: XOR<MaterialCreateInput, MaterialUncheckedCreateInput>
  }

  /**
   * Material createMany
   */
  export type MaterialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Materials.
     */
    data: MaterialCreateManyInput | MaterialCreateManyInput[]
  }

  /**
   * Material createManyAndReturn
   */
  export type MaterialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * The data used to create many Materials.
     */
    data: MaterialCreateManyInput | MaterialCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Material update
   */
  export type MaterialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The data needed to update a Material.
     */
    data: XOR<MaterialUpdateInput, MaterialUncheckedUpdateInput>
    /**
     * Choose, which Material to update.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material updateMany
   */
  export type MaterialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Materials.
     */
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyInput>
    /**
     * Filter which Materials to update
     */
    where?: MaterialWhereInput
    /**
     * Limit how many Materials to update.
     */
    limit?: number
  }

  /**
   * Material updateManyAndReturn
   */
  export type MaterialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * The data used to update Materials.
     */
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyInput>
    /**
     * Filter which Materials to update
     */
    where?: MaterialWhereInput
    /**
     * Limit how many Materials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Material upsert
   */
  export type MaterialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The filter to search for the Material to update in case it exists.
     */
    where: MaterialWhereUniqueInput
    /**
     * In case the Material found by the `where` argument doesn't exist, create a new Material with this data.
     */
    create: XOR<MaterialCreateInput, MaterialUncheckedCreateInput>
    /**
     * In case the Material was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterialUpdateInput, MaterialUncheckedUpdateInput>
  }

  /**
   * Material delete
   */
  export type MaterialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter which Material to delete.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material deleteMany
   */
  export type MaterialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Materials to delete
     */
    where?: MaterialWhereInput
    /**
     * Limit how many Materials to delete.
     */
    limit?: number
  }

  /**
   * Material.group
   */
  export type Material$groupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialGroup
     */
    select?: MaterialGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialGroup
     */
    omit?: MaterialGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialGroupInclude<ExtArgs> | null
    where?: MaterialGroupWhereInput
  }

  /**
   * Material.moves
   */
  export type Material$movesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Move
     */
    select?: MoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Move
     */
    omit?: MoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveInclude<ExtArgs> | null
    where?: MoveWhereInput
    orderBy?: MoveOrderByWithRelationInput | MoveOrderByWithRelationInput[]
    cursor?: MoveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MoveScalarFieldEnum | MoveScalarFieldEnum[]
  }

  /**
   * Material.expenses
   */
  export type Material$expensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Material.baseQuotes
   */
  export type Material$baseQuotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationBaselineItem
     */
    select?: QuotationBaselineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationBaselineItem
     */
    omit?: QuotationBaselineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationBaselineItemInclude<ExtArgs> | null
    where?: QuotationBaselineItemWhereInput
    orderBy?: QuotationBaselineItemOrderByWithRelationInput | QuotationBaselineItemOrderByWithRelationInput[]
    cursor?: QuotationBaselineItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuotationBaselineItemScalarFieldEnum | QuotationBaselineItemScalarFieldEnum[]
  }

  /**
   * Material.quoteItems
   */
  export type Material$quoteItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationItem
     */
    select?: QuotationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationItem
     */
    omit?: QuotationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationItemInclude<ExtArgs> | null
    where?: QuotationItemWhereInput
    orderBy?: QuotationItemOrderByWithRelationInput | QuotationItemOrderByWithRelationInput[]
    cursor?: QuotationItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuotationItemScalarFieldEnum | QuotationItemScalarFieldEnum[]
  }

  /**
   * Material without action
   */
  export type MaterialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
  }


  /**
   * Model Proveedor
   */

  export type AggregateProveedor = {
    _count: ProveedorCountAggregateOutputType | null
    _avg: ProveedorAvgAggregateOutputType | null
    _sum: ProveedorSumAggregateOutputType | null
    _min: ProveedorMinAggregateOutputType | null
    _max: ProveedorMaxAggregateOutputType | null
  }

  export type ProveedorAvgAggregateOutputType = {
    id: number | null
  }

  export type ProveedorSumAggregateOutputType = {
    id: number | null
  }

  export type ProveedorMinAggregateOutputType = {
    id: number | null
    name: string | null
    ruc: string | null
    phone: string | null
  }

  export type ProveedorMaxAggregateOutputType = {
    id: number | null
    name: string | null
    ruc: string | null
    phone: string | null
  }

  export type ProveedorCountAggregateOutputType = {
    id: number
    name: number
    ruc: number
    phone: number
    _all: number
  }


  export type ProveedorAvgAggregateInputType = {
    id?: true
  }

  export type ProveedorSumAggregateInputType = {
    id?: true
  }

  export type ProveedorMinAggregateInputType = {
    id?: true
    name?: true
    ruc?: true
    phone?: true
  }

  export type ProveedorMaxAggregateInputType = {
    id?: true
    name?: true
    ruc?: true
    phone?: true
  }

  export type ProveedorCountAggregateInputType = {
    id?: true
    name?: true
    ruc?: true
    phone?: true
    _all?: true
  }

  export type ProveedorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Proveedor to aggregate.
     */
    where?: ProveedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proveedors to fetch.
     */
    orderBy?: ProveedorOrderByWithRelationInput | ProveedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProveedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proveedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proveedors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Proveedors
    **/
    _count?: true | ProveedorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProveedorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProveedorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProveedorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProveedorMaxAggregateInputType
  }

  export type GetProveedorAggregateType<T extends ProveedorAggregateArgs> = {
        [P in keyof T & keyof AggregateProveedor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProveedor[P]>
      : GetScalarType<T[P], AggregateProveedor[P]>
  }




  export type ProveedorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProveedorWhereInput
    orderBy?: ProveedorOrderByWithAggregationInput | ProveedorOrderByWithAggregationInput[]
    by: ProveedorScalarFieldEnum[] | ProveedorScalarFieldEnum
    having?: ProveedorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProveedorCountAggregateInputType | true
    _avg?: ProveedorAvgAggregateInputType
    _sum?: ProveedorSumAggregateInputType
    _min?: ProveedorMinAggregateInputType
    _max?: ProveedorMaxAggregateInputType
  }

  export type ProveedorGroupByOutputType = {
    id: number
    name: string
    ruc: string | null
    phone: string | null
    _count: ProveedorCountAggregateOutputType | null
    _avg: ProveedorAvgAggregateOutputType | null
    _sum: ProveedorSumAggregateOutputType | null
    _min: ProveedorMinAggregateOutputType | null
    _max: ProveedorMaxAggregateOutputType | null
  }

  type GetProveedorGroupByPayload<T extends ProveedorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProveedorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProveedorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProveedorGroupByOutputType[P]>
            : GetScalarType<T[P], ProveedorGroupByOutputType[P]>
        }
      >
    >


  export type ProveedorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    ruc?: boolean
    phone?: boolean
    moves?: boolean | Proveedor$movesArgs<ExtArgs>
    expenses?: boolean | Proveedor$expensesArgs<ExtArgs>
    quotations?: boolean | Proveedor$quotationsArgs<ExtArgs>
    deliveries?: boolean | Proveedor$deliveriesArgs<ExtArgs>
    _count?: boolean | ProveedorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proveedor"]>

  export type ProveedorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    ruc?: boolean
    phone?: boolean
  }, ExtArgs["result"]["proveedor"]>

  export type ProveedorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    ruc?: boolean
    phone?: boolean
  }, ExtArgs["result"]["proveedor"]>

  export type ProveedorSelectScalar = {
    id?: boolean
    name?: boolean
    ruc?: boolean
    phone?: boolean
  }

  export type ProveedorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "ruc" | "phone", ExtArgs["result"]["proveedor"]>
  export type ProveedorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    moves?: boolean | Proveedor$movesArgs<ExtArgs>
    expenses?: boolean | Proveedor$expensesArgs<ExtArgs>
    quotations?: boolean | Proveedor$quotationsArgs<ExtArgs>
    deliveries?: boolean | Proveedor$deliveriesArgs<ExtArgs>
    _count?: boolean | ProveedorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProveedorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProveedorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProveedorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Proveedor"
    objects: {
      moves: Prisma.$MovePayload<ExtArgs>[]
      expenses: Prisma.$ExpensePayload<ExtArgs>[]
      quotations: Prisma.$QuotationPayload<ExtArgs>[]
      deliveries: Prisma.$PurchaseDeliveryLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      ruc: string | null
      phone: string | null
    }, ExtArgs["result"]["proveedor"]>
    composites: {}
  }

  type ProveedorGetPayload<S extends boolean | null | undefined | ProveedorDefaultArgs> = $Result.GetResult<Prisma.$ProveedorPayload, S>

  type ProveedorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProveedorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProveedorCountAggregateInputType | true
    }

  export interface ProveedorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Proveedor'], meta: { name: 'Proveedor' } }
    /**
     * Find zero or one Proveedor that matches the filter.
     * @param {ProveedorFindUniqueArgs} args - Arguments to find a Proveedor
     * @example
     * // Get one Proveedor
     * const proveedor = await prisma.proveedor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProveedorFindUniqueArgs>(args: SelectSubset<T, ProveedorFindUniqueArgs<ExtArgs>>): Prisma__ProveedorClient<$Result.GetResult<Prisma.$ProveedorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Proveedor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProveedorFindUniqueOrThrowArgs} args - Arguments to find a Proveedor
     * @example
     * // Get one Proveedor
     * const proveedor = await prisma.proveedor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProveedorFindUniqueOrThrowArgs>(args: SelectSubset<T, ProveedorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProveedorClient<$Result.GetResult<Prisma.$ProveedorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Proveedor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedorFindFirstArgs} args - Arguments to find a Proveedor
     * @example
     * // Get one Proveedor
     * const proveedor = await prisma.proveedor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProveedorFindFirstArgs>(args?: SelectSubset<T, ProveedorFindFirstArgs<ExtArgs>>): Prisma__ProveedorClient<$Result.GetResult<Prisma.$ProveedorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Proveedor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedorFindFirstOrThrowArgs} args - Arguments to find a Proveedor
     * @example
     * // Get one Proveedor
     * const proveedor = await prisma.proveedor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProveedorFindFirstOrThrowArgs>(args?: SelectSubset<T, ProveedorFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProveedorClient<$Result.GetResult<Prisma.$ProveedorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Proveedors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Proveedors
     * const proveedors = await prisma.proveedor.findMany()
     * 
     * // Get first 10 Proveedors
     * const proveedors = await prisma.proveedor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const proveedorWithIdOnly = await prisma.proveedor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProveedorFindManyArgs>(args?: SelectSubset<T, ProveedorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProveedorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Proveedor.
     * @param {ProveedorCreateArgs} args - Arguments to create a Proveedor.
     * @example
     * // Create one Proveedor
     * const Proveedor = await prisma.proveedor.create({
     *   data: {
     *     // ... data to create a Proveedor
     *   }
     * })
     * 
     */
    create<T extends ProveedorCreateArgs>(args: SelectSubset<T, ProveedorCreateArgs<ExtArgs>>): Prisma__ProveedorClient<$Result.GetResult<Prisma.$ProveedorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Proveedors.
     * @param {ProveedorCreateManyArgs} args - Arguments to create many Proveedors.
     * @example
     * // Create many Proveedors
     * const proveedor = await prisma.proveedor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProveedorCreateManyArgs>(args?: SelectSubset<T, ProveedorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Proveedors and returns the data saved in the database.
     * @param {ProveedorCreateManyAndReturnArgs} args - Arguments to create many Proveedors.
     * @example
     * // Create many Proveedors
     * const proveedor = await prisma.proveedor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Proveedors and only return the `id`
     * const proveedorWithIdOnly = await prisma.proveedor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProveedorCreateManyAndReturnArgs>(args?: SelectSubset<T, ProveedorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProveedorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Proveedor.
     * @param {ProveedorDeleteArgs} args - Arguments to delete one Proveedor.
     * @example
     * // Delete one Proveedor
     * const Proveedor = await prisma.proveedor.delete({
     *   where: {
     *     // ... filter to delete one Proveedor
     *   }
     * })
     * 
     */
    delete<T extends ProveedorDeleteArgs>(args: SelectSubset<T, ProveedorDeleteArgs<ExtArgs>>): Prisma__ProveedorClient<$Result.GetResult<Prisma.$ProveedorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Proveedor.
     * @param {ProveedorUpdateArgs} args - Arguments to update one Proveedor.
     * @example
     * // Update one Proveedor
     * const proveedor = await prisma.proveedor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProveedorUpdateArgs>(args: SelectSubset<T, ProveedorUpdateArgs<ExtArgs>>): Prisma__ProveedorClient<$Result.GetResult<Prisma.$ProveedorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Proveedors.
     * @param {ProveedorDeleteManyArgs} args - Arguments to filter Proveedors to delete.
     * @example
     * // Delete a few Proveedors
     * const { count } = await prisma.proveedor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProveedorDeleteManyArgs>(args?: SelectSubset<T, ProveedorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proveedors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Proveedors
     * const proveedor = await prisma.proveedor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProveedorUpdateManyArgs>(args: SelectSubset<T, ProveedorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proveedors and returns the data updated in the database.
     * @param {ProveedorUpdateManyAndReturnArgs} args - Arguments to update many Proveedors.
     * @example
     * // Update many Proveedors
     * const proveedor = await prisma.proveedor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Proveedors and only return the `id`
     * const proveedorWithIdOnly = await prisma.proveedor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProveedorUpdateManyAndReturnArgs>(args: SelectSubset<T, ProveedorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProveedorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Proveedor.
     * @param {ProveedorUpsertArgs} args - Arguments to update or create a Proveedor.
     * @example
     * // Update or create a Proveedor
     * const proveedor = await prisma.proveedor.upsert({
     *   create: {
     *     // ... data to create a Proveedor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Proveedor we want to update
     *   }
     * })
     */
    upsert<T extends ProveedorUpsertArgs>(args: SelectSubset<T, ProveedorUpsertArgs<ExtArgs>>): Prisma__ProveedorClient<$Result.GetResult<Prisma.$ProveedorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Proveedors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedorCountArgs} args - Arguments to filter Proveedors to count.
     * @example
     * // Count the number of Proveedors
     * const count = await prisma.proveedor.count({
     *   where: {
     *     // ... the filter for the Proveedors we want to count
     *   }
     * })
    **/
    count<T extends ProveedorCountArgs>(
      args?: Subset<T, ProveedorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProveedorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Proveedor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProveedorAggregateArgs>(args: Subset<T, ProveedorAggregateArgs>): Prisma.PrismaPromise<GetProveedorAggregateType<T>>

    /**
     * Group by Proveedor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProveedorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProveedorGroupByArgs['orderBy'] }
        : { orderBy?: ProveedorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProveedorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProveedorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Proveedor model
   */
  readonly fields: ProveedorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Proveedor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProveedorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    moves<T extends Proveedor$movesArgs<ExtArgs> = {}>(args?: Subset<T, Proveedor$movesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    expenses<T extends Proveedor$expensesArgs<ExtArgs> = {}>(args?: Subset<T, Proveedor$expensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quotations<T extends Proveedor$quotationsArgs<ExtArgs> = {}>(args?: Subset<T, Proveedor$quotationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deliveries<T extends Proveedor$deliveriesArgs<ExtArgs> = {}>(args?: Subset<T, Proveedor$deliveriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseDeliveryLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Proveedor model
   */
  interface ProveedorFieldRefs {
    readonly id: FieldRef<"Proveedor", 'Int'>
    readonly name: FieldRef<"Proveedor", 'String'>
    readonly ruc: FieldRef<"Proveedor", 'String'>
    readonly phone: FieldRef<"Proveedor", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Proveedor findUnique
   */
  export type ProveedorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proveedor
     */
    select?: ProveedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proveedor
     */
    omit?: ProveedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProveedorInclude<ExtArgs> | null
    /**
     * Filter, which Proveedor to fetch.
     */
    where: ProveedorWhereUniqueInput
  }

  /**
   * Proveedor findUniqueOrThrow
   */
  export type ProveedorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proveedor
     */
    select?: ProveedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proveedor
     */
    omit?: ProveedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProveedorInclude<ExtArgs> | null
    /**
     * Filter, which Proveedor to fetch.
     */
    where: ProveedorWhereUniqueInput
  }

  /**
   * Proveedor findFirst
   */
  export type ProveedorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proveedor
     */
    select?: ProveedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proveedor
     */
    omit?: ProveedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProveedorInclude<ExtArgs> | null
    /**
     * Filter, which Proveedor to fetch.
     */
    where?: ProveedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proveedors to fetch.
     */
    orderBy?: ProveedorOrderByWithRelationInput | ProveedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Proveedors.
     */
    cursor?: ProveedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proveedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proveedors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Proveedors.
     */
    distinct?: ProveedorScalarFieldEnum | ProveedorScalarFieldEnum[]
  }

  /**
   * Proveedor findFirstOrThrow
   */
  export type ProveedorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proveedor
     */
    select?: ProveedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proveedor
     */
    omit?: ProveedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProveedorInclude<ExtArgs> | null
    /**
     * Filter, which Proveedor to fetch.
     */
    where?: ProveedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proveedors to fetch.
     */
    orderBy?: ProveedorOrderByWithRelationInput | ProveedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Proveedors.
     */
    cursor?: ProveedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proveedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proveedors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Proveedors.
     */
    distinct?: ProveedorScalarFieldEnum | ProveedorScalarFieldEnum[]
  }

  /**
   * Proveedor findMany
   */
  export type ProveedorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proveedor
     */
    select?: ProveedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proveedor
     */
    omit?: ProveedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProveedorInclude<ExtArgs> | null
    /**
     * Filter, which Proveedors to fetch.
     */
    where?: ProveedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proveedors to fetch.
     */
    orderBy?: ProveedorOrderByWithRelationInput | ProveedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Proveedors.
     */
    cursor?: ProveedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proveedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proveedors.
     */
    skip?: number
    distinct?: ProveedorScalarFieldEnum | ProveedorScalarFieldEnum[]
  }

  /**
   * Proveedor create
   */
  export type ProveedorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proveedor
     */
    select?: ProveedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proveedor
     */
    omit?: ProveedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProveedorInclude<ExtArgs> | null
    /**
     * The data needed to create a Proveedor.
     */
    data: XOR<ProveedorCreateInput, ProveedorUncheckedCreateInput>
  }

  /**
   * Proveedor createMany
   */
  export type ProveedorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Proveedors.
     */
    data: ProveedorCreateManyInput | ProveedorCreateManyInput[]
  }

  /**
   * Proveedor createManyAndReturn
   */
  export type ProveedorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proveedor
     */
    select?: ProveedorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Proveedor
     */
    omit?: ProveedorOmit<ExtArgs> | null
    /**
     * The data used to create many Proveedors.
     */
    data: ProveedorCreateManyInput | ProveedorCreateManyInput[]
  }

  /**
   * Proveedor update
   */
  export type ProveedorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proveedor
     */
    select?: ProveedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proveedor
     */
    omit?: ProveedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProveedorInclude<ExtArgs> | null
    /**
     * The data needed to update a Proveedor.
     */
    data: XOR<ProveedorUpdateInput, ProveedorUncheckedUpdateInput>
    /**
     * Choose, which Proveedor to update.
     */
    where: ProveedorWhereUniqueInput
  }

  /**
   * Proveedor updateMany
   */
  export type ProveedorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Proveedors.
     */
    data: XOR<ProveedorUpdateManyMutationInput, ProveedorUncheckedUpdateManyInput>
    /**
     * Filter which Proveedors to update
     */
    where?: ProveedorWhereInput
    /**
     * Limit how many Proveedors to update.
     */
    limit?: number
  }

  /**
   * Proveedor updateManyAndReturn
   */
  export type ProveedorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proveedor
     */
    select?: ProveedorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Proveedor
     */
    omit?: ProveedorOmit<ExtArgs> | null
    /**
     * The data used to update Proveedors.
     */
    data: XOR<ProveedorUpdateManyMutationInput, ProveedorUncheckedUpdateManyInput>
    /**
     * Filter which Proveedors to update
     */
    where?: ProveedorWhereInput
    /**
     * Limit how many Proveedors to update.
     */
    limit?: number
  }

  /**
   * Proveedor upsert
   */
  export type ProveedorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proveedor
     */
    select?: ProveedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proveedor
     */
    omit?: ProveedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProveedorInclude<ExtArgs> | null
    /**
     * The filter to search for the Proveedor to update in case it exists.
     */
    where: ProveedorWhereUniqueInput
    /**
     * In case the Proveedor found by the `where` argument doesn't exist, create a new Proveedor with this data.
     */
    create: XOR<ProveedorCreateInput, ProveedorUncheckedCreateInput>
    /**
     * In case the Proveedor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProveedorUpdateInput, ProveedorUncheckedUpdateInput>
  }

  /**
   * Proveedor delete
   */
  export type ProveedorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proveedor
     */
    select?: ProveedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proveedor
     */
    omit?: ProveedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProveedorInclude<ExtArgs> | null
    /**
     * Filter which Proveedor to delete.
     */
    where: ProveedorWhereUniqueInput
  }

  /**
   * Proveedor deleteMany
   */
  export type ProveedorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Proveedors to delete
     */
    where?: ProveedorWhereInput
    /**
     * Limit how many Proveedors to delete.
     */
    limit?: number
  }

  /**
   * Proveedor.moves
   */
  export type Proveedor$movesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Move
     */
    select?: MoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Move
     */
    omit?: MoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveInclude<ExtArgs> | null
    where?: MoveWhereInput
    orderBy?: MoveOrderByWithRelationInput | MoveOrderByWithRelationInput[]
    cursor?: MoveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MoveScalarFieldEnum | MoveScalarFieldEnum[]
  }

  /**
   * Proveedor.expenses
   */
  export type Proveedor$expensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Proveedor.quotations
   */
  export type Proveedor$quotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    where?: QuotationWhereInput
    orderBy?: QuotationOrderByWithRelationInput | QuotationOrderByWithRelationInput[]
    cursor?: QuotationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuotationScalarFieldEnum | QuotationScalarFieldEnum[]
  }

  /**
   * Proveedor.deliveries
   */
  export type Proveedor$deliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseDeliveryLog
     */
    select?: PurchaseDeliveryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseDeliveryLog
     */
    omit?: PurchaseDeliveryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseDeliveryLogInclude<ExtArgs> | null
    where?: PurchaseDeliveryLogWhereInput
    orderBy?: PurchaseDeliveryLogOrderByWithRelationInput | PurchaseDeliveryLogOrderByWithRelationInput[]
    cursor?: PurchaseDeliveryLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseDeliveryLogScalarFieldEnum | PurchaseDeliveryLogScalarFieldEnum[]
  }

  /**
   * Proveedor without action
   */
  export type ProveedorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proveedor
     */
    select?: ProveedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proveedor
     */
    omit?: ProveedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProveedorInclude<ExtArgs> | null
  }


  /**
   * Model Frente
   */

  export type AggregateFrente = {
    _count: FrenteCountAggregateOutputType | null
    _avg: FrenteAvgAggregateOutputType | null
    _sum: FrenteSumAggregateOutputType | null
    _min: FrenteMinAggregateOutputType | null
    _max: FrenteMaxAggregateOutputType | null
  }

  export type FrenteAvgAggregateOutputType = {
    id: number | null
    obraId: number | null
  }

  export type FrenteSumAggregateOutputType = {
    id: number | null
    obraId: number | null
  }

  export type FrenteMinAggregateOutputType = {
    id: number | null
    name: string | null
    obraId: number | null
  }

  export type FrenteMaxAggregateOutputType = {
    id: number | null
    name: string | null
    obraId: number | null
  }

  export type FrenteCountAggregateOutputType = {
    id: number
    name: number
    obraId: number
    _all: number
  }


  export type FrenteAvgAggregateInputType = {
    id?: true
    obraId?: true
  }

  export type FrenteSumAggregateInputType = {
    id?: true
    obraId?: true
  }

  export type FrenteMinAggregateInputType = {
    id?: true
    name?: true
    obraId?: true
  }

  export type FrenteMaxAggregateInputType = {
    id?: true
    name?: true
    obraId?: true
  }

  export type FrenteCountAggregateInputType = {
    id?: true
    name?: true
    obraId?: true
    _all?: true
  }

  export type FrenteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Frente to aggregate.
     */
    where?: FrenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Frentes to fetch.
     */
    orderBy?: FrenteOrderByWithRelationInput | FrenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FrenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Frentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Frentes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Frentes
    **/
    _count?: true | FrenteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FrenteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FrenteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FrenteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FrenteMaxAggregateInputType
  }

  export type GetFrenteAggregateType<T extends FrenteAggregateArgs> = {
        [P in keyof T & keyof AggregateFrente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFrente[P]>
      : GetScalarType<T[P], AggregateFrente[P]>
  }




  export type FrenteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FrenteWhereInput
    orderBy?: FrenteOrderByWithAggregationInput | FrenteOrderByWithAggregationInput[]
    by: FrenteScalarFieldEnum[] | FrenteScalarFieldEnum
    having?: FrenteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FrenteCountAggregateInputType | true
    _avg?: FrenteAvgAggregateInputType
    _sum?: FrenteSumAggregateInputType
    _min?: FrenteMinAggregateInputType
    _max?: FrenteMaxAggregateInputType
  }

  export type FrenteGroupByOutputType = {
    id: number
    name: string
    obraId: number
    _count: FrenteCountAggregateOutputType | null
    _avg: FrenteAvgAggregateOutputType | null
    _sum: FrenteSumAggregateOutputType | null
    _min: FrenteMinAggregateOutputType | null
    _max: FrenteMaxAggregateOutputType | null
  }

  type GetFrenteGroupByPayload<T extends FrenteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FrenteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FrenteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FrenteGroupByOutputType[P]>
            : GetScalarType<T[P], FrenteGroupByOutputType[P]>
        }
      >
    >


  export type FrenteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    obraId?: boolean
    obra?: boolean | ObraDefaultArgs<ExtArgs>
    moves?: boolean | Frente$movesArgs<ExtArgs>
    incomes?: boolean | Frente$incomesArgs<ExtArgs>
    expenses?: boolean | Frente$expensesArgs<ExtArgs>
    _count?: boolean | FrenteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["frente"]>

  export type FrenteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    obraId?: boolean
    obra?: boolean | ObraDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["frente"]>

  export type FrenteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    obraId?: boolean
    obra?: boolean | ObraDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["frente"]>

  export type FrenteSelectScalar = {
    id?: boolean
    name?: boolean
    obraId?: boolean
  }

  export type FrenteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "obraId", ExtArgs["result"]["frente"]>
  export type FrenteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    obra?: boolean | ObraDefaultArgs<ExtArgs>
    moves?: boolean | Frente$movesArgs<ExtArgs>
    incomes?: boolean | Frente$incomesArgs<ExtArgs>
    expenses?: boolean | Frente$expensesArgs<ExtArgs>
    _count?: boolean | FrenteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FrenteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    obra?: boolean | ObraDefaultArgs<ExtArgs>
  }
  export type FrenteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    obra?: boolean | ObraDefaultArgs<ExtArgs>
  }

  export type $FrentePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Frente"
    objects: {
      obra: Prisma.$ObraPayload<ExtArgs>
      moves: Prisma.$MovePayload<ExtArgs>[]
      incomes: Prisma.$IncomePayload<ExtArgs>[]
      expenses: Prisma.$ExpensePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      obraId: number
    }, ExtArgs["result"]["frente"]>
    composites: {}
  }

  type FrenteGetPayload<S extends boolean | null | undefined | FrenteDefaultArgs> = $Result.GetResult<Prisma.$FrentePayload, S>

  type FrenteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FrenteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FrenteCountAggregateInputType | true
    }

  export interface FrenteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Frente'], meta: { name: 'Frente' } }
    /**
     * Find zero or one Frente that matches the filter.
     * @param {FrenteFindUniqueArgs} args - Arguments to find a Frente
     * @example
     * // Get one Frente
     * const frente = await prisma.frente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FrenteFindUniqueArgs>(args: SelectSubset<T, FrenteFindUniqueArgs<ExtArgs>>): Prisma__FrenteClient<$Result.GetResult<Prisma.$FrentePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Frente that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FrenteFindUniqueOrThrowArgs} args - Arguments to find a Frente
     * @example
     * // Get one Frente
     * const frente = await prisma.frente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FrenteFindUniqueOrThrowArgs>(args: SelectSubset<T, FrenteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FrenteClient<$Result.GetResult<Prisma.$FrentePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Frente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FrenteFindFirstArgs} args - Arguments to find a Frente
     * @example
     * // Get one Frente
     * const frente = await prisma.frente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FrenteFindFirstArgs>(args?: SelectSubset<T, FrenteFindFirstArgs<ExtArgs>>): Prisma__FrenteClient<$Result.GetResult<Prisma.$FrentePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Frente that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FrenteFindFirstOrThrowArgs} args - Arguments to find a Frente
     * @example
     * // Get one Frente
     * const frente = await prisma.frente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FrenteFindFirstOrThrowArgs>(args?: SelectSubset<T, FrenteFindFirstOrThrowArgs<ExtArgs>>): Prisma__FrenteClient<$Result.GetResult<Prisma.$FrentePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Frentes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FrenteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Frentes
     * const frentes = await prisma.frente.findMany()
     * 
     * // Get first 10 Frentes
     * const frentes = await prisma.frente.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const frenteWithIdOnly = await prisma.frente.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FrenteFindManyArgs>(args?: SelectSubset<T, FrenteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FrentePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Frente.
     * @param {FrenteCreateArgs} args - Arguments to create a Frente.
     * @example
     * // Create one Frente
     * const Frente = await prisma.frente.create({
     *   data: {
     *     // ... data to create a Frente
     *   }
     * })
     * 
     */
    create<T extends FrenteCreateArgs>(args: SelectSubset<T, FrenteCreateArgs<ExtArgs>>): Prisma__FrenteClient<$Result.GetResult<Prisma.$FrentePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Frentes.
     * @param {FrenteCreateManyArgs} args - Arguments to create many Frentes.
     * @example
     * // Create many Frentes
     * const frente = await prisma.frente.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FrenteCreateManyArgs>(args?: SelectSubset<T, FrenteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Frentes and returns the data saved in the database.
     * @param {FrenteCreateManyAndReturnArgs} args - Arguments to create many Frentes.
     * @example
     * // Create many Frentes
     * const frente = await prisma.frente.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Frentes and only return the `id`
     * const frenteWithIdOnly = await prisma.frente.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FrenteCreateManyAndReturnArgs>(args?: SelectSubset<T, FrenteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FrentePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Frente.
     * @param {FrenteDeleteArgs} args - Arguments to delete one Frente.
     * @example
     * // Delete one Frente
     * const Frente = await prisma.frente.delete({
     *   where: {
     *     // ... filter to delete one Frente
     *   }
     * })
     * 
     */
    delete<T extends FrenteDeleteArgs>(args: SelectSubset<T, FrenteDeleteArgs<ExtArgs>>): Prisma__FrenteClient<$Result.GetResult<Prisma.$FrentePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Frente.
     * @param {FrenteUpdateArgs} args - Arguments to update one Frente.
     * @example
     * // Update one Frente
     * const frente = await prisma.frente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FrenteUpdateArgs>(args: SelectSubset<T, FrenteUpdateArgs<ExtArgs>>): Prisma__FrenteClient<$Result.GetResult<Prisma.$FrentePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Frentes.
     * @param {FrenteDeleteManyArgs} args - Arguments to filter Frentes to delete.
     * @example
     * // Delete a few Frentes
     * const { count } = await prisma.frente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FrenteDeleteManyArgs>(args?: SelectSubset<T, FrenteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Frentes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FrenteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Frentes
     * const frente = await prisma.frente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FrenteUpdateManyArgs>(args: SelectSubset<T, FrenteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Frentes and returns the data updated in the database.
     * @param {FrenteUpdateManyAndReturnArgs} args - Arguments to update many Frentes.
     * @example
     * // Update many Frentes
     * const frente = await prisma.frente.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Frentes and only return the `id`
     * const frenteWithIdOnly = await prisma.frente.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FrenteUpdateManyAndReturnArgs>(args: SelectSubset<T, FrenteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FrentePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Frente.
     * @param {FrenteUpsertArgs} args - Arguments to update or create a Frente.
     * @example
     * // Update or create a Frente
     * const frente = await prisma.frente.upsert({
     *   create: {
     *     // ... data to create a Frente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Frente we want to update
     *   }
     * })
     */
    upsert<T extends FrenteUpsertArgs>(args: SelectSubset<T, FrenteUpsertArgs<ExtArgs>>): Prisma__FrenteClient<$Result.GetResult<Prisma.$FrentePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Frentes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FrenteCountArgs} args - Arguments to filter Frentes to count.
     * @example
     * // Count the number of Frentes
     * const count = await prisma.frente.count({
     *   where: {
     *     // ... the filter for the Frentes we want to count
     *   }
     * })
    **/
    count<T extends FrenteCountArgs>(
      args?: Subset<T, FrenteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FrenteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Frente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FrenteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FrenteAggregateArgs>(args: Subset<T, FrenteAggregateArgs>): Prisma.PrismaPromise<GetFrenteAggregateType<T>>

    /**
     * Group by Frente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FrenteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FrenteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FrenteGroupByArgs['orderBy'] }
        : { orderBy?: FrenteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FrenteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFrenteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Frente model
   */
  readonly fields: FrenteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Frente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FrenteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    obra<T extends ObraDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ObraDefaultArgs<ExtArgs>>): Prisma__ObraClient<$Result.GetResult<Prisma.$ObraPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    moves<T extends Frente$movesArgs<ExtArgs> = {}>(args?: Subset<T, Frente$movesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    incomes<T extends Frente$incomesArgs<ExtArgs> = {}>(args?: Subset<T, Frente$incomesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncomePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    expenses<T extends Frente$expensesArgs<ExtArgs> = {}>(args?: Subset<T, Frente$expensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Frente model
   */
  interface FrenteFieldRefs {
    readonly id: FieldRef<"Frente", 'Int'>
    readonly name: FieldRef<"Frente", 'String'>
    readonly obraId: FieldRef<"Frente", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Frente findUnique
   */
  export type FrenteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Frente
     */
    select?: FrenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Frente
     */
    omit?: FrenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FrenteInclude<ExtArgs> | null
    /**
     * Filter, which Frente to fetch.
     */
    where: FrenteWhereUniqueInput
  }

  /**
   * Frente findUniqueOrThrow
   */
  export type FrenteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Frente
     */
    select?: FrenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Frente
     */
    omit?: FrenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FrenteInclude<ExtArgs> | null
    /**
     * Filter, which Frente to fetch.
     */
    where: FrenteWhereUniqueInput
  }

  /**
   * Frente findFirst
   */
  export type FrenteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Frente
     */
    select?: FrenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Frente
     */
    omit?: FrenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FrenteInclude<ExtArgs> | null
    /**
     * Filter, which Frente to fetch.
     */
    where?: FrenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Frentes to fetch.
     */
    orderBy?: FrenteOrderByWithRelationInput | FrenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Frentes.
     */
    cursor?: FrenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Frentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Frentes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Frentes.
     */
    distinct?: FrenteScalarFieldEnum | FrenteScalarFieldEnum[]
  }

  /**
   * Frente findFirstOrThrow
   */
  export type FrenteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Frente
     */
    select?: FrenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Frente
     */
    omit?: FrenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FrenteInclude<ExtArgs> | null
    /**
     * Filter, which Frente to fetch.
     */
    where?: FrenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Frentes to fetch.
     */
    orderBy?: FrenteOrderByWithRelationInput | FrenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Frentes.
     */
    cursor?: FrenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Frentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Frentes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Frentes.
     */
    distinct?: FrenteScalarFieldEnum | FrenteScalarFieldEnum[]
  }

  /**
   * Frente findMany
   */
  export type FrenteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Frente
     */
    select?: FrenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Frente
     */
    omit?: FrenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FrenteInclude<ExtArgs> | null
    /**
     * Filter, which Frentes to fetch.
     */
    where?: FrenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Frentes to fetch.
     */
    orderBy?: FrenteOrderByWithRelationInput | FrenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Frentes.
     */
    cursor?: FrenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Frentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Frentes.
     */
    skip?: number
    distinct?: FrenteScalarFieldEnum | FrenteScalarFieldEnum[]
  }

  /**
   * Frente create
   */
  export type FrenteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Frente
     */
    select?: FrenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Frente
     */
    omit?: FrenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FrenteInclude<ExtArgs> | null
    /**
     * The data needed to create a Frente.
     */
    data: XOR<FrenteCreateInput, FrenteUncheckedCreateInput>
  }

  /**
   * Frente createMany
   */
  export type FrenteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Frentes.
     */
    data: FrenteCreateManyInput | FrenteCreateManyInput[]
  }

  /**
   * Frente createManyAndReturn
   */
  export type FrenteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Frente
     */
    select?: FrenteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Frente
     */
    omit?: FrenteOmit<ExtArgs> | null
    /**
     * The data used to create many Frentes.
     */
    data: FrenteCreateManyInput | FrenteCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FrenteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Frente update
   */
  export type FrenteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Frente
     */
    select?: FrenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Frente
     */
    omit?: FrenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FrenteInclude<ExtArgs> | null
    /**
     * The data needed to update a Frente.
     */
    data: XOR<FrenteUpdateInput, FrenteUncheckedUpdateInput>
    /**
     * Choose, which Frente to update.
     */
    where: FrenteWhereUniqueInput
  }

  /**
   * Frente updateMany
   */
  export type FrenteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Frentes.
     */
    data: XOR<FrenteUpdateManyMutationInput, FrenteUncheckedUpdateManyInput>
    /**
     * Filter which Frentes to update
     */
    where?: FrenteWhereInput
    /**
     * Limit how many Frentes to update.
     */
    limit?: number
  }

  /**
   * Frente updateManyAndReturn
   */
  export type FrenteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Frente
     */
    select?: FrenteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Frente
     */
    omit?: FrenteOmit<ExtArgs> | null
    /**
     * The data used to update Frentes.
     */
    data: XOR<FrenteUpdateManyMutationInput, FrenteUncheckedUpdateManyInput>
    /**
     * Filter which Frentes to update
     */
    where?: FrenteWhereInput
    /**
     * Limit how many Frentes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FrenteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Frente upsert
   */
  export type FrenteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Frente
     */
    select?: FrenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Frente
     */
    omit?: FrenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FrenteInclude<ExtArgs> | null
    /**
     * The filter to search for the Frente to update in case it exists.
     */
    where: FrenteWhereUniqueInput
    /**
     * In case the Frente found by the `where` argument doesn't exist, create a new Frente with this data.
     */
    create: XOR<FrenteCreateInput, FrenteUncheckedCreateInput>
    /**
     * In case the Frente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FrenteUpdateInput, FrenteUncheckedUpdateInput>
  }

  /**
   * Frente delete
   */
  export type FrenteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Frente
     */
    select?: FrenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Frente
     */
    omit?: FrenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FrenteInclude<ExtArgs> | null
    /**
     * Filter which Frente to delete.
     */
    where: FrenteWhereUniqueInput
  }

  /**
   * Frente deleteMany
   */
  export type FrenteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Frentes to delete
     */
    where?: FrenteWhereInput
    /**
     * Limit how many Frentes to delete.
     */
    limit?: number
  }

  /**
   * Frente.moves
   */
  export type Frente$movesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Move
     */
    select?: MoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Move
     */
    omit?: MoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveInclude<ExtArgs> | null
    where?: MoveWhereInput
    orderBy?: MoveOrderByWithRelationInput | MoveOrderByWithRelationInput[]
    cursor?: MoveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MoveScalarFieldEnum | MoveScalarFieldEnum[]
  }

  /**
   * Frente.incomes
   */
  export type Frente$incomesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Income
     */
    select?: IncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Income
     */
    omit?: IncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeInclude<ExtArgs> | null
    where?: IncomeWhereInput
    orderBy?: IncomeOrderByWithRelationInput | IncomeOrderByWithRelationInput[]
    cursor?: IncomeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncomeScalarFieldEnum | IncomeScalarFieldEnum[]
  }

  /**
   * Frente.expenses
   */
  export type Frente$expensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Frente without action
   */
  export type FrenteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Frente
     */
    select?: FrenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Frente
     */
    omit?: FrenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FrenteInclude<ExtArgs> | null
  }


  /**
   * Model MaterialGroup
   */

  export type AggregateMaterialGroup = {
    _count: MaterialGroupCountAggregateOutputType | null
    _avg: MaterialGroupAvgAggregateOutputType | null
    _sum: MaterialGroupSumAggregateOutputType | null
    _min: MaterialGroupMinAggregateOutputType | null
    _max: MaterialGroupMaxAggregateOutputType | null
  }

  export type MaterialGroupAvgAggregateOutputType = {
    id: number | null
    parentId: number | null
  }

  export type MaterialGroupSumAggregateOutputType = {
    id: number | null
    parentId: number | null
  }

  export type MaterialGroupMinAggregateOutputType = {
    id: number | null
    name: string | null
    parentId: number | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaterialGroupMaxAggregateOutputType = {
    id: number | null
    name: string | null
    parentId: number | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaterialGroupCountAggregateOutputType = {
    id: number
    name: number
    parentId: number
    color: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MaterialGroupAvgAggregateInputType = {
    id?: true
    parentId?: true
  }

  export type MaterialGroupSumAggregateInputType = {
    id?: true
    parentId?: true
  }

  export type MaterialGroupMinAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    color?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaterialGroupMaxAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    color?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaterialGroupCountAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    color?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MaterialGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaterialGroup to aggregate.
     */
    where?: MaterialGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialGroups to fetch.
     */
    orderBy?: MaterialGroupOrderByWithRelationInput | MaterialGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterialGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaterialGroups
    **/
    _count?: true | MaterialGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterialGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterialGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialGroupMaxAggregateInputType
  }

  export type GetMaterialGroupAggregateType<T extends MaterialGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterialGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterialGroup[P]>
      : GetScalarType<T[P], AggregateMaterialGroup[P]>
  }




  export type MaterialGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialGroupWhereInput
    orderBy?: MaterialGroupOrderByWithAggregationInput | MaterialGroupOrderByWithAggregationInput[]
    by: MaterialGroupScalarFieldEnum[] | MaterialGroupScalarFieldEnum
    having?: MaterialGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialGroupCountAggregateInputType | true
    _avg?: MaterialGroupAvgAggregateInputType
    _sum?: MaterialGroupSumAggregateInputType
    _min?: MaterialGroupMinAggregateInputType
    _max?: MaterialGroupMaxAggregateInputType
  }

  export type MaterialGroupGroupByOutputType = {
    id: number
    name: string
    parentId: number | null
    color: string | null
    createdAt: Date
    updatedAt: Date
    _count: MaterialGroupCountAggregateOutputType | null
    _avg: MaterialGroupAvgAggregateOutputType | null
    _sum: MaterialGroupSumAggregateOutputType | null
    _min: MaterialGroupMinAggregateOutputType | null
    _max: MaterialGroupMaxAggregateOutputType | null
  }

  type GetMaterialGroupGroupByPayload<T extends MaterialGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialGroupGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialGroupGroupByOutputType[P]>
        }
      >
    >


  export type MaterialGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    parentId?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | MaterialGroup$parentArgs<ExtArgs>
    children?: boolean | MaterialGroup$childrenArgs<ExtArgs>
    materials?: boolean | MaterialGroup$materialsArgs<ExtArgs>
    _count?: boolean | MaterialGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["materialGroup"]>

  export type MaterialGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    parentId?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | MaterialGroup$parentArgs<ExtArgs>
  }, ExtArgs["result"]["materialGroup"]>

  export type MaterialGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    parentId?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | MaterialGroup$parentArgs<ExtArgs>
  }, ExtArgs["result"]["materialGroup"]>

  export type MaterialGroupSelectScalar = {
    id?: boolean
    name?: boolean
    parentId?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MaterialGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "parentId" | "color" | "createdAt" | "updatedAt", ExtArgs["result"]["materialGroup"]>
  export type MaterialGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | MaterialGroup$parentArgs<ExtArgs>
    children?: boolean | MaterialGroup$childrenArgs<ExtArgs>
    materials?: boolean | MaterialGroup$materialsArgs<ExtArgs>
    _count?: boolean | MaterialGroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MaterialGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | MaterialGroup$parentArgs<ExtArgs>
  }
  export type MaterialGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | MaterialGroup$parentArgs<ExtArgs>
  }

  export type $MaterialGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaterialGroup"
    objects: {
      parent: Prisma.$MaterialGroupPayload<ExtArgs> | null
      children: Prisma.$MaterialGroupPayload<ExtArgs>[]
      materials: Prisma.$MaterialPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      parentId: number | null
      color: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["materialGroup"]>
    composites: {}
  }

  type MaterialGroupGetPayload<S extends boolean | null | undefined | MaterialGroupDefaultArgs> = $Result.GetResult<Prisma.$MaterialGroupPayload, S>

  type MaterialGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaterialGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaterialGroupCountAggregateInputType | true
    }

  export interface MaterialGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaterialGroup'], meta: { name: 'MaterialGroup' } }
    /**
     * Find zero or one MaterialGroup that matches the filter.
     * @param {MaterialGroupFindUniqueArgs} args - Arguments to find a MaterialGroup
     * @example
     * // Get one MaterialGroup
     * const materialGroup = await prisma.materialGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaterialGroupFindUniqueArgs>(args: SelectSubset<T, MaterialGroupFindUniqueArgs<ExtArgs>>): Prisma__MaterialGroupClient<$Result.GetResult<Prisma.$MaterialGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MaterialGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaterialGroupFindUniqueOrThrowArgs} args - Arguments to find a MaterialGroup
     * @example
     * // Get one MaterialGroup
     * const materialGroup = await prisma.materialGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaterialGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, MaterialGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaterialGroupClient<$Result.GetResult<Prisma.$MaterialGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaterialGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialGroupFindFirstArgs} args - Arguments to find a MaterialGroup
     * @example
     * // Get one MaterialGroup
     * const materialGroup = await prisma.materialGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaterialGroupFindFirstArgs>(args?: SelectSubset<T, MaterialGroupFindFirstArgs<ExtArgs>>): Prisma__MaterialGroupClient<$Result.GetResult<Prisma.$MaterialGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaterialGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialGroupFindFirstOrThrowArgs} args - Arguments to find a MaterialGroup
     * @example
     * // Get one MaterialGroup
     * const materialGroup = await prisma.materialGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaterialGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, MaterialGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaterialGroupClient<$Result.GetResult<Prisma.$MaterialGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MaterialGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaterialGroups
     * const materialGroups = await prisma.materialGroup.findMany()
     * 
     * // Get first 10 MaterialGroups
     * const materialGroups = await prisma.materialGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialGroupWithIdOnly = await prisma.materialGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaterialGroupFindManyArgs>(args?: SelectSubset<T, MaterialGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MaterialGroup.
     * @param {MaterialGroupCreateArgs} args - Arguments to create a MaterialGroup.
     * @example
     * // Create one MaterialGroup
     * const MaterialGroup = await prisma.materialGroup.create({
     *   data: {
     *     // ... data to create a MaterialGroup
     *   }
     * })
     * 
     */
    create<T extends MaterialGroupCreateArgs>(args: SelectSubset<T, MaterialGroupCreateArgs<ExtArgs>>): Prisma__MaterialGroupClient<$Result.GetResult<Prisma.$MaterialGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MaterialGroups.
     * @param {MaterialGroupCreateManyArgs} args - Arguments to create many MaterialGroups.
     * @example
     * // Create many MaterialGroups
     * const materialGroup = await prisma.materialGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaterialGroupCreateManyArgs>(args?: SelectSubset<T, MaterialGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MaterialGroups and returns the data saved in the database.
     * @param {MaterialGroupCreateManyAndReturnArgs} args - Arguments to create many MaterialGroups.
     * @example
     * // Create many MaterialGroups
     * const materialGroup = await prisma.materialGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MaterialGroups and only return the `id`
     * const materialGroupWithIdOnly = await prisma.materialGroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaterialGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, MaterialGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialGroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MaterialGroup.
     * @param {MaterialGroupDeleteArgs} args - Arguments to delete one MaterialGroup.
     * @example
     * // Delete one MaterialGroup
     * const MaterialGroup = await prisma.materialGroup.delete({
     *   where: {
     *     // ... filter to delete one MaterialGroup
     *   }
     * })
     * 
     */
    delete<T extends MaterialGroupDeleteArgs>(args: SelectSubset<T, MaterialGroupDeleteArgs<ExtArgs>>): Prisma__MaterialGroupClient<$Result.GetResult<Prisma.$MaterialGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MaterialGroup.
     * @param {MaterialGroupUpdateArgs} args - Arguments to update one MaterialGroup.
     * @example
     * // Update one MaterialGroup
     * const materialGroup = await prisma.materialGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaterialGroupUpdateArgs>(args: SelectSubset<T, MaterialGroupUpdateArgs<ExtArgs>>): Prisma__MaterialGroupClient<$Result.GetResult<Prisma.$MaterialGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MaterialGroups.
     * @param {MaterialGroupDeleteManyArgs} args - Arguments to filter MaterialGroups to delete.
     * @example
     * // Delete a few MaterialGroups
     * const { count } = await prisma.materialGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaterialGroupDeleteManyArgs>(args?: SelectSubset<T, MaterialGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaterialGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaterialGroups
     * const materialGroup = await prisma.materialGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaterialGroupUpdateManyArgs>(args: SelectSubset<T, MaterialGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaterialGroups and returns the data updated in the database.
     * @param {MaterialGroupUpdateManyAndReturnArgs} args - Arguments to update many MaterialGroups.
     * @example
     * // Update many MaterialGroups
     * const materialGroup = await prisma.materialGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MaterialGroups and only return the `id`
     * const materialGroupWithIdOnly = await prisma.materialGroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MaterialGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, MaterialGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialGroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MaterialGroup.
     * @param {MaterialGroupUpsertArgs} args - Arguments to update or create a MaterialGroup.
     * @example
     * // Update or create a MaterialGroup
     * const materialGroup = await prisma.materialGroup.upsert({
     *   create: {
     *     // ... data to create a MaterialGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaterialGroup we want to update
     *   }
     * })
     */
    upsert<T extends MaterialGroupUpsertArgs>(args: SelectSubset<T, MaterialGroupUpsertArgs<ExtArgs>>): Prisma__MaterialGroupClient<$Result.GetResult<Prisma.$MaterialGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MaterialGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialGroupCountArgs} args - Arguments to filter MaterialGroups to count.
     * @example
     * // Count the number of MaterialGroups
     * const count = await prisma.materialGroup.count({
     *   where: {
     *     // ... the filter for the MaterialGroups we want to count
     *   }
     * })
    **/
    count<T extends MaterialGroupCountArgs>(
      args?: Subset<T, MaterialGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaterialGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialGroupAggregateArgs>(args: Subset<T, MaterialGroupAggregateArgs>): Prisma.PrismaPromise<GetMaterialGroupAggregateType<T>>

    /**
     * Group by MaterialGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialGroupGroupByArgs['orderBy'] }
        : { orderBy?: MaterialGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaterialGroup model
   */
  readonly fields: MaterialGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaterialGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaterialGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends MaterialGroup$parentArgs<ExtArgs> = {}>(args?: Subset<T, MaterialGroup$parentArgs<ExtArgs>>): Prisma__MaterialGroupClient<$Result.GetResult<Prisma.$MaterialGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends MaterialGroup$childrenArgs<ExtArgs> = {}>(args?: Subset<T, MaterialGroup$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    materials<T extends MaterialGroup$materialsArgs<ExtArgs> = {}>(args?: Subset<T, MaterialGroup$materialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaterialGroup model
   */
  interface MaterialGroupFieldRefs {
    readonly id: FieldRef<"MaterialGroup", 'Int'>
    readonly name: FieldRef<"MaterialGroup", 'String'>
    readonly parentId: FieldRef<"MaterialGroup", 'Int'>
    readonly color: FieldRef<"MaterialGroup", 'String'>
    readonly createdAt: FieldRef<"MaterialGroup", 'DateTime'>
    readonly updatedAt: FieldRef<"MaterialGroup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MaterialGroup findUnique
   */
  export type MaterialGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialGroup
     */
    select?: MaterialGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialGroup
     */
    omit?: MaterialGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialGroupInclude<ExtArgs> | null
    /**
     * Filter, which MaterialGroup to fetch.
     */
    where: MaterialGroupWhereUniqueInput
  }

  /**
   * MaterialGroup findUniqueOrThrow
   */
  export type MaterialGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialGroup
     */
    select?: MaterialGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialGroup
     */
    omit?: MaterialGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialGroupInclude<ExtArgs> | null
    /**
     * Filter, which MaterialGroup to fetch.
     */
    where: MaterialGroupWhereUniqueInput
  }

  /**
   * MaterialGroup findFirst
   */
  export type MaterialGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialGroup
     */
    select?: MaterialGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialGroup
     */
    omit?: MaterialGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialGroupInclude<ExtArgs> | null
    /**
     * Filter, which MaterialGroup to fetch.
     */
    where?: MaterialGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialGroups to fetch.
     */
    orderBy?: MaterialGroupOrderByWithRelationInput | MaterialGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaterialGroups.
     */
    cursor?: MaterialGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaterialGroups.
     */
    distinct?: MaterialGroupScalarFieldEnum | MaterialGroupScalarFieldEnum[]
  }

  /**
   * MaterialGroup findFirstOrThrow
   */
  export type MaterialGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialGroup
     */
    select?: MaterialGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialGroup
     */
    omit?: MaterialGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialGroupInclude<ExtArgs> | null
    /**
     * Filter, which MaterialGroup to fetch.
     */
    where?: MaterialGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialGroups to fetch.
     */
    orderBy?: MaterialGroupOrderByWithRelationInput | MaterialGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaterialGroups.
     */
    cursor?: MaterialGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaterialGroups.
     */
    distinct?: MaterialGroupScalarFieldEnum | MaterialGroupScalarFieldEnum[]
  }

  /**
   * MaterialGroup findMany
   */
  export type MaterialGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialGroup
     */
    select?: MaterialGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialGroup
     */
    omit?: MaterialGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialGroupInclude<ExtArgs> | null
    /**
     * Filter, which MaterialGroups to fetch.
     */
    where?: MaterialGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialGroups to fetch.
     */
    orderBy?: MaterialGroupOrderByWithRelationInput | MaterialGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaterialGroups.
     */
    cursor?: MaterialGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialGroups.
     */
    skip?: number
    distinct?: MaterialGroupScalarFieldEnum | MaterialGroupScalarFieldEnum[]
  }

  /**
   * MaterialGroup create
   */
  export type MaterialGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialGroup
     */
    select?: MaterialGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialGroup
     */
    omit?: MaterialGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a MaterialGroup.
     */
    data: XOR<MaterialGroupCreateInput, MaterialGroupUncheckedCreateInput>
  }

  /**
   * MaterialGroup createMany
   */
  export type MaterialGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaterialGroups.
     */
    data: MaterialGroupCreateManyInput | MaterialGroupCreateManyInput[]
  }

  /**
   * MaterialGroup createManyAndReturn
   */
  export type MaterialGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialGroup
     */
    select?: MaterialGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialGroup
     */
    omit?: MaterialGroupOmit<ExtArgs> | null
    /**
     * The data used to create many MaterialGroups.
     */
    data: MaterialGroupCreateManyInput | MaterialGroupCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialGroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaterialGroup update
   */
  export type MaterialGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialGroup
     */
    select?: MaterialGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialGroup
     */
    omit?: MaterialGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a MaterialGroup.
     */
    data: XOR<MaterialGroupUpdateInput, MaterialGroupUncheckedUpdateInput>
    /**
     * Choose, which MaterialGroup to update.
     */
    where: MaterialGroupWhereUniqueInput
  }

  /**
   * MaterialGroup updateMany
   */
  export type MaterialGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaterialGroups.
     */
    data: XOR<MaterialGroupUpdateManyMutationInput, MaterialGroupUncheckedUpdateManyInput>
    /**
     * Filter which MaterialGroups to update
     */
    where?: MaterialGroupWhereInput
    /**
     * Limit how many MaterialGroups to update.
     */
    limit?: number
  }

  /**
   * MaterialGroup updateManyAndReturn
   */
  export type MaterialGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialGroup
     */
    select?: MaterialGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialGroup
     */
    omit?: MaterialGroupOmit<ExtArgs> | null
    /**
     * The data used to update MaterialGroups.
     */
    data: XOR<MaterialGroupUpdateManyMutationInput, MaterialGroupUncheckedUpdateManyInput>
    /**
     * Filter which MaterialGroups to update
     */
    where?: MaterialGroupWhereInput
    /**
     * Limit how many MaterialGroups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialGroupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaterialGroup upsert
   */
  export type MaterialGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialGroup
     */
    select?: MaterialGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialGroup
     */
    omit?: MaterialGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the MaterialGroup to update in case it exists.
     */
    where: MaterialGroupWhereUniqueInput
    /**
     * In case the MaterialGroup found by the `where` argument doesn't exist, create a new MaterialGroup with this data.
     */
    create: XOR<MaterialGroupCreateInput, MaterialGroupUncheckedCreateInput>
    /**
     * In case the MaterialGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterialGroupUpdateInput, MaterialGroupUncheckedUpdateInput>
  }

  /**
   * MaterialGroup delete
   */
  export type MaterialGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialGroup
     */
    select?: MaterialGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialGroup
     */
    omit?: MaterialGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialGroupInclude<ExtArgs> | null
    /**
     * Filter which MaterialGroup to delete.
     */
    where: MaterialGroupWhereUniqueInput
  }

  /**
   * MaterialGroup deleteMany
   */
  export type MaterialGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaterialGroups to delete
     */
    where?: MaterialGroupWhereInput
    /**
     * Limit how many MaterialGroups to delete.
     */
    limit?: number
  }

  /**
   * MaterialGroup.parent
   */
  export type MaterialGroup$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialGroup
     */
    select?: MaterialGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialGroup
     */
    omit?: MaterialGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialGroupInclude<ExtArgs> | null
    where?: MaterialGroupWhereInput
  }

  /**
   * MaterialGroup.children
   */
  export type MaterialGroup$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialGroup
     */
    select?: MaterialGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialGroup
     */
    omit?: MaterialGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialGroupInclude<ExtArgs> | null
    where?: MaterialGroupWhereInput
    orderBy?: MaterialGroupOrderByWithRelationInput | MaterialGroupOrderByWithRelationInput[]
    cursor?: MaterialGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialGroupScalarFieldEnum | MaterialGroupScalarFieldEnum[]
  }

  /**
   * MaterialGroup.materials
   */
  export type MaterialGroup$materialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    where?: MaterialWhereInput
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    cursor?: MaterialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * MaterialGroup without action
   */
  export type MaterialGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialGroup
     */
    select?: MaterialGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaterialGroup
     */
    omit?: MaterialGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialGroupInclude<ExtArgs> | null
  }


  /**
   * Model Move
   */

  export type AggregateMove = {
    _count: MoveCountAggregateOutputType | null
    _avg: MoveAvgAggregateOutputType | null
    _sum: MoveSumAggregateOutputType | null
    _min: MoveMinAggregateOutputType | null
    _max: MoveMaxAggregateOutputType | null
  }

  export type MoveAvgAggregateOutputType = {
    id: number | null
    obraId: number | null
    frenteId: number | null
    materialId: number | null
    proveedorId: number | null
    quantity: number | null
    unitCost: number | null
    totalCost: number | null
    igvRate: Decimal | null
  }

  export type MoveSumAggregateOutputType = {
    id: number | null
    obraId: number | null
    frenteId: number | null
    materialId: number | null
    proveedorId: number | null
    quantity: number | null
    unitCost: number | null
    totalCost: number | null
    igvRate: Decimal | null
  }

  export type MoveMinAggregateOutputType = {
    id: number | null
    obraId: number | null
    frenteId: number | null
    materialId: number | null
    proveedorId: number | null
    type: $Enums.MoveType | null
    quantity: number | null
    unitCost: number | null
    totalCost: number | null
    date: Date | null
    note: string | null
    docType: $Enums.DocType | null
    docSerie: string | null
    docNumero: string | null
    igvRate: Decimal | null
    isTaxable: boolean | null
    responsible: string | null
    assetStatus: $Enums.AssetStatus | null
  }

  export type MoveMaxAggregateOutputType = {
    id: number | null
    obraId: number | null
    frenteId: number | null
    materialId: number | null
    proveedorId: number | null
    type: $Enums.MoveType | null
    quantity: number | null
    unitCost: number | null
    totalCost: number | null
    date: Date | null
    note: string | null
    docType: $Enums.DocType | null
    docSerie: string | null
    docNumero: string | null
    igvRate: Decimal | null
    isTaxable: boolean | null
    responsible: string | null
    assetStatus: $Enums.AssetStatus | null
  }

  export type MoveCountAggregateOutputType = {
    id: number
    obraId: number
    frenteId: number
    materialId: number
    proveedorId: number
    type: number
    quantity: number
    unitCost: number
    totalCost: number
    date: number
    note: number
    docType: number
    docSerie: number
    docNumero: number
    igvRate: number
    isTaxable: number
    responsible: number
    assetStatus: number
    _all: number
  }


  export type MoveAvgAggregateInputType = {
    id?: true
    obraId?: true
    frenteId?: true
    materialId?: true
    proveedorId?: true
    quantity?: true
    unitCost?: true
    totalCost?: true
    igvRate?: true
  }

  export type MoveSumAggregateInputType = {
    id?: true
    obraId?: true
    frenteId?: true
    materialId?: true
    proveedorId?: true
    quantity?: true
    unitCost?: true
    totalCost?: true
    igvRate?: true
  }

  export type MoveMinAggregateInputType = {
    id?: true
    obraId?: true
    frenteId?: true
    materialId?: true
    proveedorId?: true
    type?: true
    quantity?: true
    unitCost?: true
    totalCost?: true
    date?: true
    note?: true
    docType?: true
    docSerie?: true
    docNumero?: true
    igvRate?: true
    isTaxable?: true
    responsible?: true
    assetStatus?: true
  }

  export type MoveMaxAggregateInputType = {
    id?: true
    obraId?: true
    frenteId?: true
    materialId?: true
    proveedorId?: true
    type?: true
    quantity?: true
    unitCost?: true
    totalCost?: true
    date?: true
    note?: true
    docType?: true
    docSerie?: true
    docNumero?: true
    igvRate?: true
    isTaxable?: true
    responsible?: true
    assetStatus?: true
  }

  export type MoveCountAggregateInputType = {
    id?: true
    obraId?: true
    frenteId?: true
    materialId?: true
    proveedorId?: true
    type?: true
    quantity?: true
    unitCost?: true
    totalCost?: true
    date?: true
    note?: true
    docType?: true
    docSerie?: true
    docNumero?: true
    igvRate?: true
    isTaxable?: true
    responsible?: true
    assetStatus?: true
    _all?: true
  }

  export type MoveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Move to aggregate.
     */
    where?: MoveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Moves to fetch.
     */
    orderBy?: MoveOrderByWithRelationInput | MoveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MoveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Moves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Moves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Moves
    **/
    _count?: true | MoveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MoveAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MoveSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MoveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MoveMaxAggregateInputType
  }

  export type GetMoveAggregateType<T extends MoveAggregateArgs> = {
        [P in keyof T & keyof AggregateMove]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMove[P]>
      : GetScalarType<T[P], AggregateMove[P]>
  }




  export type MoveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MoveWhereInput
    orderBy?: MoveOrderByWithAggregationInput | MoveOrderByWithAggregationInput[]
    by: MoveScalarFieldEnum[] | MoveScalarFieldEnum
    having?: MoveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MoveCountAggregateInputType | true
    _avg?: MoveAvgAggregateInputType
    _sum?: MoveSumAggregateInputType
    _min?: MoveMinAggregateInputType
    _max?: MoveMaxAggregateInputType
  }

  export type MoveGroupByOutputType = {
    id: number
    obraId: number
    frenteId: number | null
    materialId: number
    proveedorId: number | null
    type: $Enums.MoveType
    quantity: number
    unitCost: number | null
    totalCost: number | null
    date: Date
    note: string | null
    docType: $Enums.DocType | null
    docSerie: string | null
    docNumero: string | null
    igvRate: Decimal | null
    isTaxable: boolean | null
    responsible: string | null
    assetStatus: $Enums.AssetStatus | null
    _count: MoveCountAggregateOutputType | null
    _avg: MoveAvgAggregateOutputType | null
    _sum: MoveSumAggregateOutputType | null
    _min: MoveMinAggregateOutputType | null
    _max: MoveMaxAggregateOutputType | null
  }

  type GetMoveGroupByPayload<T extends MoveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MoveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MoveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MoveGroupByOutputType[P]>
            : GetScalarType<T[P], MoveGroupByOutputType[P]>
        }
      >
    >


  export type MoveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    obraId?: boolean
    frenteId?: boolean
    materialId?: boolean
    proveedorId?: boolean
    type?: boolean
    quantity?: boolean
    unitCost?: boolean
    totalCost?: boolean
    date?: boolean
    note?: boolean
    docType?: boolean
    docSerie?: boolean
    docNumero?: boolean
    igvRate?: boolean
    isTaxable?: boolean
    responsible?: boolean
    assetStatus?: boolean
    obra?: boolean | ObraDefaultArgs<ExtArgs>
    frente?: boolean | Move$frenteArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
    proveedor?: boolean | Move$proveedorArgs<ExtArgs>
    expense?: boolean | Move$expenseArgs<ExtArgs>
  }, ExtArgs["result"]["move"]>

  export type MoveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    obraId?: boolean
    frenteId?: boolean
    materialId?: boolean
    proveedorId?: boolean
    type?: boolean
    quantity?: boolean
    unitCost?: boolean
    totalCost?: boolean
    date?: boolean
    note?: boolean
    docType?: boolean
    docSerie?: boolean
    docNumero?: boolean
    igvRate?: boolean
    isTaxable?: boolean
    responsible?: boolean
    assetStatus?: boolean
    obra?: boolean | ObraDefaultArgs<ExtArgs>
    frente?: boolean | Move$frenteArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
    proveedor?: boolean | Move$proveedorArgs<ExtArgs>
  }, ExtArgs["result"]["move"]>

  export type MoveSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    obraId?: boolean
    frenteId?: boolean
    materialId?: boolean
    proveedorId?: boolean
    type?: boolean
    quantity?: boolean
    unitCost?: boolean
    totalCost?: boolean
    date?: boolean
    note?: boolean
    docType?: boolean
    docSerie?: boolean
    docNumero?: boolean
    igvRate?: boolean
    isTaxable?: boolean
    responsible?: boolean
    assetStatus?: boolean
    obra?: boolean | ObraDefaultArgs<ExtArgs>
    frente?: boolean | Move$frenteArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
    proveedor?: boolean | Move$proveedorArgs<ExtArgs>
  }, ExtArgs["result"]["move"]>

  export type MoveSelectScalar = {
    id?: boolean
    obraId?: boolean
    frenteId?: boolean
    materialId?: boolean
    proveedorId?: boolean
    type?: boolean
    quantity?: boolean
    unitCost?: boolean
    totalCost?: boolean
    date?: boolean
    note?: boolean
    docType?: boolean
    docSerie?: boolean
    docNumero?: boolean
    igvRate?: boolean
    isTaxable?: boolean
    responsible?: boolean
    assetStatus?: boolean
  }

  export type MoveOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "obraId" | "frenteId" | "materialId" | "proveedorId" | "type" | "quantity" | "unitCost" | "totalCost" | "date" | "note" | "docType" | "docSerie" | "docNumero" | "igvRate" | "isTaxable" | "responsible" | "assetStatus", ExtArgs["result"]["move"]>
  export type MoveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    obra?: boolean | ObraDefaultArgs<ExtArgs>
    frente?: boolean | Move$frenteArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
    proveedor?: boolean | Move$proveedorArgs<ExtArgs>
    expense?: boolean | Move$expenseArgs<ExtArgs>
  }
  export type MoveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    obra?: boolean | ObraDefaultArgs<ExtArgs>
    frente?: boolean | Move$frenteArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
    proveedor?: boolean | Move$proveedorArgs<ExtArgs>
  }
  export type MoveIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    obra?: boolean | ObraDefaultArgs<ExtArgs>
    frente?: boolean | Move$frenteArgs<ExtArgs>
    material?: boolean | MaterialDefaultArgs<ExtArgs>
    proveedor?: boolean | Move$proveedorArgs<ExtArgs>
  }

  export type $MovePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Move"
    objects: {
      obra: Prisma.$ObraPayload<ExtArgs>
      frente: Prisma.$FrentePayload<ExtArgs> | null
      material: Prisma.$MaterialPayload<ExtArgs>
      proveedor: Prisma.$ProveedorPayload<ExtArgs> | null
      expense: Prisma.$ExpensePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      obraId: number
      frenteId: number | null
      materialId: number
      proveedorId: number | null
      type: $Enums.MoveType
      quantity: number
      unitCost: number | null
      totalCost: number | null
      date: Date
      note: string | null
      docType: $Enums.DocType | null
      docSerie: string | null
      docNumero: string | null
      igvRate: Prisma.Decimal | null
      isTaxable: boolean | null
      responsible: string | null
      assetStatus: $Enums.AssetStatus | null
    }, ExtArgs["result"]["move"]>
    composites: {}
  }

  type MoveGetPayload<S extends boolean | null | undefined | MoveDefaultArgs> = $Result.GetResult<Prisma.$MovePayload, S>

  type MoveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MoveFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MoveCountAggregateInputType | true
    }

  export interface MoveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Move'], meta: { name: 'Move' } }
    /**
     * Find zero or one Move that matches the filter.
     * @param {MoveFindUniqueArgs} args - Arguments to find a Move
     * @example
     * // Get one Move
     * const move = await prisma.move.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MoveFindUniqueArgs>(args: SelectSubset<T, MoveFindUniqueArgs<ExtArgs>>): Prisma__MoveClient<$Result.GetResult<Prisma.$MovePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Move that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MoveFindUniqueOrThrowArgs} args - Arguments to find a Move
     * @example
     * // Get one Move
     * const move = await prisma.move.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MoveFindUniqueOrThrowArgs>(args: SelectSubset<T, MoveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MoveClient<$Result.GetResult<Prisma.$MovePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Move that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoveFindFirstArgs} args - Arguments to find a Move
     * @example
     * // Get one Move
     * const move = await prisma.move.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MoveFindFirstArgs>(args?: SelectSubset<T, MoveFindFirstArgs<ExtArgs>>): Prisma__MoveClient<$Result.GetResult<Prisma.$MovePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Move that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoveFindFirstOrThrowArgs} args - Arguments to find a Move
     * @example
     * // Get one Move
     * const move = await prisma.move.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MoveFindFirstOrThrowArgs>(args?: SelectSubset<T, MoveFindFirstOrThrowArgs<ExtArgs>>): Prisma__MoveClient<$Result.GetResult<Prisma.$MovePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Moves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Moves
     * const moves = await prisma.move.findMany()
     * 
     * // Get first 10 Moves
     * const moves = await prisma.move.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moveWithIdOnly = await prisma.move.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MoveFindManyArgs>(args?: SelectSubset<T, MoveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Move.
     * @param {MoveCreateArgs} args - Arguments to create a Move.
     * @example
     * // Create one Move
     * const Move = await prisma.move.create({
     *   data: {
     *     // ... data to create a Move
     *   }
     * })
     * 
     */
    create<T extends MoveCreateArgs>(args: SelectSubset<T, MoveCreateArgs<ExtArgs>>): Prisma__MoveClient<$Result.GetResult<Prisma.$MovePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Moves.
     * @param {MoveCreateManyArgs} args - Arguments to create many Moves.
     * @example
     * // Create many Moves
     * const move = await prisma.move.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MoveCreateManyArgs>(args?: SelectSubset<T, MoveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Moves and returns the data saved in the database.
     * @param {MoveCreateManyAndReturnArgs} args - Arguments to create many Moves.
     * @example
     * // Create many Moves
     * const move = await prisma.move.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Moves and only return the `id`
     * const moveWithIdOnly = await prisma.move.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MoveCreateManyAndReturnArgs>(args?: SelectSubset<T, MoveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Move.
     * @param {MoveDeleteArgs} args - Arguments to delete one Move.
     * @example
     * // Delete one Move
     * const Move = await prisma.move.delete({
     *   where: {
     *     // ... filter to delete one Move
     *   }
     * })
     * 
     */
    delete<T extends MoveDeleteArgs>(args: SelectSubset<T, MoveDeleteArgs<ExtArgs>>): Prisma__MoveClient<$Result.GetResult<Prisma.$MovePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Move.
     * @param {MoveUpdateArgs} args - Arguments to update one Move.
     * @example
     * // Update one Move
     * const move = await prisma.move.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MoveUpdateArgs>(args: SelectSubset<T, MoveUpdateArgs<ExtArgs>>): Prisma__MoveClient<$Result.GetResult<Prisma.$MovePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Moves.
     * @param {MoveDeleteManyArgs} args - Arguments to filter Moves to delete.
     * @example
     * // Delete a few Moves
     * const { count } = await prisma.move.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MoveDeleteManyArgs>(args?: SelectSubset<T, MoveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Moves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Moves
     * const move = await prisma.move.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MoveUpdateManyArgs>(args: SelectSubset<T, MoveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Moves and returns the data updated in the database.
     * @param {MoveUpdateManyAndReturnArgs} args - Arguments to update many Moves.
     * @example
     * // Update many Moves
     * const move = await prisma.move.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Moves and only return the `id`
     * const moveWithIdOnly = await prisma.move.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MoveUpdateManyAndReturnArgs>(args: SelectSubset<T, MoveUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Move.
     * @param {MoveUpsertArgs} args - Arguments to update or create a Move.
     * @example
     * // Update or create a Move
     * const move = await prisma.move.upsert({
     *   create: {
     *     // ... data to create a Move
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Move we want to update
     *   }
     * })
     */
    upsert<T extends MoveUpsertArgs>(args: SelectSubset<T, MoveUpsertArgs<ExtArgs>>): Prisma__MoveClient<$Result.GetResult<Prisma.$MovePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Moves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoveCountArgs} args - Arguments to filter Moves to count.
     * @example
     * // Count the number of Moves
     * const count = await prisma.move.count({
     *   where: {
     *     // ... the filter for the Moves we want to count
     *   }
     * })
    **/
    count<T extends MoveCountArgs>(
      args?: Subset<T, MoveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MoveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Move.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MoveAggregateArgs>(args: Subset<T, MoveAggregateArgs>): Prisma.PrismaPromise<GetMoveAggregateType<T>>

    /**
     * Group by Move.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MoveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MoveGroupByArgs['orderBy'] }
        : { orderBy?: MoveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MoveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMoveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Move model
   */
  readonly fields: MoveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Move.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MoveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    obra<T extends ObraDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ObraDefaultArgs<ExtArgs>>): Prisma__ObraClient<$Result.GetResult<Prisma.$ObraPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    frente<T extends Move$frenteArgs<ExtArgs> = {}>(args?: Subset<T, Move$frenteArgs<ExtArgs>>): Prisma__FrenteClient<$Result.GetResult<Prisma.$FrentePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    material<T extends MaterialDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaterialDefaultArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    proveedor<T extends Move$proveedorArgs<ExtArgs> = {}>(args?: Subset<T, Move$proveedorArgs<ExtArgs>>): Prisma__ProveedorClient<$Result.GetResult<Prisma.$ProveedorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    expense<T extends Move$expenseArgs<ExtArgs> = {}>(args?: Subset<T, Move$expenseArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Move model
   */
  interface MoveFieldRefs {
    readonly id: FieldRef<"Move", 'Int'>
    readonly obraId: FieldRef<"Move", 'Int'>
    readonly frenteId: FieldRef<"Move", 'Int'>
    readonly materialId: FieldRef<"Move", 'Int'>
    readonly proveedorId: FieldRef<"Move", 'Int'>
    readonly type: FieldRef<"Move", 'MoveType'>
    readonly quantity: FieldRef<"Move", 'Float'>
    readonly unitCost: FieldRef<"Move", 'Float'>
    readonly totalCost: FieldRef<"Move", 'Float'>
    readonly date: FieldRef<"Move", 'DateTime'>
    readonly note: FieldRef<"Move", 'String'>
    readonly docType: FieldRef<"Move", 'DocType'>
    readonly docSerie: FieldRef<"Move", 'String'>
    readonly docNumero: FieldRef<"Move", 'String'>
    readonly igvRate: FieldRef<"Move", 'Decimal'>
    readonly isTaxable: FieldRef<"Move", 'Boolean'>
    readonly responsible: FieldRef<"Move", 'String'>
    readonly assetStatus: FieldRef<"Move", 'AssetStatus'>
  }
    

  // Custom InputTypes
  /**
   * Move findUnique
   */
  export type MoveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Move
     */
    select?: MoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Move
     */
    omit?: MoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveInclude<ExtArgs> | null
    /**
     * Filter, which Move to fetch.
     */
    where: MoveWhereUniqueInput
  }

  /**
   * Move findUniqueOrThrow
   */
  export type MoveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Move
     */
    select?: MoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Move
     */
    omit?: MoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveInclude<ExtArgs> | null
    /**
     * Filter, which Move to fetch.
     */
    where: MoveWhereUniqueInput
  }

  /**
   * Move findFirst
   */
  export type MoveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Move
     */
    select?: MoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Move
     */
    omit?: MoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveInclude<ExtArgs> | null
    /**
     * Filter, which Move to fetch.
     */
    where?: MoveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Moves to fetch.
     */
    orderBy?: MoveOrderByWithRelationInput | MoveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Moves.
     */
    cursor?: MoveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Moves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Moves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Moves.
     */
    distinct?: MoveScalarFieldEnum | MoveScalarFieldEnum[]
  }

  /**
   * Move findFirstOrThrow
   */
  export type MoveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Move
     */
    select?: MoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Move
     */
    omit?: MoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveInclude<ExtArgs> | null
    /**
     * Filter, which Move to fetch.
     */
    where?: MoveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Moves to fetch.
     */
    orderBy?: MoveOrderByWithRelationInput | MoveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Moves.
     */
    cursor?: MoveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Moves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Moves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Moves.
     */
    distinct?: MoveScalarFieldEnum | MoveScalarFieldEnum[]
  }

  /**
   * Move findMany
   */
  export type MoveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Move
     */
    select?: MoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Move
     */
    omit?: MoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveInclude<ExtArgs> | null
    /**
     * Filter, which Moves to fetch.
     */
    where?: MoveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Moves to fetch.
     */
    orderBy?: MoveOrderByWithRelationInput | MoveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Moves.
     */
    cursor?: MoveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Moves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Moves.
     */
    skip?: number
    distinct?: MoveScalarFieldEnum | MoveScalarFieldEnum[]
  }

  /**
   * Move create
   */
  export type MoveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Move
     */
    select?: MoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Move
     */
    omit?: MoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveInclude<ExtArgs> | null
    /**
     * The data needed to create a Move.
     */
    data: XOR<MoveCreateInput, MoveUncheckedCreateInput>
  }

  /**
   * Move createMany
   */
  export type MoveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Moves.
     */
    data: MoveCreateManyInput | MoveCreateManyInput[]
  }

  /**
   * Move createManyAndReturn
   */
  export type MoveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Move
     */
    select?: MoveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Move
     */
    omit?: MoveOmit<ExtArgs> | null
    /**
     * The data used to create many Moves.
     */
    data: MoveCreateManyInput | MoveCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Move update
   */
  export type MoveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Move
     */
    select?: MoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Move
     */
    omit?: MoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveInclude<ExtArgs> | null
    /**
     * The data needed to update a Move.
     */
    data: XOR<MoveUpdateInput, MoveUncheckedUpdateInput>
    /**
     * Choose, which Move to update.
     */
    where: MoveWhereUniqueInput
  }

  /**
   * Move updateMany
   */
  export type MoveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Moves.
     */
    data: XOR<MoveUpdateManyMutationInput, MoveUncheckedUpdateManyInput>
    /**
     * Filter which Moves to update
     */
    where?: MoveWhereInput
    /**
     * Limit how many Moves to update.
     */
    limit?: number
  }

  /**
   * Move updateManyAndReturn
   */
  export type MoveUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Move
     */
    select?: MoveSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Move
     */
    omit?: MoveOmit<ExtArgs> | null
    /**
     * The data used to update Moves.
     */
    data: XOR<MoveUpdateManyMutationInput, MoveUncheckedUpdateManyInput>
    /**
     * Filter which Moves to update
     */
    where?: MoveWhereInput
    /**
     * Limit how many Moves to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Move upsert
   */
  export type MoveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Move
     */
    select?: MoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Move
     */
    omit?: MoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveInclude<ExtArgs> | null
    /**
     * The filter to search for the Move to update in case it exists.
     */
    where: MoveWhereUniqueInput
    /**
     * In case the Move found by the `where` argument doesn't exist, create a new Move with this data.
     */
    create: XOR<MoveCreateInput, MoveUncheckedCreateInput>
    /**
     * In case the Move was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MoveUpdateInput, MoveUncheckedUpdateInput>
  }

  /**
   * Move delete
   */
  export type MoveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Move
     */
    select?: MoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Move
     */
    omit?: MoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveInclude<ExtArgs> | null
    /**
     * Filter which Move to delete.
     */
    where: MoveWhereUniqueInput
  }

  /**
   * Move deleteMany
   */
  export type MoveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Moves to delete
     */
    where?: MoveWhereInput
    /**
     * Limit how many Moves to delete.
     */
    limit?: number
  }

  /**
   * Move.frente
   */
  export type Move$frenteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Frente
     */
    select?: FrenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Frente
     */
    omit?: FrenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FrenteInclude<ExtArgs> | null
    where?: FrenteWhereInput
  }

  /**
   * Move.proveedor
   */
  export type Move$proveedorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proveedor
     */
    select?: ProveedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proveedor
     */
    omit?: ProveedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProveedorInclude<ExtArgs> | null
    where?: ProveedorWhereInput
  }

  /**
   * Move.expense
   */
  export type Move$expenseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
  }

  /**
   * Move without action
   */
  export type MoveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Move
     */
    select?: MoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Move
     */
    omit?: MoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveInclude<ExtArgs> | null
  }


  /**
   * Model ExpenseCategory
   */

  export type AggregateExpenseCategory = {
    _count: ExpenseCategoryCountAggregateOutputType | null
    _avg: ExpenseCategoryAvgAggregateOutputType | null
    _sum: ExpenseCategorySumAggregateOutputType | null
    _min: ExpenseCategoryMinAggregateOutputType | null
    _max: ExpenseCategoryMaxAggregateOutputType | null
  }

  export type ExpenseCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type ExpenseCategorySumAggregateOutputType = {
    id: number | null
  }

  export type ExpenseCategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    kind: $Enums.ExpenseKind | null
  }

  export type ExpenseCategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    kind: $Enums.ExpenseKind | null
  }

  export type ExpenseCategoryCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    kind: number
    _all: number
  }


  export type ExpenseCategoryAvgAggregateInputType = {
    id?: true
  }

  export type ExpenseCategorySumAggregateInputType = {
    id?: true
  }

  export type ExpenseCategoryMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    kind?: true
  }

  export type ExpenseCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    kind?: true
  }

  export type ExpenseCategoryCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    kind?: true
    _all?: true
  }

  export type ExpenseCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpenseCategory to aggregate.
     */
    where?: ExpenseCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseCategories to fetch.
     */
    orderBy?: ExpenseCategoryOrderByWithRelationInput | ExpenseCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExpenseCategories
    **/
    _count?: true | ExpenseCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseCategoryMaxAggregateInputType
  }

  export type GetExpenseCategoryAggregateType<T extends ExpenseCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateExpenseCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpenseCategory[P]>
      : GetScalarType<T[P], AggregateExpenseCategory[P]>
  }




  export type ExpenseCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseCategoryWhereInput
    orderBy?: ExpenseCategoryOrderByWithAggregationInput | ExpenseCategoryOrderByWithAggregationInput[]
    by: ExpenseCategoryScalarFieldEnum[] | ExpenseCategoryScalarFieldEnum
    having?: ExpenseCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseCategoryCountAggregateInputType | true
    _avg?: ExpenseCategoryAvgAggregateInputType
    _sum?: ExpenseCategorySumAggregateInputType
    _min?: ExpenseCategoryMinAggregateInputType
    _max?: ExpenseCategoryMaxAggregateInputType
  }

  export type ExpenseCategoryGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    kind: $Enums.ExpenseKind
    _count: ExpenseCategoryCountAggregateOutputType | null
    _avg: ExpenseCategoryAvgAggregateOutputType | null
    _sum: ExpenseCategorySumAggregateOutputType | null
    _min: ExpenseCategoryMinAggregateOutputType | null
    _max: ExpenseCategoryMaxAggregateOutputType | null
  }

  type GetExpenseCategoryGroupByPayload<T extends ExpenseCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    kind?: boolean
    expenses?: boolean | ExpenseCategory$expensesArgs<ExtArgs>
    _count?: boolean | ExpenseCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expenseCategory"]>

  export type ExpenseCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    kind?: boolean
  }, ExtArgs["result"]["expenseCategory"]>

  export type ExpenseCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    kind?: boolean
  }, ExtArgs["result"]["expenseCategory"]>

  export type ExpenseCategorySelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    kind?: boolean
  }

  export type ExpenseCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "kind", ExtArgs["result"]["expenseCategory"]>
  export type ExpenseCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expenses?: boolean | ExpenseCategory$expensesArgs<ExtArgs>
    _count?: boolean | ExpenseCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExpenseCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ExpenseCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ExpenseCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExpenseCategory"
    objects: {
      expenses: Prisma.$ExpensePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date
      kind: $Enums.ExpenseKind
    }, ExtArgs["result"]["expenseCategory"]>
    composites: {}
  }

  type ExpenseCategoryGetPayload<S extends boolean | null | undefined | ExpenseCategoryDefaultArgs> = $Result.GetResult<Prisma.$ExpenseCategoryPayload, S>

  type ExpenseCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExpenseCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExpenseCategoryCountAggregateInputType | true
    }

  export interface ExpenseCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExpenseCategory'], meta: { name: 'ExpenseCategory' } }
    /**
     * Find zero or one ExpenseCategory that matches the filter.
     * @param {ExpenseCategoryFindUniqueArgs} args - Arguments to find a ExpenseCategory
     * @example
     * // Get one ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseCategoryFindUniqueArgs>(args: SelectSubset<T, ExpenseCategoryFindUniqueArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExpenseCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExpenseCategoryFindUniqueOrThrowArgs} args - Arguments to find a ExpenseCategory
     * @example
     * // Get one ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExpenseCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryFindFirstArgs} args - Arguments to find a ExpenseCategory
     * @example
     * // Get one ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseCategoryFindFirstArgs>(args?: SelectSubset<T, ExpenseCategoryFindFirstArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExpenseCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryFindFirstOrThrowArgs} args - Arguments to find a ExpenseCategory
     * @example
     * // Get one ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExpenseCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExpenseCategories
     * const expenseCategories = await prisma.expenseCategory.findMany()
     * 
     * // Get first 10 ExpenseCategories
     * const expenseCategories = await prisma.expenseCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseCategoryWithIdOnly = await prisma.expenseCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseCategoryFindManyArgs>(args?: SelectSubset<T, ExpenseCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExpenseCategory.
     * @param {ExpenseCategoryCreateArgs} args - Arguments to create a ExpenseCategory.
     * @example
     * // Create one ExpenseCategory
     * const ExpenseCategory = await prisma.expenseCategory.create({
     *   data: {
     *     // ... data to create a ExpenseCategory
     *   }
     * })
     * 
     */
    create<T extends ExpenseCategoryCreateArgs>(args: SelectSubset<T, ExpenseCategoryCreateArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExpenseCategories.
     * @param {ExpenseCategoryCreateManyArgs} args - Arguments to create many ExpenseCategories.
     * @example
     * // Create many ExpenseCategories
     * const expenseCategory = await prisma.expenseCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseCategoryCreateManyArgs>(args?: SelectSubset<T, ExpenseCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExpenseCategories and returns the data saved in the database.
     * @param {ExpenseCategoryCreateManyAndReturnArgs} args - Arguments to create many ExpenseCategories.
     * @example
     * // Create many ExpenseCategories
     * const expenseCategory = await prisma.expenseCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExpenseCategories and only return the `id`
     * const expenseCategoryWithIdOnly = await prisma.expenseCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpenseCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpenseCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExpenseCategory.
     * @param {ExpenseCategoryDeleteArgs} args - Arguments to delete one ExpenseCategory.
     * @example
     * // Delete one ExpenseCategory
     * const ExpenseCategory = await prisma.expenseCategory.delete({
     *   where: {
     *     // ... filter to delete one ExpenseCategory
     *   }
     * })
     * 
     */
    delete<T extends ExpenseCategoryDeleteArgs>(args: SelectSubset<T, ExpenseCategoryDeleteArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExpenseCategory.
     * @param {ExpenseCategoryUpdateArgs} args - Arguments to update one ExpenseCategory.
     * @example
     * // Update one ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseCategoryUpdateArgs>(args: SelectSubset<T, ExpenseCategoryUpdateArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExpenseCategories.
     * @param {ExpenseCategoryDeleteManyArgs} args - Arguments to filter ExpenseCategories to delete.
     * @example
     * // Delete a few ExpenseCategories
     * const { count } = await prisma.expenseCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseCategoryDeleteManyArgs>(args?: SelectSubset<T, ExpenseCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExpenseCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExpenseCategories
     * const expenseCategory = await prisma.expenseCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseCategoryUpdateManyArgs>(args: SelectSubset<T, ExpenseCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExpenseCategories and returns the data updated in the database.
     * @param {ExpenseCategoryUpdateManyAndReturnArgs} args - Arguments to update many ExpenseCategories.
     * @example
     * // Update many ExpenseCategories
     * const expenseCategory = await prisma.expenseCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExpenseCategories and only return the `id`
     * const expenseCategoryWithIdOnly = await prisma.expenseCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExpenseCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ExpenseCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExpenseCategory.
     * @param {ExpenseCategoryUpsertArgs} args - Arguments to update or create a ExpenseCategory.
     * @example
     * // Update or create a ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.upsert({
     *   create: {
     *     // ... data to create a ExpenseCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExpenseCategory we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseCategoryUpsertArgs>(args: SelectSubset<T, ExpenseCategoryUpsertArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExpenseCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryCountArgs} args - Arguments to filter ExpenseCategories to count.
     * @example
     * // Count the number of ExpenseCategories
     * const count = await prisma.expenseCategory.count({
     *   where: {
     *     // ... the filter for the ExpenseCategories we want to count
     *   }
     * })
    **/
    count<T extends ExpenseCategoryCountArgs>(
      args?: Subset<T, ExpenseCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExpenseCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseCategoryAggregateArgs>(args: Subset<T, ExpenseCategoryAggregateArgs>): Prisma.PrismaPromise<GetExpenseCategoryAggregateType<T>>

    /**
     * Group by ExpenseCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExpenseCategory model
   */
  readonly fields: ExpenseCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExpenseCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    expenses<T extends ExpenseCategory$expensesArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseCategory$expensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExpenseCategory model
   */
  interface ExpenseCategoryFieldRefs {
    readonly id: FieldRef<"ExpenseCategory", 'Int'>
    readonly name: FieldRef<"ExpenseCategory", 'String'>
    readonly createdAt: FieldRef<"ExpenseCategory", 'DateTime'>
    readonly kind: FieldRef<"ExpenseCategory", 'ExpenseKind'>
  }
    

  // Custom InputTypes
  /**
   * ExpenseCategory findUnique
   */
  export type ExpenseCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseCategory to fetch.
     */
    where: ExpenseCategoryWhereUniqueInput
  }

  /**
   * ExpenseCategory findUniqueOrThrow
   */
  export type ExpenseCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseCategory to fetch.
     */
    where: ExpenseCategoryWhereUniqueInput
  }

  /**
   * ExpenseCategory findFirst
   */
  export type ExpenseCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseCategory to fetch.
     */
    where?: ExpenseCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseCategories to fetch.
     */
    orderBy?: ExpenseCategoryOrderByWithRelationInput | ExpenseCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpenseCategories.
     */
    cursor?: ExpenseCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpenseCategories.
     */
    distinct?: ExpenseCategoryScalarFieldEnum | ExpenseCategoryScalarFieldEnum[]
  }

  /**
   * ExpenseCategory findFirstOrThrow
   */
  export type ExpenseCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseCategory to fetch.
     */
    where?: ExpenseCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseCategories to fetch.
     */
    orderBy?: ExpenseCategoryOrderByWithRelationInput | ExpenseCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpenseCategories.
     */
    cursor?: ExpenseCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpenseCategories.
     */
    distinct?: ExpenseCategoryScalarFieldEnum | ExpenseCategoryScalarFieldEnum[]
  }

  /**
   * ExpenseCategory findMany
   */
  export type ExpenseCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseCategories to fetch.
     */
    where?: ExpenseCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseCategories to fetch.
     */
    orderBy?: ExpenseCategoryOrderByWithRelationInput | ExpenseCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExpenseCategories.
     */
    cursor?: ExpenseCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseCategories.
     */
    skip?: number
    distinct?: ExpenseCategoryScalarFieldEnum | ExpenseCategoryScalarFieldEnum[]
  }

  /**
   * ExpenseCategory create
   */
  export type ExpenseCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ExpenseCategory.
     */
    data: XOR<ExpenseCategoryCreateInput, ExpenseCategoryUncheckedCreateInput>
  }

  /**
   * ExpenseCategory createMany
   */
  export type ExpenseCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExpenseCategories.
     */
    data: ExpenseCategoryCreateManyInput | ExpenseCategoryCreateManyInput[]
  }

  /**
   * ExpenseCategory createManyAndReturn
   */
  export type ExpenseCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ExpenseCategories.
     */
    data: ExpenseCategoryCreateManyInput | ExpenseCategoryCreateManyInput[]
  }

  /**
   * ExpenseCategory update
   */
  export type ExpenseCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ExpenseCategory.
     */
    data: XOR<ExpenseCategoryUpdateInput, ExpenseCategoryUncheckedUpdateInput>
    /**
     * Choose, which ExpenseCategory to update.
     */
    where: ExpenseCategoryWhereUniqueInput
  }

  /**
   * ExpenseCategory updateMany
   */
  export type ExpenseCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExpenseCategories.
     */
    data: XOR<ExpenseCategoryUpdateManyMutationInput, ExpenseCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ExpenseCategories to update
     */
    where?: ExpenseCategoryWhereInput
    /**
     * Limit how many ExpenseCategories to update.
     */
    limit?: number
  }

  /**
   * ExpenseCategory updateManyAndReturn
   */
  export type ExpenseCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * The data used to update ExpenseCategories.
     */
    data: XOR<ExpenseCategoryUpdateManyMutationInput, ExpenseCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ExpenseCategories to update
     */
    where?: ExpenseCategoryWhereInput
    /**
     * Limit how many ExpenseCategories to update.
     */
    limit?: number
  }

  /**
   * ExpenseCategory upsert
   */
  export type ExpenseCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ExpenseCategory to update in case it exists.
     */
    where: ExpenseCategoryWhereUniqueInput
    /**
     * In case the ExpenseCategory found by the `where` argument doesn't exist, create a new ExpenseCategory with this data.
     */
    create: XOR<ExpenseCategoryCreateInput, ExpenseCategoryUncheckedCreateInput>
    /**
     * In case the ExpenseCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseCategoryUpdateInput, ExpenseCategoryUncheckedUpdateInput>
  }

  /**
   * ExpenseCategory delete
   */
  export type ExpenseCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter which ExpenseCategory to delete.
     */
    where: ExpenseCategoryWhereUniqueInput
  }

  /**
   * ExpenseCategory deleteMany
   */
  export type ExpenseCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpenseCategories to delete
     */
    where?: ExpenseCategoryWhereInput
    /**
     * Limit how many ExpenseCategories to delete.
     */
    limit?: number
  }

  /**
   * ExpenseCategory.expenses
   */
  export type ExpenseCategory$expensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * ExpenseCategory without action
   */
  export type ExpenseCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Income
   */

  export type AggregateIncome = {
    _count: IncomeCountAggregateOutputType | null
    _avg: IncomeAvgAggregateOutputType | null
    _sum: IncomeSumAggregateOutputType | null
    _min: IncomeMinAggregateOutputType | null
    _max: IncomeMaxAggregateOutputType | null
  }

  export type IncomeAvgAggregateOutputType = {
    id: number | null
    obraId: number | null
    frenteId: number | null
    igvRate: Decimal | null
    base: Decimal | null
    igv: Decimal | null
    total: Decimal | null
  }

  export type IncomeSumAggregateOutputType = {
    id: number | null
    obraId: number | null
    frenteId: number | null
    igvRate: Decimal | null
    base: Decimal | null
    igv: Decimal | null
    total: Decimal | null
  }

  export type IncomeMinAggregateOutputType = {
    id: number | null
    obraId: number | null
    frenteId: number | null
    date: Date | null
    description: string | null
    docType: $Enums.DocType | null
    docSerie: string | null
    docNumero: string | null
    status: $Enums.IncomeStatus | null
    igvRate: Decimal | null
    isTaxable: boolean | null
    base: Decimal | null
    igv: Decimal | null
    total: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IncomeMaxAggregateOutputType = {
    id: number | null
    obraId: number | null
    frenteId: number | null
    date: Date | null
    description: string | null
    docType: $Enums.DocType | null
    docSerie: string | null
    docNumero: string | null
    status: $Enums.IncomeStatus | null
    igvRate: Decimal | null
    isTaxable: boolean | null
    base: Decimal | null
    igv: Decimal | null
    total: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IncomeCountAggregateOutputType = {
    id: number
    obraId: number
    frenteId: number
    date: number
    description: number
    docType: number
    docSerie: number
    docNumero: number
    status: number
    igvRate: number
    isTaxable: number
    base: number
    igv: number
    total: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IncomeAvgAggregateInputType = {
    id?: true
    obraId?: true
    frenteId?: true
    igvRate?: true
    base?: true
    igv?: true
    total?: true
  }

  export type IncomeSumAggregateInputType = {
    id?: true
    obraId?: true
    frenteId?: true
    igvRate?: true
    base?: true
    igv?: true
    total?: true
  }

  export type IncomeMinAggregateInputType = {
    id?: true
    obraId?: true
    frenteId?: true
    date?: true
    description?: true
    docType?: true
    docSerie?: true
    docNumero?: true
    status?: true
    igvRate?: true
    isTaxable?: true
    base?: true
    igv?: true
    total?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IncomeMaxAggregateInputType = {
    id?: true
    obraId?: true
    frenteId?: true
    date?: true
    description?: true
    docType?: true
    docSerie?: true
    docNumero?: true
    status?: true
    igvRate?: true
    isTaxable?: true
    base?: true
    igv?: true
    total?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IncomeCountAggregateInputType = {
    id?: true
    obraId?: true
    frenteId?: true
    date?: true
    description?: true
    docType?: true
    docSerie?: true
    docNumero?: true
    status?: true
    igvRate?: true
    isTaxable?: true
    base?: true
    igv?: true
    total?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IncomeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Income to aggregate.
     */
    where?: IncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incomes to fetch.
     */
    orderBy?: IncomeOrderByWithRelationInput | IncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Incomes
    **/
    _count?: true | IncomeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IncomeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IncomeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncomeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncomeMaxAggregateInputType
  }

  export type GetIncomeAggregateType<T extends IncomeAggregateArgs> = {
        [P in keyof T & keyof AggregateIncome]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncome[P]>
      : GetScalarType<T[P], AggregateIncome[P]>
  }




  export type IncomeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncomeWhereInput
    orderBy?: IncomeOrderByWithAggregationInput | IncomeOrderByWithAggregationInput[]
    by: IncomeScalarFieldEnum[] | IncomeScalarFieldEnum
    having?: IncomeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncomeCountAggregateInputType | true
    _avg?: IncomeAvgAggregateInputType
    _sum?: IncomeSumAggregateInputType
    _min?: IncomeMinAggregateInputType
    _max?: IncomeMaxAggregateInputType
  }

  export type IncomeGroupByOutputType = {
    id: number
    obraId: number
    frenteId: number | null
    date: Date
    description: string | null
    docType: $Enums.DocType
    docSerie: string | null
    docNumero: string | null
    status: $Enums.IncomeStatus
    igvRate: Decimal
    isTaxable: boolean
    base: Decimal
    igv: Decimal
    total: Decimal
    createdAt: Date
    updatedAt: Date
    _count: IncomeCountAggregateOutputType | null
    _avg: IncomeAvgAggregateOutputType | null
    _sum: IncomeSumAggregateOutputType | null
    _min: IncomeMinAggregateOutputType | null
    _max: IncomeMaxAggregateOutputType | null
  }

  type GetIncomeGroupByPayload<T extends IncomeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IncomeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IncomeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IncomeGroupByOutputType[P]>
            : GetScalarType<T[P], IncomeGroupByOutputType[P]>
        }
      >
    >


  export type IncomeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    obraId?: boolean
    frenteId?: boolean
    date?: boolean
    description?: boolean
    docType?: boolean
    docSerie?: boolean
    docNumero?: boolean
    status?: boolean
    igvRate?: boolean
    isTaxable?: boolean
    base?: boolean
    igv?: boolean
    total?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    obra?: boolean | ObraDefaultArgs<ExtArgs>
    frente?: boolean | Income$frenteArgs<ExtArgs>
  }, ExtArgs["result"]["income"]>

  export type IncomeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    obraId?: boolean
    frenteId?: boolean
    date?: boolean
    description?: boolean
    docType?: boolean
    docSerie?: boolean
    docNumero?: boolean
    status?: boolean
    igvRate?: boolean
    isTaxable?: boolean
    base?: boolean
    igv?: boolean
    total?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    obra?: boolean | ObraDefaultArgs<ExtArgs>
    frente?: boolean | Income$frenteArgs<ExtArgs>
  }, ExtArgs["result"]["income"]>

  export type IncomeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    obraId?: boolean
    frenteId?: boolean
    date?: boolean
    description?: boolean
    docType?: boolean
    docSerie?: boolean
    docNumero?: boolean
    status?: boolean
    igvRate?: boolean
    isTaxable?: boolean
    base?: boolean
    igv?: boolean
    total?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    obra?: boolean | ObraDefaultArgs<ExtArgs>
    frente?: boolean | Income$frenteArgs<ExtArgs>
  }, ExtArgs["result"]["income"]>

  export type IncomeSelectScalar = {
    id?: boolean
    obraId?: boolean
    frenteId?: boolean
    date?: boolean
    description?: boolean
    docType?: boolean
    docSerie?: boolean
    docNumero?: boolean
    status?: boolean
    igvRate?: boolean
    isTaxable?: boolean
    base?: boolean
    igv?: boolean
    total?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IncomeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "obraId" | "frenteId" | "date" | "description" | "docType" | "docSerie" | "docNumero" | "status" | "igvRate" | "isTaxable" | "base" | "igv" | "total" | "createdAt" | "updatedAt", ExtArgs["result"]["income"]>
  export type IncomeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    obra?: boolean | ObraDefaultArgs<ExtArgs>
    frente?: boolean | Income$frenteArgs<ExtArgs>
  }
  export type IncomeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    obra?: boolean | ObraDefaultArgs<ExtArgs>
    frente?: boolean | Income$frenteArgs<ExtArgs>
  }
  export type IncomeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    obra?: boolean | ObraDefaultArgs<ExtArgs>
    frente?: boolean | Income$frenteArgs<ExtArgs>
  }

  export type $IncomePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Income"
    objects: {
      obra: Prisma.$ObraPayload<ExtArgs>
      frente: Prisma.$FrentePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      obraId: number
      frenteId: number | null
      date: Date
      description: string | null
      docType: $Enums.DocType
      docSerie: string | null
      docNumero: string | null
      status: $Enums.IncomeStatus
      igvRate: Prisma.Decimal
      isTaxable: boolean
      base: Prisma.Decimal
      igv: Prisma.Decimal
      total: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["income"]>
    composites: {}
  }

  type IncomeGetPayload<S extends boolean | null | undefined | IncomeDefaultArgs> = $Result.GetResult<Prisma.$IncomePayload, S>

  type IncomeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IncomeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IncomeCountAggregateInputType | true
    }

  export interface IncomeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Income'], meta: { name: 'Income' } }
    /**
     * Find zero or one Income that matches the filter.
     * @param {IncomeFindUniqueArgs} args - Arguments to find a Income
     * @example
     * // Get one Income
     * const income = await prisma.income.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IncomeFindUniqueArgs>(args: SelectSubset<T, IncomeFindUniqueArgs<ExtArgs>>): Prisma__IncomeClient<$Result.GetResult<Prisma.$IncomePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Income that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IncomeFindUniqueOrThrowArgs} args - Arguments to find a Income
     * @example
     * // Get one Income
     * const income = await prisma.income.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IncomeFindUniqueOrThrowArgs>(args: SelectSubset<T, IncomeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IncomeClient<$Result.GetResult<Prisma.$IncomePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Income that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeFindFirstArgs} args - Arguments to find a Income
     * @example
     * // Get one Income
     * const income = await prisma.income.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IncomeFindFirstArgs>(args?: SelectSubset<T, IncomeFindFirstArgs<ExtArgs>>): Prisma__IncomeClient<$Result.GetResult<Prisma.$IncomePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Income that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeFindFirstOrThrowArgs} args - Arguments to find a Income
     * @example
     * // Get one Income
     * const income = await prisma.income.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IncomeFindFirstOrThrowArgs>(args?: SelectSubset<T, IncomeFindFirstOrThrowArgs<ExtArgs>>): Prisma__IncomeClient<$Result.GetResult<Prisma.$IncomePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Incomes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Incomes
     * const incomes = await prisma.income.findMany()
     * 
     * // Get first 10 Incomes
     * const incomes = await prisma.income.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const incomeWithIdOnly = await prisma.income.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IncomeFindManyArgs>(args?: SelectSubset<T, IncomeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncomePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Income.
     * @param {IncomeCreateArgs} args - Arguments to create a Income.
     * @example
     * // Create one Income
     * const Income = await prisma.income.create({
     *   data: {
     *     // ... data to create a Income
     *   }
     * })
     * 
     */
    create<T extends IncomeCreateArgs>(args: SelectSubset<T, IncomeCreateArgs<ExtArgs>>): Prisma__IncomeClient<$Result.GetResult<Prisma.$IncomePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Incomes.
     * @param {IncomeCreateManyArgs} args - Arguments to create many Incomes.
     * @example
     * // Create many Incomes
     * const income = await prisma.income.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IncomeCreateManyArgs>(args?: SelectSubset<T, IncomeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Incomes and returns the data saved in the database.
     * @param {IncomeCreateManyAndReturnArgs} args - Arguments to create many Incomes.
     * @example
     * // Create many Incomes
     * const income = await prisma.income.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Incomes and only return the `id`
     * const incomeWithIdOnly = await prisma.income.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IncomeCreateManyAndReturnArgs>(args?: SelectSubset<T, IncomeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncomePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Income.
     * @param {IncomeDeleteArgs} args - Arguments to delete one Income.
     * @example
     * // Delete one Income
     * const Income = await prisma.income.delete({
     *   where: {
     *     // ... filter to delete one Income
     *   }
     * })
     * 
     */
    delete<T extends IncomeDeleteArgs>(args: SelectSubset<T, IncomeDeleteArgs<ExtArgs>>): Prisma__IncomeClient<$Result.GetResult<Prisma.$IncomePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Income.
     * @param {IncomeUpdateArgs} args - Arguments to update one Income.
     * @example
     * // Update one Income
     * const income = await prisma.income.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IncomeUpdateArgs>(args: SelectSubset<T, IncomeUpdateArgs<ExtArgs>>): Prisma__IncomeClient<$Result.GetResult<Prisma.$IncomePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Incomes.
     * @param {IncomeDeleteManyArgs} args - Arguments to filter Incomes to delete.
     * @example
     * // Delete a few Incomes
     * const { count } = await prisma.income.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IncomeDeleteManyArgs>(args?: SelectSubset<T, IncomeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Incomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Incomes
     * const income = await prisma.income.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IncomeUpdateManyArgs>(args: SelectSubset<T, IncomeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Incomes and returns the data updated in the database.
     * @param {IncomeUpdateManyAndReturnArgs} args - Arguments to update many Incomes.
     * @example
     * // Update many Incomes
     * const income = await prisma.income.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Incomes and only return the `id`
     * const incomeWithIdOnly = await prisma.income.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IncomeUpdateManyAndReturnArgs>(args: SelectSubset<T, IncomeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncomePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Income.
     * @param {IncomeUpsertArgs} args - Arguments to update or create a Income.
     * @example
     * // Update or create a Income
     * const income = await prisma.income.upsert({
     *   create: {
     *     // ... data to create a Income
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Income we want to update
     *   }
     * })
     */
    upsert<T extends IncomeUpsertArgs>(args: SelectSubset<T, IncomeUpsertArgs<ExtArgs>>): Prisma__IncomeClient<$Result.GetResult<Prisma.$IncomePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Incomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeCountArgs} args - Arguments to filter Incomes to count.
     * @example
     * // Count the number of Incomes
     * const count = await prisma.income.count({
     *   where: {
     *     // ... the filter for the Incomes we want to count
     *   }
     * })
    **/
    count<T extends IncomeCountArgs>(
      args?: Subset<T, IncomeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncomeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Income.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncomeAggregateArgs>(args: Subset<T, IncomeAggregateArgs>): Prisma.PrismaPromise<GetIncomeAggregateType<T>>

    /**
     * Group by Income.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IncomeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IncomeGroupByArgs['orderBy'] }
        : { orderBy?: IncomeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IncomeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncomeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Income model
   */
  readonly fields: IncomeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Income.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IncomeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    obra<T extends ObraDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ObraDefaultArgs<ExtArgs>>): Prisma__ObraClient<$Result.GetResult<Prisma.$ObraPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    frente<T extends Income$frenteArgs<ExtArgs> = {}>(args?: Subset<T, Income$frenteArgs<ExtArgs>>): Prisma__FrenteClient<$Result.GetResult<Prisma.$FrentePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Income model
   */
  interface IncomeFieldRefs {
    readonly id: FieldRef<"Income", 'Int'>
    readonly obraId: FieldRef<"Income", 'Int'>
    readonly frenteId: FieldRef<"Income", 'Int'>
    readonly date: FieldRef<"Income", 'DateTime'>
    readonly description: FieldRef<"Income", 'String'>
    readonly docType: FieldRef<"Income", 'DocType'>
    readonly docSerie: FieldRef<"Income", 'String'>
    readonly docNumero: FieldRef<"Income", 'String'>
    readonly status: FieldRef<"Income", 'IncomeStatus'>
    readonly igvRate: FieldRef<"Income", 'Decimal'>
    readonly isTaxable: FieldRef<"Income", 'Boolean'>
    readonly base: FieldRef<"Income", 'Decimal'>
    readonly igv: FieldRef<"Income", 'Decimal'>
    readonly total: FieldRef<"Income", 'Decimal'>
    readonly createdAt: FieldRef<"Income", 'DateTime'>
    readonly updatedAt: FieldRef<"Income", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Income findUnique
   */
  export type IncomeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Income
     */
    select?: IncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Income
     */
    omit?: IncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeInclude<ExtArgs> | null
    /**
     * Filter, which Income to fetch.
     */
    where: IncomeWhereUniqueInput
  }

  /**
   * Income findUniqueOrThrow
   */
  export type IncomeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Income
     */
    select?: IncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Income
     */
    omit?: IncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeInclude<ExtArgs> | null
    /**
     * Filter, which Income to fetch.
     */
    where: IncomeWhereUniqueInput
  }

  /**
   * Income findFirst
   */
  export type IncomeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Income
     */
    select?: IncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Income
     */
    omit?: IncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeInclude<ExtArgs> | null
    /**
     * Filter, which Income to fetch.
     */
    where?: IncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incomes to fetch.
     */
    orderBy?: IncomeOrderByWithRelationInput | IncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Incomes.
     */
    cursor?: IncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Incomes.
     */
    distinct?: IncomeScalarFieldEnum | IncomeScalarFieldEnum[]
  }

  /**
   * Income findFirstOrThrow
   */
  export type IncomeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Income
     */
    select?: IncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Income
     */
    omit?: IncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeInclude<ExtArgs> | null
    /**
     * Filter, which Income to fetch.
     */
    where?: IncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incomes to fetch.
     */
    orderBy?: IncomeOrderByWithRelationInput | IncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Incomes.
     */
    cursor?: IncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Incomes.
     */
    distinct?: IncomeScalarFieldEnum | IncomeScalarFieldEnum[]
  }

  /**
   * Income findMany
   */
  export type IncomeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Income
     */
    select?: IncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Income
     */
    omit?: IncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeInclude<ExtArgs> | null
    /**
     * Filter, which Incomes to fetch.
     */
    where?: IncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incomes to fetch.
     */
    orderBy?: IncomeOrderByWithRelationInput | IncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Incomes.
     */
    cursor?: IncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incomes.
     */
    skip?: number
    distinct?: IncomeScalarFieldEnum | IncomeScalarFieldEnum[]
  }

  /**
   * Income create
   */
  export type IncomeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Income
     */
    select?: IncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Income
     */
    omit?: IncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeInclude<ExtArgs> | null
    /**
     * The data needed to create a Income.
     */
    data: XOR<IncomeCreateInput, IncomeUncheckedCreateInput>
  }

  /**
   * Income createMany
   */
  export type IncomeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Incomes.
     */
    data: IncomeCreateManyInput | IncomeCreateManyInput[]
  }

  /**
   * Income createManyAndReturn
   */
  export type IncomeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Income
     */
    select?: IncomeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Income
     */
    omit?: IncomeOmit<ExtArgs> | null
    /**
     * The data used to create many Incomes.
     */
    data: IncomeCreateManyInput | IncomeCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Income update
   */
  export type IncomeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Income
     */
    select?: IncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Income
     */
    omit?: IncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeInclude<ExtArgs> | null
    /**
     * The data needed to update a Income.
     */
    data: XOR<IncomeUpdateInput, IncomeUncheckedUpdateInput>
    /**
     * Choose, which Income to update.
     */
    where: IncomeWhereUniqueInput
  }

  /**
   * Income updateMany
   */
  export type IncomeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Incomes.
     */
    data: XOR<IncomeUpdateManyMutationInput, IncomeUncheckedUpdateManyInput>
    /**
     * Filter which Incomes to update
     */
    where?: IncomeWhereInput
    /**
     * Limit how many Incomes to update.
     */
    limit?: number
  }

  /**
   * Income updateManyAndReturn
   */
  export type IncomeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Income
     */
    select?: IncomeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Income
     */
    omit?: IncomeOmit<ExtArgs> | null
    /**
     * The data used to update Incomes.
     */
    data: XOR<IncomeUpdateManyMutationInput, IncomeUncheckedUpdateManyInput>
    /**
     * Filter which Incomes to update
     */
    where?: IncomeWhereInput
    /**
     * Limit how many Incomes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Income upsert
   */
  export type IncomeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Income
     */
    select?: IncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Income
     */
    omit?: IncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeInclude<ExtArgs> | null
    /**
     * The filter to search for the Income to update in case it exists.
     */
    where: IncomeWhereUniqueInput
    /**
     * In case the Income found by the `where` argument doesn't exist, create a new Income with this data.
     */
    create: XOR<IncomeCreateInput, IncomeUncheckedCreateInput>
    /**
     * In case the Income was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IncomeUpdateInput, IncomeUncheckedUpdateInput>
  }

  /**
   * Income delete
   */
  export type IncomeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Income
     */
    select?: IncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Income
     */
    omit?: IncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeInclude<ExtArgs> | null
    /**
     * Filter which Income to delete.
     */
    where: IncomeWhereUniqueInput
  }

  /**
   * Income deleteMany
   */
  export type IncomeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Incomes to delete
     */
    where?: IncomeWhereInput
    /**
     * Limit how many Incomes to delete.
     */
    limit?: number
  }

  /**
   * Income.frente
   */
  export type Income$frenteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Frente
     */
    select?: FrenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Frente
     */
    omit?: FrenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FrenteInclude<ExtArgs> | null
    where?: FrenteWhereInput
  }

  /**
   * Income without action
   */
  export type IncomeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Income
     */
    select?: IncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Income
     */
    omit?: IncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeInclude<ExtArgs> | null
  }


  /**
   * Model Expense
   */

  export type AggregateExpense = {
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  export type ExpenseAvgAggregateOutputType = {
    id: number | null
    obraId: number | null
    frenteId: number | null
    proveedorId: number | null
    materialId: number | null
    categoryId: number | null
    moveId: number | null
    quantity: Decimal | null
    unitCost: Decimal | null
    igvRate: Decimal | null
    base: Decimal | null
    igv: Decimal | null
    total: Decimal | null
    reminderIntervalDays: number | null
  }

  export type ExpenseSumAggregateOutputType = {
    id: number | null
    obraId: number | null
    frenteId: number | null
    proveedorId: number | null
    materialId: number | null
    categoryId: number | null
    moveId: number | null
    quantity: Decimal | null
    unitCost: Decimal | null
    igvRate: Decimal | null
    base: Decimal | null
    igv: Decimal | null
    total: Decimal | null
    reminderIntervalDays: number | null
  }

  export type ExpenseMinAggregateOutputType = {
    id: number | null
    obraId: number | null
    frenteId: number | null
    proveedorId: number | null
    materialId: number | null
    categoryId: number | null
    moveId: number | null
    docType: $Enums.DocType | null
    docSerie: string | null
    docNumero: string | null
    date: Date | null
    description: string | null
    spentBy: string | null
    type: $Enums.ExpenseType | null
    variableType: $Enums.VariableType | null
    quantity: Decimal | null
    unitCost: Decimal | null
    igvRate: Decimal | null
    isTaxable: boolean | null
    base: Decimal | null
    igv: Decimal | null
    total: Decimal | null
    paymentMethod: $Enums.PaymentMethod | null
    paidAt: Date | null
    status: string | null
    reminderIntervalDays: number | null
    reminderNextDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpenseMaxAggregateOutputType = {
    id: number | null
    obraId: number | null
    frenteId: number | null
    proveedorId: number | null
    materialId: number | null
    categoryId: number | null
    moveId: number | null
    docType: $Enums.DocType | null
    docSerie: string | null
    docNumero: string | null
    date: Date | null
    description: string | null
    spentBy: string | null
    type: $Enums.ExpenseType | null
    variableType: $Enums.VariableType | null
    quantity: Decimal | null
    unitCost: Decimal | null
    igvRate: Decimal | null
    isTaxable: boolean | null
    base: Decimal | null
    igv: Decimal | null
    total: Decimal | null
    paymentMethod: $Enums.PaymentMethod | null
    paidAt: Date | null
    status: string | null
    reminderIntervalDays: number | null
    reminderNextDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpenseCountAggregateOutputType = {
    id: number
    obraId: number
    frenteId: number
    proveedorId: number
    materialId: number
    categoryId: number
    moveId: number
    docType: number
    docSerie: number
    docNumero: number
    date: number
    description: number
    spentBy: number
    type: number
    variableType: number
    quantity: number
    unitCost: number
    igvRate: number
    isTaxable: number
    base: number
    igv: number
    total: number
    paymentMethod: number
    paidAt: number
    status: number
    reminderIntervalDays: number
    reminderNextDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExpenseAvgAggregateInputType = {
    id?: true
    obraId?: true
    frenteId?: true
    proveedorId?: true
    materialId?: true
    categoryId?: true
    moveId?: true
    quantity?: true
    unitCost?: true
    igvRate?: true
    base?: true
    igv?: true
    total?: true
    reminderIntervalDays?: true
  }

  export type ExpenseSumAggregateInputType = {
    id?: true
    obraId?: true
    frenteId?: true
    proveedorId?: true
    materialId?: true
    categoryId?: true
    moveId?: true
    quantity?: true
    unitCost?: true
    igvRate?: true
    base?: true
    igv?: true
    total?: true
    reminderIntervalDays?: true
  }

  export type ExpenseMinAggregateInputType = {
    id?: true
    obraId?: true
    frenteId?: true
    proveedorId?: true
    materialId?: true
    categoryId?: true
    moveId?: true
    docType?: true
    docSerie?: true
    docNumero?: true
    date?: true
    description?: true
    spentBy?: true
    type?: true
    variableType?: true
    quantity?: true
    unitCost?: true
    igvRate?: true
    isTaxable?: true
    base?: true
    igv?: true
    total?: true
    paymentMethod?: true
    paidAt?: true
    status?: true
    reminderIntervalDays?: true
    reminderNextDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpenseMaxAggregateInputType = {
    id?: true
    obraId?: true
    frenteId?: true
    proveedorId?: true
    materialId?: true
    categoryId?: true
    moveId?: true
    docType?: true
    docSerie?: true
    docNumero?: true
    date?: true
    description?: true
    spentBy?: true
    type?: true
    variableType?: true
    quantity?: true
    unitCost?: true
    igvRate?: true
    isTaxable?: true
    base?: true
    igv?: true
    total?: true
    paymentMethod?: true
    paidAt?: true
    status?: true
    reminderIntervalDays?: true
    reminderNextDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpenseCountAggregateInputType = {
    id?: true
    obraId?: true
    frenteId?: true
    proveedorId?: true
    materialId?: true
    categoryId?: true
    moveId?: true
    docType?: true
    docSerie?: true
    docNumero?: true
    date?: true
    description?: true
    spentBy?: true
    type?: true
    variableType?: true
    quantity?: true
    unitCost?: true
    igvRate?: true
    isTaxable?: true
    base?: true
    igv?: true
    total?: true
    paymentMethod?: true
    paidAt?: true
    status?: true
    reminderIntervalDays?: true
    reminderNextDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExpenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expense to aggregate.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Expenses
    **/
    _count?: true | ExpenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseMaxAggregateInputType
  }

  export type GetExpenseAggregateType<T extends ExpenseAggregateArgs> = {
        [P in keyof T & keyof AggregateExpense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpense[P]>
      : GetScalarType<T[P], AggregateExpense[P]>
  }




  export type ExpenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithAggregationInput | ExpenseOrderByWithAggregationInput[]
    by: ExpenseScalarFieldEnum[] | ExpenseScalarFieldEnum
    having?: ExpenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseCountAggregateInputType | true
    _avg?: ExpenseAvgAggregateInputType
    _sum?: ExpenseSumAggregateInputType
    _min?: ExpenseMinAggregateInputType
    _max?: ExpenseMaxAggregateInputType
  }

  export type ExpenseGroupByOutputType = {
    id: number
    obraId: number
    frenteId: number | null
    proveedorId: number | null
    materialId: number | null
    categoryId: number | null
    moveId: number | null
    docType: $Enums.DocType
    docSerie: string | null
    docNumero: string | null
    date: Date
    description: string | null
    spentBy: string | null
    type: $Enums.ExpenseType
    variableType: $Enums.VariableType
    quantity: Decimal | null
    unitCost: Decimal | null
    igvRate: Decimal
    isTaxable: boolean
    base: Decimal
    igv: Decimal
    total: Decimal
    paymentMethod: $Enums.PaymentMethod
    paidAt: Date | null
    status: string
    reminderIntervalDays: number | null
    reminderNextDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  type GetExpenseGroupByPayload<T extends ExpenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    obraId?: boolean
    frenteId?: boolean
    proveedorId?: boolean
    materialId?: boolean
    categoryId?: boolean
    moveId?: boolean
    docType?: boolean
    docSerie?: boolean
    docNumero?: boolean
    date?: boolean
    description?: boolean
    spentBy?: boolean
    type?: boolean
    variableType?: boolean
    quantity?: boolean
    unitCost?: boolean
    igvRate?: boolean
    isTaxable?: boolean
    base?: boolean
    igv?: boolean
    total?: boolean
    paymentMethod?: boolean
    paidAt?: boolean
    status?: boolean
    reminderIntervalDays?: boolean
    reminderNextDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    obra?: boolean | ObraDefaultArgs<ExtArgs>
    frente?: boolean | Expense$frenteArgs<ExtArgs>
    proveedor?: boolean | Expense$proveedorArgs<ExtArgs>
    material?: boolean | Expense$materialArgs<ExtArgs>
    category?: boolean | Expense$categoryArgs<ExtArgs>
    move?: boolean | Expense$moveArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    obraId?: boolean
    frenteId?: boolean
    proveedorId?: boolean
    materialId?: boolean
    categoryId?: boolean
    moveId?: boolean
    docType?: boolean
    docSerie?: boolean
    docNumero?: boolean
    date?: boolean
    description?: boolean
    spentBy?: boolean
    type?: boolean
    variableType?: boolean
    quantity?: boolean
    unitCost?: boolean
    igvRate?: boolean
    isTaxable?: boolean
    base?: boolean
    igv?: boolean
    total?: boolean
    paymentMethod?: boolean
    paidAt?: boolean
    status?: boolean
    reminderIntervalDays?: boolean
    reminderNextDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    obra?: boolean | ObraDefaultArgs<ExtArgs>
    frente?: boolean | Expense$frenteArgs<ExtArgs>
    proveedor?: boolean | Expense$proveedorArgs<ExtArgs>
    material?: boolean | Expense$materialArgs<ExtArgs>
    category?: boolean | Expense$categoryArgs<ExtArgs>
    move?: boolean | Expense$moveArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    obraId?: boolean
    frenteId?: boolean
    proveedorId?: boolean
    materialId?: boolean
    categoryId?: boolean
    moveId?: boolean
    docType?: boolean
    docSerie?: boolean
    docNumero?: boolean
    date?: boolean
    description?: boolean
    spentBy?: boolean
    type?: boolean
    variableType?: boolean
    quantity?: boolean
    unitCost?: boolean
    igvRate?: boolean
    isTaxable?: boolean
    base?: boolean
    igv?: boolean
    total?: boolean
    paymentMethod?: boolean
    paidAt?: boolean
    status?: boolean
    reminderIntervalDays?: boolean
    reminderNextDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    obra?: boolean | ObraDefaultArgs<ExtArgs>
    frente?: boolean | Expense$frenteArgs<ExtArgs>
    proveedor?: boolean | Expense$proveedorArgs<ExtArgs>
    material?: boolean | Expense$materialArgs<ExtArgs>
    category?: boolean | Expense$categoryArgs<ExtArgs>
    move?: boolean | Expense$moveArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectScalar = {
    id?: boolean
    obraId?: boolean
    frenteId?: boolean
    proveedorId?: boolean
    materialId?: boolean
    categoryId?: boolean
    moveId?: boolean
    docType?: boolean
    docSerie?: boolean
    docNumero?: boolean
    date?: boolean
    description?: boolean
    spentBy?: boolean
    type?: boolean
    variableType?: boolean
    quantity?: boolean
    unitCost?: boolean
    igvRate?: boolean
    isTaxable?: boolean
    base?: boolean
    igv?: boolean
    total?: boolean
    paymentMethod?: boolean
    paidAt?: boolean
    status?: boolean
    reminderIntervalDays?: boolean
    reminderNextDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExpenseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "obraId" | "frenteId" | "proveedorId" | "materialId" | "categoryId" | "moveId" | "docType" | "docSerie" | "docNumero" | "date" | "description" | "spentBy" | "type" | "variableType" | "quantity" | "unitCost" | "igvRate" | "isTaxable" | "base" | "igv" | "total" | "paymentMethod" | "paidAt" | "status" | "reminderIntervalDays" | "reminderNextDate" | "createdAt" | "updatedAt", ExtArgs["result"]["expense"]>
  export type ExpenseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    obra?: boolean | ObraDefaultArgs<ExtArgs>
    frente?: boolean | Expense$frenteArgs<ExtArgs>
    proveedor?: boolean | Expense$proveedorArgs<ExtArgs>
    material?: boolean | Expense$materialArgs<ExtArgs>
    category?: boolean | Expense$categoryArgs<ExtArgs>
    move?: boolean | Expense$moveArgs<ExtArgs>
  }
  export type ExpenseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    obra?: boolean | ObraDefaultArgs<ExtArgs>
    frente?: boolean | Expense$frenteArgs<ExtArgs>
    proveedor?: boolean | Expense$proveedorArgs<ExtArgs>
    material?: boolean | Expense$materialArgs<ExtArgs>
    category?: boolean | Expense$categoryArgs<ExtArgs>
    move?: boolean | Expense$moveArgs<ExtArgs>
  }
  export type ExpenseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    obra?: boolean | ObraDefaultArgs<ExtArgs>
    frente?: boolean | Expense$frenteArgs<ExtArgs>
    proveedor?: boolean | Expense$proveedorArgs<ExtArgs>
    material?: boolean | Expense$materialArgs<ExtArgs>
    category?: boolean | Expense$categoryArgs<ExtArgs>
    move?: boolean | Expense$moveArgs<ExtArgs>
  }

  export type $ExpensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Expense"
    objects: {
      obra: Prisma.$ObraPayload<ExtArgs>
      frente: Prisma.$FrentePayload<ExtArgs> | null
      proveedor: Prisma.$ProveedorPayload<ExtArgs> | null
      material: Prisma.$MaterialPayload<ExtArgs> | null
      category: Prisma.$ExpenseCategoryPayload<ExtArgs> | null
      move: Prisma.$MovePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      obraId: number
      frenteId: number | null
      proveedorId: number | null
      materialId: number | null
      categoryId: number | null
      moveId: number | null
      docType: $Enums.DocType
      docSerie: string | null
      docNumero: string | null
      date: Date
      description: string | null
      spentBy: string | null
      type: $Enums.ExpenseType
      variableType: $Enums.VariableType
      quantity: Prisma.Decimal | null
      unitCost: Prisma.Decimal | null
      igvRate: Prisma.Decimal
      isTaxable: boolean
      base: Prisma.Decimal
      igv: Prisma.Decimal
      total: Prisma.Decimal
      paymentMethod: $Enums.PaymentMethod
      paidAt: Date | null
      status: string
      reminderIntervalDays: number | null
      reminderNextDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["expense"]>
    composites: {}
  }

  type ExpenseGetPayload<S extends boolean | null | undefined | ExpenseDefaultArgs> = $Result.GetResult<Prisma.$ExpensePayload, S>

  type ExpenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExpenseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExpenseCountAggregateInputType | true
    }

  export interface ExpenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Expense'], meta: { name: 'Expense' } }
    /**
     * Find zero or one Expense that matches the filter.
     * @param {ExpenseFindUniqueArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseFindUniqueArgs>(args: SelectSubset<T, ExpenseFindUniqueArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Expense that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExpenseFindUniqueOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseFindFirstArgs>(args?: SelectSubset<T, ExpenseFindFirstArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Expenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Expenses
     * const expenses = await prisma.expense.findMany()
     * 
     * // Get first 10 Expenses
     * const expenses = await prisma.expense.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseWithIdOnly = await prisma.expense.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseFindManyArgs>(args?: SelectSubset<T, ExpenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Expense.
     * @param {ExpenseCreateArgs} args - Arguments to create a Expense.
     * @example
     * // Create one Expense
     * const Expense = await prisma.expense.create({
     *   data: {
     *     // ... data to create a Expense
     *   }
     * })
     * 
     */
    create<T extends ExpenseCreateArgs>(args: SelectSubset<T, ExpenseCreateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Expenses.
     * @param {ExpenseCreateManyArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseCreateManyArgs>(args?: SelectSubset<T, ExpenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Expenses and returns the data saved in the database.
     * @param {ExpenseCreateManyAndReturnArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Expenses and only return the `id`
     * const expenseWithIdOnly = await prisma.expense.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpenseCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpenseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Expense.
     * @param {ExpenseDeleteArgs} args - Arguments to delete one Expense.
     * @example
     * // Delete one Expense
     * const Expense = await prisma.expense.delete({
     *   where: {
     *     // ... filter to delete one Expense
     *   }
     * })
     * 
     */
    delete<T extends ExpenseDeleteArgs>(args: SelectSubset<T, ExpenseDeleteArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Expense.
     * @param {ExpenseUpdateArgs} args - Arguments to update one Expense.
     * @example
     * // Update one Expense
     * const expense = await prisma.expense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseUpdateArgs>(args: SelectSubset<T, ExpenseUpdateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Expenses.
     * @param {ExpenseDeleteManyArgs} args - Arguments to filter Expenses to delete.
     * @example
     * // Delete a few Expenses
     * const { count } = await prisma.expense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseDeleteManyArgs>(args?: SelectSubset<T, ExpenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseUpdateManyArgs>(args: SelectSubset<T, ExpenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses and returns the data updated in the database.
     * @param {ExpenseUpdateManyAndReturnArgs} args - Arguments to update many Expenses.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Expenses and only return the `id`
     * const expenseWithIdOnly = await prisma.expense.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExpenseUpdateManyAndReturnArgs>(args: SelectSubset<T, ExpenseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Expense.
     * @param {ExpenseUpsertArgs} args - Arguments to update or create a Expense.
     * @example
     * // Update or create a Expense
     * const expense = await prisma.expense.upsert({
     *   create: {
     *     // ... data to create a Expense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Expense we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseUpsertArgs>(args: SelectSubset<T, ExpenseUpsertArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCountArgs} args - Arguments to filter Expenses to count.
     * @example
     * // Count the number of Expenses
     * const count = await prisma.expense.count({
     *   where: {
     *     // ... the filter for the Expenses we want to count
     *   }
     * })
    **/
    count<T extends ExpenseCountArgs>(
      args?: Subset<T, ExpenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseAggregateArgs>(args: Subset<T, ExpenseAggregateArgs>): Prisma.PrismaPromise<GetExpenseAggregateType<T>>

    /**
     * Group by Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Expense model
   */
  readonly fields: ExpenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Expense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    obra<T extends ObraDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ObraDefaultArgs<ExtArgs>>): Prisma__ObraClient<$Result.GetResult<Prisma.$ObraPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    frente<T extends Expense$frenteArgs<ExtArgs> = {}>(args?: Subset<T, Expense$frenteArgs<ExtArgs>>): Prisma__FrenteClient<$Result.GetResult<Prisma.$FrentePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    proveedor<T extends Expense$proveedorArgs<ExtArgs> = {}>(args?: Subset<T, Expense$proveedorArgs<ExtArgs>>): Prisma__ProveedorClient<$Result.GetResult<Prisma.$ProveedorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    material<T extends Expense$materialArgs<ExtArgs> = {}>(args?: Subset<T, Expense$materialArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    category<T extends Expense$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Expense$categoryArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    move<T extends Expense$moveArgs<ExtArgs> = {}>(args?: Subset<T, Expense$moveArgs<ExtArgs>>): Prisma__MoveClient<$Result.GetResult<Prisma.$MovePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Expense model
   */
  interface ExpenseFieldRefs {
    readonly id: FieldRef<"Expense", 'Int'>
    readonly obraId: FieldRef<"Expense", 'Int'>
    readonly frenteId: FieldRef<"Expense", 'Int'>
    readonly proveedorId: FieldRef<"Expense", 'Int'>
    readonly materialId: FieldRef<"Expense", 'Int'>
    readonly categoryId: FieldRef<"Expense", 'Int'>
    readonly moveId: FieldRef<"Expense", 'Int'>
    readonly docType: FieldRef<"Expense", 'DocType'>
    readonly docSerie: FieldRef<"Expense", 'String'>
    readonly docNumero: FieldRef<"Expense", 'String'>
    readonly date: FieldRef<"Expense", 'DateTime'>
    readonly description: FieldRef<"Expense", 'String'>
    readonly spentBy: FieldRef<"Expense", 'String'>
    readonly type: FieldRef<"Expense", 'ExpenseType'>
    readonly variableType: FieldRef<"Expense", 'VariableType'>
    readonly quantity: FieldRef<"Expense", 'Decimal'>
    readonly unitCost: FieldRef<"Expense", 'Decimal'>
    readonly igvRate: FieldRef<"Expense", 'Decimal'>
    readonly isTaxable: FieldRef<"Expense", 'Boolean'>
    readonly base: FieldRef<"Expense", 'Decimal'>
    readonly igv: FieldRef<"Expense", 'Decimal'>
    readonly total: FieldRef<"Expense", 'Decimal'>
    readonly paymentMethod: FieldRef<"Expense", 'PaymentMethod'>
    readonly paidAt: FieldRef<"Expense", 'DateTime'>
    readonly status: FieldRef<"Expense", 'String'>
    readonly reminderIntervalDays: FieldRef<"Expense", 'Int'>
    readonly reminderNextDate: FieldRef<"Expense", 'DateTime'>
    readonly createdAt: FieldRef<"Expense", 'DateTime'>
    readonly updatedAt: FieldRef<"Expense", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Expense findUnique
   */
  export type ExpenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findUniqueOrThrow
   */
  export type ExpenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findFirst
   */
  export type ExpenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findFirstOrThrow
   */
  export type ExpenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findMany
   */
  export type ExpenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expenses to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense create
   */
  export type ExpenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to create a Expense.
     */
    data: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
  }

  /**
   * Expense createMany
   */
  export type ExpenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
  }

  /**
   * Expense createManyAndReturn
   */
  export type ExpenseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Expense update
   */
  export type ExpenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to update a Expense.
     */
    data: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
    /**
     * Choose, which Expense to update.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense updateMany
   */
  export type ExpenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to update.
     */
    limit?: number
  }

  /**
   * Expense updateManyAndReturn
   */
  export type ExpenseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Expense upsert
   */
  export type ExpenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The filter to search for the Expense to update in case it exists.
     */
    where: ExpenseWhereUniqueInput
    /**
     * In case the Expense found by the `where` argument doesn't exist, create a new Expense with this data.
     */
    create: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
    /**
     * In case the Expense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
  }

  /**
   * Expense delete
   */
  export type ExpenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter which Expense to delete.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense deleteMany
   */
  export type ExpenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expenses to delete
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to delete.
     */
    limit?: number
  }

  /**
   * Expense.frente
   */
  export type Expense$frenteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Frente
     */
    select?: FrenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Frente
     */
    omit?: FrenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FrenteInclude<ExtArgs> | null
    where?: FrenteWhereInput
  }

  /**
   * Expense.proveedor
   */
  export type Expense$proveedorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proveedor
     */
    select?: ProveedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proveedor
     */
    omit?: ProveedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProveedorInclude<ExtArgs> | null
    where?: ProveedorWhereInput
  }

  /**
   * Expense.material
   */
  export type Expense$materialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    where?: MaterialWhereInput
  }

  /**
   * Expense.category
   */
  export type Expense$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    where?: ExpenseCategoryWhereInput
  }

  /**
   * Expense.move
   */
  export type Expense$moveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Move
     */
    select?: MoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Move
     */
    omit?: MoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveInclude<ExtArgs> | null
    where?: MoveWhereInput
  }

  /**
   * Expense without action
   */
  export type ExpenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
  }


  /**
   * Model DailyCashRendition
   */

  export type AggregateDailyCashRendition = {
    _count: DailyCashRenditionCountAggregateOutputType | null
    _avg: DailyCashRenditionAvgAggregateOutputType | null
    _sum: DailyCashRenditionSumAggregateOutputType | null
    _min: DailyCashRenditionMinAggregateOutputType | null
    _max: DailyCashRenditionMaxAggregateOutputType | null
  }

  export type DailyCashRenditionAvgAggregateOutputType = {
    id: number | null
    obraId: number | null
    openingBalance: Decimal | null
    received: Decimal | null
    spent: Decimal | null
    personalContribution: Decimal | null
    balance: Decimal | null
  }

  export type DailyCashRenditionSumAggregateOutputType = {
    id: number | null
    obraId: number | null
    openingBalance: Decimal | null
    received: Decimal | null
    spent: Decimal | null
    personalContribution: Decimal | null
    balance: Decimal | null
  }

  export type DailyCashRenditionMinAggregateOutputType = {
    id: number | null
    date: Date | null
    obraId: number | null
    openingBalance: Decimal | null
    received: Decimal | null
    spent: Decimal | null
    personalContribution: Decimal | null
    balance: Decimal | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DailyCashRenditionMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    obraId: number | null
    openingBalance: Decimal | null
    received: Decimal | null
    spent: Decimal | null
    personalContribution: Decimal | null
    balance: Decimal | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DailyCashRenditionCountAggregateOutputType = {
    id: number
    date: number
    obraId: number
    openingBalance: number
    received: number
    spent: number
    personalContribution: number
    balance: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DailyCashRenditionAvgAggregateInputType = {
    id?: true
    obraId?: true
    openingBalance?: true
    received?: true
    spent?: true
    personalContribution?: true
    balance?: true
  }

  export type DailyCashRenditionSumAggregateInputType = {
    id?: true
    obraId?: true
    openingBalance?: true
    received?: true
    spent?: true
    personalContribution?: true
    balance?: true
  }

  export type DailyCashRenditionMinAggregateInputType = {
    id?: true
    date?: true
    obraId?: true
    openingBalance?: true
    received?: true
    spent?: true
    personalContribution?: true
    balance?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DailyCashRenditionMaxAggregateInputType = {
    id?: true
    date?: true
    obraId?: true
    openingBalance?: true
    received?: true
    spent?: true
    personalContribution?: true
    balance?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DailyCashRenditionCountAggregateInputType = {
    id?: true
    date?: true
    obraId?: true
    openingBalance?: true
    received?: true
    spent?: true
    personalContribution?: true
    balance?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DailyCashRenditionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyCashRendition to aggregate.
     */
    where?: DailyCashRenditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyCashRenditions to fetch.
     */
    orderBy?: DailyCashRenditionOrderByWithRelationInput | DailyCashRenditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyCashRenditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyCashRenditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyCashRenditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyCashRenditions
    **/
    _count?: true | DailyCashRenditionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyCashRenditionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyCashRenditionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyCashRenditionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyCashRenditionMaxAggregateInputType
  }

  export type GetDailyCashRenditionAggregateType<T extends DailyCashRenditionAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyCashRendition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyCashRendition[P]>
      : GetScalarType<T[P], AggregateDailyCashRendition[P]>
  }




  export type DailyCashRenditionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyCashRenditionWhereInput
    orderBy?: DailyCashRenditionOrderByWithAggregationInput | DailyCashRenditionOrderByWithAggregationInput[]
    by: DailyCashRenditionScalarFieldEnum[] | DailyCashRenditionScalarFieldEnum
    having?: DailyCashRenditionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyCashRenditionCountAggregateInputType | true
    _avg?: DailyCashRenditionAvgAggregateInputType
    _sum?: DailyCashRenditionSumAggregateInputType
    _min?: DailyCashRenditionMinAggregateInputType
    _max?: DailyCashRenditionMaxAggregateInputType
  }

  export type DailyCashRenditionGroupByOutputType = {
    id: number
    date: Date
    obraId: number | null
    openingBalance: Decimal
    received: Decimal
    spent: Decimal
    personalContribution: Decimal
    balance: Decimal
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: DailyCashRenditionCountAggregateOutputType | null
    _avg: DailyCashRenditionAvgAggregateOutputType | null
    _sum: DailyCashRenditionSumAggregateOutputType | null
    _min: DailyCashRenditionMinAggregateOutputType | null
    _max: DailyCashRenditionMaxAggregateOutputType | null
  }

  type GetDailyCashRenditionGroupByPayload<T extends DailyCashRenditionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DailyCashRenditionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyCashRenditionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyCashRenditionGroupByOutputType[P]>
            : GetScalarType<T[P], DailyCashRenditionGroupByOutputType[P]>
        }
      >
    >


  export type DailyCashRenditionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    obraId?: boolean
    openingBalance?: boolean
    received?: boolean
    spent?: boolean
    personalContribution?: boolean
    balance?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    obra?: boolean | DailyCashRendition$obraArgs<ExtArgs>
    expenses?: boolean | DailyCashRendition$expensesArgs<ExtArgs>
    _count?: boolean | DailyCashRenditionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyCashRendition"]>

  export type DailyCashRenditionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    obraId?: boolean
    openingBalance?: boolean
    received?: boolean
    spent?: boolean
    personalContribution?: boolean
    balance?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    obra?: boolean | DailyCashRendition$obraArgs<ExtArgs>
  }, ExtArgs["result"]["dailyCashRendition"]>

  export type DailyCashRenditionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    obraId?: boolean
    openingBalance?: boolean
    received?: boolean
    spent?: boolean
    personalContribution?: boolean
    balance?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    obra?: boolean | DailyCashRendition$obraArgs<ExtArgs>
  }, ExtArgs["result"]["dailyCashRendition"]>

  export type DailyCashRenditionSelectScalar = {
    id?: boolean
    date?: boolean
    obraId?: boolean
    openingBalance?: boolean
    received?: boolean
    spent?: boolean
    personalContribution?: boolean
    balance?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DailyCashRenditionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "obraId" | "openingBalance" | "received" | "spent" | "personalContribution" | "balance" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["dailyCashRendition"]>
  export type DailyCashRenditionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    obra?: boolean | DailyCashRendition$obraArgs<ExtArgs>
    expenses?: boolean | DailyCashRendition$expensesArgs<ExtArgs>
    _count?: boolean | DailyCashRenditionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DailyCashRenditionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    obra?: boolean | DailyCashRendition$obraArgs<ExtArgs>
  }
  export type DailyCashRenditionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    obra?: boolean | DailyCashRendition$obraArgs<ExtArgs>
  }

  export type $DailyCashRenditionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DailyCashRendition"
    objects: {
      obra: Prisma.$ObraPayload<ExtArgs> | null
      expenses: Prisma.$DailyCashExpensePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      date: Date
      obraId: number | null
      openingBalance: Prisma.Decimal
      received: Prisma.Decimal
      spent: Prisma.Decimal
      personalContribution: Prisma.Decimal
      balance: Prisma.Decimal
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dailyCashRendition"]>
    composites: {}
  }

  type DailyCashRenditionGetPayload<S extends boolean | null | undefined | DailyCashRenditionDefaultArgs> = $Result.GetResult<Prisma.$DailyCashRenditionPayload, S>

  type DailyCashRenditionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DailyCashRenditionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DailyCashRenditionCountAggregateInputType | true
    }

  export interface DailyCashRenditionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyCashRendition'], meta: { name: 'DailyCashRendition' } }
    /**
     * Find zero or one DailyCashRendition that matches the filter.
     * @param {DailyCashRenditionFindUniqueArgs} args - Arguments to find a DailyCashRendition
     * @example
     * // Get one DailyCashRendition
     * const dailyCashRendition = await prisma.dailyCashRendition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DailyCashRenditionFindUniqueArgs>(args: SelectSubset<T, DailyCashRenditionFindUniqueArgs<ExtArgs>>): Prisma__DailyCashRenditionClient<$Result.GetResult<Prisma.$DailyCashRenditionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DailyCashRendition that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DailyCashRenditionFindUniqueOrThrowArgs} args - Arguments to find a DailyCashRendition
     * @example
     * // Get one DailyCashRendition
     * const dailyCashRendition = await prisma.dailyCashRendition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DailyCashRenditionFindUniqueOrThrowArgs>(args: SelectSubset<T, DailyCashRenditionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DailyCashRenditionClient<$Result.GetResult<Prisma.$DailyCashRenditionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DailyCashRendition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyCashRenditionFindFirstArgs} args - Arguments to find a DailyCashRendition
     * @example
     * // Get one DailyCashRendition
     * const dailyCashRendition = await prisma.dailyCashRendition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DailyCashRenditionFindFirstArgs>(args?: SelectSubset<T, DailyCashRenditionFindFirstArgs<ExtArgs>>): Prisma__DailyCashRenditionClient<$Result.GetResult<Prisma.$DailyCashRenditionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DailyCashRendition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyCashRenditionFindFirstOrThrowArgs} args - Arguments to find a DailyCashRendition
     * @example
     * // Get one DailyCashRendition
     * const dailyCashRendition = await prisma.dailyCashRendition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DailyCashRenditionFindFirstOrThrowArgs>(args?: SelectSubset<T, DailyCashRenditionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DailyCashRenditionClient<$Result.GetResult<Prisma.$DailyCashRenditionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DailyCashRenditions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyCashRenditionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyCashRenditions
     * const dailyCashRenditions = await prisma.dailyCashRendition.findMany()
     * 
     * // Get first 10 DailyCashRenditions
     * const dailyCashRenditions = await prisma.dailyCashRendition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dailyCashRenditionWithIdOnly = await prisma.dailyCashRendition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DailyCashRenditionFindManyArgs>(args?: SelectSubset<T, DailyCashRenditionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyCashRenditionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DailyCashRendition.
     * @param {DailyCashRenditionCreateArgs} args - Arguments to create a DailyCashRendition.
     * @example
     * // Create one DailyCashRendition
     * const DailyCashRendition = await prisma.dailyCashRendition.create({
     *   data: {
     *     // ... data to create a DailyCashRendition
     *   }
     * })
     * 
     */
    create<T extends DailyCashRenditionCreateArgs>(args: SelectSubset<T, DailyCashRenditionCreateArgs<ExtArgs>>): Prisma__DailyCashRenditionClient<$Result.GetResult<Prisma.$DailyCashRenditionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DailyCashRenditions.
     * @param {DailyCashRenditionCreateManyArgs} args - Arguments to create many DailyCashRenditions.
     * @example
     * // Create many DailyCashRenditions
     * const dailyCashRendition = await prisma.dailyCashRendition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DailyCashRenditionCreateManyArgs>(args?: SelectSubset<T, DailyCashRenditionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DailyCashRenditions and returns the data saved in the database.
     * @param {DailyCashRenditionCreateManyAndReturnArgs} args - Arguments to create many DailyCashRenditions.
     * @example
     * // Create many DailyCashRenditions
     * const dailyCashRendition = await prisma.dailyCashRendition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DailyCashRenditions and only return the `id`
     * const dailyCashRenditionWithIdOnly = await prisma.dailyCashRendition.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DailyCashRenditionCreateManyAndReturnArgs>(args?: SelectSubset<T, DailyCashRenditionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyCashRenditionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DailyCashRendition.
     * @param {DailyCashRenditionDeleteArgs} args - Arguments to delete one DailyCashRendition.
     * @example
     * // Delete one DailyCashRendition
     * const DailyCashRendition = await prisma.dailyCashRendition.delete({
     *   where: {
     *     // ... filter to delete one DailyCashRendition
     *   }
     * })
     * 
     */
    delete<T extends DailyCashRenditionDeleteArgs>(args: SelectSubset<T, DailyCashRenditionDeleteArgs<ExtArgs>>): Prisma__DailyCashRenditionClient<$Result.GetResult<Prisma.$DailyCashRenditionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DailyCashRendition.
     * @param {DailyCashRenditionUpdateArgs} args - Arguments to update one DailyCashRendition.
     * @example
     * // Update one DailyCashRendition
     * const dailyCashRendition = await prisma.dailyCashRendition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DailyCashRenditionUpdateArgs>(args: SelectSubset<T, DailyCashRenditionUpdateArgs<ExtArgs>>): Prisma__DailyCashRenditionClient<$Result.GetResult<Prisma.$DailyCashRenditionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DailyCashRenditions.
     * @param {DailyCashRenditionDeleteManyArgs} args - Arguments to filter DailyCashRenditions to delete.
     * @example
     * // Delete a few DailyCashRenditions
     * const { count } = await prisma.dailyCashRendition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DailyCashRenditionDeleteManyArgs>(args?: SelectSubset<T, DailyCashRenditionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyCashRenditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyCashRenditionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyCashRenditions
     * const dailyCashRendition = await prisma.dailyCashRendition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DailyCashRenditionUpdateManyArgs>(args: SelectSubset<T, DailyCashRenditionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyCashRenditions and returns the data updated in the database.
     * @param {DailyCashRenditionUpdateManyAndReturnArgs} args - Arguments to update many DailyCashRenditions.
     * @example
     * // Update many DailyCashRenditions
     * const dailyCashRendition = await prisma.dailyCashRendition.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DailyCashRenditions and only return the `id`
     * const dailyCashRenditionWithIdOnly = await prisma.dailyCashRendition.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DailyCashRenditionUpdateManyAndReturnArgs>(args: SelectSubset<T, DailyCashRenditionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyCashRenditionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DailyCashRendition.
     * @param {DailyCashRenditionUpsertArgs} args - Arguments to update or create a DailyCashRendition.
     * @example
     * // Update or create a DailyCashRendition
     * const dailyCashRendition = await prisma.dailyCashRendition.upsert({
     *   create: {
     *     // ... data to create a DailyCashRendition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyCashRendition we want to update
     *   }
     * })
     */
    upsert<T extends DailyCashRenditionUpsertArgs>(args: SelectSubset<T, DailyCashRenditionUpsertArgs<ExtArgs>>): Prisma__DailyCashRenditionClient<$Result.GetResult<Prisma.$DailyCashRenditionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DailyCashRenditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyCashRenditionCountArgs} args - Arguments to filter DailyCashRenditions to count.
     * @example
     * // Count the number of DailyCashRenditions
     * const count = await prisma.dailyCashRendition.count({
     *   where: {
     *     // ... the filter for the DailyCashRenditions we want to count
     *   }
     * })
    **/
    count<T extends DailyCashRenditionCountArgs>(
      args?: Subset<T, DailyCashRenditionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyCashRenditionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyCashRendition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyCashRenditionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyCashRenditionAggregateArgs>(args: Subset<T, DailyCashRenditionAggregateArgs>): Prisma.PrismaPromise<GetDailyCashRenditionAggregateType<T>>

    /**
     * Group by DailyCashRendition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyCashRenditionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyCashRenditionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyCashRenditionGroupByArgs['orderBy'] }
        : { orderBy?: DailyCashRenditionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyCashRenditionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyCashRenditionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DailyCashRendition model
   */
  readonly fields: DailyCashRenditionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyCashRendition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DailyCashRenditionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    obra<T extends DailyCashRendition$obraArgs<ExtArgs> = {}>(args?: Subset<T, DailyCashRendition$obraArgs<ExtArgs>>): Prisma__ObraClient<$Result.GetResult<Prisma.$ObraPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    expenses<T extends DailyCashRendition$expensesArgs<ExtArgs> = {}>(args?: Subset<T, DailyCashRendition$expensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyCashExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DailyCashRendition model
   */
  interface DailyCashRenditionFieldRefs {
    readonly id: FieldRef<"DailyCashRendition", 'Int'>
    readonly date: FieldRef<"DailyCashRendition", 'DateTime'>
    readonly obraId: FieldRef<"DailyCashRendition", 'Int'>
    readonly openingBalance: FieldRef<"DailyCashRendition", 'Decimal'>
    readonly received: FieldRef<"DailyCashRendition", 'Decimal'>
    readonly spent: FieldRef<"DailyCashRendition", 'Decimal'>
    readonly personalContribution: FieldRef<"DailyCashRendition", 'Decimal'>
    readonly balance: FieldRef<"DailyCashRendition", 'Decimal'>
    readonly notes: FieldRef<"DailyCashRendition", 'String'>
    readonly createdAt: FieldRef<"DailyCashRendition", 'DateTime'>
    readonly updatedAt: FieldRef<"DailyCashRendition", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DailyCashRendition findUnique
   */
  export type DailyCashRenditionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyCashRendition
     */
    select?: DailyCashRenditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyCashRendition
     */
    omit?: DailyCashRenditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyCashRenditionInclude<ExtArgs> | null
    /**
     * Filter, which DailyCashRendition to fetch.
     */
    where: DailyCashRenditionWhereUniqueInput
  }

  /**
   * DailyCashRendition findUniqueOrThrow
   */
  export type DailyCashRenditionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyCashRendition
     */
    select?: DailyCashRenditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyCashRendition
     */
    omit?: DailyCashRenditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyCashRenditionInclude<ExtArgs> | null
    /**
     * Filter, which DailyCashRendition to fetch.
     */
    where: DailyCashRenditionWhereUniqueInput
  }

  /**
   * DailyCashRendition findFirst
   */
  export type DailyCashRenditionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyCashRendition
     */
    select?: DailyCashRenditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyCashRendition
     */
    omit?: DailyCashRenditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyCashRenditionInclude<ExtArgs> | null
    /**
     * Filter, which DailyCashRendition to fetch.
     */
    where?: DailyCashRenditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyCashRenditions to fetch.
     */
    orderBy?: DailyCashRenditionOrderByWithRelationInput | DailyCashRenditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyCashRenditions.
     */
    cursor?: DailyCashRenditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyCashRenditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyCashRenditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyCashRenditions.
     */
    distinct?: DailyCashRenditionScalarFieldEnum | DailyCashRenditionScalarFieldEnum[]
  }

  /**
   * DailyCashRendition findFirstOrThrow
   */
  export type DailyCashRenditionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyCashRendition
     */
    select?: DailyCashRenditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyCashRendition
     */
    omit?: DailyCashRenditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyCashRenditionInclude<ExtArgs> | null
    /**
     * Filter, which DailyCashRendition to fetch.
     */
    where?: DailyCashRenditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyCashRenditions to fetch.
     */
    orderBy?: DailyCashRenditionOrderByWithRelationInput | DailyCashRenditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyCashRenditions.
     */
    cursor?: DailyCashRenditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyCashRenditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyCashRenditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyCashRenditions.
     */
    distinct?: DailyCashRenditionScalarFieldEnum | DailyCashRenditionScalarFieldEnum[]
  }

  /**
   * DailyCashRendition findMany
   */
  export type DailyCashRenditionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyCashRendition
     */
    select?: DailyCashRenditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyCashRendition
     */
    omit?: DailyCashRenditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyCashRenditionInclude<ExtArgs> | null
    /**
     * Filter, which DailyCashRenditions to fetch.
     */
    where?: DailyCashRenditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyCashRenditions to fetch.
     */
    orderBy?: DailyCashRenditionOrderByWithRelationInput | DailyCashRenditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyCashRenditions.
     */
    cursor?: DailyCashRenditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyCashRenditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyCashRenditions.
     */
    skip?: number
    distinct?: DailyCashRenditionScalarFieldEnum | DailyCashRenditionScalarFieldEnum[]
  }

  /**
   * DailyCashRendition create
   */
  export type DailyCashRenditionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyCashRendition
     */
    select?: DailyCashRenditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyCashRendition
     */
    omit?: DailyCashRenditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyCashRenditionInclude<ExtArgs> | null
    /**
     * The data needed to create a DailyCashRendition.
     */
    data: XOR<DailyCashRenditionCreateInput, DailyCashRenditionUncheckedCreateInput>
  }

  /**
   * DailyCashRendition createMany
   */
  export type DailyCashRenditionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyCashRenditions.
     */
    data: DailyCashRenditionCreateManyInput | DailyCashRenditionCreateManyInput[]
  }

  /**
   * DailyCashRendition createManyAndReturn
   */
  export type DailyCashRenditionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyCashRendition
     */
    select?: DailyCashRenditionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyCashRendition
     */
    omit?: DailyCashRenditionOmit<ExtArgs> | null
    /**
     * The data used to create many DailyCashRenditions.
     */
    data: DailyCashRenditionCreateManyInput | DailyCashRenditionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyCashRenditionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyCashRendition update
   */
  export type DailyCashRenditionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyCashRendition
     */
    select?: DailyCashRenditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyCashRendition
     */
    omit?: DailyCashRenditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyCashRenditionInclude<ExtArgs> | null
    /**
     * The data needed to update a DailyCashRendition.
     */
    data: XOR<DailyCashRenditionUpdateInput, DailyCashRenditionUncheckedUpdateInput>
    /**
     * Choose, which DailyCashRendition to update.
     */
    where: DailyCashRenditionWhereUniqueInput
  }

  /**
   * DailyCashRendition updateMany
   */
  export type DailyCashRenditionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyCashRenditions.
     */
    data: XOR<DailyCashRenditionUpdateManyMutationInput, DailyCashRenditionUncheckedUpdateManyInput>
    /**
     * Filter which DailyCashRenditions to update
     */
    where?: DailyCashRenditionWhereInput
    /**
     * Limit how many DailyCashRenditions to update.
     */
    limit?: number
  }

  /**
   * DailyCashRendition updateManyAndReturn
   */
  export type DailyCashRenditionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyCashRendition
     */
    select?: DailyCashRenditionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyCashRendition
     */
    omit?: DailyCashRenditionOmit<ExtArgs> | null
    /**
     * The data used to update DailyCashRenditions.
     */
    data: XOR<DailyCashRenditionUpdateManyMutationInput, DailyCashRenditionUncheckedUpdateManyInput>
    /**
     * Filter which DailyCashRenditions to update
     */
    where?: DailyCashRenditionWhereInput
    /**
     * Limit how many DailyCashRenditions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyCashRenditionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyCashRendition upsert
   */
  export type DailyCashRenditionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyCashRendition
     */
    select?: DailyCashRenditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyCashRendition
     */
    omit?: DailyCashRenditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyCashRenditionInclude<ExtArgs> | null
    /**
     * The filter to search for the DailyCashRendition to update in case it exists.
     */
    where: DailyCashRenditionWhereUniqueInput
    /**
     * In case the DailyCashRendition found by the `where` argument doesn't exist, create a new DailyCashRendition with this data.
     */
    create: XOR<DailyCashRenditionCreateInput, DailyCashRenditionUncheckedCreateInput>
    /**
     * In case the DailyCashRendition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyCashRenditionUpdateInput, DailyCashRenditionUncheckedUpdateInput>
  }

  /**
   * DailyCashRendition delete
   */
  export type DailyCashRenditionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyCashRendition
     */
    select?: DailyCashRenditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyCashRendition
     */
    omit?: DailyCashRenditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyCashRenditionInclude<ExtArgs> | null
    /**
     * Filter which DailyCashRendition to delete.
     */
    where: DailyCashRenditionWhereUniqueInput
  }

  /**
   * DailyCashRendition deleteMany
   */
  export type DailyCashRenditionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyCashRenditions to delete
     */
    where?: DailyCashRenditionWhereInput
    /**
     * Limit how many DailyCashRenditions to delete.
     */
    limit?: number
  }

  /**
   * DailyCashRendition.obra
   */
  export type DailyCashRendition$obraArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obra
     */
    select?: ObraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Obra
     */
    omit?: ObraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObraInclude<ExtArgs> | null
    where?: ObraWhereInput
  }

  /**
   * DailyCashRendition.expenses
   */
  export type DailyCashRendition$expensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyCashExpense
     */
    select?: DailyCashExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyCashExpense
     */
    omit?: DailyCashExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyCashExpenseInclude<ExtArgs> | null
    where?: DailyCashExpenseWhereInput
    orderBy?: DailyCashExpenseOrderByWithRelationInput | DailyCashExpenseOrderByWithRelationInput[]
    cursor?: DailyCashExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyCashExpenseScalarFieldEnum | DailyCashExpenseScalarFieldEnum[]
  }

  /**
   * DailyCashRendition without action
   */
  export type DailyCashRenditionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyCashRendition
     */
    select?: DailyCashRenditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyCashRendition
     */
    omit?: DailyCashRenditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyCashRenditionInclude<ExtArgs> | null
  }


  /**
   * Model DailyCashExpense
   */

  export type AggregateDailyCashExpense = {
    _count: DailyCashExpenseCountAggregateOutputType | null
    _avg: DailyCashExpenseAvgAggregateOutputType | null
    _sum: DailyCashExpenseSumAggregateOutputType | null
    _min: DailyCashExpenseMinAggregateOutputType | null
    _max: DailyCashExpenseMaxAggregateOutputType | null
  }

  export type DailyCashExpenseAvgAggregateOutputType = {
    id: number | null
    renditionId: number | null
    amount: Decimal | null
    personalAmount: Decimal | null
  }

  export type DailyCashExpenseSumAggregateOutputType = {
    id: number | null
    renditionId: number | null
    amount: Decimal | null
    personalAmount: Decimal | null
  }

  export type DailyCashExpenseMinAggregateOutputType = {
    id: number | null
    renditionId: number | null
    description: string | null
    amount: Decimal | null
    personalAmount: Decimal | null
    paidWithPersonal: boolean | null
    createdAt: Date | null
  }

  export type DailyCashExpenseMaxAggregateOutputType = {
    id: number | null
    renditionId: number | null
    description: string | null
    amount: Decimal | null
    personalAmount: Decimal | null
    paidWithPersonal: boolean | null
    createdAt: Date | null
  }

  export type DailyCashExpenseCountAggregateOutputType = {
    id: number
    renditionId: number
    description: number
    amount: number
    personalAmount: number
    paidWithPersonal: number
    createdAt: number
    _all: number
  }


  export type DailyCashExpenseAvgAggregateInputType = {
    id?: true
    renditionId?: true
    amount?: true
    personalAmount?: true
  }

  export type DailyCashExpenseSumAggregateInputType = {
    id?: true
    renditionId?: true
    amount?: true
    personalAmount?: true
  }

  export type DailyCashExpenseMinAggregateInputType = {
    id?: true
    renditionId?: true
    description?: true
    amount?: true
    personalAmount?: true
    paidWithPersonal?: true
    createdAt?: true
  }

  export type DailyCashExpenseMaxAggregateInputType = {
    id?: true
    renditionId?: true
    description?: true
    amount?: true
    personalAmount?: true
    paidWithPersonal?: true
    createdAt?: true
  }

  export type DailyCashExpenseCountAggregateInputType = {
    id?: true
    renditionId?: true
    description?: true
    amount?: true
    personalAmount?: true
    paidWithPersonal?: true
    createdAt?: true
    _all?: true
  }

  export type DailyCashExpenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyCashExpense to aggregate.
     */
    where?: DailyCashExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyCashExpenses to fetch.
     */
    orderBy?: DailyCashExpenseOrderByWithRelationInput | DailyCashExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyCashExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyCashExpenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyCashExpenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyCashExpenses
    **/
    _count?: true | DailyCashExpenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyCashExpenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyCashExpenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyCashExpenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyCashExpenseMaxAggregateInputType
  }

  export type GetDailyCashExpenseAggregateType<T extends DailyCashExpenseAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyCashExpense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyCashExpense[P]>
      : GetScalarType<T[P], AggregateDailyCashExpense[P]>
  }




  export type DailyCashExpenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyCashExpenseWhereInput
    orderBy?: DailyCashExpenseOrderByWithAggregationInput | DailyCashExpenseOrderByWithAggregationInput[]
    by: DailyCashExpenseScalarFieldEnum[] | DailyCashExpenseScalarFieldEnum
    having?: DailyCashExpenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyCashExpenseCountAggregateInputType | true
    _avg?: DailyCashExpenseAvgAggregateInputType
    _sum?: DailyCashExpenseSumAggregateInputType
    _min?: DailyCashExpenseMinAggregateInputType
    _max?: DailyCashExpenseMaxAggregateInputType
  }

  export type DailyCashExpenseGroupByOutputType = {
    id: number
    renditionId: number
    description: string
    amount: Decimal
    personalAmount: Decimal
    paidWithPersonal: boolean
    createdAt: Date
    _count: DailyCashExpenseCountAggregateOutputType | null
    _avg: DailyCashExpenseAvgAggregateOutputType | null
    _sum: DailyCashExpenseSumAggregateOutputType | null
    _min: DailyCashExpenseMinAggregateOutputType | null
    _max: DailyCashExpenseMaxAggregateOutputType | null
  }

  type GetDailyCashExpenseGroupByPayload<T extends DailyCashExpenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DailyCashExpenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyCashExpenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyCashExpenseGroupByOutputType[P]>
            : GetScalarType<T[P], DailyCashExpenseGroupByOutputType[P]>
        }
      >
    >


  export type DailyCashExpenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    renditionId?: boolean
    description?: boolean
    amount?: boolean
    personalAmount?: boolean
    paidWithPersonal?: boolean
    createdAt?: boolean
    rendition?: boolean | DailyCashRenditionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyCashExpense"]>

  export type DailyCashExpenseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    renditionId?: boolean
    description?: boolean
    amount?: boolean
    personalAmount?: boolean
    paidWithPersonal?: boolean
    createdAt?: boolean
    rendition?: boolean | DailyCashRenditionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyCashExpense"]>

  export type DailyCashExpenseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    renditionId?: boolean
    description?: boolean
    amount?: boolean
    personalAmount?: boolean
    paidWithPersonal?: boolean
    createdAt?: boolean
    rendition?: boolean | DailyCashRenditionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyCashExpense"]>

  export type DailyCashExpenseSelectScalar = {
    id?: boolean
    renditionId?: boolean
    description?: boolean
    amount?: boolean
    personalAmount?: boolean
    paidWithPersonal?: boolean
    createdAt?: boolean
  }

  export type DailyCashExpenseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "renditionId" | "description" | "amount" | "personalAmount" | "paidWithPersonal" | "createdAt", ExtArgs["result"]["dailyCashExpense"]>
  export type DailyCashExpenseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rendition?: boolean | DailyCashRenditionDefaultArgs<ExtArgs>
  }
  export type DailyCashExpenseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rendition?: boolean | DailyCashRenditionDefaultArgs<ExtArgs>
  }
  export type DailyCashExpenseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rendition?: boolean | DailyCashRenditionDefaultArgs<ExtArgs>
  }

  export type $DailyCashExpensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DailyCashExpense"
    objects: {
      rendition: Prisma.$DailyCashRenditionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      renditionId: number
      description: string
      amount: Prisma.Decimal
      personalAmount: Prisma.Decimal
      paidWithPersonal: boolean
      createdAt: Date
    }, ExtArgs["result"]["dailyCashExpense"]>
    composites: {}
  }

  type DailyCashExpenseGetPayload<S extends boolean | null | undefined | DailyCashExpenseDefaultArgs> = $Result.GetResult<Prisma.$DailyCashExpensePayload, S>

  type DailyCashExpenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DailyCashExpenseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DailyCashExpenseCountAggregateInputType | true
    }

  export interface DailyCashExpenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyCashExpense'], meta: { name: 'DailyCashExpense' } }
    /**
     * Find zero or one DailyCashExpense that matches the filter.
     * @param {DailyCashExpenseFindUniqueArgs} args - Arguments to find a DailyCashExpense
     * @example
     * // Get one DailyCashExpense
     * const dailyCashExpense = await prisma.dailyCashExpense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DailyCashExpenseFindUniqueArgs>(args: SelectSubset<T, DailyCashExpenseFindUniqueArgs<ExtArgs>>): Prisma__DailyCashExpenseClient<$Result.GetResult<Prisma.$DailyCashExpensePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DailyCashExpense that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DailyCashExpenseFindUniqueOrThrowArgs} args - Arguments to find a DailyCashExpense
     * @example
     * // Get one DailyCashExpense
     * const dailyCashExpense = await prisma.dailyCashExpense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DailyCashExpenseFindUniqueOrThrowArgs>(args: SelectSubset<T, DailyCashExpenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DailyCashExpenseClient<$Result.GetResult<Prisma.$DailyCashExpensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DailyCashExpense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyCashExpenseFindFirstArgs} args - Arguments to find a DailyCashExpense
     * @example
     * // Get one DailyCashExpense
     * const dailyCashExpense = await prisma.dailyCashExpense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DailyCashExpenseFindFirstArgs>(args?: SelectSubset<T, DailyCashExpenseFindFirstArgs<ExtArgs>>): Prisma__DailyCashExpenseClient<$Result.GetResult<Prisma.$DailyCashExpensePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DailyCashExpense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyCashExpenseFindFirstOrThrowArgs} args - Arguments to find a DailyCashExpense
     * @example
     * // Get one DailyCashExpense
     * const dailyCashExpense = await prisma.dailyCashExpense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DailyCashExpenseFindFirstOrThrowArgs>(args?: SelectSubset<T, DailyCashExpenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__DailyCashExpenseClient<$Result.GetResult<Prisma.$DailyCashExpensePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DailyCashExpenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyCashExpenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyCashExpenses
     * const dailyCashExpenses = await prisma.dailyCashExpense.findMany()
     * 
     * // Get first 10 DailyCashExpenses
     * const dailyCashExpenses = await prisma.dailyCashExpense.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dailyCashExpenseWithIdOnly = await prisma.dailyCashExpense.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DailyCashExpenseFindManyArgs>(args?: SelectSubset<T, DailyCashExpenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyCashExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DailyCashExpense.
     * @param {DailyCashExpenseCreateArgs} args - Arguments to create a DailyCashExpense.
     * @example
     * // Create one DailyCashExpense
     * const DailyCashExpense = await prisma.dailyCashExpense.create({
     *   data: {
     *     // ... data to create a DailyCashExpense
     *   }
     * })
     * 
     */
    create<T extends DailyCashExpenseCreateArgs>(args: SelectSubset<T, DailyCashExpenseCreateArgs<ExtArgs>>): Prisma__DailyCashExpenseClient<$Result.GetResult<Prisma.$DailyCashExpensePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DailyCashExpenses.
     * @param {DailyCashExpenseCreateManyArgs} args - Arguments to create many DailyCashExpenses.
     * @example
     * // Create many DailyCashExpenses
     * const dailyCashExpense = await prisma.dailyCashExpense.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DailyCashExpenseCreateManyArgs>(args?: SelectSubset<T, DailyCashExpenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DailyCashExpenses and returns the data saved in the database.
     * @param {DailyCashExpenseCreateManyAndReturnArgs} args - Arguments to create many DailyCashExpenses.
     * @example
     * // Create many DailyCashExpenses
     * const dailyCashExpense = await prisma.dailyCashExpense.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DailyCashExpenses and only return the `id`
     * const dailyCashExpenseWithIdOnly = await prisma.dailyCashExpense.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DailyCashExpenseCreateManyAndReturnArgs>(args?: SelectSubset<T, DailyCashExpenseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyCashExpensePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DailyCashExpense.
     * @param {DailyCashExpenseDeleteArgs} args - Arguments to delete one DailyCashExpense.
     * @example
     * // Delete one DailyCashExpense
     * const DailyCashExpense = await prisma.dailyCashExpense.delete({
     *   where: {
     *     // ... filter to delete one DailyCashExpense
     *   }
     * })
     * 
     */
    delete<T extends DailyCashExpenseDeleteArgs>(args: SelectSubset<T, DailyCashExpenseDeleteArgs<ExtArgs>>): Prisma__DailyCashExpenseClient<$Result.GetResult<Prisma.$DailyCashExpensePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DailyCashExpense.
     * @param {DailyCashExpenseUpdateArgs} args - Arguments to update one DailyCashExpense.
     * @example
     * // Update one DailyCashExpense
     * const dailyCashExpense = await prisma.dailyCashExpense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DailyCashExpenseUpdateArgs>(args: SelectSubset<T, DailyCashExpenseUpdateArgs<ExtArgs>>): Prisma__DailyCashExpenseClient<$Result.GetResult<Prisma.$DailyCashExpensePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DailyCashExpenses.
     * @param {DailyCashExpenseDeleteManyArgs} args - Arguments to filter DailyCashExpenses to delete.
     * @example
     * // Delete a few DailyCashExpenses
     * const { count } = await prisma.dailyCashExpense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DailyCashExpenseDeleteManyArgs>(args?: SelectSubset<T, DailyCashExpenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyCashExpenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyCashExpenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyCashExpenses
     * const dailyCashExpense = await prisma.dailyCashExpense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DailyCashExpenseUpdateManyArgs>(args: SelectSubset<T, DailyCashExpenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyCashExpenses and returns the data updated in the database.
     * @param {DailyCashExpenseUpdateManyAndReturnArgs} args - Arguments to update many DailyCashExpenses.
     * @example
     * // Update many DailyCashExpenses
     * const dailyCashExpense = await prisma.dailyCashExpense.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DailyCashExpenses and only return the `id`
     * const dailyCashExpenseWithIdOnly = await prisma.dailyCashExpense.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DailyCashExpenseUpdateManyAndReturnArgs>(args: SelectSubset<T, DailyCashExpenseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyCashExpensePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DailyCashExpense.
     * @param {DailyCashExpenseUpsertArgs} args - Arguments to update or create a DailyCashExpense.
     * @example
     * // Update or create a DailyCashExpense
     * const dailyCashExpense = await prisma.dailyCashExpense.upsert({
     *   create: {
     *     // ... data to create a DailyCashExpense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyCashExpense we want to update
     *   }
     * })
     */
    upsert<T extends DailyCashExpenseUpsertArgs>(args: SelectSubset<T, DailyCashExpenseUpsertArgs<ExtArgs>>): Prisma__DailyCashExpenseClient<$Result.GetResult<Prisma.$DailyCashExpensePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DailyCashExpenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyCashExpenseCountArgs} args - Arguments to filter DailyCashExpenses to count.
     * @example
     * // Count the number of DailyCashExpenses
     * const count = await prisma.dailyCashExpense.count({
     *   where: {
     *     // ... the filter for the DailyCashExpenses we want to count
     *   }
     * })
    **/
    count<T extends DailyCashExpenseCountArgs>(
      args?: Subset<T, DailyCashExpenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyCashExpenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyCashExpense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyCashExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyCashExpenseAggregateArgs>(args: Subset<T, DailyCashExpenseAggregateArgs>): Prisma.PrismaPromise<GetDailyCashExpenseAggregateType<T>>

    /**
     * Group by DailyCashExpense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyCashExpenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyCashExpenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyCashExpenseGroupByArgs['orderBy'] }
        : { orderBy?: DailyCashExpenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyCashExpenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyCashExpenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DailyCashExpense model
   */
  readonly fields: DailyCashExpenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyCashExpense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DailyCashExpenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rendition<T extends DailyCashRenditionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DailyCashRenditionDefaultArgs<ExtArgs>>): Prisma__DailyCashRenditionClient<$Result.GetResult<Prisma.$DailyCashRenditionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DailyCashExpense model
   */
  interface DailyCashExpenseFieldRefs {
    readonly id: FieldRef<"DailyCashExpense", 'Int'>
    readonly renditionId: FieldRef<"DailyCashExpense", 'Int'>
    readonly description: FieldRef<"DailyCashExpense", 'String'>
    readonly amount: FieldRef<"DailyCashExpense", 'Decimal'>
    readonly personalAmount: FieldRef<"DailyCashExpense", 'Decimal'>
    readonly paidWithPersonal: FieldRef<"DailyCashExpense", 'Boolean'>
    readonly createdAt: FieldRef<"DailyCashExpense", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DailyCashExpense findUnique
   */
  export type DailyCashExpenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyCashExpense
     */
    select?: DailyCashExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyCashExpense
     */
    omit?: DailyCashExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyCashExpenseInclude<ExtArgs> | null
    /**
     * Filter, which DailyCashExpense to fetch.
     */
    where: DailyCashExpenseWhereUniqueInput
  }

  /**
   * DailyCashExpense findUniqueOrThrow
   */
  export type DailyCashExpenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyCashExpense
     */
    select?: DailyCashExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyCashExpense
     */
    omit?: DailyCashExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyCashExpenseInclude<ExtArgs> | null
    /**
     * Filter, which DailyCashExpense to fetch.
     */
    where: DailyCashExpenseWhereUniqueInput
  }

  /**
   * DailyCashExpense findFirst
   */
  export type DailyCashExpenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyCashExpense
     */
    select?: DailyCashExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyCashExpense
     */
    omit?: DailyCashExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyCashExpenseInclude<ExtArgs> | null
    /**
     * Filter, which DailyCashExpense to fetch.
     */
    where?: DailyCashExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyCashExpenses to fetch.
     */
    orderBy?: DailyCashExpenseOrderByWithRelationInput | DailyCashExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyCashExpenses.
     */
    cursor?: DailyCashExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyCashExpenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyCashExpenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyCashExpenses.
     */
    distinct?: DailyCashExpenseScalarFieldEnum | DailyCashExpenseScalarFieldEnum[]
  }

  /**
   * DailyCashExpense findFirstOrThrow
   */
  export type DailyCashExpenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyCashExpense
     */
    select?: DailyCashExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyCashExpense
     */
    omit?: DailyCashExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyCashExpenseInclude<ExtArgs> | null
    /**
     * Filter, which DailyCashExpense to fetch.
     */
    where?: DailyCashExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyCashExpenses to fetch.
     */
    orderBy?: DailyCashExpenseOrderByWithRelationInput | DailyCashExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyCashExpenses.
     */
    cursor?: DailyCashExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyCashExpenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyCashExpenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyCashExpenses.
     */
    distinct?: DailyCashExpenseScalarFieldEnum | DailyCashExpenseScalarFieldEnum[]
  }

  /**
   * DailyCashExpense findMany
   */
  export type DailyCashExpenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyCashExpense
     */
    select?: DailyCashExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyCashExpense
     */
    omit?: DailyCashExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyCashExpenseInclude<ExtArgs> | null
    /**
     * Filter, which DailyCashExpenses to fetch.
     */
    where?: DailyCashExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyCashExpenses to fetch.
     */
    orderBy?: DailyCashExpenseOrderByWithRelationInput | DailyCashExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyCashExpenses.
     */
    cursor?: DailyCashExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyCashExpenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyCashExpenses.
     */
    skip?: number
    distinct?: DailyCashExpenseScalarFieldEnum | DailyCashExpenseScalarFieldEnum[]
  }

  /**
   * DailyCashExpense create
   */
  export type DailyCashExpenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyCashExpense
     */
    select?: DailyCashExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyCashExpense
     */
    omit?: DailyCashExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyCashExpenseInclude<ExtArgs> | null
    /**
     * The data needed to create a DailyCashExpense.
     */
    data: XOR<DailyCashExpenseCreateInput, DailyCashExpenseUncheckedCreateInput>
  }

  /**
   * DailyCashExpense createMany
   */
  export type DailyCashExpenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyCashExpenses.
     */
    data: DailyCashExpenseCreateManyInput | DailyCashExpenseCreateManyInput[]
  }

  /**
   * DailyCashExpense createManyAndReturn
   */
  export type DailyCashExpenseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyCashExpense
     */
    select?: DailyCashExpenseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyCashExpense
     */
    omit?: DailyCashExpenseOmit<ExtArgs> | null
    /**
     * The data used to create many DailyCashExpenses.
     */
    data: DailyCashExpenseCreateManyInput | DailyCashExpenseCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyCashExpenseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyCashExpense update
   */
  export type DailyCashExpenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyCashExpense
     */
    select?: DailyCashExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyCashExpense
     */
    omit?: DailyCashExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyCashExpenseInclude<ExtArgs> | null
    /**
     * The data needed to update a DailyCashExpense.
     */
    data: XOR<DailyCashExpenseUpdateInput, DailyCashExpenseUncheckedUpdateInput>
    /**
     * Choose, which DailyCashExpense to update.
     */
    where: DailyCashExpenseWhereUniqueInput
  }

  /**
   * DailyCashExpense updateMany
   */
  export type DailyCashExpenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyCashExpenses.
     */
    data: XOR<DailyCashExpenseUpdateManyMutationInput, DailyCashExpenseUncheckedUpdateManyInput>
    /**
     * Filter which DailyCashExpenses to update
     */
    where?: DailyCashExpenseWhereInput
    /**
     * Limit how many DailyCashExpenses to update.
     */
    limit?: number
  }

  /**
   * DailyCashExpense updateManyAndReturn
   */
  export type DailyCashExpenseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyCashExpense
     */
    select?: DailyCashExpenseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyCashExpense
     */
    omit?: DailyCashExpenseOmit<ExtArgs> | null
    /**
     * The data used to update DailyCashExpenses.
     */
    data: XOR<DailyCashExpenseUpdateManyMutationInput, DailyCashExpenseUncheckedUpdateManyInput>
    /**
     * Filter which DailyCashExpenses to update
     */
    where?: DailyCashExpenseWhereInput
    /**
     * Limit how many DailyCashExpenses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyCashExpenseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyCashExpense upsert
   */
  export type DailyCashExpenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyCashExpense
     */
    select?: DailyCashExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyCashExpense
     */
    omit?: DailyCashExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyCashExpenseInclude<ExtArgs> | null
    /**
     * The filter to search for the DailyCashExpense to update in case it exists.
     */
    where: DailyCashExpenseWhereUniqueInput
    /**
     * In case the DailyCashExpense found by the `where` argument doesn't exist, create a new DailyCashExpense with this data.
     */
    create: XOR<DailyCashExpenseCreateInput, DailyCashExpenseUncheckedCreateInput>
    /**
     * In case the DailyCashExpense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyCashExpenseUpdateInput, DailyCashExpenseUncheckedUpdateInput>
  }

  /**
   * DailyCashExpense delete
   */
  export type DailyCashExpenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyCashExpense
     */
    select?: DailyCashExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyCashExpense
     */
    omit?: DailyCashExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyCashExpenseInclude<ExtArgs> | null
    /**
     * Filter which DailyCashExpense to delete.
     */
    where: DailyCashExpenseWhereUniqueInput
  }

  /**
   * DailyCashExpense deleteMany
   */
  export type DailyCashExpenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyCashExpenses to delete
     */
    where?: DailyCashExpenseWhereInput
    /**
     * Limit how many DailyCashExpenses to delete.
     */
    limit?: number
  }

  /**
   * DailyCashExpense without action
   */
  export type DailyCashExpenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyCashExpense
     */
    select?: DailyCashExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyCashExpense
     */
    omit?: DailyCashExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyCashExpenseInclude<ExtArgs> | null
  }


  /**
   * Model AdminSetting
   */

  export type AggregateAdminSetting = {
    _count: AdminSettingCountAggregateOutputType | null
    _avg: AdminSettingAvgAggregateOutputType | null
    _sum: AdminSettingSumAggregateOutputType | null
    _min: AdminSettingMinAggregateOutputType | null
    _max: AdminSettingMaxAggregateOutputType | null
  }

  export type AdminSettingAvgAggregateOutputType = {
    id: number | null
  }

  export type AdminSettingSumAggregateOutputType = {
    id: number | null
  }

  export type AdminSettingMinAggregateOutputType = {
    id: number | null
    deletePasswordHash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminSettingMaxAggregateOutputType = {
    id: number | null
    deletePasswordHash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminSettingCountAggregateOutputType = {
    id: number
    deletePasswordHash: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminSettingAvgAggregateInputType = {
    id?: true
  }

  export type AdminSettingSumAggregateInputType = {
    id?: true
  }

  export type AdminSettingMinAggregateInputType = {
    id?: true
    deletePasswordHash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminSettingMaxAggregateInputType = {
    id?: true
    deletePasswordHash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminSettingCountAggregateInputType = {
    id?: true
    deletePasswordHash?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminSetting to aggregate.
     */
    where?: AdminSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminSettings to fetch.
     */
    orderBy?: AdminSettingOrderByWithRelationInput | AdminSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminSettings
    **/
    _count?: true | AdminSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminSettingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSettingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminSettingMaxAggregateInputType
  }

  export type GetAdminSettingAggregateType<T extends AdminSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminSetting[P]>
      : GetScalarType<T[P], AggregateAdminSetting[P]>
  }




  export type AdminSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminSettingWhereInput
    orderBy?: AdminSettingOrderByWithAggregationInput | AdminSettingOrderByWithAggregationInput[]
    by: AdminSettingScalarFieldEnum[] | AdminSettingScalarFieldEnum
    having?: AdminSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminSettingCountAggregateInputType | true
    _avg?: AdminSettingAvgAggregateInputType
    _sum?: AdminSettingSumAggregateInputType
    _min?: AdminSettingMinAggregateInputType
    _max?: AdminSettingMaxAggregateInputType
  }

  export type AdminSettingGroupByOutputType = {
    id: number
    deletePasswordHash: string
    createdAt: Date
    updatedAt: Date
    _count: AdminSettingCountAggregateOutputType | null
    _avg: AdminSettingAvgAggregateOutputType | null
    _sum: AdminSettingSumAggregateOutputType | null
    _min: AdminSettingMinAggregateOutputType | null
    _max: AdminSettingMaxAggregateOutputType | null
  }

  type GetAdminSettingGroupByPayload<T extends AdminSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminSettingGroupByOutputType[P]>
            : GetScalarType<T[P], AdminSettingGroupByOutputType[P]>
        }
      >
    >


  export type AdminSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deletePasswordHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["adminSetting"]>

  export type AdminSettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deletePasswordHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["adminSetting"]>

  export type AdminSettingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deletePasswordHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["adminSetting"]>

  export type AdminSettingSelectScalar = {
    id?: boolean
    deletePasswordHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminSettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "deletePasswordHash" | "createdAt" | "updatedAt", ExtArgs["result"]["adminSetting"]>

  export type $AdminSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminSetting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      deletePasswordHash: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["adminSetting"]>
    composites: {}
  }

  type AdminSettingGetPayload<S extends boolean | null | undefined | AdminSettingDefaultArgs> = $Result.GetResult<Prisma.$AdminSettingPayload, S>

  type AdminSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminSettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminSettingCountAggregateInputType | true
    }

  export interface AdminSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminSetting'], meta: { name: 'AdminSetting' } }
    /**
     * Find zero or one AdminSetting that matches the filter.
     * @param {AdminSettingFindUniqueArgs} args - Arguments to find a AdminSetting
     * @example
     * // Get one AdminSetting
     * const adminSetting = await prisma.adminSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminSettingFindUniqueArgs>(args: SelectSubset<T, AdminSettingFindUniqueArgs<ExtArgs>>): Prisma__AdminSettingClient<$Result.GetResult<Prisma.$AdminSettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminSetting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminSettingFindUniqueOrThrowArgs} args - Arguments to find a AdminSetting
     * @example
     * // Get one AdminSetting
     * const adminSetting = await prisma.adminSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminSettingClient<$Result.GetResult<Prisma.$AdminSettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSettingFindFirstArgs} args - Arguments to find a AdminSetting
     * @example
     * // Get one AdminSetting
     * const adminSetting = await prisma.adminSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminSettingFindFirstArgs>(args?: SelectSubset<T, AdminSettingFindFirstArgs<ExtArgs>>): Prisma__AdminSettingClient<$Result.GetResult<Prisma.$AdminSettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSettingFindFirstOrThrowArgs} args - Arguments to find a AdminSetting
     * @example
     * // Get one AdminSetting
     * const adminSetting = await prisma.adminSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminSettingClient<$Result.GetResult<Prisma.$AdminSettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminSettings
     * const adminSettings = await prisma.adminSetting.findMany()
     * 
     * // Get first 10 AdminSettings
     * const adminSettings = await prisma.adminSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminSettingWithIdOnly = await prisma.adminSetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminSettingFindManyArgs>(args?: SelectSubset<T, AdminSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminSetting.
     * @param {AdminSettingCreateArgs} args - Arguments to create a AdminSetting.
     * @example
     * // Create one AdminSetting
     * const AdminSetting = await prisma.adminSetting.create({
     *   data: {
     *     // ... data to create a AdminSetting
     *   }
     * })
     * 
     */
    create<T extends AdminSettingCreateArgs>(args: SelectSubset<T, AdminSettingCreateArgs<ExtArgs>>): Prisma__AdminSettingClient<$Result.GetResult<Prisma.$AdminSettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminSettings.
     * @param {AdminSettingCreateManyArgs} args - Arguments to create many AdminSettings.
     * @example
     * // Create many AdminSettings
     * const adminSetting = await prisma.adminSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminSettingCreateManyArgs>(args?: SelectSubset<T, AdminSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminSettings and returns the data saved in the database.
     * @param {AdminSettingCreateManyAndReturnArgs} args - Arguments to create many AdminSettings.
     * @example
     * // Create many AdminSettings
     * const adminSetting = await prisma.adminSetting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminSettings and only return the `id`
     * const adminSettingWithIdOnly = await prisma.adminSetting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminSettingCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminSettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminSettingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminSetting.
     * @param {AdminSettingDeleteArgs} args - Arguments to delete one AdminSetting.
     * @example
     * // Delete one AdminSetting
     * const AdminSetting = await prisma.adminSetting.delete({
     *   where: {
     *     // ... filter to delete one AdminSetting
     *   }
     * })
     * 
     */
    delete<T extends AdminSettingDeleteArgs>(args: SelectSubset<T, AdminSettingDeleteArgs<ExtArgs>>): Prisma__AdminSettingClient<$Result.GetResult<Prisma.$AdminSettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminSetting.
     * @param {AdminSettingUpdateArgs} args - Arguments to update one AdminSetting.
     * @example
     * // Update one AdminSetting
     * const adminSetting = await prisma.adminSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminSettingUpdateArgs>(args: SelectSubset<T, AdminSettingUpdateArgs<ExtArgs>>): Prisma__AdminSettingClient<$Result.GetResult<Prisma.$AdminSettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminSettings.
     * @param {AdminSettingDeleteManyArgs} args - Arguments to filter AdminSettings to delete.
     * @example
     * // Delete a few AdminSettings
     * const { count } = await prisma.adminSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminSettingDeleteManyArgs>(args?: SelectSubset<T, AdminSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminSettings
     * const adminSetting = await prisma.adminSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminSettingUpdateManyArgs>(args: SelectSubset<T, AdminSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminSettings and returns the data updated in the database.
     * @param {AdminSettingUpdateManyAndReturnArgs} args - Arguments to update many AdminSettings.
     * @example
     * // Update many AdminSettings
     * const adminSetting = await prisma.adminSetting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminSettings and only return the `id`
     * const adminSettingWithIdOnly = await prisma.adminSetting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminSettingUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminSettingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminSettingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminSetting.
     * @param {AdminSettingUpsertArgs} args - Arguments to update or create a AdminSetting.
     * @example
     * // Update or create a AdminSetting
     * const adminSetting = await prisma.adminSetting.upsert({
     *   create: {
     *     // ... data to create a AdminSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminSetting we want to update
     *   }
     * })
     */
    upsert<T extends AdminSettingUpsertArgs>(args: SelectSubset<T, AdminSettingUpsertArgs<ExtArgs>>): Prisma__AdminSettingClient<$Result.GetResult<Prisma.$AdminSettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSettingCountArgs} args - Arguments to filter AdminSettings to count.
     * @example
     * // Count the number of AdminSettings
     * const count = await prisma.adminSetting.count({
     *   where: {
     *     // ... the filter for the AdminSettings we want to count
     *   }
     * })
    **/
    count<T extends AdminSettingCountArgs>(
      args?: Subset<T, AdminSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminSettingAggregateArgs>(args: Subset<T, AdminSettingAggregateArgs>): Prisma.PrismaPromise<GetAdminSettingAggregateType<T>>

    /**
     * Group by AdminSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminSettingGroupByArgs['orderBy'] }
        : { orderBy?: AdminSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminSetting model
   */
  readonly fields: AdminSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminSetting model
   */
  interface AdminSettingFieldRefs {
    readonly id: FieldRef<"AdminSetting", 'Int'>
    readonly deletePasswordHash: FieldRef<"AdminSetting", 'String'>
    readonly createdAt: FieldRef<"AdminSetting", 'DateTime'>
    readonly updatedAt: FieldRef<"AdminSetting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminSetting findUnique
   */
  export type AdminSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSetting
     */
    select?: AdminSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSetting
     */
    omit?: AdminSettingOmit<ExtArgs> | null
    /**
     * Filter, which AdminSetting to fetch.
     */
    where: AdminSettingWhereUniqueInput
  }

  /**
   * AdminSetting findUniqueOrThrow
   */
  export type AdminSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSetting
     */
    select?: AdminSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSetting
     */
    omit?: AdminSettingOmit<ExtArgs> | null
    /**
     * Filter, which AdminSetting to fetch.
     */
    where: AdminSettingWhereUniqueInput
  }

  /**
   * AdminSetting findFirst
   */
  export type AdminSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSetting
     */
    select?: AdminSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSetting
     */
    omit?: AdminSettingOmit<ExtArgs> | null
    /**
     * Filter, which AdminSetting to fetch.
     */
    where?: AdminSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminSettings to fetch.
     */
    orderBy?: AdminSettingOrderByWithRelationInput | AdminSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminSettings.
     */
    cursor?: AdminSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminSettings.
     */
    distinct?: AdminSettingScalarFieldEnum | AdminSettingScalarFieldEnum[]
  }

  /**
   * AdminSetting findFirstOrThrow
   */
  export type AdminSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSetting
     */
    select?: AdminSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSetting
     */
    omit?: AdminSettingOmit<ExtArgs> | null
    /**
     * Filter, which AdminSetting to fetch.
     */
    where?: AdminSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminSettings to fetch.
     */
    orderBy?: AdminSettingOrderByWithRelationInput | AdminSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminSettings.
     */
    cursor?: AdminSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminSettings.
     */
    distinct?: AdminSettingScalarFieldEnum | AdminSettingScalarFieldEnum[]
  }

  /**
   * AdminSetting findMany
   */
  export type AdminSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSetting
     */
    select?: AdminSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSetting
     */
    omit?: AdminSettingOmit<ExtArgs> | null
    /**
     * Filter, which AdminSettings to fetch.
     */
    where?: AdminSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminSettings to fetch.
     */
    orderBy?: AdminSettingOrderByWithRelationInput | AdminSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminSettings.
     */
    cursor?: AdminSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminSettings.
     */
    skip?: number
    distinct?: AdminSettingScalarFieldEnum | AdminSettingScalarFieldEnum[]
  }

  /**
   * AdminSetting create
   */
  export type AdminSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSetting
     */
    select?: AdminSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSetting
     */
    omit?: AdminSettingOmit<ExtArgs> | null
    /**
     * The data needed to create a AdminSetting.
     */
    data: XOR<AdminSettingCreateInput, AdminSettingUncheckedCreateInput>
  }

  /**
   * AdminSetting createMany
   */
  export type AdminSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminSettings.
     */
    data: AdminSettingCreateManyInput | AdminSettingCreateManyInput[]
  }

  /**
   * AdminSetting createManyAndReturn
   */
  export type AdminSettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSetting
     */
    select?: AdminSettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSetting
     */
    omit?: AdminSettingOmit<ExtArgs> | null
    /**
     * The data used to create many AdminSettings.
     */
    data: AdminSettingCreateManyInput | AdminSettingCreateManyInput[]
  }

  /**
   * AdminSetting update
   */
  export type AdminSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSetting
     */
    select?: AdminSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSetting
     */
    omit?: AdminSettingOmit<ExtArgs> | null
    /**
     * The data needed to update a AdminSetting.
     */
    data: XOR<AdminSettingUpdateInput, AdminSettingUncheckedUpdateInput>
    /**
     * Choose, which AdminSetting to update.
     */
    where: AdminSettingWhereUniqueInput
  }

  /**
   * AdminSetting updateMany
   */
  export type AdminSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminSettings.
     */
    data: XOR<AdminSettingUpdateManyMutationInput, AdminSettingUncheckedUpdateManyInput>
    /**
     * Filter which AdminSettings to update
     */
    where?: AdminSettingWhereInput
    /**
     * Limit how many AdminSettings to update.
     */
    limit?: number
  }

  /**
   * AdminSetting updateManyAndReturn
   */
  export type AdminSettingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSetting
     */
    select?: AdminSettingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSetting
     */
    omit?: AdminSettingOmit<ExtArgs> | null
    /**
     * The data used to update AdminSettings.
     */
    data: XOR<AdminSettingUpdateManyMutationInput, AdminSettingUncheckedUpdateManyInput>
    /**
     * Filter which AdminSettings to update
     */
    where?: AdminSettingWhereInput
    /**
     * Limit how many AdminSettings to update.
     */
    limit?: number
  }

  /**
   * AdminSetting upsert
   */
  export type AdminSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSetting
     */
    select?: AdminSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSetting
     */
    omit?: AdminSettingOmit<ExtArgs> | null
    /**
     * The filter to search for the AdminSetting to update in case it exists.
     */
    where: AdminSettingWhereUniqueInput
    /**
     * In case the AdminSetting found by the `where` argument doesn't exist, create a new AdminSetting with this data.
     */
    create: XOR<AdminSettingCreateInput, AdminSettingUncheckedCreateInput>
    /**
     * In case the AdminSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminSettingUpdateInput, AdminSettingUncheckedUpdateInput>
  }

  /**
   * AdminSetting delete
   */
  export type AdminSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSetting
     */
    select?: AdminSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSetting
     */
    omit?: AdminSettingOmit<ExtArgs> | null
    /**
     * Filter which AdminSetting to delete.
     */
    where: AdminSettingWhereUniqueInput
  }

  /**
   * AdminSetting deleteMany
   */
  export type AdminSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminSettings to delete
     */
    where?: AdminSettingWhereInput
    /**
     * Limit how many AdminSettings to delete.
     */
    limit?: number
  }

  /**
   * AdminSetting without action
   */
  export type AdminSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSetting
     */
    select?: AdminSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSetting
     */
    omit?: AdminSettingOmit<ExtArgs> | null
  }


  /**
   * Model Employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeAvgAggregateOutputType = {
    id: number | null
    baseSalary: Decimal | null
    dailyHours: Decimal | null
    pensionRate: Decimal | null
    healthRate: Decimal | null
    obraId: number | null
  }

  export type EmployeeSumAggregateOutputType = {
    id: number | null
    baseSalary: Decimal | null
    dailyHours: Decimal | null
    pensionRate: Decimal | null
    healthRate: Decimal | null
    obraId: number | null
  }

  export type EmployeeMinAggregateOutputType = {
    id: number | null
    code: string | null
    firstName: string | null
    lastName: string | null
    documentType: $Enums.DocumentType | null
    documentNumber: string | null
    position: string | null
    phone: string | null
    email: string | null
    bankType: $Enums.BankType | null
    accountNumber: string | null
    cci: string | null
    startDate: Date | null
    endDate: Date | null
    baseSalary: Decimal | null
    dailyHours: Decimal | null
    pensionSystem: $Enums.PensionSystem | null
    pensionRate: Decimal | null
    healthRate: Decimal | null
    isActive: boolean | null
    area: $Enums.EmployeeArea | null
    obraId: number | null
    notes: string | null
    absenceSundayPenalty: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeMaxAggregateOutputType = {
    id: number | null
    code: string | null
    firstName: string | null
    lastName: string | null
    documentType: $Enums.DocumentType | null
    documentNumber: string | null
    position: string | null
    phone: string | null
    email: string | null
    bankType: $Enums.BankType | null
    accountNumber: string | null
    cci: string | null
    startDate: Date | null
    endDate: Date | null
    baseSalary: Decimal | null
    dailyHours: Decimal | null
    pensionSystem: $Enums.PensionSystem | null
    pensionRate: Decimal | null
    healthRate: Decimal | null
    isActive: boolean | null
    area: $Enums.EmployeeArea | null
    obraId: number | null
    notes: string | null
    absenceSundayPenalty: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeCountAggregateOutputType = {
    id: number
    code: number
    firstName: number
    lastName: number
    documentType: number
    documentNumber: number
    position: number
    phone: number
    email: number
    bankType: number
    accountNumber: number
    cci: number
    startDate: number
    endDate: number
    baseSalary: number
    dailyHours: number
    pensionSystem: number
    pensionRate: number
    healthRate: number
    isActive: number
    area: number
    obraId: number
    notes: number
    absenceSundayPenalty: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmployeeAvgAggregateInputType = {
    id?: true
    baseSalary?: true
    dailyHours?: true
    pensionRate?: true
    healthRate?: true
    obraId?: true
  }

  export type EmployeeSumAggregateInputType = {
    id?: true
    baseSalary?: true
    dailyHours?: true
    pensionRate?: true
    healthRate?: true
    obraId?: true
  }

  export type EmployeeMinAggregateInputType = {
    id?: true
    code?: true
    firstName?: true
    lastName?: true
    documentType?: true
    documentNumber?: true
    position?: true
    phone?: true
    email?: true
    bankType?: true
    accountNumber?: true
    cci?: true
    startDate?: true
    endDate?: true
    baseSalary?: true
    dailyHours?: true
    pensionSystem?: true
    pensionRate?: true
    healthRate?: true
    isActive?: true
    area?: true
    obraId?: true
    notes?: true
    absenceSundayPenalty?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeMaxAggregateInputType = {
    id?: true
    code?: true
    firstName?: true
    lastName?: true
    documentType?: true
    documentNumber?: true
    position?: true
    phone?: true
    email?: true
    bankType?: true
    accountNumber?: true
    cci?: true
    startDate?: true
    endDate?: true
    baseSalary?: true
    dailyHours?: true
    pensionSystem?: true
    pensionRate?: true
    healthRate?: true
    isActive?: true
    area?: true
    obraId?: true
    notes?: true
    absenceSundayPenalty?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeCountAggregateInputType = {
    id?: true
    code?: true
    firstName?: true
    lastName?: true
    documentType?: true
    documentNumber?: true
    position?: true
    phone?: true
    email?: true
    bankType?: true
    accountNumber?: true
    cci?: true
    startDate?: true
    endDate?: true
    baseSalary?: true
    dailyHours?: true
    pensionSystem?: true
    pensionRate?: true
    healthRate?: true
    isActive?: true
    area?: true
    obraId?: true
    notes?: true
    absenceSundayPenalty?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employee to aggregate.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithAggregationInput | EmployeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _avg?: EmployeeAvgAggregateInputType
    _sum?: EmployeeSumAggregateInputType
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    id: number
    code: string | null
    firstName: string
    lastName: string
    documentType: $Enums.DocumentType | null
    documentNumber: string | null
    position: string | null
    phone: string | null
    email: string | null
    bankType: $Enums.BankType
    accountNumber: string | null
    cci: string | null
    startDate: Date | null
    endDate: Date | null
    baseSalary: Decimal
    dailyHours: Decimal
    pensionSystem: $Enums.PensionSystem
    pensionRate: Decimal
    healthRate: Decimal
    isActive: boolean
    area: $Enums.EmployeeArea
    obraId: number | null
    notes: string | null
    absenceSundayPenalty: boolean
    createdAt: Date
    updatedAt: Date
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    firstName?: boolean
    lastName?: boolean
    documentType?: boolean
    documentNumber?: boolean
    position?: boolean
    phone?: boolean
    email?: boolean
    bankType?: boolean
    accountNumber?: boolean
    cci?: boolean
    startDate?: boolean
    endDate?: boolean
    baseSalary?: boolean
    dailyHours?: boolean
    pensionSystem?: boolean
    pensionRate?: boolean
    healthRate?: boolean
    isActive?: boolean
    area?: boolean
    obraId?: boolean
    notes?: boolean
    absenceSundayPenalty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    obra?: boolean | Employee$obraArgs<ExtArgs>
    attendances?: boolean | Employee$attendancesArgs<ExtArgs>
    payrollEntries?: boolean | Employee$payrollEntriesArgs<ExtArgs>
    accumulationPayment?: boolean | Employee$accumulationPaymentArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    firstName?: boolean
    lastName?: boolean
    documentType?: boolean
    documentNumber?: boolean
    position?: boolean
    phone?: boolean
    email?: boolean
    bankType?: boolean
    accountNumber?: boolean
    cci?: boolean
    startDate?: boolean
    endDate?: boolean
    baseSalary?: boolean
    dailyHours?: boolean
    pensionSystem?: boolean
    pensionRate?: boolean
    healthRate?: boolean
    isActive?: boolean
    area?: boolean
    obraId?: boolean
    notes?: boolean
    absenceSundayPenalty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    obra?: boolean | Employee$obraArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    firstName?: boolean
    lastName?: boolean
    documentType?: boolean
    documentNumber?: boolean
    position?: boolean
    phone?: boolean
    email?: boolean
    bankType?: boolean
    accountNumber?: boolean
    cci?: boolean
    startDate?: boolean
    endDate?: boolean
    baseSalary?: boolean
    dailyHours?: boolean
    pensionSystem?: boolean
    pensionRate?: boolean
    healthRate?: boolean
    isActive?: boolean
    area?: boolean
    obraId?: boolean
    notes?: boolean
    absenceSundayPenalty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    obra?: boolean | Employee$obraArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectScalar = {
    id?: boolean
    code?: boolean
    firstName?: boolean
    lastName?: boolean
    documentType?: boolean
    documentNumber?: boolean
    position?: boolean
    phone?: boolean
    email?: boolean
    bankType?: boolean
    accountNumber?: boolean
    cci?: boolean
    startDate?: boolean
    endDate?: boolean
    baseSalary?: boolean
    dailyHours?: boolean
    pensionSystem?: boolean
    pensionRate?: boolean
    healthRate?: boolean
    isActive?: boolean
    area?: boolean
    obraId?: boolean
    notes?: boolean
    absenceSundayPenalty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmployeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "firstName" | "lastName" | "documentType" | "documentNumber" | "position" | "phone" | "email" | "bankType" | "accountNumber" | "cci" | "startDate" | "endDate" | "baseSalary" | "dailyHours" | "pensionSystem" | "pensionRate" | "healthRate" | "isActive" | "area" | "obraId" | "notes" | "absenceSundayPenalty" | "createdAt" | "updatedAt", ExtArgs["result"]["employee"]>
  export type EmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    obra?: boolean | Employee$obraArgs<ExtArgs>
    attendances?: boolean | Employee$attendancesArgs<ExtArgs>
    payrollEntries?: boolean | Employee$payrollEntriesArgs<ExtArgs>
    accumulationPayment?: boolean | Employee$accumulationPaymentArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    obra?: boolean | Employee$obraArgs<ExtArgs>
  }
  export type EmployeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    obra?: boolean | Employee$obraArgs<ExtArgs>
  }

  export type $EmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employee"
    objects: {
      obra: Prisma.$ObraPayload<ExtArgs> | null
      attendances: Prisma.$AttendanceRecordPayload<ExtArgs>[]
      payrollEntries: Prisma.$PayrollEntryPayload<ExtArgs>[]
      accumulationPayment: Prisma.$EmployeeAccumulationPaymentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string | null
      firstName: string
      lastName: string
      documentType: $Enums.DocumentType | null
      documentNumber: string | null
      position: string | null
      phone: string | null
      email: string | null
      bankType: $Enums.BankType
      accountNumber: string | null
      cci: string | null
      startDate: Date | null
      endDate: Date | null
      baseSalary: Prisma.Decimal
      dailyHours: Prisma.Decimal
      pensionSystem: $Enums.PensionSystem
      pensionRate: Prisma.Decimal
      healthRate: Prisma.Decimal
      isActive: boolean
      area: $Enums.EmployeeArea
      obraId: number | null
      notes: string | null
      absenceSundayPenalty: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type EmployeeGetPayload<S extends boolean | null | undefined | EmployeeDefaultArgs> = $Result.GetResult<Prisma.$EmployeePayload, S>

  type EmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface EmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employee'], meta: { name: 'Employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeFindUniqueArgs>(args: SelectSubset<T, EmployeeFindUniqueArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeFindFirstArgs>(args?: SelectSubset<T, EmployeeFindFirstArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeWithIdOnly = await prisma.employee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeFindManyArgs>(args?: SelectSubset<T, EmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends EmployeeCreateArgs>(args: SelectSubset<T, EmployeeCreateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeCreateManyArgs>(args?: SelectSubset<T, EmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {EmployeeCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDeleteArgs>(args: SelectSubset<T, EmployeeDeleteArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeUpdateArgs>(args: SelectSubset<T, EmployeeUpdateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDeleteManyArgs>(args?: SelectSubset<T, EmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeUpdateManyArgs>(args: SelectSubset<T, EmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees and returns the data updated in the database.
     * @param {EmployeeUpdateManyAndReturnArgs} args - Arguments to update many Employees.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeUpsertArgs>(args: SelectSubset<T, EmployeeUpsertArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employee model
   */
  readonly fields: EmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    obra<T extends Employee$obraArgs<ExtArgs> = {}>(args?: Subset<T, Employee$obraArgs<ExtArgs>>): Prisma__ObraClient<$Result.GetResult<Prisma.$ObraPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    attendances<T extends Employee$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payrollEntries<T extends Employee$payrollEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$payrollEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accumulationPayment<T extends Employee$accumulationPaymentArgs<ExtArgs> = {}>(args?: Subset<T, Employee$accumulationPaymentArgs<ExtArgs>>): Prisma__EmployeeAccumulationPaymentClient<$Result.GetResult<Prisma.$EmployeeAccumulationPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employee model
   */
  interface EmployeeFieldRefs {
    readonly id: FieldRef<"Employee", 'Int'>
    readonly code: FieldRef<"Employee", 'String'>
    readonly firstName: FieldRef<"Employee", 'String'>
    readonly lastName: FieldRef<"Employee", 'String'>
    readonly documentType: FieldRef<"Employee", 'DocumentType'>
    readonly documentNumber: FieldRef<"Employee", 'String'>
    readonly position: FieldRef<"Employee", 'String'>
    readonly phone: FieldRef<"Employee", 'String'>
    readonly email: FieldRef<"Employee", 'String'>
    readonly bankType: FieldRef<"Employee", 'BankType'>
    readonly accountNumber: FieldRef<"Employee", 'String'>
    readonly cci: FieldRef<"Employee", 'String'>
    readonly startDate: FieldRef<"Employee", 'DateTime'>
    readonly endDate: FieldRef<"Employee", 'DateTime'>
    readonly baseSalary: FieldRef<"Employee", 'Decimal'>
    readonly dailyHours: FieldRef<"Employee", 'Decimal'>
    readonly pensionSystem: FieldRef<"Employee", 'PensionSystem'>
    readonly pensionRate: FieldRef<"Employee", 'Decimal'>
    readonly healthRate: FieldRef<"Employee", 'Decimal'>
    readonly isActive: FieldRef<"Employee", 'Boolean'>
    readonly area: FieldRef<"Employee", 'EmployeeArea'>
    readonly obraId: FieldRef<"Employee", 'Int'>
    readonly notes: FieldRef<"Employee", 'String'>
    readonly absenceSundayPenalty: FieldRef<"Employee", 'Boolean'>
    readonly createdAt: FieldRef<"Employee", 'DateTime'>
    readonly updatedAt: FieldRef<"Employee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findUniqueOrThrow
   */
  export type EmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findFirstOrThrow
   */
  export type EmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee create
   */
  export type EmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Employee.
     */
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }

  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
  }

  /**
   * Employee createManyAndReturn
   */
  export type EmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee update
   */
  export type EmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Employee.
     */
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employee updateManyAndReturn
   */
  export type EmployeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Employee to update in case it exists.
     */
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     */
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }

  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter which Employee to delete.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to delete.
     */
    limit?: number
  }

  /**
   * Employee.obra
   */
  export type Employee$obraArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obra
     */
    select?: ObraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Obra
     */
    omit?: ObraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObraInclude<ExtArgs> | null
    where?: ObraWhereInput
  }

  /**
   * Employee.attendances
   */
  export type Employee$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    where?: AttendanceRecordWhereInput
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    cursor?: AttendanceRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * Employee.payrollEntries
   */
  export type Employee$payrollEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryInclude<ExtArgs> | null
    where?: PayrollEntryWhereInput
    orderBy?: PayrollEntryOrderByWithRelationInput | PayrollEntryOrderByWithRelationInput[]
    cursor?: PayrollEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayrollEntryScalarFieldEnum | PayrollEntryScalarFieldEnum[]
  }

  /**
   * Employee.accumulationPayment
   */
  export type Employee$accumulationPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAccumulationPayment
     */
    select?: EmployeeAccumulationPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAccumulationPayment
     */
    omit?: EmployeeAccumulationPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAccumulationPaymentInclude<ExtArgs> | null
    where?: EmployeeAccumulationPaymentWhereInput
  }

  /**
   * Employee without action
   */
  export type EmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
  }


  /**
   * Model EmployeeAccumulationPayment
   */

  export type AggregateEmployeeAccumulationPayment = {
    _count: EmployeeAccumulationPaymentCountAggregateOutputType | null
    _avg: EmployeeAccumulationPaymentAvgAggregateOutputType | null
    _sum: EmployeeAccumulationPaymentSumAggregateOutputType | null
    _min: EmployeeAccumulationPaymentMinAggregateOutputType | null
    _max: EmployeeAccumulationPaymentMaxAggregateOutputType | null
  }

  export type EmployeeAccumulationPaymentAvgAggregateOutputType = {
    employeeId: number | null
  }

  export type EmployeeAccumulationPaymentSumAggregateOutputType = {
    employeeId: number | null
  }

  export type EmployeeAccumulationPaymentMinAggregateOutputType = {
    employeeId: number | null
    paid: boolean | null
    paidAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeAccumulationPaymentMaxAggregateOutputType = {
    employeeId: number | null
    paid: boolean | null
    paidAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeAccumulationPaymentCountAggregateOutputType = {
    employeeId: number
    paid: number
    paidAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmployeeAccumulationPaymentAvgAggregateInputType = {
    employeeId?: true
  }

  export type EmployeeAccumulationPaymentSumAggregateInputType = {
    employeeId?: true
  }

  export type EmployeeAccumulationPaymentMinAggregateInputType = {
    employeeId?: true
    paid?: true
    paidAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeAccumulationPaymentMaxAggregateInputType = {
    employeeId?: true
    paid?: true
    paidAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeAccumulationPaymentCountAggregateInputType = {
    employeeId?: true
    paid?: true
    paidAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmployeeAccumulationPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeAccumulationPayment to aggregate.
     */
    where?: EmployeeAccumulationPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeAccumulationPayments to fetch.
     */
    orderBy?: EmployeeAccumulationPaymentOrderByWithRelationInput | EmployeeAccumulationPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeAccumulationPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeAccumulationPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeAccumulationPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeAccumulationPayments
    **/
    _count?: true | EmployeeAccumulationPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeAccumulationPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeAccumulationPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeAccumulationPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeAccumulationPaymentMaxAggregateInputType
  }

  export type GetEmployeeAccumulationPaymentAggregateType<T extends EmployeeAccumulationPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeAccumulationPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeAccumulationPayment[P]>
      : GetScalarType<T[P], AggregateEmployeeAccumulationPayment[P]>
  }




  export type EmployeeAccumulationPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeAccumulationPaymentWhereInput
    orderBy?: EmployeeAccumulationPaymentOrderByWithAggregationInput | EmployeeAccumulationPaymentOrderByWithAggregationInput[]
    by: EmployeeAccumulationPaymentScalarFieldEnum[] | EmployeeAccumulationPaymentScalarFieldEnum
    having?: EmployeeAccumulationPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeAccumulationPaymentCountAggregateInputType | true
    _avg?: EmployeeAccumulationPaymentAvgAggregateInputType
    _sum?: EmployeeAccumulationPaymentSumAggregateInputType
    _min?: EmployeeAccumulationPaymentMinAggregateInputType
    _max?: EmployeeAccumulationPaymentMaxAggregateInputType
  }

  export type EmployeeAccumulationPaymentGroupByOutputType = {
    employeeId: number
    paid: boolean
    paidAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: EmployeeAccumulationPaymentCountAggregateOutputType | null
    _avg: EmployeeAccumulationPaymentAvgAggregateOutputType | null
    _sum: EmployeeAccumulationPaymentSumAggregateOutputType | null
    _min: EmployeeAccumulationPaymentMinAggregateOutputType | null
    _max: EmployeeAccumulationPaymentMaxAggregateOutputType | null
  }

  type GetEmployeeAccumulationPaymentGroupByPayload<T extends EmployeeAccumulationPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeAccumulationPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeAccumulationPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeAccumulationPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeAccumulationPaymentGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeAccumulationPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    employeeId?: boolean
    paid?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeAccumulationPayment"]>

  export type EmployeeAccumulationPaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    employeeId?: boolean
    paid?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeAccumulationPayment"]>

  export type EmployeeAccumulationPaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    employeeId?: boolean
    paid?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeAccumulationPayment"]>

  export type EmployeeAccumulationPaymentSelectScalar = {
    employeeId?: boolean
    paid?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmployeeAccumulationPaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"employeeId" | "paid" | "paidAt" | "createdAt" | "updatedAt", ExtArgs["result"]["employeeAccumulationPayment"]>
  export type EmployeeAccumulationPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type EmployeeAccumulationPaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type EmployeeAccumulationPaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $EmployeeAccumulationPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeAccumulationPayment"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      employeeId: number
      paid: boolean
      paidAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["employeeAccumulationPayment"]>
    composites: {}
  }

  type EmployeeAccumulationPaymentGetPayload<S extends boolean | null | undefined | EmployeeAccumulationPaymentDefaultArgs> = $Result.GetResult<Prisma.$EmployeeAccumulationPaymentPayload, S>

  type EmployeeAccumulationPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeAccumulationPaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeAccumulationPaymentCountAggregateInputType | true
    }

  export interface EmployeeAccumulationPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeAccumulationPayment'], meta: { name: 'EmployeeAccumulationPayment' } }
    /**
     * Find zero or one EmployeeAccumulationPayment that matches the filter.
     * @param {EmployeeAccumulationPaymentFindUniqueArgs} args - Arguments to find a EmployeeAccumulationPayment
     * @example
     * // Get one EmployeeAccumulationPayment
     * const employeeAccumulationPayment = await prisma.employeeAccumulationPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeAccumulationPaymentFindUniqueArgs>(args: SelectSubset<T, EmployeeAccumulationPaymentFindUniqueArgs<ExtArgs>>): Prisma__EmployeeAccumulationPaymentClient<$Result.GetResult<Prisma.$EmployeeAccumulationPaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmployeeAccumulationPayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeAccumulationPaymentFindUniqueOrThrowArgs} args - Arguments to find a EmployeeAccumulationPayment
     * @example
     * // Get one EmployeeAccumulationPayment
     * const employeeAccumulationPayment = await prisma.employeeAccumulationPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeAccumulationPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeAccumulationPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeAccumulationPaymentClient<$Result.GetResult<Prisma.$EmployeeAccumulationPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeAccumulationPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAccumulationPaymentFindFirstArgs} args - Arguments to find a EmployeeAccumulationPayment
     * @example
     * // Get one EmployeeAccumulationPayment
     * const employeeAccumulationPayment = await prisma.employeeAccumulationPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeAccumulationPaymentFindFirstArgs>(args?: SelectSubset<T, EmployeeAccumulationPaymentFindFirstArgs<ExtArgs>>): Prisma__EmployeeAccumulationPaymentClient<$Result.GetResult<Prisma.$EmployeeAccumulationPaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeAccumulationPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAccumulationPaymentFindFirstOrThrowArgs} args - Arguments to find a EmployeeAccumulationPayment
     * @example
     * // Get one EmployeeAccumulationPayment
     * const employeeAccumulationPayment = await prisma.employeeAccumulationPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeAccumulationPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeAccumulationPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeAccumulationPaymentClient<$Result.GetResult<Prisma.$EmployeeAccumulationPaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmployeeAccumulationPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAccumulationPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeAccumulationPayments
     * const employeeAccumulationPayments = await prisma.employeeAccumulationPayment.findMany()
     * 
     * // Get first 10 EmployeeAccumulationPayments
     * const employeeAccumulationPayments = await prisma.employeeAccumulationPayment.findMany({ take: 10 })
     * 
     * // Only select the `employeeId`
     * const employeeAccumulationPaymentWithEmployeeIdOnly = await prisma.employeeAccumulationPayment.findMany({ select: { employeeId: true } })
     * 
     */
    findMany<T extends EmployeeAccumulationPaymentFindManyArgs>(args?: SelectSubset<T, EmployeeAccumulationPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeAccumulationPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmployeeAccumulationPayment.
     * @param {EmployeeAccumulationPaymentCreateArgs} args - Arguments to create a EmployeeAccumulationPayment.
     * @example
     * // Create one EmployeeAccumulationPayment
     * const EmployeeAccumulationPayment = await prisma.employeeAccumulationPayment.create({
     *   data: {
     *     // ... data to create a EmployeeAccumulationPayment
     *   }
     * })
     * 
     */
    create<T extends EmployeeAccumulationPaymentCreateArgs>(args: SelectSubset<T, EmployeeAccumulationPaymentCreateArgs<ExtArgs>>): Prisma__EmployeeAccumulationPaymentClient<$Result.GetResult<Prisma.$EmployeeAccumulationPaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmployeeAccumulationPayments.
     * @param {EmployeeAccumulationPaymentCreateManyArgs} args - Arguments to create many EmployeeAccumulationPayments.
     * @example
     * // Create many EmployeeAccumulationPayments
     * const employeeAccumulationPayment = await prisma.employeeAccumulationPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeAccumulationPaymentCreateManyArgs>(args?: SelectSubset<T, EmployeeAccumulationPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmployeeAccumulationPayments and returns the data saved in the database.
     * @param {EmployeeAccumulationPaymentCreateManyAndReturnArgs} args - Arguments to create many EmployeeAccumulationPayments.
     * @example
     * // Create many EmployeeAccumulationPayments
     * const employeeAccumulationPayment = await prisma.employeeAccumulationPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmployeeAccumulationPayments and only return the `employeeId`
     * const employeeAccumulationPaymentWithEmployeeIdOnly = await prisma.employeeAccumulationPayment.createManyAndReturn({
     *   select: { employeeId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeAccumulationPaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeAccumulationPaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeAccumulationPaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmployeeAccumulationPayment.
     * @param {EmployeeAccumulationPaymentDeleteArgs} args - Arguments to delete one EmployeeAccumulationPayment.
     * @example
     * // Delete one EmployeeAccumulationPayment
     * const EmployeeAccumulationPayment = await prisma.employeeAccumulationPayment.delete({
     *   where: {
     *     // ... filter to delete one EmployeeAccumulationPayment
     *   }
     * })
     * 
     */
    delete<T extends EmployeeAccumulationPaymentDeleteArgs>(args: SelectSubset<T, EmployeeAccumulationPaymentDeleteArgs<ExtArgs>>): Prisma__EmployeeAccumulationPaymentClient<$Result.GetResult<Prisma.$EmployeeAccumulationPaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmployeeAccumulationPayment.
     * @param {EmployeeAccumulationPaymentUpdateArgs} args - Arguments to update one EmployeeAccumulationPayment.
     * @example
     * // Update one EmployeeAccumulationPayment
     * const employeeAccumulationPayment = await prisma.employeeAccumulationPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeAccumulationPaymentUpdateArgs>(args: SelectSubset<T, EmployeeAccumulationPaymentUpdateArgs<ExtArgs>>): Prisma__EmployeeAccumulationPaymentClient<$Result.GetResult<Prisma.$EmployeeAccumulationPaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmployeeAccumulationPayments.
     * @param {EmployeeAccumulationPaymentDeleteManyArgs} args - Arguments to filter EmployeeAccumulationPayments to delete.
     * @example
     * // Delete a few EmployeeAccumulationPayments
     * const { count } = await prisma.employeeAccumulationPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeAccumulationPaymentDeleteManyArgs>(args?: SelectSubset<T, EmployeeAccumulationPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeAccumulationPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAccumulationPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeAccumulationPayments
     * const employeeAccumulationPayment = await prisma.employeeAccumulationPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeAccumulationPaymentUpdateManyArgs>(args: SelectSubset<T, EmployeeAccumulationPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeAccumulationPayments and returns the data updated in the database.
     * @param {EmployeeAccumulationPaymentUpdateManyAndReturnArgs} args - Arguments to update many EmployeeAccumulationPayments.
     * @example
     * // Update many EmployeeAccumulationPayments
     * const employeeAccumulationPayment = await prisma.employeeAccumulationPayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmployeeAccumulationPayments and only return the `employeeId`
     * const employeeAccumulationPaymentWithEmployeeIdOnly = await prisma.employeeAccumulationPayment.updateManyAndReturn({
     *   select: { employeeId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeAccumulationPaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeAccumulationPaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeAccumulationPaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmployeeAccumulationPayment.
     * @param {EmployeeAccumulationPaymentUpsertArgs} args - Arguments to update or create a EmployeeAccumulationPayment.
     * @example
     * // Update or create a EmployeeAccumulationPayment
     * const employeeAccumulationPayment = await prisma.employeeAccumulationPayment.upsert({
     *   create: {
     *     // ... data to create a EmployeeAccumulationPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeAccumulationPayment we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeAccumulationPaymentUpsertArgs>(args: SelectSubset<T, EmployeeAccumulationPaymentUpsertArgs<ExtArgs>>): Prisma__EmployeeAccumulationPaymentClient<$Result.GetResult<Prisma.$EmployeeAccumulationPaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmployeeAccumulationPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAccumulationPaymentCountArgs} args - Arguments to filter EmployeeAccumulationPayments to count.
     * @example
     * // Count the number of EmployeeAccumulationPayments
     * const count = await prisma.employeeAccumulationPayment.count({
     *   where: {
     *     // ... the filter for the EmployeeAccumulationPayments we want to count
     *   }
     * })
    **/
    count<T extends EmployeeAccumulationPaymentCountArgs>(
      args?: Subset<T, EmployeeAccumulationPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeAccumulationPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeAccumulationPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAccumulationPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAccumulationPaymentAggregateArgs>(args: Subset<T, EmployeeAccumulationPaymentAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAccumulationPaymentAggregateType<T>>

    /**
     * Group by EmployeeAccumulationPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAccumulationPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeAccumulationPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeAccumulationPaymentGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeAccumulationPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeAccumulationPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeAccumulationPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeAccumulationPayment model
   */
  readonly fields: EmployeeAccumulationPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeAccumulationPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeAccumulationPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeAccumulationPayment model
   */
  interface EmployeeAccumulationPaymentFieldRefs {
    readonly employeeId: FieldRef<"EmployeeAccumulationPayment", 'Int'>
    readonly paid: FieldRef<"EmployeeAccumulationPayment", 'Boolean'>
    readonly paidAt: FieldRef<"EmployeeAccumulationPayment", 'DateTime'>
    readonly createdAt: FieldRef<"EmployeeAccumulationPayment", 'DateTime'>
    readonly updatedAt: FieldRef<"EmployeeAccumulationPayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeAccumulationPayment findUnique
   */
  export type EmployeeAccumulationPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAccumulationPayment
     */
    select?: EmployeeAccumulationPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAccumulationPayment
     */
    omit?: EmployeeAccumulationPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAccumulationPaymentInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeAccumulationPayment to fetch.
     */
    where: EmployeeAccumulationPaymentWhereUniqueInput
  }

  /**
   * EmployeeAccumulationPayment findUniqueOrThrow
   */
  export type EmployeeAccumulationPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAccumulationPayment
     */
    select?: EmployeeAccumulationPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAccumulationPayment
     */
    omit?: EmployeeAccumulationPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAccumulationPaymentInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeAccumulationPayment to fetch.
     */
    where: EmployeeAccumulationPaymentWhereUniqueInput
  }

  /**
   * EmployeeAccumulationPayment findFirst
   */
  export type EmployeeAccumulationPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAccumulationPayment
     */
    select?: EmployeeAccumulationPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAccumulationPayment
     */
    omit?: EmployeeAccumulationPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAccumulationPaymentInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeAccumulationPayment to fetch.
     */
    where?: EmployeeAccumulationPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeAccumulationPayments to fetch.
     */
    orderBy?: EmployeeAccumulationPaymentOrderByWithRelationInput | EmployeeAccumulationPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeAccumulationPayments.
     */
    cursor?: EmployeeAccumulationPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeAccumulationPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeAccumulationPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeAccumulationPayments.
     */
    distinct?: EmployeeAccumulationPaymentScalarFieldEnum | EmployeeAccumulationPaymentScalarFieldEnum[]
  }

  /**
   * EmployeeAccumulationPayment findFirstOrThrow
   */
  export type EmployeeAccumulationPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAccumulationPayment
     */
    select?: EmployeeAccumulationPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAccumulationPayment
     */
    omit?: EmployeeAccumulationPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAccumulationPaymentInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeAccumulationPayment to fetch.
     */
    where?: EmployeeAccumulationPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeAccumulationPayments to fetch.
     */
    orderBy?: EmployeeAccumulationPaymentOrderByWithRelationInput | EmployeeAccumulationPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeAccumulationPayments.
     */
    cursor?: EmployeeAccumulationPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeAccumulationPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeAccumulationPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeAccumulationPayments.
     */
    distinct?: EmployeeAccumulationPaymentScalarFieldEnum | EmployeeAccumulationPaymentScalarFieldEnum[]
  }

  /**
   * EmployeeAccumulationPayment findMany
   */
  export type EmployeeAccumulationPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAccumulationPayment
     */
    select?: EmployeeAccumulationPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAccumulationPayment
     */
    omit?: EmployeeAccumulationPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAccumulationPaymentInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeAccumulationPayments to fetch.
     */
    where?: EmployeeAccumulationPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeAccumulationPayments to fetch.
     */
    orderBy?: EmployeeAccumulationPaymentOrderByWithRelationInput | EmployeeAccumulationPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeAccumulationPayments.
     */
    cursor?: EmployeeAccumulationPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeAccumulationPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeAccumulationPayments.
     */
    skip?: number
    distinct?: EmployeeAccumulationPaymentScalarFieldEnum | EmployeeAccumulationPaymentScalarFieldEnum[]
  }

  /**
   * EmployeeAccumulationPayment create
   */
  export type EmployeeAccumulationPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAccumulationPayment
     */
    select?: EmployeeAccumulationPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAccumulationPayment
     */
    omit?: EmployeeAccumulationPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAccumulationPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeAccumulationPayment.
     */
    data: XOR<EmployeeAccumulationPaymentCreateInput, EmployeeAccumulationPaymentUncheckedCreateInput>
  }

  /**
   * EmployeeAccumulationPayment createMany
   */
  export type EmployeeAccumulationPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeAccumulationPayments.
     */
    data: EmployeeAccumulationPaymentCreateManyInput | EmployeeAccumulationPaymentCreateManyInput[]
  }

  /**
   * EmployeeAccumulationPayment createManyAndReturn
   */
  export type EmployeeAccumulationPaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAccumulationPayment
     */
    select?: EmployeeAccumulationPaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAccumulationPayment
     */
    omit?: EmployeeAccumulationPaymentOmit<ExtArgs> | null
    /**
     * The data used to create many EmployeeAccumulationPayments.
     */
    data: EmployeeAccumulationPaymentCreateManyInput | EmployeeAccumulationPaymentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAccumulationPaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeAccumulationPayment update
   */
  export type EmployeeAccumulationPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAccumulationPayment
     */
    select?: EmployeeAccumulationPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAccumulationPayment
     */
    omit?: EmployeeAccumulationPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAccumulationPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeAccumulationPayment.
     */
    data: XOR<EmployeeAccumulationPaymentUpdateInput, EmployeeAccumulationPaymentUncheckedUpdateInput>
    /**
     * Choose, which EmployeeAccumulationPayment to update.
     */
    where: EmployeeAccumulationPaymentWhereUniqueInput
  }

  /**
   * EmployeeAccumulationPayment updateMany
   */
  export type EmployeeAccumulationPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeAccumulationPayments.
     */
    data: XOR<EmployeeAccumulationPaymentUpdateManyMutationInput, EmployeeAccumulationPaymentUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeAccumulationPayments to update
     */
    where?: EmployeeAccumulationPaymentWhereInput
    /**
     * Limit how many EmployeeAccumulationPayments to update.
     */
    limit?: number
  }

  /**
   * EmployeeAccumulationPayment updateManyAndReturn
   */
  export type EmployeeAccumulationPaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAccumulationPayment
     */
    select?: EmployeeAccumulationPaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAccumulationPayment
     */
    omit?: EmployeeAccumulationPaymentOmit<ExtArgs> | null
    /**
     * The data used to update EmployeeAccumulationPayments.
     */
    data: XOR<EmployeeAccumulationPaymentUpdateManyMutationInput, EmployeeAccumulationPaymentUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeAccumulationPayments to update
     */
    where?: EmployeeAccumulationPaymentWhereInput
    /**
     * Limit how many EmployeeAccumulationPayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAccumulationPaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeAccumulationPayment upsert
   */
  export type EmployeeAccumulationPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAccumulationPayment
     */
    select?: EmployeeAccumulationPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAccumulationPayment
     */
    omit?: EmployeeAccumulationPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAccumulationPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeAccumulationPayment to update in case it exists.
     */
    where: EmployeeAccumulationPaymentWhereUniqueInput
    /**
     * In case the EmployeeAccumulationPayment found by the `where` argument doesn't exist, create a new EmployeeAccumulationPayment with this data.
     */
    create: XOR<EmployeeAccumulationPaymentCreateInput, EmployeeAccumulationPaymentUncheckedCreateInput>
    /**
     * In case the EmployeeAccumulationPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeAccumulationPaymentUpdateInput, EmployeeAccumulationPaymentUncheckedUpdateInput>
  }

  /**
   * EmployeeAccumulationPayment delete
   */
  export type EmployeeAccumulationPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAccumulationPayment
     */
    select?: EmployeeAccumulationPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAccumulationPayment
     */
    omit?: EmployeeAccumulationPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAccumulationPaymentInclude<ExtArgs> | null
    /**
     * Filter which EmployeeAccumulationPayment to delete.
     */
    where: EmployeeAccumulationPaymentWhereUniqueInput
  }

  /**
   * EmployeeAccumulationPayment deleteMany
   */
  export type EmployeeAccumulationPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeAccumulationPayments to delete
     */
    where?: EmployeeAccumulationPaymentWhereInput
    /**
     * Limit how many EmployeeAccumulationPayments to delete.
     */
    limit?: number
  }

  /**
   * EmployeeAccumulationPayment without action
   */
  export type EmployeeAccumulationPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeAccumulationPayment
     */
    select?: EmployeeAccumulationPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeAccumulationPayment
     */
    omit?: EmployeeAccumulationPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeAccumulationPaymentInclude<ExtArgs> | null
  }


  /**
   * Model AttendanceRecord
   */

  export type AggregateAttendanceRecord = {
    _count: AttendanceRecordCountAggregateOutputType | null
    _avg: AttendanceRecordAvgAggregateOutputType | null
    _sum: AttendanceRecordSumAggregateOutputType | null
    _min: AttendanceRecordMinAggregateOutputType | null
    _max: AttendanceRecordMaxAggregateOutputType | null
  }

  export type AttendanceRecordAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
    minutesLate: number | null
    permissionHours: Decimal | null
    extraHours: Decimal | null
    holidayCount: number | null
  }

  export type AttendanceRecordSumAggregateOutputType = {
    id: number | null
    employeeId: number | null
    minutesLate: number | null
    permissionHours: Decimal | null
    extraHours: Decimal | null
    holidayCount: number | null
  }

  export type AttendanceRecordMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    date: Date | null
    status: $Enums.AttendanceStatus | null
    minutesLate: number | null
    permissionHours: Decimal | null
    extraHours: Decimal | null
    permissionPaid: boolean | null
    holidayWorked: boolean | null
    holidayCount: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceRecordMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    date: Date | null
    status: $Enums.AttendanceStatus | null
    minutesLate: number | null
    permissionHours: Decimal | null
    extraHours: Decimal | null
    permissionPaid: boolean | null
    holidayWorked: boolean | null
    holidayCount: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceRecordCountAggregateOutputType = {
    id: number
    employeeId: number
    date: number
    status: number
    minutesLate: number
    permissionHours: number
    extraHours: number
    permissionPaid: number
    holidayWorked: number
    holidayCount: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AttendanceRecordAvgAggregateInputType = {
    id?: true
    employeeId?: true
    minutesLate?: true
    permissionHours?: true
    extraHours?: true
    holidayCount?: true
  }

  export type AttendanceRecordSumAggregateInputType = {
    id?: true
    employeeId?: true
    minutesLate?: true
    permissionHours?: true
    extraHours?: true
    holidayCount?: true
  }

  export type AttendanceRecordMinAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    status?: true
    minutesLate?: true
    permissionHours?: true
    extraHours?: true
    permissionPaid?: true
    holidayWorked?: true
    holidayCount?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceRecordMaxAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    status?: true
    minutesLate?: true
    permissionHours?: true
    extraHours?: true
    permissionPaid?: true
    holidayWorked?: true
    holidayCount?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceRecordCountAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    status?: true
    minutesLate?: true
    permissionHours?: true
    extraHours?: true
    permissionPaid?: true
    holidayWorked?: true
    holidayCount?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AttendanceRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceRecord to aggregate.
     */
    where?: AttendanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceRecords to fetch.
     */
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttendanceRecords
    **/
    _count?: true | AttendanceRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendanceRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendanceRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceRecordMaxAggregateInputType
  }

  export type GetAttendanceRecordAggregateType<T extends AttendanceRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendanceRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendanceRecord[P]>
      : GetScalarType<T[P], AggregateAttendanceRecord[P]>
  }




  export type AttendanceRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceRecordWhereInput
    orderBy?: AttendanceRecordOrderByWithAggregationInput | AttendanceRecordOrderByWithAggregationInput[]
    by: AttendanceRecordScalarFieldEnum[] | AttendanceRecordScalarFieldEnum
    having?: AttendanceRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceRecordCountAggregateInputType | true
    _avg?: AttendanceRecordAvgAggregateInputType
    _sum?: AttendanceRecordSumAggregateInputType
    _min?: AttendanceRecordMinAggregateInputType
    _max?: AttendanceRecordMaxAggregateInputType
  }

  export type AttendanceRecordGroupByOutputType = {
    id: number
    employeeId: number
    date: Date
    status: $Enums.AttendanceStatus
    minutesLate: number | null
    permissionHours: Decimal | null
    extraHours: Decimal | null
    permissionPaid: boolean | null
    holidayWorked: boolean
    holidayCount: number
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: AttendanceRecordCountAggregateOutputType | null
    _avg: AttendanceRecordAvgAggregateOutputType | null
    _sum: AttendanceRecordSumAggregateOutputType | null
    _min: AttendanceRecordMinAggregateOutputType | null
    _max: AttendanceRecordMaxAggregateOutputType | null
  }

  type GetAttendanceRecordGroupByPayload<T extends AttendanceRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceRecordGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceRecordGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    date?: boolean
    status?: boolean
    minutesLate?: boolean
    permissionHours?: boolean
    extraHours?: boolean
    permissionPaid?: boolean
    holidayWorked?: boolean
    holidayCount?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceRecord"]>

  export type AttendanceRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    date?: boolean
    status?: boolean
    minutesLate?: boolean
    permissionHours?: boolean
    extraHours?: boolean
    permissionPaid?: boolean
    holidayWorked?: boolean
    holidayCount?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceRecord"]>

  export type AttendanceRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    date?: boolean
    status?: boolean
    minutesLate?: boolean
    permissionHours?: boolean
    extraHours?: boolean
    permissionPaid?: boolean
    holidayWorked?: boolean
    holidayCount?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceRecord"]>

  export type AttendanceRecordSelectScalar = {
    id?: boolean
    employeeId?: boolean
    date?: boolean
    status?: boolean
    minutesLate?: boolean
    permissionHours?: boolean
    extraHours?: boolean
    permissionPaid?: boolean
    holidayWorked?: boolean
    holidayCount?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AttendanceRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "date" | "status" | "minutesLate" | "permissionHours" | "extraHours" | "permissionPaid" | "holidayWorked" | "holidayCount" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["attendanceRecord"]>
  export type AttendanceRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type AttendanceRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type AttendanceRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $AttendanceRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AttendanceRecord"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      date: Date
      status: $Enums.AttendanceStatus
      minutesLate: number | null
      permissionHours: Prisma.Decimal | null
      extraHours: Prisma.Decimal | null
      permissionPaid: boolean | null
      holidayWorked: boolean
      holidayCount: number
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["attendanceRecord"]>
    composites: {}
  }

  type AttendanceRecordGetPayload<S extends boolean | null | undefined | AttendanceRecordDefaultArgs> = $Result.GetResult<Prisma.$AttendanceRecordPayload, S>

  type AttendanceRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceRecordCountAggregateInputType | true
    }

  export interface AttendanceRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AttendanceRecord'], meta: { name: 'AttendanceRecord' } }
    /**
     * Find zero or one AttendanceRecord that matches the filter.
     * @param {AttendanceRecordFindUniqueArgs} args - Arguments to find a AttendanceRecord
     * @example
     * // Get one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceRecordFindUniqueArgs>(args: SelectSubset<T, AttendanceRecordFindUniqueArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AttendanceRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceRecordFindUniqueOrThrowArgs} args - Arguments to find a AttendanceRecord
     * @example
     * // Get one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordFindFirstArgs} args - Arguments to find a AttendanceRecord
     * @example
     * // Get one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceRecordFindFirstArgs>(args?: SelectSubset<T, AttendanceRecordFindFirstArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordFindFirstOrThrowArgs} args - Arguments to find a AttendanceRecord
     * @example
     * // Get one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AttendanceRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttendanceRecords
     * const attendanceRecords = await prisma.attendanceRecord.findMany()
     * 
     * // Get first 10 AttendanceRecords
     * const attendanceRecords = await prisma.attendanceRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceRecordWithIdOnly = await prisma.attendanceRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceRecordFindManyArgs>(args?: SelectSubset<T, AttendanceRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AttendanceRecord.
     * @param {AttendanceRecordCreateArgs} args - Arguments to create a AttendanceRecord.
     * @example
     * // Create one AttendanceRecord
     * const AttendanceRecord = await prisma.attendanceRecord.create({
     *   data: {
     *     // ... data to create a AttendanceRecord
     *   }
     * })
     * 
     */
    create<T extends AttendanceRecordCreateArgs>(args: SelectSubset<T, AttendanceRecordCreateArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AttendanceRecords.
     * @param {AttendanceRecordCreateManyArgs} args - Arguments to create many AttendanceRecords.
     * @example
     * // Create many AttendanceRecords
     * const attendanceRecord = await prisma.attendanceRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceRecordCreateManyArgs>(args?: SelectSubset<T, AttendanceRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AttendanceRecords and returns the data saved in the database.
     * @param {AttendanceRecordCreateManyAndReturnArgs} args - Arguments to create many AttendanceRecords.
     * @example
     * // Create many AttendanceRecords
     * const attendanceRecord = await prisma.attendanceRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AttendanceRecords and only return the `id`
     * const attendanceRecordWithIdOnly = await prisma.attendanceRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AttendanceRecord.
     * @param {AttendanceRecordDeleteArgs} args - Arguments to delete one AttendanceRecord.
     * @example
     * // Delete one AttendanceRecord
     * const AttendanceRecord = await prisma.attendanceRecord.delete({
     *   where: {
     *     // ... filter to delete one AttendanceRecord
     *   }
     * })
     * 
     */
    delete<T extends AttendanceRecordDeleteArgs>(args: SelectSubset<T, AttendanceRecordDeleteArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AttendanceRecord.
     * @param {AttendanceRecordUpdateArgs} args - Arguments to update one AttendanceRecord.
     * @example
     * // Update one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceRecordUpdateArgs>(args: SelectSubset<T, AttendanceRecordUpdateArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AttendanceRecords.
     * @param {AttendanceRecordDeleteManyArgs} args - Arguments to filter AttendanceRecords to delete.
     * @example
     * // Delete a few AttendanceRecords
     * const { count } = await prisma.attendanceRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceRecordDeleteManyArgs>(args?: SelectSubset<T, AttendanceRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttendanceRecords
     * const attendanceRecord = await prisma.attendanceRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceRecordUpdateManyArgs>(args: SelectSubset<T, AttendanceRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceRecords and returns the data updated in the database.
     * @param {AttendanceRecordUpdateManyAndReturnArgs} args - Arguments to update many AttendanceRecords.
     * @example
     * // Update many AttendanceRecords
     * const attendanceRecord = await prisma.attendanceRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AttendanceRecords and only return the `id`
     * const attendanceRecordWithIdOnly = await prisma.attendanceRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AttendanceRecord.
     * @param {AttendanceRecordUpsertArgs} args - Arguments to update or create a AttendanceRecord.
     * @example
     * // Update or create a AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.upsert({
     *   create: {
     *     // ... data to create a AttendanceRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttendanceRecord we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceRecordUpsertArgs>(args: SelectSubset<T, AttendanceRecordUpsertArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AttendanceRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordCountArgs} args - Arguments to filter AttendanceRecords to count.
     * @example
     * // Count the number of AttendanceRecords
     * const count = await prisma.attendanceRecord.count({
     *   where: {
     *     // ... the filter for the AttendanceRecords we want to count
     *   }
     * })
    **/
    count<T extends AttendanceRecordCountArgs>(
      args?: Subset<T, AttendanceRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttendanceRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceRecordAggregateArgs>(args: Subset<T, AttendanceRecordAggregateArgs>): Prisma.PrismaPromise<GetAttendanceRecordAggregateType<T>>

    /**
     * Group by AttendanceRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceRecordGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AttendanceRecord model
   */
  readonly fields: AttendanceRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttendanceRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AttendanceRecord model
   */
  interface AttendanceRecordFieldRefs {
    readonly id: FieldRef<"AttendanceRecord", 'Int'>
    readonly employeeId: FieldRef<"AttendanceRecord", 'Int'>
    readonly date: FieldRef<"AttendanceRecord", 'DateTime'>
    readonly status: FieldRef<"AttendanceRecord", 'AttendanceStatus'>
    readonly minutesLate: FieldRef<"AttendanceRecord", 'Int'>
    readonly permissionHours: FieldRef<"AttendanceRecord", 'Decimal'>
    readonly extraHours: FieldRef<"AttendanceRecord", 'Decimal'>
    readonly permissionPaid: FieldRef<"AttendanceRecord", 'Boolean'>
    readonly holidayWorked: FieldRef<"AttendanceRecord", 'Boolean'>
    readonly holidayCount: FieldRef<"AttendanceRecord", 'Int'>
    readonly notes: FieldRef<"AttendanceRecord", 'String'>
    readonly createdAt: FieldRef<"AttendanceRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"AttendanceRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AttendanceRecord findUnique
   */
  export type AttendanceRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecord to fetch.
     */
    where: AttendanceRecordWhereUniqueInput
  }

  /**
   * AttendanceRecord findUniqueOrThrow
   */
  export type AttendanceRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecord to fetch.
     */
    where: AttendanceRecordWhereUniqueInput
  }

  /**
   * AttendanceRecord findFirst
   */
  export type AttendanceRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecord to fetch.
     */
    where?: AttendanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceRecords to fetch.
     */
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceRecords.
     */
    cursor?: AttendanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceRecords.
     */
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * AttendanceRecord findFirstOrThrow
   */
  export type AttendanceRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecord to fetch.
     */
    where?: AttendanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceRecords to fetch.
     */
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceRecords.
     */
    cursor?: AttendanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceRecords.
     */
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * AttendanceRecord findMany
   */
  export type AttendanceRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecords to fetch.
     */
    where?: AttendanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceRecords to fetch.
     */
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttendanceRecords.
     */
    cursor?: AttendanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceRecords.
     */
    skip?: number
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * AttendanceRecord create
   */
  export type AttendanceRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a AttendanceRecord.
     */
    data: XOR<AttendanceRecordCreateInput, AttendanceRecordUncheckedCreateInput>
  }

  /**
   * AttendanceRecord createMany
   */
  export type AttendanceRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AttendanceRecords.
     */
    data: AttendanceRecordCreateManyInput | AttendanceRecordCreateManyInput[]
  }

  /**
   * AttendanceRecord createManyAndReturn
   */
  export type AttendanceRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * The data used to create many AttendanceRecords.
     */
    data: AttendanceRecordCreateManyInput | AttendanceRecordCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceRecord update
   */
  export type AttendanceRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a AttendanceRecord.
     */
    data: XOR<AttendanceRecordUpdateInput, AttendanceRecordUncheckedUpdateInput>
    /**
     * Choose, which AttendanceRecord to update.
     */
    where: AttendanceRecordWhereUniqueInput
  }

  /**
   * AttendanceRecord updateMany
   */
  export type AttendanceRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AttendanceRecords.
     */
    data: XOR<AttendanceRecordUpdateManyMutationInput, AttendanceRecordUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceRecords to update
     */
    where?: AttendanceRecordWhereInput
    /**
     * Limit how many AttendanceRecords to update.
     */
    limit?: number
  }

  /**
   * AttendanceRecord updateManyAndReturn
   */
  export type AttendanceRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * The data used to update AttendanceRecords.
     */
    data: XOR<AttendanceRecordUpdateManyMutationInput, AttendanceRecordUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceRecords to update
     */
    where?: AttendanceRecordWhereInput
    /**
     * Limit how many AttendanceRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceRecord upsert
   */
  export type AttendanceRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the AttendanceRecord to update in case it exists.
     */
    where: AttendanceRecordWhereUniqueInput
    /**
     * In case the AttendanceRecord found by the `where` argument doesn't exist, create a new AttendanceRecord with this data.
     */
    create: XOR<AttendanceRecordCreateInput, AttendanceRecordUncheckedCreateInput>
    /**
     * In case the AttendanceRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceRecordUpdateInput, AttendanceRecordUncheckedUpdateInput>
  }

  /**
   * AttendanceRecord delete
   */
  export type AttendanceRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter which AttendanceRecord to delete.
     */
    where: AttendanceRecordWhereUniqueInput
  }

  /**
   * AttendanceRecord deleteMany
   */
  export type AttendanceRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceRecords to delete
     */
    where?: AttendanceRecordWhereInput
    /**
     * Limit how many AttendanceRecords to delete.
     */
    limit?: number
  }

  /**
   * AttendanceRecord without action
   */
  export type AttendanceRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
  }


  /**
   * Model PayrollPeriod
   */

  export type AggregatePayrollPeriod = {
    _count: PayrollPeriodCountAggregateOutputType | null
    _avg: PayrollPeriodAvgAggregateOutputType | null
    _sum: PayrollPeriodSumAggregateOutputType | null
    _min: PayrollPeriodMinAggregateOutputType | null
    _max: PayrollPeriodMaxAggregateOutputType | null
  }

  export type PayrollPeriodAvgAggregateOutputType = {
    id: number | null
    obraId: number | null
    month: number | null
    year: number | null
    workingDays: number | null
  }

  export type PayrollPeriodSumAggregateOutputType = {
    id: number | null
    obraId: number | null
    month: number | null
    year: number | null
    workingDays: number | null
  }

  export type PayrollPeriodMinAggregateOutputType = {
    id: number | null
    obraId: number | null
    month: number | null
    year: number | null
    startDate: Date | null
    endDate: Date | null
    workingDays: number | null
    status: $Enums.PayrollPeriodStatus | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayrollPeriodMaxAggregateOutputType = {
    id: number | null
    obraId: number | null
    month: number | null
    year: number | null
    startDate: Date | null
    endDate: Date | null
    workingDays: number | null
    status: $Enums.PayrollPeriodStatus | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayrollPeriodCountAggregateOutputType = {
    id: number
    obraId: number
    month: number
    year: number
    startDate: number
    endDate: number
    workingDays: number
    status: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PayrollPeriodAvgAggregateInputType = {
    id?: true
    obraId?: true
    month?: true
    year?: true
    workingDays?: true
  }

  export type PayrollPeriodSumAggregateInputType = {
    id?: true
    obraId?: true
    month?: true
    year?: true
    workingDays?: true
  }

  export type PayrollPeriodMinAggregateInputType = {
    id?: true
    obraId?: true
    month?: true
    year?: true
    startDate?: true
    endDate?: true
    workingDays?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayrollPeriodMaxAggregateInputType = {
    id?: true
    obraId?: true
    month?: true
    year?: true
    startDate?: true
    endDate?: true
    workingDays?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayrollPeriodCountAggregateInputType = {
    id?: true
    obraId?: true
    month?: true
    year?: true
    startDate?: true
    endDate?: true
    workingDays?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PayrollPeriodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PayrollPeriod to aggregate.
     */
    where?: PayrollPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollPeriods to fetch.
     */
    orderBy?: PayrollPeriodOrderByWithRelationInput | PayrollPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PayrollPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PayrollPeriods
    **/
    _count?: true | PayrollPeriodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PayrollPeriodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PayrollPeriodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PayrollPeriodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PayrollPeriodMaxAggregateInputType
  }

  export type GetPayrollPeriodAggregateType<T extends PayrollPeriodAggregateArgs> = {
        [P in keyof T & keyof AggregatePayrollPeriod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayrollPeriod[P]>
      : GetScalarType<T[P], AggregatePayrollPeriod[P]>
  }




  export type PayrollPeriodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollPeriodWhereInput
    orderBy?: PayrollPeriodOrderByWithAggregationInput | PayrollPeriodOrderByWithAggregationInput[]
    by: PayrollPeriodScalarFieldEnum[] | PayrollPeriodScalarFieldEnum
    having?: PayrollPeriodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PayrollPeriodCountAggregateInputType | true
    _avg?: PayrollPeriodAvgAggregateInputType
    _sum?: PayrollPeriodSumAggregateInputType
    _min?: PayrollPeriodMinAggregateInputType
    _max?: PayrollPeriodMaxAggregateInputType
  }

  export type PayrollPeriodGroupByOutputType = {
    id: number
    obraId: number | null
    month: number
    year: number
    startDate: Date
    endDate: Date
    workingDays: number
    status: $Enums.PayrollPeriodStatus
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: PayrollPeriodCountAggregateOutputType | null
    _avg: PayrollPeriodAvgAggregateOutputType | null
    _sum: PayrollPeriodSumAggregateOutputType | null
    _min: PayrollPeriodMinAggregateOutputType | null
    _max: PayrollPeriodMaxAggregateOutputType | null
  }

  type GetPayrollPeriodGroupByPayload<T extends PayrollPeriodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PayrollPeriodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PayrollPeriodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PayrollPeriodGroupByOutputType[P]>
            : GetScalarType<T[P], PayrollPeriodGroupByOutputType[P]>
        }
      >
    >


  export type PayrollPeriodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    obraId?: boolean
    month?: boolean
    year?: boolean
    startDate?: boolean
    endDate?: boolean
    workingDays?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    obra?: boolean | PayrollPeriod$obraArgs<ExtArgs>
    entries?: boolean | PayrollPeriod$entriesArgs<ExtArgs>
    _count?: boolean | PayrollPeriodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payrollPeriod"]>

  export type PayrollPeriodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    obraId?: boolean
    month?: boolean
    year?: boolean
    startDate?: boolean
    endDate?: boolean
    workingDays?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    obra?: boolean | PayrollPeriod$obraArgs<ExtArgs>
  }, ExtArgs["result"]["payrollPeriod"]>

  export type PayrollPeriodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    obraId?: boolean
    month?: boolean
    year?: boolean
    startDate?: boolean
    endDate?: boolean
    workingDays?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    obra?: boolean | PayrollPeriod$obraArgs<ExtArgs>
  }, ExtArgs["result"]["payrollPeriod"]>

  export type PayrollPeriodSelectScalar = {
    id?: boolean
    obraId?: boolean
    month?: boolean
    year?: boolean
    startDate?: boolean
    endDate?: boolean
    workingDays?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PayrollPeriodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "obraId" | "month" | "year" | "startDate" | "endDate" | "workingDays" | "status" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["payrollPeriod"]>
  export type PayrollPeriodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    obra?: boolean | PayrollPeriod$obraArgs<ExtArgs>
    entries?: boolean | PayrollPeriod$entriesArgs<ExtArgs>
    _count?: boolean | PayrollPeriodCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PayrollPeriodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    obra?: boolean | PayrollPeriod$obraArgs<ExtArgs>
  }
  export type PayrollPeriodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    obra?: boolean | PayrollPeriod$obraArgs<ExtArgs>
  }

  export type $PayrollPeriodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PayrollPeriod"
    objects: {
      obra: Prisma.$ObraPayload<ExtArgs> | null
      entries: Prisma.$PayrollEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      obraId: number | null
      month: number
      year: number
      startDate: Date
      endDate: Date
      workingDays: number
      status: $Enums.PayrollPeriodStatus
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payrollPeriod"]>
    composites: {}
  }

  type PayrollPeriodGetPayload<S extends boolean | null | undefined | PayrollPeriodDefaultArgs> = $Result.GetResult<Prisma.$PayrollPeriodPayload, S>

  type PayrollPeriodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PayrollPeriodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PayrollPeriodCountAggregateInputType | true
    }

  export interface PayrollPeriodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PayrollPeriod'], meta: { name: 'PayrollPeriod' } }
    /**
     * Find zero or one PayrollPeriod that matches the filter.
     * @param {PayrollPeriodFindUniqueArgs} args - Arguments to find a PayrollPeriod
     * @example
     * // Get one PayrollPeriod
     * const payrollPeriod = await prisma.payrollPeriod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PayrollPeriodFindUniqueArgs>(args: SelectSubset<T, PayrollPeriodFindUniqueArgs<ExtArgs>>): Prisma__PayrollPeriodClient<$Result.GetResult<Prisma.$PayrollPeriodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PayrollPeriod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PayrollPeriodFindUniqueOrThrowArgs} args - Arguments to find a PayrollPeriod
     * @example
     * // Get one PayrollPeriod
     * const payrollPeriod = await prisma.payrollPeriod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PayrollPeriodFindUniqueOrThrowArgs>(args: SelectSubset<T, PayrollPeriodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PayrollPeriodClient<$Result.GetResult<Prisma.$PayrollPeriodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PayrollPeriod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollPeriodFindFirstArgs} args - Arguments to find a PayrollPeriod
     * @example
     * // Get one PayrollPeriod
     * const payrollPeriod = await prisma.payrollPeriod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PayrollPeriodFindFirstArgs>(args?: SelectSubset<T, PayrollPeriodFindFirstArgs<ExtArgs>>): Prisma__PayrollPeriodClient<$Result.GetResult<Prisma.$PayrollPeriodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PayrollPeriod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollPeriodFindFirstOrThrowArgs} args - Arguments to find a PayrollPeriod
     * @example
     * // Get one PayrollPeriod
     * const payrollPeriod = await prisma.payrollPeriod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PayrollPeriodFindFirstOrThrowArgs>(args?: SelectSubset<T, PayrollPeriodFindFirstOrThrowArgs<ExtArgs>>): Prisma__PayrollPeriodClient<$Result.GetResult<Prisma.$PayrollPeriodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PayrollPeriods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollPeriodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PayrollPeriods
     * const payrollPeriods = await prisma.payrollPeriod.findMany()
     * 
     * // Get first 10 PayrollPeriods
     * const payrollPeriods = await prisma.payrollPeriod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payrollPeriodWithIdOnly = await prisma.payrollPeriod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PayrollPeriodFindManyArgs>(args?: SelectSubset<T, PayrollPeriodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPeriodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PayrollPeriod.
     * @param {PayrollPeriodCreateArgs} args - Arguments to create a PayrollPeriod.
     * @example
     * // Create one PayrollPeriod
     * const PayrollPeriod = await prisma.payrollPeriod.create({
     *   data: {
     *     // ... data to create a PayrollPeriod
     *   }
     * })
     * 
     */
    create<T extends PayrollPeriodCreateArgs>(args: SelectSubset<T, PayrollPeriodCreateArgs<ExtArgs>>): Prisma__PayrollPeriodClient<$Result.GetResult<Prisma.$PayrollPeriodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PayrollPeriods.
     * @param {PayrollPeriodCreateManyArgs} args - Arguments to create many PayrollPeriods.
     * @example
     * // Create many PayrollPeriods
     * const payrollPeriod = await prisma.payrollPeriod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PayrollPeriodCreateManyArgs>(args?: SelectSubset<T, PayrollPeriodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PayrollPeriods and returns the data saved in the database.
     * @param {PayrollPeriodCreateManyAndReturnArgs} args - Arguments to create many PayrollPeriods.
     * @example
     * // Create many PayrollPeriods
     * const payrollPeriod = await prisma.payrollPeriod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PayrollPeriods and only return the `id`
     * const payrollPeriodWithIdOnly = await prisma.payrollPeriod.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PayrollPeriodCreateManyAndReturnArgs>(args?: SelectSubset<T, PayrollPeriodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPeriodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PayrollPeriod.
     * @param {PayrollPeriodDeleteArgs} args - Arguments to delete one PayrollPeriod.
     * @example
     * // Delete one PayrollPeriod
     * const PayrollPeriod = await prisma.payrollPeriod.delete({
     *   where: {
     *     // ... filter to delete one PayrollPeriod
     *   }
     * })
     * 
     */
    delete<T extends PayrollPeriodDeleteArgs>(args: SelectSubset<T, PayrollPeriodDeleteArgs<ExtArgs>>): Prisma__PayrollPeriodClient<$Result.GetResult<Prisma.$PayrollPeriodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PayrollPeriod.
     * @param {PayrollPeriodUpdateArgs} args - Arguments to update one PayrollPeriod.
     * @example
     * // Update one PayrollPeriod
     * const payrollPeriod = await prisma.payrollPeriod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PayrollPeriodUpdateArgs>(args: SelectSubset<T, PayrollPeriodUpdateArgs<ExtArgs>>): Prisma__PayrollPeriodClient<$Result.GetResult<Prisma.$PayrollPeriodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PayrollPeriods.
     * @param {PayrollPeriodDeleteManyArgs} args - Arguments to filter PayrollPeriods to delete.
     * @example
     * // Delete a few PayrollPeriods
     * const { count } = await prisma.payrollPeriod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PayrollPeriodDeleteManyArgs>(args?: SelectSubset<T, PayrollPeriodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PayrollPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollPeriodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PayrollPeriods
     * const payrollPeriod = await prisma.payrollPeriod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PayrollPeriodUpdateManyArgs>(args: SelectSubset<T, PayrollPeriodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PayrollPeriods and returns the data updated in the database.
     * @param {PayrollPeriodUpdateManyAndReturnArgs} args - Arguments to update many PayrollPeriods.
     * @example
     * // Update many PayrollPeriods
     * const payrollPeriod = await prisma.payrollPeriod.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PayrollPeriods and only return the `id`
     * const payrollPeriodWithIdOnly = await prisma.payrollPeriod.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PayrollPeriodUpdateManyAndReturnArgs>(args: SelectSubset<T, PayrollPeriodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPeriodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PayrollPeriod.
     * @param {PayrollPeriodUpsertArgs} args - Arguments to update or create a PayrollPeriod.
     * @example
     * // Update or create a PayrollPeriod
     * const payrollPeriod = await prisma.payrollPeriod.upsert({
     *   create: {
     *     // ... data to create a PayrollPeriod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PayrollPeriod we want to update
     *   }
     * })
     */
    upsert<T extends PayrollPeriodUpsertArgs>(args: SelectSubset<T, PayrollPeriodUpsertArgs<ExtArgs>>): Prisma__PayrollPeriodClient<$Result.GetResult<Prisma.$PayrollPeriodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PayrollPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollPeriodCountArgs} args - Arguments to filter PayrollPeriods to count.
     * @example
     * // Count the number of PayrollPeriods
     * const count = await prisma.payrollPeriod.count({
     *   where: {
     *     // ... the filter for the PayrollPeriods we want to count
     *   }
     * })
    **/
    count<T extends PayrollPeriodCountArgs>(
      args?: Subset<T, PayrollPeriodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PayrollPeriodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PayrollPeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollPeriodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PayrollPeriodAggregateArgs>(args: Subset<T, PayrollPeriodAggregateArgs>): Prisma.PrismaPromise<GetPayrollPeriodAggregateType<T>>

    /**
     * Group by PayrollPeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollPeriodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PayrollPeriodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PayrollPeriodGroupByArgs['orderBy'] }
        : { orderBy?: PayrollPeriodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PayrollPeriodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayrollPeriodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PayrollPeriod model
   */
  readonly fields: PayrollPeriodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PayrollPeriod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PayrollPeriodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    obra<T extends PayrollPeriod$obraArgs<ExtArgs> = {}>(args?: Subset<T, PayrollPeriod$obraArgs<ExtArgs>>): Prisma__ObraClient<$Result.GetResult<Prisma.$ObraPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    entries<T extends PayrollPeriod$entriesArgs<ExtArgs> = {}>(args?: Subset<T, PayrollPeriod$entriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PayrollPeriod model
   */
  interface PayrollPeriodFieldRefs {
    readonly id: FieldRef<"PayrollPeriod", 'Int'>
    readonly obraId: FieldRef<"PayrollPeriod", 'Int'>
    readonly month: FieldRef<"PayrollPeriod", 'Int'>
    readonly year: FieldRef<"PayrollPeriod", 'Int'>
    readonly startDate: FieldRef<"PayrollPeriod", 'DateTime'>
    readonly endDate: FieldRef<"PayrollPeriod", 'DateTime'>
    readonly workingDays: FieldRef<"PayrollPeriod", 'Int'>
    readonly status: FieldRef<"PayrollPeriod", 'PayrollPeriodStatus'>
    readonly notes: FieldRef<"PayrollPeriod", 'String'>
    readonly createdAt: FieldRef<"PayrollPeriod", 'DateTime'>
    readonly updatedAt: FieldRef<"PayrollPeriod", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PayrollPeriod findUnique
   */
  export type PayrollPeriodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriod
     */
    select?: PayrollPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollPeriod
     */
    omit?: PayrollPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollPeriodInclude<ExtArgs> | null
    /**
     * Filter, which PayrollPeriod to fetch.
     */
    where: PayrollPeriodWhereUniqueInput
  }

  /**
   * PayrollPeriod findUniqueOrThrow
   */
  export type PayrollPeriodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriod
     */
    select?: PayrollPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollPeriod
     */
    omit?: PayrollPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollPeriodInclude<ExtArgs> | null
    /**
     * Filter, which PayrollPeriod to fetch.
     */
    where: PayrollPeriodWhereUniqueInput
  }

  /**
   * PayrollPeriod findFirst
   */
  export type PayrollPeriodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriod
     */
    select?: PayrollPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollPeriod
     */
    omit?: PayrollPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollPeriodInclude<ExtArgs> | null
    /**
     * Filter, which PayrollPeriod to fetch.
     */
    where?: PayrollPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollPeriods to fetch.
     */
    orderBy?: PayrollPeriodOrderByWithRelationInput | PayrollPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PayrollPeriods.
     */
    cursor?: PayrollPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PayrollPeriods.
     */
    distinct?: PayrollPeriodScalarFieldEnum | PayrollPeriodScalarFieldEnum[]
  }

  /**
   * PayrollPeriod findFirstOrThrow
   */
  export type PayrollPeriodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriod
     */
    select?: PayrollPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollPeriod
     */
    omit?: PayrollPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollPeriodInclude<ExtArgs> | null
    /**
     * Filter, which PayrollPeriod to fetch.
     */
    where?: PayrollPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollPeriods to fetch.
     */
    orderBy?: PayrollPeriodOrderByWithRelationInput | PayrollPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PayrollPeriods.
     */
    cursor?: PayrollPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PayrollPeriods.
     */
    distinct?: PayrollPeriodScalarFieldEnum | PayrollPeriodScalarFieldEnum[]
  }

  /**
   * PayrollPeriod findMany
   */
  export type PayrollPeriodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriod
     */
    select?: PayrollPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollPeriod
     */
    omit?: PayrollPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollPeriodInclude<ExtArgs> | null
    /**
     * Filter, which PayrollPeriods to fetch.
     */
    where?: PayrollPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollPeriods to fetch.
     */
    orderBy?: PayrollPeriodOrderByWithRelationInput | PayrollPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PayrollPeriods.
     */
    cursor?: PayrollPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollPeriods.
     */
    skip?: number
    distinct?: PayrollPeriodScalarFieldEnum | PayrollPeriodScalarFieldEnum[]
  }

  /**
   * PayrollPeriod create
   */
  export type PayrollPeriodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriod
     */
    select?: PayrollPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollPeriod
     */
    omit?: PayrollPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollPeriodInclude<ExtArgs> | null
    /**
     * The data needed to create a PayrollPeriod.
     */
    data: XOR<PayrollPeriodCreateInput, PayrollPeriodUncheckedCreateInput>
  }

  /**
   * PayrollPeriod createMany
   */
  export type PayrollPeriodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PayrollPeriods.
     */
    data: PayrollPeriodCreateManyInput | PayrollPeriodCreateManyInput[]
  }

  /**
   * PayrollPeriod createManyAndReturn
   */
  export type PayrollPeriodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriod
     */
    select?: PayrollPeriodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollPeriod
     */
    omit?: PayrollPeriodOmit<ExtArgs> | null
    /**
     * The data used to create many PayrollPeriods.
     */
    data: PayrollPeriodCreateManyInput | PayrollPeriodCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollPeriodIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PayrollPeriod update
   */
  export type PayrollPeriodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriod
     */
    select?: PayrollPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollPeriod
     */
    omit?: PayrollPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollPeriodInclude<ExtArgs> | null
    /**
     * The data needed to update a PayrollPeriod.
     */
    data: XOR<PayrollPeriodUpdateInput, PayrollPeriodUncheckedUpdateInput>
    /**
     * Choose, which PayrollPeriod to update.
     */
    where: PayrollPeriodWhereUniqueInput
  }

  /**
   * PayrollPeriod updateMany
   */
  export type PayrollPeriodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PayrollPeriods.
     */
    data: XOR<PayrollPeriodUpdateManyMutationInput, PayrollPeriodUncheckedUpdateManyInput>
    /**
     * Filter which PayrollPeriods to update
     */
    where?: PayrollPeriodWhereInput
    /**
     * Limit how many PayrollPeriods to update.
     */
    limit?: number
  }

  /**
   * PayrollPeriod updateManyAndReturn
   */
  export type PayrollPeriodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriod
     */
    select?: PayrollPeriodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollPeriod
     */
    omit?: PayrollPeriodOmit<ExtArgs> | null
    /**
     * The data used to update PayrollPeriods.
     */
    data: XOR<PayrollPeriodUpdateManyMutationInput, PayrollPeriodUncheckedUpdateManyInput>
    /**
     * Filter which PayrollPeriods to update
     */
    where?: PayrollPeriodWhereInput
    /**
     * Limit how many PayrollPeriods to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollPeriodIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PayrollPeriod upsert
   */
  export type PayrollPeriodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriod
     */
    select?: PayrollPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollPeriod
     */
    omit?: PayrollPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollPeriodInclude<ExtArgs> | null
    /**
     * The filter to search for the PayrollPeriod to update in case it exists.
     */
    where: PayrollPeriodWhereUniqueInput
    /**
     * In case the PayrollPeriod found by the `where` argument doesn't exist, create a new PayrollPeriod with this data.
     */
    create: XOR<PayrollPeriodCreateInput, PayrollPeriodUncheckedCreateInput>
    /**
     * In case the PayrollPeriod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PayrollPeriodUpdateInput, PayrollPeriodUncheckedUpdateInput>
  }

  /**
   * PayrollPeriod delete
   */
  export type PayrollPeriodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriod
     */
    select?: PayrollPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollPeriod
     */
    omit?: PayrollPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollPeriodInclude<ExtArgs> | null
    /**
     * Filter which PayrollPeriod to delete.
     */
    where: PayrollPeriodWhereUniqueInput
  }

  /**
   * PayrollPeriod deleteMany
   */
  export type PayrollPeriodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PayrollPeriods to delete
     */
    where?: PayrollPeriodWhereInput
    /**
     * Limit how many PayrollPeriods to delete.
     */
    limit?: number
  }

  /**
   * PayrollPeriod.obra
   */
  export type PayrollPeriod$obraArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obra
     */
    select?: ObraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Obra
     */
    omit?: ObraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObraInclude<ExtArgs> | null
    where?: ObraWhereInput
  }

  /**
   * PayrollPeriod.entries
   */
  export type PayrollPeriod$entriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryInclude<ExtArgs> | null
    where?: PayrollEntryWhereInput
    orderBy?: PayrollEntryOrderByWithRelationInput | PayrollEntryOrderByWithRelationInput[]
    cursor?: PayrollEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayrollEntryScalarFieldEnum | PayrollEntryScalarFieldEnum[]
  }

  /**
   * PayrollPeriod without action
   */
  export type PayrollPeriodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriod
     */
    select?: PayrollPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollPeriod
     */
    omit?: PayrollPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollPeriodInclude<ExtArgs> | null
  }


  /**
   * Model PayrollEntry
   */

  export type AggregatePayrollEntry = {
    _count: PayrollEntryCountAggregateOutputType | null
    _avg: PayrollEntryAvgAggregateOutputType | null
    _sum: PayrollEntrySumAggregateOutputType | null
    _min: PayrollEntryMinAggregateOutputType | null
    _max: PayrollEntryMaxAggregateOutputType | null
  }

  export type PayrollEntryAvgAggregateOutputType = {
    id: number | null
    periodId: number | null
    employeeId: number | null
    baseSalary: Decimal | null
    dailyRate: Decimal | null
    hourlyRate: Decimal | null
    workedDays: number | null
    absenceDays: number | null
    tardinessMinutes: number | null
    permissionHours: Decimal | null
    overtimeHours: Decimal | null
    bonusesTotal: Decimal | null
    deductionsTotal: Decimal | null
    pensionAmount: Decimal | null
    healthAmount: Decimal | null
    grossEarnings: Decimal | null
    netPay: Decimal | null
    permissionDays: number | null
    holidayDays: number | null
    holidayBonus: Decimal | null
  }

  export type PayrollEntrySumAggregateOutputType = {
    id: number | null
    periodId: number | null
    employeeId: number | null
    baseSalary: Decimal | null
    dailyRate: Decimal | null
    hourlyRate: Decimal | null
    workedDays: number | null
    absenceDays: number | null
    tardinessMinutes: number | null
    permissionHours: Decimal | null
    overtimeHours: Decimal | null
    bonusesTotal: Decimal | null
    deductionsTotal: Decimal | null
    pensionAmount: Decimal | null
    healthAmount: Decimal | null
    grossEarnings: Decimal | null
    netPay: Decimal | null
    permissionDays: number | null
    holidayDays: number | null
    holidayBonus: Decimal | null
  }

  export type PayrollEntryMinAggregateOutputType = {
    id: number | null
    periodId: number | null
    employeeId: number | null
    baseSalary: Decimal | null
    dailyRate: Decimal | null
    hourlyRate: Decimal | null
    workedDays: number | null
    absenceDays: number | null
    tardinessMinutes: number | null
    permissionHours: Decimal | null
    overtimeHours: Decimal | null
    bonusesTotal: Decimal | null
    deductionsTotal: Decimal | null
    pensionAmount: Decimal | null
    healthAmount: Decimal | null
    grossEarnings: Decimal | null
    netPay: Decimal | null
    permissionDays: number | null
    holidayDays: number | null
    holidayBonus: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayrollEntryMaxAggregateOutputType = {
    id: number | null
    periodId: number | null
    employeeId: number | null
    baseSalary: Decimal | null
    dailyRate: Decimal | null
    hourlyRate: Decimal | null
    workedDays: number | null
    absenceDays: number | null
    tardinessMinutes: number | null
    permissionHours: Decimal | null
    overtimeHours: Decimal | null
    bonusesTotal: Decimal | null
    deductionsTotal: Decimal | null
    pensionAmount: Decimal | null
    healthAmount: Decimal | null
    grossEarnings: Decimal | null
    netPay: Decimal | null
    permissionDays: number | null
    holidayDays: number | null
    holidayBonus: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayrollEntryCountAggregateOutputType = {
    id: number
    periodId: number
    employeeId: number
    baseSalary: number
    dailyRate: number
    hourlyRate: number
    workedDays: number
    absenceDays: number
    tardinessMinutes: number
    permissionHours: number
    overtimeHours: number
    bonusesTotal: number
    deductionsTotal: number
    pensionAmount: number
    healthAmount: number
    grossEarnings: number
    netPay: number
    permissionDays: number
    holidayDays: number
    holidayBonus: number
    details: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PayrollEntryAvgAggregateInputType = {
    id?: true
    periodId?: true
    employeeId?: true
    baseSalary?: true
    dailyRate?: true
    hourlyRate?: true
    workedDays?: true
    absenceDays?: true
    tardinessMinutes?: true
    permissionHours?: true
    overtimeHours?: true
    bonusesTotal?: true
    deductionsTotal?: true
    pensionAmount?: true
    healthAmount?: true
    grossEarnings?: true
    netPay?: true
    permissionDays?: true
    holidayDays?: true
    holidayBonus?: true
  }

  export type PayrollEntrySumAggregateInputType = {
    id?: true
    periodId?: true
    employeeId?: true
    baseSalary?: true
    dailyRate?: true
    hourlyRate?: true
    workedDays?: true
    absenceDays?: true
    tardinessMinutes?: true
    permissionHours?: true
    overtimeHours?: true
    bonusesTotal?: true
    deductionsTotal?: true
    pensionAmount?: true
    healthAmount?: true
    grossEarnings?: true
    netPay?: true
    permissionDays?: true
    holidayDays?: true
    holidayBonus?: true
  }

  export type PayrollEntryMinAggregateInputType = {
    id?: true
    periodId?: true
    employeeId?: true
    baseSalary?: true
    dailyRate?: true
    hourlyRate?: true
    workedDays?: true
    absenceDays?: true
    tardinessMinutes?: true
    permissionHours?: true
    overtimeHours?: true
    bonusesTotal?: true
    deductionsTotal?: true
    pensionAmount?: true
    healthAmount?: true
    grossEarnings?: true
    netPay?: true
    permissionDays?: true
    holidayDays?: true
    holidayBonus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayrollEntryMaxAggregateInputType = {
    id?: true
    periodId?: true
    employeeId?: true
    baseSalary?: true
    dailyRate?: true
    hourlyRate?: true
    workedDays?: true
    absenceDays?: true
    tardinessMinutes?: true
    permissionHours?: true
    overtimeHours?: true
    bonusesTotal?: true
    deductionsTotal?: true
    pensionAmount?: true
    healthAmount?: true
    grossEarnings?: true
    netPay?: true
    permissionDays?: true
    holidayDays?: true
    holidayBonus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayrollEntryCountAggregateInputType = {
    id?: true
    periodId?: true
    employeeId?: true
    baseSalary?: true
    dailyRate?: true
    hourlyRate?: true
    workedDays?: true
    absenceDays?: true
    tardinessMinutes?: true
    permissionHours?: true
    overtimeHours?: true
    bonusesTotal?: true
    deductionsTotal?: true
    pensionAmount?: true
    healthAmount?: true
    grossEarnings?: true
    netPay?: true
    permissionDays?: true
    holidayDays?: true
    holidayBonus?: true
    details?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PayrollEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PayrollEntry to aggregate.
     */
    where?: PayrollEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollEntries to fetch.
     */
    orderBy?: PayrollEntryOrderByWithRelationInput | PayrollEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PayrollEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PayrollEntries
    **/
    _count?: true | PayrollEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PayrollEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PayrollEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PayrollEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PayrollEntryMaxAggregateInputType
  }

  export type GetPayrollEntryAggregateType<T extends PayrollEntryAggregateArgs> = {
        [P in keyof T & keyof AggregatePayrollEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayrollEntry[P]>
      : GetScalarType<T[P], AggregatePayrollEntry[P]>
  }




  export type PayrollEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollEntryWhereInput
    orderBy?: PayrollEntryOrderByWithAggregationInput | PayrollEntryOrderByWithAggregationInput[]
    by: PayrollEntryScalarFieldEnum[] | PayrollEntryScalarFieldEnum
    having?: PayrollEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PayrollEntryCountAggregateInputType | true
    _avg?: PayrollEntryAvgAggregateInputType
    _sum?: PayrollEntrySumAggregateInputType
    _min?: PayrollEntryMinAggregateInputType
    _max?: PayrollEntryMaxAggregateInputType
  }

  export type PayrollEntryGroupByOutputType = {
    id: number
    periodId: number
    employeeId: number
    baseSalary: Decimal
    dailyRate: Decimal
    hourlyRate: Decimal
    workedDays: number
    absenceDays: number
    tardinessMinutes: number
    permissionHours: Decimal
    overtimeHours: Decimal
    bonusesTotal: Decimal
    deductionsTotal: Decimal
    pensionAmount: Decimal
    healthAmount: Decimal
    grossEarnings: Decimal
    netPay: Decimal
    permissionDays: number
    holidayDays: number
    holidayBonus: Decimal
    details: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: PayrollEntryCountAggregateOutputType | null
    _avg: PayrollEntryAvgAggregateOutputType | null
    _sum: PayrollEntrySumAggregateOutputType | null
    _min: PayrollEntryMinAggregateOutputType | null
    _max: PayrollEntryMaxAggregateOutputType | null
  }

  type GetPayrollEntryGroupByPayload<T extends PayrollEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PayrollEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PayrollEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PayrollEntryGroupByOutputType[P]>
            : GetScalarType<T[P], PayrollEntryGroupByOutputType[P]>
        }
      >
    >


  export type PayrollEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    periodId?: boolean
    employeeId?: boolean
    baseSalary?: boolean
    dailyRate?: boolean
    hourlyRate?: boolean
    workedDays?: boolean
    absenceDays?: boolean
    tardinessMinutes?: boolean
    permissionHours?: boolean
    overtimeHours?: boolean
    bonusesTotal?: boolean
    deductionsTotal?: boolean
    pensionAmount?: boolean
    healthAmount?: boolean
    grossEarnings?: boolean
    netPay?: boolean
    permissionDays?: boolean
    holidayDays?: boolean
    holidayBonus?: boolean
    details?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    period?: boolean | PayrollPeriodDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    adjustments?: boolean | PayrollEntry$adjustmentsArgs<ExtArgs>
    _count?: boolean | PayrollEntryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payrollEntry"]>

  export type PayrollEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    periodId?: boolean
    employeeId?: boolean
    baseSalary?: boolean
    dailyRate?: boolean
    hourlyRate?: boolean
    workedDays?: boolean
    absenceDays?: boolean
    tardinessMinutes?: boolean
    permissionHours?: boolean
    overtimeHours?: boolean
    bonusesTotal?: boolean
    deductionsTotal?: boolean
    pensionAmount?: boolean
    healthAmount?: boolean
    grossEarnings?: boolean
    netPay?: boolean
    permissionDays?: boolean
    holidayDays?: boolean
    holidayBonus?: boolean
    details?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    period?: boolean | PayrollPeriodDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payrollEntry"]>

  export type PayrollEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    periodId?: boolean
    employeeId?: boolean
    baseSalary?: boolean
    dailyRate?: boolean
    hourlyRate?: boolean
    workedDays?: boolean
    absenceDays?: boolean
    tardinessMinutes?: boolean
    permissionHours?: boolean
    overtimeHours?: boolean
    bonusesTotal?: boolean
    deductionsTotal?: boolean
    pensionAmount?: boolean
    healthAmount?: boolean
    grossEarnings?: boolean
    netPay?: boolean
    permissionDays?: boolean
    holidayDays?: boolean
    holidayBonus?: boolean
    details?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    period?: boolean | PayrollPeriodDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payrollEntry"]>

  export type PayrollEntrySelectScalar = {
    id?: boolean
    periodId?: boolean
    employeeId?: boolean
    baseSalary?: boolean
    dailyRate?: boolean
    hourlyRate?: boolean
    workedDays?: boolean
    absenceDays?: boolean
    tardinessMinutes?: boolean
    permissionHours?: boolean
    overtimeHours?: boolean
    bonusesTotal?: boolean
    deductionsTotal?: boolean
    pensionAmount?: boolean
    healthAmount?: boolean
    grossEarnings?: boolean
    netPay?: boolean
    permissionDays?: boolean
    holidayDays?: boolean
    holidayBonus?: boolean
    details?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PayrollEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "periodId" | "employeeId" | "baseSalary" | "dailyRate" | "hourlyRate" | "workedDays" | "absenceDays" | "tardinessMinutes" | "permissionHours" | "overtimeHours" | "bonusesTotal" | "deductionsTotal" | "pensionAmount" | "healthAmount" | "grossEarnings" | "netPay" | "permissionDays" | "holidayDays" | "holidayBonus" | "details" | "createdAt" | "updatedAt", ExtArgs["result"]["payrollEntry"]>
  export type PayrollEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    period?: boolean | PayrollPeriodDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    adjustments?: boolean | PayrollEntry$adjustmentsArgs<ExtArgs>
    _count?: boolean | PayrollEntryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PayrollEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    period?: boolean | PayrollPeriodDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type PayrollEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    period?: boolean | PayrollPeriodDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $PayrollEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PayrollEntry"
    objects: {
      period: Prisma.$PayrollPeriodPayload<ExtArgs>
      employee: Prisma.$EmployeePayload<ExtArgs>
      adjustments: Prisma.$PayrollAdjustmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      periodId: number
      employeeId: number
      baseSalary: Prisma.Decimal
      dailyRate: Prisma.Decimal
      hourlyRate: Prisma.Decimal
      workedDays: number
      absenceDays: number
      tardinessMinutes: number
      permissionHours: Prisma.Decimal
      overtimeHours: Prisma.Decimal
      bonusesTotal: Prisma.Decimal
      deductionsTotal: Prisma.Decimal
      pensionAmount: Prisma.Decimal
      healthAmount: Prisma.Decimal
      grossEarnings: Prisma.Decimal
      netPay: Prisma.Decimal
      permissionDays: number
      holidayDays: number
      holidayBonus: Prisma.Decimal
      details: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payrollEntry"]>
    composites: {}
  }

  type PayrollEntryGetPayload<S extends boolean | null | undefined | PayrollEntryDefaultArgs> = $Result.GetResult<Prisma.$PayrollEntryPayload, S>

  type PayrollEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PayrollEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PayrollEntryCountAggregateInputType | true
    }

  export interface PayrollEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PayrollEntry'], meta: { name: 'PayrollEntry' } }
    /**
     * Find zero or one PayrollEntry that matches the filter.
     * @param {PayrollEntryFindUniqueArgs} args - Arguments to find a PayrollEntry
     * @example
     * // Get one PayrollEntry
     * const payrollEntry = await prisma.payrollEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PayrollEntryFindUniqueArgs>(args: SelectSubset<T, PayrollEntryFindUniqueArgs<ExtArgs>>): Prisma__PayrollEntryClient<$Result.GetResult<Prisma.$PayrollEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PayrollEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PayrollEntryFindUniqueOrThrowArgs} args - Arguments to find a PayrollEntry
     * @example
     * // Get one PayrollEntry
     * const payrollEntry = await prisma.payrollEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PayrollEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, PayrollEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PayrollEntryClient<$Result.GetResult<Prisma.$PayrollEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PayrollEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollEntryFindFirstArgs} args - Arguments to find a PayrollEntry
     * @example
     * // Get one PayrollEntry
     * const payrollEntry = await prisma.payrollEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PayrollEntryFindFirstArgs>(args?: SelectSubset<T, PayrollEntryFindFirstArgs<ExtArgs>>): Prisma__PayrollEntryClient<$Result.GetResult<Prisma.$PayrollEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PayrollEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollEntryFindFirstOrThrowArgs} args - Arguments to find a PayrollEntry
     * @example
     * // Get one PayrollEntry
     * const payrollEntry = await prisma.payrollEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PayrollEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, PayrollEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__PayrollEntryClient<$Result.GetResult<Prisma.$PayrollEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PayrollEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PayrollEntries
     * const payrollEntries = await prisma.payrollEntry.findMany()
     * 
     * // Get first 10 PayrollEntries
     * const payrollEntries = await prisma.payrollEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payrollEntryWithIdOnly = await prisma.payrollEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PayrollEntryFindManyArgs>(args?: SelectSubset<T, PayrollEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PayrollEntry.
     * @param {PayrollEntryCreateArgs} args - Arguments to create a PayrollEntry.
     * @example
     * // Create one PayrollEntry
     * const PayrollEntry = await prisma.payrollEntry.create({
     *   data: {
     *     // ... data to create a PayrollEntry
     *   }
     * })
     * 
     */
    create<T extends PayrollEntryCreateArgs>(args: SelectSubset<T, PayrollEntryCreateArgs<ExtArgs>>): Prisma__PayrollEntryClient<$Result.GetResult<Prisma.$PayrollEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PayrollEntries.
     * @param {PayrollEntryCreateManyArgs} args - Arguments to create many PayrollEntries.
     * @example
     * // Create many PayrollEntries
     * const payrollEntry = await prisma.payrollEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PayrollEntryCreateManyArgs>(args?: SelectSubset<T, PayrollEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PayrollEntries and returns the data saved in the database.
     * @param {PayrollEntryCreateManyAndReturnArgs} args - Arguments to create many PayrollEntries.
     * @example
     * // Create many PayrollEntries
     * const payrollEntry = await prisma.payrollEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PayrollEntries and only return the `id`
     * const payrollEntryWithIdOnly = await prisma.payrollEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PayrollEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, PayrollEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PayrollEntry.
     * @param {PayrollEntryDeleteArgs} args - Arguments to delete one PayrollEntry.
     * @example
     * // Delete one PayrollEntry
     * const PayrollEntry = await prisma.payrollEntry.delete({
     *   where: {
     *     // ... filter to delete one PayrollEntry
     *   }
     * })
     * 
     */
    delete<T extends PayrollEntryDeleteArgs>(args: SelectSubset<T, PayrollEntryDeleteArgs<ExtArgs>>): Prisma__PayrollEntryClient<$Result.GetResult<Prisma.$PayrollEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PayrollEntry.
     * @param {PayrollEntryUpdateArgs} args - Arguments to update one PayrollEntry.
     * @example
     * // Update one PayrollEntry
     * const payrollEntry = await prisma.payrollEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PayrollEntryUpdateArgs>(args: SelectSubset<T, PayrollEntryUpdateArgs<ExtArgs>>): Prisma__PayrollEntryClient<$Result.GetResult<Prisma.$PayrollEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PayrollEntries.
     * @param {PayrollEntryDeleteManyArgs} args - Arguments to filter PayrollEntries to delete.
     * @example
     * // Delete a few PayrollEntries
     * const { count } = await prisma.payrollEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PayrollEntryDeleteManyArgs>(args?: SelectSubset<T, PayrollEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PayrollEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PayrollEntries
     * const payrollEntry = await prisma.payrollEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PayrollEntryUpdateManyArgs>(args: SelectSubset<T, PayrollEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PayrollEntries and returns the data updated in the database.
     * @param {PayrollEntryUpdateManyAndReturnArgs} args - Arguments to update many PayrollEntries.
     * @example
     * // Update many PayrollEntries
     * const payrollEntry = await prisma.payrollEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PayrollEntries and only return the `id`
     * const payrollEntryWithIdOnly = await prisma.payrollEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PayrollEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, PayrollEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PayrollEntry.
     * @param {PayrollEntryUpsertArgs} args - Arguments to update or create a PayrollEntry.
     * @example
     * // Update or create a PayrollEntry
     * const payrollEntry = await prisma.payrollEntry.upsert({
     *   create: {
     *     // ... data to create a PayrollEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PayrollEntry we want to update
     *   }
     * })
     */
    upsert<T extends PayrollEntryUpsertArgs>(args: SelectSubset<T, PayrollEntryUpsertArgs<ExtArgs>>): Prisma__PayrollEntryClient<$Result.GetResult<Prisma.$PayrollEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PayrollEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollEntryCountArgs} args - Arguments to filter PayrollEntries to count.
     * @example
     * // Count the number of PayrollEntries
     * const count = await prisma.payrollEntry.count({
     *   where: {
     *     // ... the filter for the PayrollEntries we want to count
     *   }
     * })
    **/
    count<T extends PayrollEntryCountArgs>(
      args?: Subset<T, PayrollEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PayrollEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PayrollEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PayrollEntryAggregateArgs>(args: Subset<T, PayrollEntryAggregateArgs>): Prisma.PrismaPromise<GetPayrollEntryAggregateType<T>>

    /**
     * Group by PayrollEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PayrollEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PayrollEntryGroupByArgs['orderBy'] }
        : { orderBy?: PayrollEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PayrollEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayrollEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PayrollEntry model
   */
  readonly fields: PayrollEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PayrollEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PayrollEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    period<T extends PayrollPeriodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PayrollPeriodDefaultArgs<ExtArgs>>): Prisma__PayrollPeriodClient<$Result.GetResult<Prisma.$PayrollPeriodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    adjustments<T extends PayrollEntry$adjustmentsArgs<ExtArgs> = {}>(args?: Subset<T, PayrollEntry$adjustmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollAdjustmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PayrollEntry model
   */
  interface PayrollEntryFieldRefs {
    readonly id: FieldRef<"PayrollEntry", 'Int'>
    readonly periodId: FieldRef<"PayrollEntry", 'Int'>
    readonly employeeId: FieldRef<"PayrollEntry", 'Int'>
    readonly baseSalary: FieldRef<"PayrollEntry", 'Decimal'>
    readonly dailyRate: FieldRef<"PayrollEntry", 'Decimal'>
    readonly hourlyRate: FieldRef<"PayrollEntry", 'Decimal'>
    readonly workedDays: FieldRef<"PayrollEntry", 'Int'>
    readonly absenceDays: FieldRef<"PayrollEntry", 'Int'>
    readonly tardinessMinutes: FieldRef<"PayrollEntry", 'Int'>
    readonly permissionHours: FieldRef<"PayrollEntry", 'Decimal'>
    readonly overtimeHours: FieldRef<"PayrollEntry", 'Decimal'>
    readonly bonusesTotal: FieldRef<"PayrollEntry", 'Decimal'>
    readonly deductionsTotal: FieldRef<"PayrollEntry", 'Decimal'>
    readonly pensionAmount: FieldRef<"PayrollEntry", 'Decimal'>
    readonly healthAmount: FieldRef<"PayrollEntry", 'Decimal'>
    readonly grossEarnings: FieldRef<"PayrollEntry", 'Decimal'>
    readonly netPay: FieldRef<"PayrollEntry", 'Decimal'>
    readonly permissionDays: FieldRef<"PayrollEntry", 'Int'>
    readonly holidayDays: FieldRef<"PayrollEntry", 'Int'>
    readonly holidayBonus: FieldRef<"PayrollEntry", 'Decimal'>
    readonly details: FieldRef<"PayrollEntry", 'Json'>
    readonly createdAt: FieldRef<"PayrollEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"PayrollEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PayrollEntry findUnique
   */
  export type PayrollEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryInclude<ExtArgs> | null
    /**
     * Filter, which PayrollEntry to fetch.
     */
    where: PayrollEntryWhereUniqueInput
  }

  /**
   * PayrollEntry findUniqueOrThrow
   */
  export type PayrollEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryInclude<ExtArgs> | null
    /**
     * Filter, which PayrollEntry to fetch.
     */
    where: PayrollEntryWhereUniqueInput
  }

  /**
   * PayrollEntry findFirst
   */
  export type PayrollEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryInclude<ExtArgs> | null
    /**
     * Filter, which PayrollEntry to fetch.
     */
    where?: PayrollEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollEntries to fetch.
     */
    orderBy?: PayrollEntryOrderByWithRelationInput | PayrollEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PayrollEntries.
     */
    cursor?: PayrollEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PayrollEntries.
     */
    distinct?: PayrollEntryScalarFieldEnum | PayrollEntryScalarFieldEnum[]
  }

  /**
   * PayrollEntry findFirstOrThrow
   */
  export type PayrollEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryInclude<ExtArgs> | null
    /**
     * Filter, which PayrollEntry to fetch.
     */
    where?: PayrollEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollEntries to fetch.
     */
    orderBy?: PayrollEntryOrderByWithRelationInput | PayrollEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PayrollEntries.
     */
    cursor?: PayrollEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PayrollEntries.
     */
    distinct?: PayrollEntryScalarFieldEnum | PayrollEntryScalarFieldEnum[]
  }

  /**
   * PayrollEntry findMany
   */
  export type PayrollEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryInclude<ExtArgs> | null
    /**
     * Filter, which PayrollEntries to fetch.
     */
    where?: PayrollEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollEntries to fetch.
     */
    orderBy?: PayrollEntryOrderByWithRelationInput | PayrollEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PayrollEntries.
     */
    cursor?: PayrollEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollEntries.
     */
    skip?: number
    distinct?: PayrollEntryScalarFieldEnum | PayrollEntryScalarFieldEnum[]
  }

  /**
   * PayrollEntry create
   */
  export type PayrollEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a PayrollEntry.
     */
    data: XOR<PayrollEntryCreateInput, PayrollEntryUncheckedCreateInput>
  }

  /**
   * PayrollEntry createMany
   */
  export type PayrollEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PayrollEntries.
     */
    data: PayrollEntryCreateManyInput | PayrollEntryCreateManyInput[]
  }

  /**
   * PayrollEntry createManyAndReturn
   */
  export type PayrollEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * The data used to create many PayrollEntries.
     */
    data: PayrollEntryCreateManyInput | PayrollEntryCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PayrollEntry update
   */
  export type PayrollEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a PayrollEntry.
     */
    data: XOR<PayrollEntryUpdateInput, PayrollEntryUncheckedUpdateInput>
    /**
     * Choose, which PayrollEntry to update.
     */
    where: PayrollEntryWhereUniqueInput
  }

  /**
   * PayrollEntry updateMany
   */
  export type PayrollEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PayrollEntries.
     */
    data: XOR<PayrollEntryUpdateManyMutationInput, PayrollEntryUncheckedUpdateManyInput>
    /**
     * Filter which PayrollEntries to update
     */
    where?: PayrollEntryWhereInput
    /**
     * Limit how many PayrollEntries to update.
     */
    limit?: number
  }

  /**
   * PayrollEntry updateManyAndReturn
   */
  export type PayrollEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * The data used to update PayrollEntries.
     */
    data: XOR<PayrollEntryUpdateManyMutationInput, PayrollEntryUncheckedUpdateManyInput>
    /**
     * Filter which PayrollEntries to update
     */
    where?: PayrollEntryWhereInput
    /**
     * Limit how many PayrollEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PayrollEntry upsert
   */
  export type PayrollEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the PayrollEntry to update in case it exists.
     */
    where: PayrollEntryWhereUniqueInput
    /**
     * In case the PayrollEntry found by the `where` argument doesn't exist, create a new PayrollEntry with this data.
     */
    create: XOR<PayrollEntryCreateInput, PayrollEntryUncheckedCreateInput>
    /**
     * In case the PayrollEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PayrollEntryUpdateInput, PayrollEntryUncheckedUpdateInput>
  }

  /**
   * PayrollEntry delete
   */
  export type PayrollEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryInclude<ExtArgs> | null
    /**
     * Filter which PayrollEntry to delete.
     */
    where: PayrollEntryWhereUniqueInput
  }

  /**
   * PayrollEntry deleteMany
   */
  export type PayrollEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PayrollEntries to delete
     */
    where?: PayrollEntryWhereInput
    /**
     * Limit how many PayrollEntries to delete.
     */
    limit?: number
  }

  /**
   * PayrollEntry.adjustments
   */
  export type PayrollEntry$adjustmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollAdjustment
     */
    select?: PayrollAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollAdjustment
     */
    omit?: PayrollAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollAdjustmentInclude<ExtArgs> | null
    where?: PayrollAdjustmentWhereInput
    orderBy?: PayrollAdjustmentOrderByWithRelationInput | PayrollAdjustmentOrderByWithRelationInput[]
    cursor?: PayrollAdjustmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayrollAdjustmentScalarFieldEnum | PayrollAdjustmentScalarFieldEnum[]
  }

  /**
   * PayrollEntry without action
   */
  export type PayrollEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryInclude<ExtArgs> | null
  }


  /**
   * Model PayrollAdjustment
   */

  export type AggregatePayrollAdjustment = {
    _count: PayrollAdjustmentCountAggregateOutputType | null
    _avg: PayrollAdjustmentAvgAggregateOutputType | null
    _sum: PayrollAdjustmentSumAggregateOutputType | null
    _min: PayrollAdjustmentMinAggregateOutputType | null
    _max: PayrollAdjustmentMaxAggregateOutputType | null
  }

  export type PayrollAdjustmentAvgAggregateOutputType = {
    id: number | null
    entryId: number | null
    amount: Decimal | null
  }

  export type PayrollAdjustmentSumAggregateOutputType = {
    id: number | null
    entryId: number | null
    amount: Decimal | null
  }

  export type PayrollAdjustmentMinAggregateOutputType = {
    id: number | null
    entryId: number | null
    type: $Enums.PayrollAdjustmentType | null
    concept: string | null
    amount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayrollAdjustmentMaxAggregateOutputType = {
    id: number | null
    entryId: number | null
    type: $Enums.PayrollAdjustmentType | null
    concept: string | null
    amount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayrollAdjustmentCountAggregateOutputType = {
    id: number
    entryId: number
    type: number
    concept: number
    amount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PayrollAdjustmentAvgAggregateInputType = {
    id?: true
    entryId?: true
    amount?: true
  }

  export type PayrollAdjustmentSumAggregateInputType = {
    id?: true
    entryId?: true
    amount?: true
  }

  export type PayrollAdjustmentMinAggregateInputType = {
    id?: true
    entryId?: true
    type?: true
    concept?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayrollAdjustmentMaxAggregateInputType = {
    id?: true
    entryId?: true
    type?: true
    concept?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayrollAdjustmentCountAggregateInputType = {
    id?: true
    entryId?: true
    type?: true
    concept?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PayrollAdjustmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PayrollAdjustment to aggregate.
     */
    where?: PayrollAdjustmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollAdjustments to fetch.
     */
    orderBy?: PayrollAdjustmentOrderByWithRelationInput | PayrollAdjustmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PayrollAdjustmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollAdjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollAdjustments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PayrollAdjustments
    **/
    _count?: true | PayrollAdjustmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PayrollAdjustmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PayrollAdjustmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PayrollAdjustmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PayrollAdjustmentMaxAggregateInputType
  }

  export type GetPayrollAdjustmentAggregateType<T extends PayrollAdjustmentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayrollAdjustment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayrollAdjustment[P]>
      : GetScalarType<T[P], AggregatePayrollAdjustment[P]>
  }




  export type PayrollAdjustmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollAdjustmentWhereInput
    orderBy?: PayrollAdjustmentOrderByWithAggregationInput | PayrollAdjustmentOrderByWithAggregationInput[]
    by: PayrollAdjustmentScalarFieldEnum[] | PayrollAdjustmentScalarFieldEnum
    having?: PayrollAdjustmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PayrollAdjustmentCountAggregateInputType | true
    _avg?: PayrollAdjustmentAvgAggregateInputType
    _sum?: PayrollAdjustmentSumAggregateInputType
    _min?: PayrollAdjustmentMinAggregateInputType
    _max?: PayrollAdjustmentMaxAggregateInputType
  }

  export type PayrollAdjustmentGroupByOutputType = {
    id: number
    entryId: number
    type: $Enums.PayrollAdjustmentType
    concept: string
    amount: Decimal
    createdAt: Date
    updatedAt: Date
    _count: PayrollAdjustmentCountAggregateOutputType | null
    _avg: PayrollAdjustmentAvgAggregateOutputType | null
    _sum: PayrollAdjustmentSumAggregateOutputType | null
    _min: PayrollAdjustmentMinAggregateOutputType | null
    _max: PayrollAdjustmentMaxAggregateOutputType | null
  }

  type GetPayrollAdjustmentGroupByPayload<T extends PayrollAdjustmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PayrollAdjustmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PayrollAdjustmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PayrollAdjustmentGroupByOutputType[P]>
            : GetScalarType<T[P], PayrollAdjustmentGroupByOutputType[P]>
        }
      >
    >


  export type PayrollAdjustmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entryId?: boolean
    type?: boolean
    concept?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    entry?: boolean | PayrollEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payrollAdjustment"]>

  export type PayrollAdjustmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entryId?: boolean
    type?: boolean
    concept?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    entry?: boolean | PayrollEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payrollAdjustment"]>

  export type PayrollAdjustmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entryId?: boolean
    type?: boolean
    concept?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    entry?: boolean | PayrollEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payrollAdjustment"]>

  export type PayrollAdjustmentSelectScalar = {
    id?: boolean
    entryId?: boolean
    type?: boolean
    concept?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PayrollAdjustmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entryId" | "type" | "concept" | "amount" | "createdAt" | "updatedAt", ExtArgs["result"]["payrollAdjustment"]>
  export type PayrollAdjustmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entry?: boolean | PayrollEntryDefaultArgs<ExtArgs>
  }
  export type PayrollAdjustmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entry?: boolean | PayrollEntryDefaultArgs<ExtArgs>
  }
  export type PayrollAdjustmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entry?: boolean | PayrollEntryDefaultArgs<ExtArgs>
  }

  export type $PayrollAdjustmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PayrollAdjustment"
    objects: {
      entry: Prisma.$PayrollEntryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      entryId: number
      type: $Enums.PayrollAdjustmentType
      concept: string
      amount: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payrollAdjustment"]>
    composites: {}
  }

  type PayrollAdjustmentGetPayload<S extends boolean | null | undefined | PayrollAdjustmentDefaultArgs> = $Result.GetResult<Prisma.$PayrollAdjustmentPayload, S>

  type PayrollAdjustmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PayrollAdjustmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PayrollAdjustmentCountAggregateInputType | true
    }

  export interface PayrollAdjustmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PayrollAdjustment'], meta: { name: 'PayrollAdjustment' } }
    /**
     * Find zero or one PayrollAdjustment that matches the filter.
     * @param {PayrollAdjustmentFindUniqueArgs} args - Arguments to find a PayrollAdjustment
     * @example
     * // Get one PayrollAdjustment
     * const payrollAdjustment = await prisma.payrollAdjustment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PayrollAdjustmentFindUniqueArgs>(args: SelectSubset<T, PayrollAdjustmentFindUniqueArgs<ExtArgs>>): Prisma__PayrollAdjustmentClient<$Result.GetResult<Prisma.$PayrollAdjustmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PayrollAdjustment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PayrollAdjustmentFindUniqueOrThrowArgs} args - Arguments to find a PayrollAdjustment
     * @example
     * // Get one PayrollAdjustment
     * const payrollAdjustment = await prisma.payrollAdjustment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PayrollAdjustmentFindUniqueOrThrowArgs>(args: SelectSubset<T, PayrollAdjustmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PayrollAdjustmentClient<$Result.GetResult<Prisma.$PayrollAdjustmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PayrollAdjustment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollAdjustmentFindFirstArgs} args - Arguments to find a PayrollAdjustment
     * @example
     * // Get one PayrollAdjustment
     * const payrollAdjustment = await prisma.payrollAdjustment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PayrollAdjustmentFindFirstArgs>(args?: SelectSubset<T, PayrollAdjustmentFindFirstArgs<ExtArgs>>): Prisma__PayrollAdjustmentClient<$Result.GetResult<Prisma.$PayrollAdjustmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PayrollAdjustment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollAdjustmentFindFirstOrThrowArgs} args - Arguments to find a PayrollAdjustment
     * @example
     * // Get one PayrollAdjustment
     * const payrollAdjustment = await prisma.payrollAdjustment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PayrollAdjustmentFindFirstOrThrowArgs>(args?: SelectSubset<T, PayrollAdjustmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PayrollAdjustmentClient<$Result.GetResult<Prisma.$PayrollAdjustmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PayrollAdjustments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollAdjustmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PayrollAdjustments
     * const payrollAdjustments = await prisma.payrollAdjustment.findMany()
     * 
     * // Get first 10 PayrollAdjustments
     * const payrollAdjustments = await prisma.payrollAdjustment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payrollAdjustmentWithIdOnly = await prisma.payrollAdjustment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PayrollAdjustmentFindManyArgs>(args?: SelectSubset<T, PayrollAdjustmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollAdjustmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PayrollAdjustment.
     * @param {PayrollAdjustmentCreateArgs} args - Arguments to create a PayrollAdjustment.
     * @example
     * // Create one PayrollAdjustment
     * const PayrollAdjustment = await prisma.payrollAdjustment.create({
     *   data: {
     *     // ... data to create a PayrollAdjustment
     *   }
     * })
     * 
     */
    create<T extends PayrollAdjustmentCreateArgs>(args: SelectSubset<T, PayrollAdjustmentCreateArgs<ExtArgs>>): Prisma__PayrollAdjustmentClient<$Result.GetResult<Prisma.$PayrollAdjustmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PayrollAdjustments.
     * @param {PayrollAdjustmentCreateManyArgs} args - Arguments to create many PayrollAdjustments.
     * @example
     * // Create many PayrollAdjustments
     * const payrollAdjustment = await prisma.payrollAdjustment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PayrollAdjustmentCreateManyArgs>(args?: SelectSubset<T, PayrollAdjustmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PayrollAdjustments and returns the data saved in the database.
     * @param {PayrollAdjustmentCreateManyAndReturnArgs} args - Arguments to create many PayrollAdjustments.
     * @example
     * // Create many PayrollAdjustments
     * const payrollAdjustment = await prisma.payrollAdjustment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PayrollAdjustments and only return the `id`
     * const payrollAdjustmentWithIdOnly = await prisma.payrollAdjustment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PayrollAdjustmentCreateManyAndReturnArgs>(args?: SelectSubset<T, PayrollAdjustmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollAdjustmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PayrollAdjustment.
     * @param {PayrollAdjustmentDeleteArgs} args - Arguments to delete one PayrollAdjustment.
     * @example
     * // Delete one PayrollAdjustment
     * const PayrollAdjustment = await prisma.payrollAdjustment.delete({
     *   where: {
     *     // ... filter to delete one PayrollAdjustment
     *   }
     * })
     * 
     */
    delete<T extends PayrollAdjustmentDeleteArgs>(args: SelectSubset<T, PayrollAdjustmentDeleteArgs<ExtArgs>>): Prisma__PayrollAdjustmentClient<$Result.GetResult<Prisma.$PayrollAdjustmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PayrollAdjustment.
     * @param {PayrollAdjustmentUpdateArgs} args - Arguments to update one PayrollAdjustment.
     * @example
     * // Update one PayrollAdjustment
     * const payrollAdjustment = await prisma.payrollAdjustment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PayrollAdjustmentUpdateArgs>(args: SelectSubset<T, PayrollAdjustmentUpdateArgs<ExtArgs>>): Prisma__PayrollAdjustmentClient<$Result.GetResult<Prisma.$PayrollAdjustmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PayrollAdjustments.
     * @param {PayrollAdjustmentDeleteManyArgs} args - Arguments to filter PayrollAdjustments to delete.
     * @example
     * // Delete a few PayrollAdjustments
     * const { count } = await prisma.payrollAdjustment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PayrollAdjustmentDeleteManyArgs>(args?: SelectSubset<T, PayrollAdjustmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PayrollAdjustments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollAdjustmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PayrollAdjustments
     * const payrollAdjustment = await prisma.payrollAdjustment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PayrollAdjustmentUpdateManyArgs>(args: SelectSubset<T, PayrollAdjustmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PayrollAdjustments and returns the data updated in the database.
     * @param {PayrollAdjustmentUpdateManyAndReturnArgs} args - Arguments to update many PayrollAdjustments.
     * @example
     * // Update many PayrollAdjustments
     * const payrollAdjustment = await prisma.payrollAdjustment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PayrollAdjustments and only return the `id`
     * const payrollAdjustmentWithIdOnly = await prisma.payrollAdjustment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PayrollAdjustmentUpdateManyAndReturnArgs>(args: SelectSubset<T, PayrollAdjustmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollAdjustmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PayrollAdjustment.
     * @param {PayrollAdjustmentUpsertArgs} args - Arguments to update or create a PayrollAdjustment.
     * @example
     * // Update or create a PayrollAdjustment
     * const payrollAdjustment = await prisma.payrollAdjustment.upsert({
     *   create: {
     *     // ... data to create a PayrollAdjustment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PayrollAdjustment we want to update
     *   }
     * })
     */
    upsert<T extends PayrollAdjustmentUpsertArgs>(args: SelectSubset<T, PayrollAdjustmentUpsertArgs<ExtArgs>>): Prisma__PayrollAdjustmentClient<$Result.GetResult<Prisma.$PayrollAdjustmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PayrollAdjustments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollAdjustmentCountArgs} args - Arguments to filter PayrollAdjustments to count.
     * @example
     * // Count the number of PayrollAdjustments
     * const count = await prisma.payrollAdjustment.count({
     *   where: {
     *     // ... the filter for the PayrollAdjustments we want to count
     *   }
     * })
    **/
    count<T extends PayrollAdjustmentCountArgs>(
      args?: Subset<T, PayrollAdjustmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PayrollAdjustmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PayrollAdjustment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollAdjustmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PayrollAdjustmentAggregateArgs>(args: Subset<T, PayrollAdjustmentAggregateArgs>): Prisma.PrismaPromise<GetPayrollAdjustmentAggregateType<T>>

    /**
     * Group by PayrollAdjustment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollAdjustmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PayrollAdjustmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PayrollAdjustmentGroupByArgs['orderBy'] }
        : { orderBy?: PayrollAdjustmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PayrollAdjustmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayrollAdjustmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PayrollAdjustment model
   */
  readonly fields: PayrollAdjustmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PayrollAdjustment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PayrollAdjustmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    entry<T extends PayrollEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PayrollEntryDefaultArgs<ExtArgs>>): Prisma__PayrollEntryClient<$Result.GetResult<Prisma.$PayrollEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PayrollAdjustment model
   */
  interface PayrollAdjustmentFieldRefs {
    readonly id: FieldRef<"PayrollAdjustment", 'Int'>
    readonly entryId: FieldRef<"PayrollAdjustment", 'Int'>
    readonly type: FieldRef<"PayrollAdjustment", 'PayrollAdjustmentType'>
    readonly concept: FieldRef<"PayrollAdjustment", 'String'>
    readonly amount: FieldRef<"PayrollAdjustment", 'Decimal'>
    readonly createdAt: FieldRef<"PayrollAdjustment", 'DateTime'>
    readonly updatedAt: FieldRef<"PayrollAdjustment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PayrollAdjustment findUnique
   */
  export type PayrollAdjustmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollAdjustment
     */
    select?: PayrollAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollAdjustment
     */
    omit?: PayrollAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which PayrollAdjustment to fetch.
     */
    where: PayrollAdjustmentWhereUniqueInput
  }

  /**
   * PayrollAdjustment findUniqueOrThrow
   */
  export type PayrollAdjustmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollAdjustment
     */
    select?: PayrollAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollAdjustment
     */
    omit?: PayrollAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which PayrollAdjustment to fetch.
     */
    where: PayrollAdjustmentWhereUniqueInput
  }

  /**
   * PayrollAdjustment findFirst
   */
  export type PayrollAdjustmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollAdjustment
     */
    select?: PayrollAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollAdjustment
     */
    omit?: PayrollAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which PayrollAdjustment to fetch.
     */
    where?: PayrollAdjustmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollAdjustments to fetch.
     */
    orderBy?: PayrollAdjustmentOrderByWithRelationInput | PayrollAdjustmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PayrollAdjustments.
     */
    cursor?: PayrollAdjustmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollAdjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollAdjustments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PayrollAdjustments.
     */
    distinct?: PayrollAdjustmentScalarFieldEnum | PayrollAdjustmentScalarFieldEnum[]
  }

  /**
   * PayrollAdjustment findFirstOrThrow
   */
  export type PayrollAdjustmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollAdjustment
     */
    select?: PayrollAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollAdjustment
     */
    omit?: PayrollAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which PayrollAdjustment to fetch.
     */
    where?: PayrollAdjustmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollAdjustments to fetch.
     */
    orderBy?: PayrollAdjustmentOrderByWithRelationInput | PayrollAdjustmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PayrollAdjustments.
     */
    cursor?: PayrollAdjustmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollAdjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollAdjustments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PayrollAdjustments.
     */
    distinct?: PayrollAdjustmentScalarFieldEnum | PayrollAdjustmentScalarFieldEnum[]
  }

  /**
   * PayrollAdjustment findMany
   */
  export type PayrollAdjustmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollAdjustment
     */
    select?: PayrollAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollAdjustment
     */
    omit?: PayrollAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which PayrollAdjustments to fetch.
     */
    where?: PayrollAdjustmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollAdjustments to fetch.
     */
    orderBy?: PayrollAdjustmentOrderByWithRelationInput | PayrollAdjustmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PayrollAdjustments.
     */
    cursor?: PayrollAdjustmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollAdjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollAdjustments.
     */
    skip?: number
    distinct?: PayrollAdjustmentScalarFieldEnum | PayrollAdjustmentScalarFieldEnum[]
  }

  /**
   * PayrollAdjustment create
   */
  export type PayrollAdjustmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollAdjustment
     */
    select?: PayrollAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollAdjustment
     */
    omit?: PayrollAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollAdjustmentInclude<ExtArgs> | null
    /**
     * The data needed to create a PayrollAdjustment.
     */
    data: XOR<PayrollAdjustmentCreateInput, PayrollAdjustmentUncheckedCreateInput>
  }

  /**
   * PayrollAdjustment createMany
   */
  export type PayrollAdjustmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PayrollAdjustments.
     */
    data: PayrollAdjustmentCreateManyInput | PayrollAdjustmentCreateManyInput[]
  }

  /**
   * PayrollAdjustment createManyAndReturn
   */
  export type PayrollAdjustmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollAdjustment
     */
    select?: PayrollAdjustmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollAdjustment
     */
    omit?: PayrollAdjustmentOmit<ExtArgs> | null
    /**
     * The data used to create many PayrollAdjustments.
     */
    data: PayrollAdjustmentCreateManyInput | PayrollAdjustmentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollAdjustmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PayrollAdjustment update
   */
  export type PayrollAdjustmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollAdjustment
     */
    select?: PayrollAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollAdjustment
     */
    omit?: PayrollAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollAdjustmentInclude<ExtArgs> | null
    /**
     * The data needed to update a PayrollAdjustment.
     */
    data: XOR<PayrollAdjustmentUpdateInput, PayrollAdjustmentUncheckedUpdateInput>
    /**
     * Choose, which PayrollAdjustment to update.
     */
    where: PayrollAdjustmentWhereUniqueInput
  }

  /**
   * PayrollAdjustment updateMany
   */
  export type PayrollAdjustmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PayrollAdjustments.
     */
    data: XOR<PayrollAdjustmentUpdateManyMutationInput, PayrollAdjustmentUncheckedUpdateManyInput>
    /**
     * Filter which PayrollAdjustments to update
     */
    where?: PayrollAdjustmentWhereInput
    /**
     * Limit how many PayrollAdjustments to update.
     */
    limit?: number
  }

  /**
   * PayrollAdjustment updateManyAndReturn
   */
  export type PayrollAdjustmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollAdjustment
     */
    select?: PayrollAdjustmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollAdjustment
     */
    omit?: PayrollAdjustmentOmit<ExtArgs> | null
    /**
     * The data used to update PayrollAdjustments.
     */
    data: XOR<PayrollAdjustmentUpdateManyMutationInput, PayrollAdjustmentUncheckedUpdateManyInput>
    /**
     * Filter which PayrollAdjustments to update
     */
    where?: PayrollAdjustmentWhereInput
    /**
     * Limit how many PayrollAdjustments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollAdjustmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PayrollAdjustment upsert
   */
  export type PayrollAdjustmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollAdjustment
     */
    select?: PayrollAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollAdjustment
     */
    omit?: PayrollAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollAdjustmentInclude<ExtArgs> | null
    /**
     * The filter to search for the PayrollAdjustment to update in case it exists.
     */
    where: PayrollAdjustmentWhereUniqueInput
    /**
     * In case the PayrollAdjustment found by the `where` argument doesn't exist, create a new PayrollAdjustment with this data.
     */
    create: XOR<PayrollAdjustmentCreateInput, PayrollAdjustmentUncheckedCreateInput>
    /**
     * In case the PayrollAdjustment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PayrollAdjustmentUpdateInput, PayrollAdjustmentUncheckedUpdateInput>
  }

  /**
   * PayrollAdjustment delete
   */
  export type PayrollAdjustmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollAdjustment
     */
    select?: PayrollAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollAdjustment
     */
    omit?: PayrollAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollAdjustmentInclude<ExtArgs> | null
    /**
     * Filter which PayrollAdjustment to delete.
     */
    where: PayrollAdjustmentWhereUniqueInput
  }

  /**
   * PayrollAdjustment deleteMany
   */
  export type PayrollAdjustmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PayrollAdjustments to delete
     */
    where?: PayrollAdjustmentWhereInput
    /**
     * Limit how many PayrollAdjustments to delete.
     */
    limit?: number
  }

  /**
   * PayrollAdjustment without action
   */
  export type PayrollAdjustmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollAdjustment
     */
    select?: PayrollAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollAdjustment
     */
    omit?: PayrollAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollAdjustmentInclude<ExtArgs> | null
  }


  /**
   * Model Partner
   */

  export type AggregatePartner = {
    _count: PartnerCountAggregateOutputType | null
    _avg: PartnerAvgAggregateOutputType | null
    _sum: PartnerSumAggregateOutputType | null
    _min: PartnerMinAggregateOutputType | null
    _max: PartnerMaxAggregateOutputType | null
  }

  export type PartnerAvgAggregateOutputType = {
    id: number | null
  }

  export type PartnerSumAggregateOutputType = {
    id: number | null
  }

  export type PartnerMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PartnerMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PartnerCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PartnerAvgAggregateInputType = {
    id?: true
  }

  export type PartnerSumAggregateInputType = {
    id?: true
  }

  export type PartnerMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PartnerMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PartnerCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PartnerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Partner to aggregate.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Partners
    **/
    _count?: true | PartnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PartnerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PartnerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartnerMaxAggregateInputType
  }

  export type GetPartnerAggregateType<T extends PartnerAggregateArgs> = {
        [P in keyof T & keyof AggregatePartner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePartner[P]>
      : GetScalarType<T[P], AggregatePartner[P]>
  }




  export type PartnerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartnerWhereInput
    orderBy?: PartnerOrderByWithAggregationInput | PartnerOrderByWithAggregationInput[]
    by: PartnerScalarFieldEnum[] | PartnerScalarFieldEnum
    having?: PartnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartnerCountAggregateInputType | true
    _avg?: PartnerAvgAggregateInputType
    _sum?: PartnerSumAggregateInputType
    _min?: PartnerMinAggregateInputType
    _max?: PartnerMaxAggregateInputType
  }

  export type PartnerGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: PartnerCountAggregateOutputType | null
    _avg: PartnerAvgAggregateOutputType | null
    _sum: PartnerSumAggregateOutputType | null
    _min: PartnerMinAggregateOutputType | null
    _max: PartnerMaxAggregateOutputType | null
  }

  type GetPartnerGroupByPayload<T extends PartnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PartnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartnerGroupByOutputType[P]>
            : GetScalarType<T[P], PartnerGroupByOutputType[P]>
        }
      >
    >


  export type PartnerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    loansGiven?: boolean | Partner$loansGivenArgs<ExtArgs>
    loansReceived?: boolean | Partner$loansReceivedArgs<ExtArgs>
    _count?: boolean | PartnerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partner"]>

  export type PartnerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["partner"]>

  export type PartnerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["partner"]>

  export type PartnerSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PartnerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["partner"]>
  export type PartnerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loansGiven?: boolean | Partner$loansGivenArgs<ExtArgs>
    loansReceived?: boolean | Partner$loansReceivedArgs<ExtArgs>
    _count?: boolean | PartnerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PartnerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PartnerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PartnerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Partner"
    objects: {
      loansGiven: Prisma.$PartnerLoanPayload<ExtArgs>[]
      loansReceived: Prisma.$PartnerLoanPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["partner"]>
    composites: {}
  }

  type PartnerGetPayload<S extends boolean | null | undefined | PartnerDefaultArgs> = $Result.GetResult<Prisma.$PartnerPayload, S>

  type PartnerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PartnerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PartnerCountAggregateInputType | true
    }

  export interface PartnerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Partner'], meta: { name: 'Partner' } }
    /**
     * Find zero or one Partner that matches the filter.
     * @param {PartnerFindUniqueArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PartnerFindUniqueArgs>(args: SelectSubset<T, PartnerFindUniqueArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Partner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PartnerFindUniqueOrThrowArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PartnerFindUniqueOrThrowArgs>(args: SelectSubset<T, PartnerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Partner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerFindFirstArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PartnerFindFirstArgs>(args?: SelectSubset<T, PartnerFindFirstArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Partner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerFindFirstOrThrowArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PartnerFindFirstOrThrowArgs>(args?: SelectSubset<T, PartnerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Partners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Partners
     * const partners = await prisma.partner.findMany()
     * 
     * // Get first 10 Partners
     * const partners = await prisma.partner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partnerWithIdOnly = await prisma.partner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PartnerFindManyArgs>(args?: SelectSubset<T, PartnerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Partner.
     * @param {PartnerCreateArgs} args - Arguments to create a Partner.
     * @example
     * // Create one Partner
     * const Partner = await prisma.partner.create({
     *   data: {
     *     // ... data to create a Partner
     *   }
     * })
     * 
     */
    create<T extends PartnerCreateArgs>(args: SelectSubset<T, PartnerCreateArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Partners.
     * @param {PartnerCreateManyArgs} args - Arguments to create many Partners.
     * @example
     * // Create many Partners
     * const partner = await prisma.partner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PartnerCreateManyArgs>(args?: SelectSubset<T, PartnerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Partners and returns the data saved in the database.
     * @param {PartnerCreateManyAndReturnArgs} args - Arguments to create many Partners.
     * @example
     * // Create many Partners
     * const partner = await prisma.partner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Partners and only return the `id`
     * const partnerWithIdOnly = await prisma.partner.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PartnerCreateManyAndReturnArgs>(args?: SelectSubset<T, PartnerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Partner.
     * @param {PartnerDeleteArgs} args - Arguments to delete one Partner.
     * @example
     * // Delete one Partner
     * const Partner = await prisma.partner.delete({
     *   where: {
     *     // ... filter to delete one Partner
     *   }
     * })
     * 
     */
    delete<T extends PartnerDeleteArgs>(args: SelectSubset<T, PartnerDeleteArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Partner.
     * @param {PartnerUpdateArgs} args - Arguments to update one Partner.
     * @example
     * // Update one Partner
     * const partner = await prisma.partner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PartnerUpdateArgs>(args: SelectSubset<T, PartnerUpdateArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Partners.
     * @param {PartnerDeleteManyArgs} args - Arguments to filter Partners to delete.
     * @example
     * // Delete a few Partners
     * const { count } = await prisma.partner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PartnerDeleteManyArgs>(args?: SelectSubset<T, PartnerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Partners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Partners
     * const partner = await prisma.partner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PartnerUpdateManyArgs>(args: SelectSubset<T, PartnerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Partners and returns the data updated in the database.
     * @param {PartnerUpdateManyAndReturnArgs} args - Arguments to update many Partners.
     * @example
     * // Update many Partners
     * const partner = await prisma.partner.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Partners and only return the `id`
     * const partnerWithIdOnly = await prisma.partner.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PartnerUpdateManyAndReturnArgs>(args: SelectSubset<T, PartnerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Partner.
     * @param {PartnerUpsertArgs} args - Arguments to update or create a Partner.
     * @example
     * // Update or create a Partner
     * const partner = await prisma.partner.upsert({
     *   create: {
     *     // ... data to create a Partner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Partner we want to update
     *   }
     * })
     */
    upsert<T extends PartnerUpsertArgs>(args: SelectSubset<T, PartnerUpsertArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Partners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerCountArgs} args - Arguments to filter Partners to count.
     * @example
     * // Count the number of Partners
     * const count = await prisma.partner.count({
     *   where: {
     *     // ... the filter for the Partners we want to count
     *   }
     * })
    **/
    count<T extends PartnerCountArgs>(
      args?: Subset<T, PartnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Partner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartnerAggregateArgs>(args: Subset<T, PartnerAggregateArgs>): Prisma.PrismaPromise<GetPartnerAggregateType<T>>

    /**
     * Group by Partner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartnerGroupByArgs['orderBy'] }
        : { orderBy?: PartnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Partner model
   */
  readonly fields: PartnerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Partner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PartnerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    loansGiven<T extends Partner$loansGivenArgs<ExtArgs> = {}>(args?: Subset<T, Partner$loansGivenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerLoanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    loansReceived<T extends Partner$loansReceivedArgs<ExtArgs> = {}>(args?: Subset<T, Partner$loansReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerLoanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Partner model
   */
  interface PartnerFieldRefs {
    readonly id: FieldRef<"Partner", 'Int'>
    readonly name: FieldRef<"Partner", 'String'>
    readonly createdAt: FieldRef<"Partner", 'DateTime'>
    readonly updatedAt: FieldRef<"Partner", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Partner findUnique
   */
  export type PartnerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where: PartnerWhereUniqueInput
  }

  /**
   * Partner findUniqueOrThrow
   */
  export type PartnerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where: PartnerWhereUniqueInput
  }

  /**
   * Partner findFirst
   */
  export type PartnerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Partners.
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Partners.
     */
    distinct?: PartnerScalarFieldEnum | PartnerScalarFieldEnum[]
  }

  /**
   * Partner findFirstOrThrow
   */
  export type PartnerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Partners.
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Partners.
     */
    distinct?: PartnerScalarFieldEnum | PartnerScalarFieldEnum[]
  }

  /**
   * Partner findMany
   */
  export type PartnerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partners to fetch.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Partners.
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    distinct?: PartnerScalarFieldEnum | PartnerScalarFieldEnum[]
  }

  /**
   * Partner create
   */
  export type PartnerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * The data needed to create a Partner.
     */
    data: XOR<PartnerCreateInput, PartnerUncheckedCreateInput>
  }

  /**
   * Partner createMany
   */
  export type PartnerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Partners.
     */
    data: PartnerCreateManyInput | PartnerCreateManyInput[]
  }

  /**
   * Partner createManyAndReturn
   */
  export type PartnerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * The data used to create many Partners.
     */
    data: PartnerCreateManyInput | PartnerCreateManyInput[]
  }

  /**
   * Partner update
   */
  export type PartnerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * The data needed to update a Partner.
     */
    data: XOR<PartnerUpdateInput, PartnerUncheckedUpdateInput>
    /**
     * Choose, which Partner to update.
     */
    where: PartnerWhereUniqueInput
  }

  /**
   * Partner updateMany
   */
  export type PartnerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Partners.
     */
    data: XOR<PartnerUpdateManyMutationInput, PartnerUncheckedUpdateManyInput>
    /**
     * Filter which Partners to update
     */
    where?: PartnerWhereInput
    /**
     * Limit how many Partners to update.
     */
    limit?: number
  }

  /**
   * Partner updateManyAndReturn
   */
  export type PartnerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * The data used to update Partners.
     */
    data: XOR<PartnerUpdateManyMutationInput, PartnerUncheckedUpdateManyInput>
    /**
     * Filter which Partners to update
     */
    where?: PartnerWhereInput
    /**
     * Limit how many Partners to update.
     */
    limit?: number
  }

  /**
   * Partner upsert
   */
  export type PartnerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * The filter to search for the Partner to update in case it exists.
     */
    where: PartnerWhereUniqueInput
    /**
     * In case the Partner found by the `where` argument doesn't exist, create a new Partner with this data.
     */
    create: XOR<PartnerCreateInput, PartnerUncheckedCreateInput>
    /**
     * In case the Partner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartnerUpdateInput, PartnerUncheckedUpdateInput>
  }

  /**
   * Partner delete
   */
  export type PartnerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter which Partner to delete.
     */
    where: PartnerWhereUniqueInput
  }

  /**
   * Partner deleteMany
   */
  export type PartnerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Partners to delete
     */
    where?: PartnerWhereInput
    /**
     * Limit how many Partners to delete.
     */
    limit?: number
  }

  /**
   * Partner.loansGiven
   */
  export type Partner$loansGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerLoan
     */
    select?: PartnerLoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerLoan
     */
    omit?: PartnerLoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerLoanInclude<ExtArgs> | null
    where?: PartnerLoanWhereInput
    orderBy?: PartnerLoanOrderByWithRelationInput | PartnerLoanOrderByWithRelationInput[]
    cursor?: PartnerLoanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PartnerLoanScalarFieldEnum | PartnerLoanScalarFieldEnum[]
  }

  /**
   * Partner.loansReceived
   */
  export type Partner$loansReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerLoan
     */
    select?: PartnerLoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerLoan
     */
    omit?: PartnerLoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerLoanInclude<ExtArgs> | null
    where?: PartnerLoanWhereInput
    orderBy?: PartnerLoanOrderByWithRelationInput | PartnerLoanOrderByWithRelationInput[]
    cursor?: PartnerLoanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PartnerLoanScalarFieldEnum | PartnerLoanScalarFieldEnum[]
  }

  /**
   * Partner without action
   */
  export type PartnerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
  }


  /**
   * Model PartnerLoan
   */

  export type AggregatePartnerLoan = {
    _count: PartnerLoanCountAggregateOutputType | null
    _avg: PartnerLoanAvgAggregateOutputType | null
    _sum: PartnerLoanSumAggregateOutputType | null
    _min: PartnerLoanMinAggregateOutputType | null
    _max: PartnerLoanMaxAggregateOutputType | null
  }

  export type PartnerLoanAvgAggregateOutputType = {
    id: number | null
    giverId: number | null
    receiverId: number | null
    amount: Decimal | null
  }

  export type PartnerLoanSumAggregateOutputType = {
    id: number | null
    giverId: number | null
    receiverId: number | null
    amount: Decimal | null
  }

  export type PartnerLoanMinAggregateOutputType = {
    id: number | null
    date: Date | null
    giverId: number | null
    receiverId: number | null
    amount: Decimal | null
    note: string | null
    status: $Enums.PartnerLoanStatus | null
    closeDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PartnerLoanMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    giverId: number | null
    receiverId: number | null
    amount: Decimal | null
    note: string | null
    status: $Enums.PartnerLoanStatus | null
    closeDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PartnerLoanCountAggregateOutputType = {
    id: number
    date: number
    giverId: number
    receiverId: number
    amount: number
    note: number
    status: number
    financeRefs: number
    closeDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PartnerLoanAvgAggregateInputType = {
    id?: true
    giverId?: true
    receiverId?: true
    amount?: true
  }

  export type PartnerLoanSumAggregateInputType = {
    id?: true
    giverId?: true
    receiverId?: true
    amount?: true
  }

  export type PartnerLoanMinAggregateInputType = {
    id?: true
    date?: true
    giverId?: true
    receiverId?: true
    amount?: true
    note?: true
    status?: true
    closeDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PartnerLoanMaxAggregateInputType = {
    id?: true
    date?: true
    giverId?: true
    receiverId?: true
    amount?: true
    note?: true
    status?: true
    closeDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PartnerLoanCountAggregateInputType = {
    id?: true
    date?: true
    giverId?: true
    receiverId?: true
    amount?: true
    note?: true
    status?: true
    financeRefs?: true
    closeDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PartnerLoanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PartnerLoan to aggregate.
     */
    where?: PartnerLoanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartnerLoans to fetch.
     */
    orderBy?: PartnerLoanOrderByWithRelationInput | PartnerLoanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartnerLoanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartnerLoans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartnerLoans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PartnerLoans
    **/
    _count?: true | PartnerLoanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PartnerLoanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PartnerLoanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartnerLoanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartnerLoanMaxAggregateInputType
  }

  export type GetPartnerLoanAggregateType<T extends PartnerLoanAggregateArgs> = {
        [P in keyof T & keyof AggregatePartnerLoan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePartnerLoan[P]>
      : GetScalarType<T[P], AggregatePartnerLoan[P]>
  }




  export type PartnerLoanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartnerLoanWhereInput
    orderBy?: PartnerLoanOrderByWithAggregationInput | PartnerLoanOrderByWithAggregationInput[]
    by: PartnerLoanScalarFieldEnum[] | PartnerLoanScalarFieldEnum
    having?: PartnerLoanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartnerLoanCountAggregateInputType | true
    _avg?: PartnerLoanAvgAggregateInputType
    _sum?: PartnerLoanSumAggregateInputType
    _min?: PartnerLoanMinAggregateInputType
    _max?: PartnerLoanMaxAggregateInputType
  }

  export type PartnerLoanGroupByOutputType = {
    id: number
    date: Date
    giverId: number
    receiverId: number
    amount: Decimal
    note: string | null
    status: $Enums.PartnerLoanStatus
    financeRefs: JsonValue | null
    closeDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PartnerLoanCountAggregateOutputType | null
    _avg: PartnerLoanAvgAggregateOutputType | null
    _sum: PartnerLoanSumAggregateOutputType | null
    _min: PartnerLoanMinAggregateOutputType | null
    _max: PartnerLoanMaxAggregateOutputType | null
  }

  type GetPartnerLoanGroupByPayload<T extends PartnerLoanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PartnerLoanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartnerLoanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartnerLoanGroupByOutputType[P]>
            : GetScalarType<T[P], PartnerLoanGroupByOutputType[P]>
        }
      >
    >


  export type PartnerLoanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    giverId?: boolean
    receiverId?: boolean
    amount?: boolean
    note?: boolean
    status?: boolean
    financeRefs?: boolean
    closeDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    giver?: boolean | PartnerDefaultArgs<ExtArgs>
    receiver?: boolean | PartnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partnerLoan"]>

  export type PartnerLoanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    giverId?: boolean
    receiverId?: boolean
    amount?: boolean
    note?: boolean
    status?: boolean
    financeRefs?: boolean
    closeDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    giver?: boolean | PartnerDefaultArgs<ExtArgs>
    receiver?: boolean | PartnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partnerLoan"]>

  export type PartnerLoanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    giverId?: boolean
    receiverId?: boolean
    amount?: boolean
    note?: boolean
    status?: boolean
    financeRefs?: boolean
    closeDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    giver?: boolean | PartnerDefaultArgs<ExtArgs>
    receiver?: boolean | PartnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partnerLoan"]>

  export type PartnerLoanSelectScalar = {
    id?: boolean
    date?: boolean
    giverId?: boolean
    receiverId?: boolean
    amount?: boolean
    note?: boolean
    status?: boolean
    financeRefs?: boolean
    closeDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PartnerLoanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "giverId" | "receiverId" | "amount" | "note" | "status" | "financeRefs" | "closeDate" | "createdAt" | "updatedAt", ExtArgs["result"]["partnerLoan"]>
  export type PartnerLoanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    giver?: boolean | PartnerDefaultArgs<ExtArgs>
    receiver?: boolean | PartnerDefaultArgs<ExtArgs>
  }
  export type PartnerLoanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    giver?: boolean | PartnerDefaultArgs<ExtArgs>
    receiver?: boolean | PartnerDefaultArgs<ExtArgs>
  }
  export type PartnerLoanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    giver?: boolean | PartnerDefaultArgs<ExtArgs>
    receiver?: boolean | PartnerDefaultArgs<ExtArgs>
  }

  export type $PartnerLoanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PartnerLoan"
    objects: {
      giver: Prisma.$PartnerPayload<ExtArgs>
      receiver: Prisma.$PartnerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      date: Date
      giverId: number
      receiverId: number
      amount: Prisma.Decimal
      note: string | null
      status: $Enums.PartnerLoanStatus
      financeRefs: Prisma.JsonValue | null
      closeDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["partnerLoan"]>
    composites: {}
  }

  type PartnerLoanGetPayload<S extends boolean | null | undefined | PartnerLoanDefaultArgs> = $Result.GetResult<Prisma.$PartnerLoanPayload, S>

  type PartnerLoanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PartnerLoanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PartnerLoanCountAggregateInputType | true
    }

  export interface PartnerLoanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PartnerLoan'], meta: { name: 'PartnerLoan' } }
    /**
     * Find zero or one PartnerLoan that matches the filter.
     * @param {PartnerLoanFindUniqueArgs} args - Arguments to find a PartnerLoan
     * @example
     * // Get one PartnerLoan
     * const partnerLoan = await prisma.partnerLoan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PartnerLoanFindUniqueArgs>(args: SelectSubset<T, PartnerLoanFindUniqueArgs<ExtArgs>>): Prisma__PartnerLoanClient<$Result.GetResult<Prisma.$PartnerLoanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PartnerLoan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PartnerLoanFindUniqueOrThrowArgs} args - Arguments to find a PartnerLoan
     * @example
     * // Get one PartnerLoan
     * const partnerLoan = await prisma.partnerLoan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PartnerLoanFindUniqueOrThrowArgs>(args: SelectSubset<T, PartnerLoanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PartnerLoanClient<$Result.GetResult<Prisma.$PartnerLoanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PartnerLoan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerLoanFindFirstArgs} args - Arguments to find a PartnerLoan
     * @example
     * // Get one PartnerLoan
     * const partnerLoan = await prisma.partnerLoan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PartnerLoanFindFirstArgs>(args?: SelectSubset<T, PartnerLoanFindFirstArgs<ExtArgs>>): Prisma__PartnerLoanClient<$Result.GetResult<Prisma.$PartnerLoanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PartnerLoan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerLoanFindFirstOrThrowArgs} args - Arguments to find a PartnerLoan
     * @example
     * // Get one PartnerLoan
     * const partnerLoan = await prisma.partnerLoan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PartnerLoanFindFirstOrThrowArgs>(args?: SelectSubset<T, PartnerLoanFindFirstOrThrowArgs<ExtArgs>>): Prisma__PartnerLoanClient<$Result.GetResult<Prisma.$PartnerLoanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PartnerLoans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerLoanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PartnerLoans
     * const partnerLoans = await prisma.partnerLoan.findMany()
     * 
     * // Get first 10 PartnerLoans
     * const partnerLoans = await prisma.partnerLoan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partnerLoanWithIdOnly = await prisma.partnerLoan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PartnerLoanFindManyArgs>(args?: SelectSubset<T, PartnerLoanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerLoanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PartnerLoan.
     * @param {PartnerLoanCreateArgs} args - Arguments to create a PartnerLoan.
     * @example
     * // Create one PartnerLoan
     * const PartnerLoan = await prisma.partnerLoan.create({
     *   data: {
     *     // ... data to create a PartnerLoan
     *   }
     * })
     * 
     */
    create<T extends PartnerLoanCreateArgs>(args: SelectSubset<T, PartnerLoanCreateArgs<ExtArgs>>): Prisma__PartnerLoanClient<$Result.GetResult<Prisma.$PartnerLoanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PartnerLoans.
     * @param {PartnerLoanCreateManyArgs} args - Arguments to create many PartnerLoans.
     * @example
     * // Create many PartnerLoans
     * const partnerLoan = await prisma.partnerLoan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PartnerLoanCreateManyArgs>(args?: SelectSubset<T, PartnerLoanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PartnerLoans and returns the data saved in the database.
     * @param {PartnerLoanCreateManyAndReturnArgs} args - Arguments to create many PartnerLoans.
     * @example
     * // Create many PartnerLoans
     * const partnerLoan = await prisma.partnerLoan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PartnerLoans and only return the `id`
     * const partnerLoanWithIdOnly = await prisma.partnerLoan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PartnerLoanCreateManyAndReturnArgs>(args?: SelectSubset<T, PartnerLoanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerLoanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PartnerLoan.
     * @param {PartnerLoanDeleteArgs} args - Arguments to delete one PartnerLoan.
     * @example
     * // Delete one PartnerLoan
     * const PartnerLoan = await prisma.partnerLoan.delete({
     *   where: {
     *     // ... filter to delete one PartnerLoan
     *   }
     * })
     * 
     */
    delete<T extends PartnerLoanDeleteArgs>(args: SelectSubset<T, PartnerLoanDeleteArgs<ExtArgs>>): Prisma__PartnerLoanClient<$Result.GetResult<Prisma.$PartnerLoanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PartnerLoan.
     * @param {PartnerLoanUpdateArgs} args - Arguments to update one PartnerLoan.
     * @example
     * // Update one PartnerLoan
     * const partnerLoan = await prisma.partnerLoan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PartnerLoanUpdateArgs>(args: SelectSubset<T, PartnerLoanUpdateArgs<ExtArgs>>): Prisma__PartnerLoanClient<$Result.GetResult<Prisma.$PartnerLoanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PartnerLoans.
     * @param {PartnerLoanDeleteManyArgs} args - Arguments to filter PartnerLoans to delete.
     * @example
     * // Delete a few PartnerLoans
     * const { count } = await prisma.partnerLoan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PartnerLoanDeleteManyArgs>(args?: SelectSubset<T, PartnerLoanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PartnerLoans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerLoanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PartnerLoans
     * const partnerLoan = await prisma.partnerLoan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PartnerLoanUpdateManyArgs>(args: SelectSubset<T, PartnerLoanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PartnerLoans and returns the data updated in the database.
     * @param {PartnerLoanUpdateManyAndReturnArgs} args - Arguments to update many PartnerLoans.
     * @example
     * // Update many PartnerLoans
     * const partnerLoan = await prisma.partnerLoan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PartnerLoans and only return the `id`
     * const partnerLoanWithIdOnly = await prisma.partnerLoan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PartnerLoanUpdateManyAndReturnArgs>(args: SelectSubset<T, PartnerLoanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerLoanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PartnerLoan.
     * @param {PartnerLoanUpsertArgs} args - Arguments to update or create a PartnerLoan.
     * @example
     * // Update or create a PartnerLoan
     * const partnerLoan = await prisma.partnerLoan.upsert({
     *   create: {
     *     // ... data to create a PartnerLoan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PartnerLoan we want to update
     *   }
     * })
     */
    upsert<T extends PartnerLoanUpsertArgs>(args: SelectSubset<T, PartnerLoanUpsertArgs<ExtArgs>>): Prisma__PartnerLoanClient<$Result.GetResult<Prisma.$PartnerLoanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PartnerLoans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerLoanCountArgs} args - Arguments to filter PartnerLoans to count.
     * @example
     * // Count the number of PartnerLoans
     * const count = await prisma.partnerLoan.count({
     *   where: {
     *     // ... the filter for the PartnerLoans we want to count
     *   }
     * })
    **/
    count<T extends PartnerLoanCountArgs>(
      args?: Subset<T, PartnerLoanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartnerLoanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PartnerLoan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerLoanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartnerLoanAggregateArgs>(args: Subset<T, PartnerLoanAggregateArgs>): Prisma.PrismaPromise<GetPartnerLoanAggregateType<T>>

    /**
     * Group by PartnerLoan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerLoanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartnerLoanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartnerLoanGroupByArgs['orderBy'] }
        : { orderBy?: PartnerLoanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartnerLoanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartnerLoanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PartnerLoan model
   */
  readonly fields: PartnerLoanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PartnerLoan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PartnerLoanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    giver<T extends PartnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PartnerDefaultArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    receiver<T extends PartnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PartnerDefaultArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PartnerLoan model
   */
  interface PartnerLoanFieldRefs {
    readonly id: FieldRef<"PartnerLoan", 'Int'>
    readonly date: FieldRef<"PartnerLoan", 'DateTime'>
    readonly giverId: FieldRef<"PartnerLoan", 'Int'>
    readonly receiverId: FieldRef<"PartnerLoan", 'Int'>
    readonly amount: FieldRef<"PartnerLoan", 'Decimal'>
    readonly note: FieldRef<"PartnerLoan", 'String'>
    readonly status: FieldRef<"PartnerLoan", 'PartnerLoanStatus'>
    readonly financeRefs: FieldRef<"PartnerLoan", 'Json'>
    readonly closeDate: FieldRef<"PartnerLoan", 'DateTime'>
    readonly createdAt: FieldRef<"PartnerLoan", 'DateTime'>
    readonly updatedAt: FieldRef<"PartnerLoan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PartnerLoan findUnique
   */
  export type PartnerLoanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerLoan
     */
    select?: PartnerLoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerLoan
     */
    omit?: PartnerLoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerLoanInclude<ExtArgs> | null
    /**
     * Filter, which PartnerLoan to fetch.
     */
    where: PartnerLoanWhereUniqueInput
  }

  /**
   * PartnerLoan findUniqueOrThrow
   */
  export type PartnerLoanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerLoan
     */
    select?: PartnerLoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerLoan
     */
    omit?: PartnerLoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerLoanInclude<ExtArgs> | null
    /**
     * Filter, which PartnerLoan to fetch.
     */
    where: PartnerLoanWhereUniqueInput
  }

  /**
   * PartnerLoan findFirst
   */
  export type PartnerLoanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerLoan
     */
    select?: PartnerLoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerLoan
     */
    omit?: PartnerLoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerLoanInclude<ExtArgs> | null
    /**
     * Filter, which PartnerLoan to fetch.
     */
    where?: PartnerLoanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartnerLoans to fetch.
     */
    orderBy?: PartnerLoanOrderByWithRelationInput | PartnerLoanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PartnerLoans.
     */
    cursor?: PartnerLoanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartnerLoans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartnerLoans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PartnerLoans.
     */
    distinct?: PartnerLoanScalarFieldEnum | PartnerLoanScalarFieldEnum[]
  }

  /**
   * PartnerLoan findFirstOrThrow
   */
  export type PartnerLoanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerLoan
     */
    select?: PartnerLoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerLoan
     */
    omit?: PartnerLoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerLoanInclude<ExtArgs> | null
    /**
     * Filter, which PartnerLoan to fetch.
     */
    where?: PartnerLoanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartnerLoans to fetch.
     */
    orderBy?: PartnerLoanOrderByWithRelationInput | PartnerLoanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PartnerLoans.
     */
    cursor?: PartnerLoanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartnerLoans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartnerLoans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PartnerLoans.
     */
    distinct?: PartnerLoanScalarFieldEnum | PartnerLoanScalarFieldEnum[]
  }

  /**
   * PartnerLoan findMany
   */
  export type PartnerLoanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerLoan
     */
    select?: PartnerLoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerLoan
     */
    omit?: PartnerLoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerLoanInclude<ExtArgs> | null
    /**
     * Filter, which PartnerLoans to fetch.
     */
    where?: PartnerLoanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartnerLoans to fetch.
     */
    orderBy?: PartnerLoanOrderByWithRelationInput | PartnerLoanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PartnerLoans.
     */
    cursor?: PartnerLoanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartnerLoans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartnerLoans.
     */
    skip?: number
    distinct?: PartnerLoanScalarFieldEnum | PartnerLoanScalarFieldEnum[]
  }

  /**
   * PartnerLoan create
   */
  export type PartnerLoanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerLoan
     */
    select?: PartnerLoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerLoan
     */
    omit?: PartnerLoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerLoanInclude<ExtArgs> | null
    /**
     * The data needed to create a PartnerLoan.
     */
    data: XOR<PartnerLoanCreateInput, PartnerLoanUncheckedCreateInput>
  }

  /**
   * PartnerLoan createMany
   */
  export type PartnerLoanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PartnerLoans.
     */
    data: PartnerLoanCreateManyInput | PartnerLoanCreateManyInput[]
  }

  /**
   * PartnerLoan createManyAndReturn
   */
  export type PartnerLoanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerLoan
     */
    select?: PartnerLoanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerLoan
     */
    omit?: PartnerLoanOmit<ExtArgs> | null
    /**
     * The data used to create many PartnerLoans.
     */
    data: PartnerLoanCreateManyInput | PartnerLoanCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerLoanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PartnerLoan update
   */
  export type PartnerLoanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerLoan
     */
    select?: PartnerLoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerLoan
     */
    omit?: PartnerLoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerLoanInclude<ExtArgs> | null
    /**
     * The data needed to update a PartnerLoan.
     */
    data: XOR<PartnerLoanUpdateInput, PartnerLoanUncheckedUpdateInput>
    /**
     * Choose, which PartnerLoan to update.
     */
    where: PartnerLoanWhereUniqueInput
  }

  /**
   * PartnerLoan updateMany
   */
  export type PartnerLoanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PartnerLoans.
     */
    data: XOR<PartnerLoanUpdateManyMutationInput, PartnerLoanUncheckedUpdateManyInput>
    /**
     * Filter which PartnerLoans to update
     */
    where?: PartnerLoanWhereInput
    /**
     * Limit how many PartnerLoans to update.
     */
    limit?: number
  }

  /**
   * PartnerLoan updateManyAndReturn
   */
  export type PartnerLoanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerLoan
     */
    select?: PartnerLoanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerLoan
     */
    omit?: PartnerLoanOmit<ExtArgs> | null
    /**
     * The data used to update PartnerLoans.
     */
    data: XOR<PartnerLoanUpdateManyMutationInput, PartnerLoanUncheckedUpdateManyInput>
    /**
     * Filter which PartnerLoans to update
     */
    where?: PartnerLoanWhereInput
    /**
     * Limit how many PartnerLoans to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerLoanIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PartnerLoan upsert
   */
  export type PartnerLoanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerLoan
     */
    select?: PartnerLoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerLoan
     */
    omit?: PartnerLoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerLoanInclude<ExtArgs> | null
    /**
     * The filter to search for the PartnerLoan to update in case it exists.
     */
    where: PartnerLoanWhereUniqueInput
    /**
     * In case the PartnerLoan found by the `where` argument doesn't exist, create a new PartnerLoan with this data.
     */
    create: XOR<PartnerLoanCreateInput, PartnerLoanUncheckedCreateInput>
    /**
     * In case the PartnerLoan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartnerLoanUpdateInput, PartnerLoanUncheckedUpdateInput>
  }

  /**
   * PartnerLoan delete
   */
  export type PartnerLoanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerLoan
     */
    select?: PartnerLoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerLoan
     */
    omit?: PartnerLoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerLoanInclude<ExtArgs> | null
    /**
     * Filter which PartnerLoan to delete.
     */
    where: PartnerLoanWhereUniqueInput
  }

  /**
   * PartnerLoan deleteMany
   */
  export type PartnerLoanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PartnerLoans to delete
     */
    where?: PartnerLoanWhereInput
    /**
     * Limit how many PartnerLoans to delete.
     */
    limit?: number
  }

  /**
   * PartnerLoan without action
   */
  export type PartnerLoanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerLoan
     */
    select?: PartnerLoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartnerLoan
     */
    omit?: PartnerLoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerLoanInclude<ExtArgs> | null
  }


  /**
   * Model FoodIngredient
   */

  export type AggregateFoodIngredient = {
    _count: FoodIngredientCountAggregateOutputType | null
    _avg: FoodIngredientAvgAggregateOutputType | null
    _sum: FoodIngredientSumAggregateOutputType | null
    _min: FoodIngredientMinAggregateOutputType | null
    _max: FoodIngredientMaxAggregateOutputType | null
  }

  export type FoodIngredientAvgAggregateOutputType = {
    id: number | null
    defaultWastePct: Decimal | null
  }

  export type FoodIngredientSumAggregateOutputType = {
    id: number | null
    defaultWastePct: Decimal | null
  }

  export type FoodIngredientMinAggregateOutputType = {
    id: number | null
    name: string | null
    category: string | null
    unit: string | null
    defaultWastePct: Decimal | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FoodIngredientMaxAggregateOutputType = {
    id: number | null
    name: string | null
    category: string | null
    unit: string | null
    defaultWastePct: Decimal | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FoodIngredientCountAggregateOutputType = {
    id: number
    name: number
    category: number
    unit: number
    defaultWastePct: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FoodIngredientAvgAggregateInputType = {
    id?: true
    defaultWastePct?: true
  }

  export type FoodIngredientSumAggregateInputType = {
    id?: true
    defaultWastePct?: true
  }

  export type FoodIngredientMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    unit?: true
    defaultWastePct?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FoodIngredientMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    unit?: true
    defaultWastePct?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FoodIngredientCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    unit?: true
    defaultWastePct?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FoodIngredientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodIngredient to aggregate.
     */
    where?: FoodIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodIngredients to fetch.
     */
    orderBy?: FoodIngredientOrderByWithRelationInput | FoodIngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoodIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodIngredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodIngredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FoodIngredients
    **/
    _count?: true | FoodIngredientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FoodIngredientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FoodIngredientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoodIngredientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoodIngredientMaxAggregateInputType
  }

  export type GetFoodIngredientAggregateType<T extends FoodIngredientAggregateArgs> = {
        [P in keyof T & keyof AggregateFoodIngredient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoodIngredient[P]>
      : GetScalarType<T[P], AggregateFoodIngredient[P]>
  }




  export type FoodIngredientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodIngredientWhereInput
    orderBy?: FoodIngredientOrderByWithAggregationInput | FoodIngredientOrderByWithAggregationInput[]
    by: FoodIngredientScalarFieldEnum[] | FoodIngredientScalarFieldEnum
    having?: FoodIngredientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoodIngredientCountAggregateInputType | true
    _avg?: FoodIngredientAvgAggregateInputType
    _sum?: FoodIngredientSumAggregateInputType
    _min?: FoodIngredientMinAggregateInputType
    _max?: FoodIngredientMaxAggregateInputType
  }

  export type FoodIngredientGroupByOutputType = {
    id: number
    name: string
    category: string | null
    unit: string | null
    defaultWastePct: Decimal
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: FoodIngredientCountAggregateOutputType | null
    _avg: FoodIngredientAvgAggregateOutputType | null
    _sum: FoodIngredientSumAggregateOutputType | null
    _min: FoodIngredientMinAggregateOutputType | null
    _max: FoodIngredientMaxAggregateOutputType | null
  }

  type GetFoodIngredientGroupByPayload<T extends FoodIngredientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoodIngredientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoodIngredientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoodIngredientGroupByOutputType[P]>
            : GetScalarType<T[P], FoodIngredientGroupByOutputType[P]>
        }
      >
    >


  export type FoodIngredientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    unit?: boolean
    defaultWastePct?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    costs?: boolean | FoodIngredient$costsArgs<ExtArgs>
    items?: boolean | FoodIngredient$itemsArgs<ExtArgs>
    _count?: boolean | FoodIngredientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodIngredient"]>

  export type FoodIngredientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    unit?: boolean
    defaultWastePct?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["foodIngredient"]>

  export type FoodIngredientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    unit?: boolean
    defaultWastePct?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["foodIngredient"]>

  export type FoodIngredientSelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    unit?: boolean
    defaultWastePct?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FoodIngredientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "category" | "unit" | "defaultWastePct" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["foodIngredient"]>
  export type FoodIngredientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    costs?: boolean | FoodIngredient$costsArgs<ExtArgs>
    items?: boolean | FoodIngredient$itemsArgs<ExtArgs>
    _count?: boolean | FoodIngredientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FoodIngredientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FoodIngredientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FoodIngredientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FoodIngredient"
    objects: {
      costs: Prisma.$FoodIngredientCostPayload<ExtArgs>[]
      items: Prisma.$FoodRecipeItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      category: string | null
      unit: string | null
      defaultWastePct: Prisma.Decimal
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["foodIngredient"]>
    composites: {}
  }

  type FoodIngredientGetPayload<S extends boolean | null | undefined | FoodIngredientDefaultArgs> = $Result.GetResult<Prisma.$FoodIngredientPayload, S>

  type FoodIngredientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FoodIngredientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FoodIngredientCountAggregateInputType | true
    }

  export interface FoodIngredientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FoodIngredient'], meta: { name: 'FoodIngredient' } }
    /**
     * Find zero or one FoodIngredient that matches the filter.
     * @param {FoodIngredientFindUniqueArgs} args - Arguments to find a FoodIngredient
     * @example
     * // Get one FoodIngredient
     * const foodIngredient = await prisma.foodIngredient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoodIngredientFindUniqueArgs>(args: SelectSubset<T, FoodIngredientFindUniqueArgs<ExtArgs>>): Prisma__FoodIngredientClient<$Result.GetResult<Prisma.$FoodIngredientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FoodIngredient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FoodIngredientFindUniqueOrThrowArgs} args - Arguments to find a FoodIngredient
     * @example
     * // Get one FoodIngredient
     * const foodIngredient = await prisma.foodIngredient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoodIngredientFindUniqueOrThrowArgs>(args: SelectSubset<T, FoodIngredientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoodIngredientClient<$Result.GetResult<Prisma.$FoodIngredientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodIngredient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodIngredientFindFirstArgs} args - Arguments to find a FoodIngredient
     * @example
     * // Get one FoodIngredient
     * const foodIngredient = await prisma.foodIngredient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoodIngredientFindFirstArgs>(args?: SelectSubset<T, FoodIngredientFindFirstArgs<ExtArgs>>): Prisma__FoodIngredientClient<$Result.GetResult<Prisma.$FoodIngredientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodIngredient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodIngredientFindFirstOrThrowArgs} args - Arguments to find a FoodIngredient
     * @example
     * // Get one FoodIngredient
     * const foodIngredient = await prisma.foodIngredient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoodIngredientFindFirstOrThrowArgs>(args?: SelectSubset<T, FoodIngredientFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoodIngredientClient<$Result.GetResult<Prisma.$FoodIngredientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FoodIngredients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodIngredientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoodIngredients
     * const foodIngredients = await prisma.foodIngredient.findMany()
     * 
     * // Get first 10 FoodIngredients
     * const foodIngredients = await prisma.foodIngredient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foodIngredientWithIdOnly = await prisma.foodIngredient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FoodIngredientFindManyArgs>(args?: SelectSubset<T, FoodIngredientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodIngredientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FoodIngredient.
     * @param {FoodIngredientCreateArgs} args - Arguments to create a FoodIngredient.
     * @example
     * // Create one FoodIngredient
     * const FoodIngredient = await prisma.foodIngredient.create({
     *   data: {
     *     // ... data to create a FoodIngredient
     *   }
     * })
     * 
     */
    create<T extends FoodIngredientCreateArgs>(args: SelectSubset<T, FoodIngredientCreateArgs<ExtArgs>>): Prisma__FoodIngredientClient<$Result.GetResult<Prisma.$FoodIngredientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FoodIngredients.
     * @param {FoodIngredientCreateManyArgs} args - Arguments to create many FoodIngredients.
     * @example
     * // Create many FoodIngredients
     * const foodIngredient = await prisma.foodIngredient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoodIngredientCreateManyArgs>(args?: SelectSubset<T, FoodIngredientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FoodIngredients and returns the data saved in the database.
     * @param {FoodIngredientCreateManyAndReturnArgs} args - Arguments to create many FoodIngredients.
     * @example
     * // Create many FoodIngredients
     * const foodIngredient = await prisma.foodIngredient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FoodIngredients and only return the `id`
     * const foodIngredientWithIdOnly = await prisma.foodIngredient.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FoodIngredientCreateManyAndReturnArgs>(args?: SelectSubset<T, FoodIngredientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodIngredientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FoodIngredient.
     * @param {FoodIngredientDeleteArgs} args - Arguments to delete one FoodIngredient.
     * @example
     * // Delete one FoodIngredient
     * const FoodIngredient = await prisma.foodIngredient.delete({
     *   where: {
     *     // ... filter to delete one FoodIngredient
     *   }
     * })
     * 
     */
    delete<T extends FoodIngredientDeleteArgs>(args: SelectSubset<T, FoodIngredientDeleteArgs<ExtArgs>>): Prisma__FoodIngredientClient<$Result.GetResult<Prisma.$FoodIngredientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FoodIngredient.
     * @param {FoodIngredientUpdateArgs} args - Arguments to update one FoodIngredient.
     * @example
     * // Update one FoodIngredient
     * const foodIngredient = await prisma.foodIngredient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoodIngredientUpdateArgs>(args: SelectSubset<T, FoodIngredientUpdateArgs<ExtArgs>>): Prisma__FoodIngredientClient<$Result.GetResult<Prisma.$FoodIngredientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FoodIngredients.
     * @param {FoodIngredientDeleteManyArgs} args - Arguments to filter FoodIngredients to delete.
     * @example
     * // Delete a few FoodIngredients
     * const { count } = await prisma.foodIngredient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoodIngredientDeleteManyArgs>(args?: SelectSubset<T, FoodIngredientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodIngredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodIngredientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoodIngredients
     * const foodIngredient = await prisma.foodIngredient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoodIngredientUpdateManyArgs>(args: SelectSubset<T, FoodIngredientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodIngredients and returns the data updated in the database.
     * @param {FoodIngredientUpdateManyAndReturnArgs} args - Arguments to update many FoodIngredients.
     * @example
     * // Update many FoodIngredients
     * const foodIngredient = await prisma.foodIngredient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FoodIngredients and only return the `id`
     * const foodIngredientWithIdOnly = await prisma.foodIngredient.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FoodIngredientUpdateManyAndReturnArgs>(args: SelectSubset<T, FoodIngredientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodIngredientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FoodIngredient.
     * @param {FoodIngredientUpsertArgs} args - Arguments to update or create a FoodIngredient.
     * @example
     * // Update or create a FoodIngredient
     * const foodIngredient = await prisma.foodIngredient.upsert({
     *   create: {
     *     // ... data to create a FoodIngredient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoodIngredient we want to update
     *   }
     * })
     */
    upsert<T extends FoodIngredientUpsertArgs>(args: SelectSubset<T, FoodIngredientUpsertArgs<ExtArgs>>): Prisma__FoodIngredientClient<$Result.GetResult<Prisma.$FoodIngredientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FoodIngredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodIngredientCountArgs} args - Arguments to filter FoodIngredients to count.
     * @example
     * // Count the number of FoodIngredients
     * const count = await prisma.foodIngredient.count({
     *   where: {
     *     // ... the filter for the FoodIngredients we want to count
     *   }
     * })
    **/
    count<T extends FoodIngredientCountArgs>(
      args?: Subset<T, FoodIngredientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoodIngredientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FoodIngredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodIngredientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoodIngredientAggregateArgs>(args: Subset<T, FoodIngredientAggregateArgs>): Prisma.PrismaPromise<GetFoodIngredientAggregateType<T>>

    /**
     * Group by FoodIngredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodIngredientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoodIngredientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoodIngredientGroupByArgs['orderBy'] }
        : { orderBy?: FoodIngredientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoodIngredientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoodIngredientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FoodIngredient model
   */
  readonly fields: FoodIngredientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FoodIngredient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoodIngredientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    costs<T extends FoodIngredient$costsArgs<ExtArgs> = {}>(args?: Subset<T, FoodIngredient$costsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodIngredientCostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    items<T extends FoodIngredient$itemsArgs<ExtArgs> = {}>(args?: Subset<T, FoodIngredient$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodRecipeItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FoodIngredient model
   */
  interface FoodIngredientFieldRefs {
    readonly id: FieldRef<"FoodIngredient", 'Int'>
    readonly name: FieldRef<"FoodIngredient", 'String'>
    readonly category: FieldRef<"FoodIngredient", 'String'>
    readonly unit: FieldRef<"FoodIngredient", 'String'>
    readonly defaultWastePct: FieldRef<"FoodIngredient", 'Decimal'>
    readonly notes: FieldRef<"FoodIngredient", 'String'>
    readonly createdAt: FieldRef<"FoodIngredient", 'DateTime'>
    readonly updatedAt: FieldRef<"FoodIngredient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FoodIngredient findUnique
   */
  export type FoodIngredientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodIngredient
     */
    select?: FoodIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodIngredient
     */
    omit?: FoodIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodIngredientInclude<ExtArgs> | null
    /**
     * Filter, which FoodIngredient to fetch.
     */
    where: FoodIngredientWhereUniqueInput
  }

  /**
   * FoodIngredient findUniqueOrThrow
   */
  export type FoodIngredientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodIngredient
     */
    select?: FoodIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodIngredient
     */
    omit?: FoodIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodIngredientInclude<ExtArgs> | null
    /**
     * Filter, which FoodIngredient to fetch.
     */
    where: FoodIngredientWhereUniqueInput
  }

  /**
   * FoodIngredient findFirst
   */
  export type FoodIngredientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodIngredient
     */
    select?: FoodIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodIngredient
     */
    omit?: FoodIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodIngredientInclude<ExtArgs> | null
    /**
     * Filter, which FoodIngredient to fetch.
     */
    where?: FoodIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodIngredients to fetch.
     */
    orderBy?: FoodIngredientOrderByWithRelationInput | FoodIngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodIngredients.
     */
    cursor?: FoodIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodIngredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodIngredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodIngredients.
     */
    distinct?: FoodIngredientScalarFieldEnum | FoodIngredientScalarFieldEnum[]
  }

  /**
   * FoodIngredient findFirstOrThrow
   */
  export type FoodIngredientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodIngredient
     */
    select?: FoodIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodIngredient
     */
    omit?: FoodIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodIngredientInclude<ExtArgs> | null
    /**
     * Filter, which FoodIngredient to fetch.
     */
    where?: FoodIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodIngredients to fetch.
     */
    orderBy?: FoodIngredientOrderByWithRelationInput | FoodIngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodIngredients.
     */
    cursor?: FoodIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodIngredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodIngredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodIngredients.
     */
    distinct?: FoodIngredientScalarFieldEnum | FoodIngredientScalarFieldEnum[]
  }

  /**
   * FoodIngredient findMany
   */
  export type FoodIngredientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodIngredient
     */
    select?: FoodIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodIngredient
     */
    omit?: FoodIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodIngredientInclude<ExtArgs> | null
    /**
     * Filter, which FoodIngredients to fetch.
     */
    where?: FoodIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodIngredients to fetch.
     */
    orderBy?: FoodIngredientOrderByWithRelationInput | FoodIngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FoodIngredients.
     */
    cursor?: FoodIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodIngredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodIngredients.
     */
    skip?: number
    distinct?: FoodIngredientScalarFieldEnum | FoodIngredientScalarFieldEnum[]
  }

  /**
   * FoodIngredient create
   */
  export type FoodIngredientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodIngredient
     */
    select?: FoodIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodIngredient
     */
    omit?: FoodIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodIngredientInclude<ExtArgs> | null
    /**
     * The data needed to create a FoodIngredient.
     */
    data: XOR<FoodIngredientCreateInput, FoodIngredientUncheckedCreateInput>
  }

  /**
   * FoodIngredient createMany
   */
  export type FoodIngredientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FoodIngredients.
     */
    data: FoodIngredientCreateManyInput | FoodIngredientCreateManyInput[]
  }

  /**
   * FoodIngredient createManyAndReturn
   */
  export type FoodIngredientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodIngredient
     */
    select?: FoodIngredientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodIngredient
     */
    omit?: FoodIngredientOmit<ExtArgs> | null
    /**
     * The data used to create many FoodIngredients.
     */
    data: FoodIngredientCreateManyInput | FoodIngredientCreateManyInput[]
  }

  /**
   * FoodIngredient update
   */
  export type FoodIngredientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodIngredient
     */
    select?: FoodIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodIngredient
     */
    omit?: FoodIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodIngredientInclude<ExtArgs> | null
    /**
     * The data needed to update a FoodIngredient.
     */
    data: XOR<FoodIngredientUpdateInput, FoodIngredientUncheckedUpdateInput>
    /**
     * Choose, which FoodIngredient to update.
     */
    where: FoodIngredientWhereUniqueInput
  }

  /**
   * FoodIngredient updateMany
   */
  export type FoodIngredientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FoodIngredients.
     */
    data: XOR<FoodIngredientUpdateManyMutationInput, FoodIngredientUncheckedUpdateManyInput>
    /**
     * Filter which FoodIngredients to update
     */
    where?: FoodIngredientWhereInput
    /**
     * Limit how many FoodIngredients to update.
     */
    limit?: number
  }

  /**
   * FoodIngredient updateManyAndReturn
   */
  export type FoodIngredientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodIngredient
     */
    select?: FoodIngredientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodIngredient
     */
    omit?: FoodIngredientOmit<ExtArgs> | null
    /**
     * The data used to update FoodIngredients.
     */
    data: XOR<FoodIngredientUpdateManyMutationInput, FoodIngredientUncheckedUpdateManyInput>
    /**
     * Filter which FoodIngredients to update
     */
    where?: FoodIngredientWhereInput
    /**
     * Limit how many FoodIngredients to update.
     */
    limit?: number
  }

  /**
   * FoodIngredient upsert
   */
  export type FoodIngredientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodIngredient
     */
    select?: FoodIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodIngredient
     */
    omit?: FoodIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodIngredientInclude<ExtArgs> | null
    /**
     * The filter to search for the FoodIngredient to update in case it exists.
     */
    where: FoodIngredientWhereUniqueInput
    /**
     * In case the FoodIngredient found by the `where` argument doesn't exist, create a new FoodIngredient with this data.
     */
    create: XOR<FoodIngredientCreateInput, FoodIngredientUncheckedCreateInput>
    /**
     * In case the FoodIngredient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoodIngredientUpdateInput, FoodIngredientUncheckedUpdateInput>
  }

  /**
   * FoodIngredient delete
   */
  export type FoodIngredientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodIngredient
     */
    select?: FoodIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodIngredient
     */
    omit?: FoodIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodIngredientInclude<ExtArgs> | null
    /**
     * Filter which FoodIngredient to delete.
     */
    where: FoodIngredientWhereUniqueInput
  }

  /**
   * FoodIngredient deleteMany
   */
  export type FoodIngredientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodIngredients to delete
     */
    where?: FoodIngredientWhereInput
    /**
     * Limit how many FoodIngredients to delete.
     */
    limit?: number
  }

  /**
   * FoodIngredient.costs
   */
  export type FoodIngredient$costsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodIngredientCost
     */
    select?: FoodIngredientCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodIngredientCost
     */
    omit?: FoodIngredientCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodIngredientCostInclude<ExtArgs> | null
    where?: FoodIngredientCostWhereInput
    orderBy?: FoodIngredientCostOrderByWithRelationInput | FoodIngredientCostOrderByWithRelationInput[]
    cursor?: FoodIngredientCostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoodIngredientCostScalarFieldEnum | FoodIngredientCostScalarFieldEnum[]
  }

  /**
   * FoodIngredient.items
   */
  export type FoodIngredient$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipeItem
     */
    select?: FoodRecipeItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipeItem
     */
    omit?: FoodRecipeItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRecipeItemInclude<ExtArgs> | null
    where?: FoodRecipeItemWhereInput
    orderBy?: FoodRecipeItemOrderByWithRelationInput | FoodRecipeItemOrderByWithRelationInput[]
    cursor?: FoodRecipeItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoodRecipeItemScalarFieldEnum | FoodRecipeItemScalarFieldEnum[]
  }

  /**
   * FoodIngredient without action
   */
  export type FoodIngredientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodIngredient
     */
    select?: FoodIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodIngredient
     */
    omit?: FoodIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodIngredientInclude<ExtArgs> | null
  }


  /**
   * Model FoodIngredientCost
   */

  export type AggregateFoodIngredientCost = {
    _count: FoodIngredientCostCountAggregateOutputType | null
    _avg: FoodIngredientCostAvgAggregateOutputType | null
    _sum: FoodIngredientCostSumAggregateOutputType | null
    _min: FoodIngredientCostMinAggregateOutputType | null
    _max: FoodIngredientCostMaxAggregateOutputType | null
  }

  export type FoodIngredientCostAvgAggregateOutputType = {
    id: number | null
    ingredientId: number | null
    unitCost: Decimal | null
  }

  export type FoodIngredientCostSumAggregateOutputType = {
    id: number | null
    ingredientId: number | null
    unitCost: Decimal | null
  }

  export type FoodIngredientCostMinAggregateOutputType = {
    id: number | null
    ingredientId: number | null
    unitCost: Decimal | null
    effectiveDate: Date | null
    source: string | null
    createdAt: Date | null
  }

  export type FoodIngredientCostMaxAggregateOutputType = {
    id: number | null
    ingredientId: number | null
    unitCost: Decimal | null
    effectiveDate: Date | null
    source: string | null
    createdAt: Date | null
  }

  export type FoodIngredientCostCountAggregateOutputType = {
    id: number
    ingredientId: number
    unitCost: number
    effectiveDate: number
    source: number
    createdAt: number
    _all: number
  }


  export type FoodIngredientCostAvgAggregateInputType = {
    id?: true
    ingredientId?: true
    unitCost?: true
  }

  export type FoodIngredientCostSumAggregateInputType = {
    id?: true
    ingredientId?: true
    unitCost?: true
  }

  export type FoodIngredientCostMinAggregateInputType = {
    id?: true
    ingredientId?: true
    unitCost?: true
    effectiveDate?: true
    source?: true
    createdAt?: true
  }

  export type FoodIngredientCostMaxAggregateInputType = {
    id?: true
    ingredientId?: true
    unitCost?: true
    effectiveDate?: true
    source?: true
    createdAt?: true
  }

  export type FoodIngredientCostCountAggregateInputType = {
    id?: true
    ingredientId?: true
    unitCost?: true
    effectiveDate?: true
    source?: true
    createdAt?: true
    _all?: true
  }

  export type FoodIngredientCostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodIngredientCost to aggregate.
     */
    where?: FoodIngredientCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodIngredientCosts to fetch.
     */
    orderBy?: FoodIngredientCostOrderByWithRelationInput | FoodIngredientCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoodIngredientCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodIngredientCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodIngredientCosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FoodIngredientCosts
    **/
    _count?: true | FoodIngredientCostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FoodIngredientCostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FoodIngredientCostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoodIngredientCostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoodIngredientCostMaxAggregateInputType
  }

  export type GetFoodIngredientCostAggregateType<T extends FoodIngredientCostAggregateArgs> = {
        [P in keyof T & keyof AggregateFoodIngredientCost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoodIngredientCost[P]>
      : GetScalarType<T[P], AggregateFoodIngredientCost[P]>
  }




  export type FoodIngredientCostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodIngredientCostWhereInput
    orderBy?: FoodIngredientCostOrderByWithAggregationInput | FoodIngredientCostOrderByWithAggregationInput[]
    by: FoodIngredientCostScalarFieldEnum[] | FoodIngredientCostScalarFieldEnum
    having?: FoodIngredientCostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoodIngredientCostCountAggregateInputType | true
    _avg?: FoodIngredientCostAvgAggregateInputType
    _sum?: FoodIngredientCostSumAggregateInputType
    _min?: FoodIngredientCostMinAggregateInputType
    _max?: FoodIngredientCostMaxAggregateInputType
  }

  export type FoodIngredientCostGroupByOutputType = {
    id: number
    ingredientId: number
    unitCost: Decimal
    effectiveDate: Date | null
    source: string | null
    createdAt: Date
    _count: FoodIngredientCostCountAggregateOutputType | null
    _avg: FoodIngredientCostAvgAggregateOutputType | null
    _sum: FoodIngredientCostSumAggregateOutputType | null
    _min: FoodIngredientCostMinAggregateOutputType | null
    _max: FoodIngredientCostMaxAggregateOutputType | null
  }

  type GetFoodIngredientCostGroupByPayload<T extends FoodIngredientCostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoodIngredientCostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoodIngredientCostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoodIngredientCostGroupByOutputType[P]>
            : GetScalarType<T[P], FoodIngredientCostGroupByOutputType[P]>
        }
      >
    >


  export type FoodIngredientCostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ingredientId?: boolean
    unitCost?: boolean
    effectiveDate?: boolean
    source?: boolean
    createdAt?: boolean
    ingredient?: boolean | FoodIngredientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodIngredientCost"]>

  export type FoodIngredientCostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ingredientId?: boolean
    unitCost?: boolean
    effectiveDate?: boolean
    source?: boolean
    createdAt?: boolean
    ingredient?: boolean | FoodIngredientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodIngredientCost"]>

  export type FoodIngredientCostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ingredientId?: boolean
    unitCost?: boolean
    effectiveDate?: boolean
    source?: boolean
    createdAt?: boolean
    ingredient?: boolean | FoodIngredientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodIngredientCost"]>

  export type FoodIngredientCostSelectScalar = {
    id?: boolean
    ingredientId?: boolean
    unitCost?: boolean
    effectiveDate?: boolean
    source?: boolean
    createdAt?: boolean
  }

  export type FoodIngredientCostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ingredientId" | "unitCost" | "effectiveDate" | "source" | "createdAt", ExtArgs["result"]["foodIngredientCost"]>
  export type FoodIngredientCostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ingredient?: boolean | FoodIngredientDefaultArgs<ExtArgs>
  }
  export type FoodIngredientCostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ingredient?: boolean | FoodIngredientDefaultArgs<ExtArgs>
  }
  export type FoodIngredientCostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ingredient?: boolean | FoodIngredientDefaultArgs<ExtArgs>
  }

  export type $FoodIngredientCostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FoodIngredientCost"
    objects: {
      ingredient: Prisma.$FoodIngredientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ingredientId: number
      unitCost: Prisma.Decimal
      effectiveDate: Date | null
      source: string | null
      createdAt: Date
    }, ExtArgs["result"]["foodIngredientCost"]>
    composites: {}
  }

  type FoodIngredientCostGetPayload<S extends boolean | null | undefined | FoodIngredientCostDefaultArgs> = $Result.GetResult<Prisma.$FoodIngredientCostPayload, S>

  type FoodIngredientCostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FoodIngredientCostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FoodIngredientCostCountAggregateInputType | true
    }

  export interface FoodIngredientCostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FoodIngredientCost'], meta: { name: 'FoodIngredientCost' } }
    /**
     * Find zero or one FoodIngredientCost that matches the filter.
     * @param {FoodIngredientCostFindUniqueArgs} args - Arguments to find a FoodIngredientCost
     * @example
     * // Get one FoodIngredientCost
     * const foodIngredientCost = await prisma.foodIngredientCost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoodIngredientCostFindUniqueArgs>(args: SelectSubset<T, FoodIngredientCostFindUniqueArgs<ExtArgs>>): Prisma__FoodIngredientCostClient<$Result.GetResult<Prisma.$FoodIngredientCostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FoodIngredientCost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FoodIngredientCostFindUniqueOrThrowArgs} args - Arguments to find a FoodIngredientCost
     * @example
     * // Get one FoodIngredientCost
     * const foodIngredientCost = await prisma.foodIngredientCost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoodIngredientCostFindUniqueOrThrowArgs>(args: SelectSubset<T, FoodIngredientCostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoodIngredientCostClient<$Result.GetResult<Prisma.$FoodIngredientCostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodIngredientCost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodIngredientCostFindFirstArgs} args - Arguments to find a FoodIngredientCost
     * @example
     * // Get one FoodIngredientCost
     * const foodIngredientCost = await prisma.foodIngredientCost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoodIngredientCostFindFirstArgs>(args?: SelectSubset<T, FoodIngredientCostFindFirstArgs<ExtArgs>>): Prisma__FoodIngredientCostClient<$Result.GetResult<Prisma.$FoodIngredientCostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodIngredientCost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodIngredientCostFindFirstOrThrowArgs} args - Arguments to find a FoodIngredientCost
     * @example
     * // Get one FoodIngredientCost
     * const foodIngredientCost = await prisma.foodIngredientCost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoodIngredientCostFindFirstOrThrowArgs>(args?: SelectSubset<T, FoodIngredientCostFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoodIngredientCostClient<$Result.GetResult<Prisma.$FoodIngredientCostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FoodIngredientCosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodIngredientCostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoodIngredientCosts
     * const foodIngredientCosts = await prisma.foodIngredientCost.findMany()
     * 
     * // Get first 10 FoodIngredientCosts
     * const foodIngredientCosts = await prisma.foodIngredientCost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foodIngredientCostWithIdOnly = await prisma.foodIngredientCost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FoodIngredientCostFindManyArgs>(args?: SelectSubset<T, FoodIngredientCostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodIngredientCostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FoodIngredientCost.
     * @param {FoodIngredientCostCreateArgs} args - Arguments to create a FoodIngredientCost.
     * @example
     * // Create one FoodIngredientCost
     * const FoodIngredientCost = await prisma.foodIngredientCost.create({
     *   data: {
     *     // ... data to create a FoodIngredientCost
     *   }
     * })
     * 
     */
    create<T extends FoodIngredientCostCreateArgs>(args: SelectSubset<T, FoodIngredientCostCreateArgs<ExtArgs>>): Prisma__FoodIngredientCostClient<$Result.GetResult<Prisma.$FoodIngredientCostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FoodIngredientCosts.
     * @param {FoodIngredientCostCreateManyArgs} args - Arguments to create many FoodIngredientCosts.
     * @example
     * // Create many FoodIngredientCosts
     * const foodIngredientCost = await prisma.foodIngredientCost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoodIngredientCostCreateManyArgs>(args?: SelectSubset<T, FoodIngredientCostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FoodIngredientCosts and returns the data saved in the database.
     * @param {FoodIngredientCostCreateManyAndReturnArgs} args - Arguments to create many FoodIngredientCosts.
     * @example
     * // Create many FoodIngredientCosts
     * const foodIngredientCost = await prisma.foodIngredientCost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FoodIngredientCosts and only return the `id`
     * const foodIngredientCostWithIdOnly = await prisma.foodIngredientCost.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FoodIngredientCostCreateManyAndReturnArgs>(args?: SelectSubset<T, FoodIngredientCostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodIngredientCostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FoodIngredientCost.
     * @param {FoodIngredientCostDeleteArgs} args - Arguments to delete one FoodIngredientCost.
     * @example
     * // Delete one FoodIngredientCost
     * const FoodIngredientCost = await prisma.foodIngredientCost.delete({
     *   where: {
     *     // ... filter to delete one FoodIngredientCost
     *   }
     * })
     * 
     */
    delete<T extends FoodIngredientCostDeleteArgs>(args: SelectSubset<T, FoodIngredientCostDeleteArgs<ExtArgs>>): Prisma__FoodIngredientCostClient<$Result.GetResult<Prisma.$FoodIngredientCostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FoodIngredientCost.
     * @param {FoodIngredientCostUpdateArgs} args - Arguments to update one FoodIngredientCost.
     * @example
     * // Update one FoodIngredientCost
     * const foodIngredientCost = await prisma.foodIngredientCost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoodIngredientCostUpdateArgs>(args: SelectSubset<T, FoodIngredientCostUpdateArgs<ExtArgs>>): Prisma__FoodIngredientCostClient<$Result.GetResult<Prisma.$FoodIngredientCostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FoodIngredientCosts.
     * @param {FoodIngredientCostDeleteManyArgs} args - Arguments to filter FoodIngredientCosts to delete.
     * @example
     * // Delete a few FoodIngredientCosts
     * const { count } = await prisma.foodIngredientCost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoodIngredientCostDeleteManyArgs>(args?: SelectSubset<T, FoodIngredientCostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodIngredientCosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodIngredientCostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoodIngredientCosts
     * const foodIngredientCost = await prisma.foodIngredientCost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoodIngredientCostUpdateManyArgs>(args: SelectSubset<T, FoodIngredientCostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodIngredientCosts and returns the data updated in the database.
     * @param {FoodIngredientCostUpdateManyAndReturnArgs} args - Arguments to update many FoodIngredientCosts.
     * @example
     * // Update many FoodIngredientCosts
     * const foodIngredientCost = await prisma.foodIngredientCost.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FoodIngredientCosts and only return the `id`
     * const foodIngredientCostWithIdOnly = await prisma.foodIngredientCost.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FoodIngredientCostUpdateManyAndReturnArgs>(args: SelectSubset<T, FoodIngredientCostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodIngredientCostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FoodIngredientCost.
     * @param {FoodIngredientCostUpsertArgs} args - Arguments to update or create a FoodIngredientCost.
     * @example
     * // Update or create a FoodIngredientCost
     * const foodIngredientCost = await prisma.foodIngredientCost.upsert({
     *   create: {
     *     // ... data to create a FoodIngredientCost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoodIngredientCost we want to update
     *   }
     * })
     */
    upsert<T extends FoodIngredientCostUpsertArgs>(args: SelectSubset<T, FoodIngredientCostUpsertArgs<ExtArgs>>): Prisma__FoodIngredientCostClient<$Result.GetResult<Prisma.$FoodIngredientCostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FoodIngredientCosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodIngredientCostCountArgs} args - Arguments to filter FoodIngredientCosts to count.
     * @example
     * // Count the number of FoodIngredientCosts
     * const count = await prisma.foodIngredientCost.count({
     *   where: {
     *     // ... the filter for the FoodIngredientCosts we want to count
     *   }
     * })
    **/
    count<T extends FoodIngredientCostCountArgs>(
      args?: Subset<T, FoodIngredientCostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoodIngredientCostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FoodIngredientCost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodIngredientCostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoodIngredientCostAggregateArgs>(args: Subset<T, FoodIngredientCostAggregateArgs>): Prisma.PrismaPromise<GetFoodIngredientCostAggregateType<T>>

    /**
     * Group by FoodIngredientCost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodIngredientCostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoodIngredientCostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoodIngredientCostGroupByArgs['orderBy'] }
        : { orderBy?: FoodIngredientCostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoodIngredientCostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoodIngredientCostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FoodIngredientCost model
   */
  readonly fields: FoodIngredientCostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FoodIngredientCost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoodIngredientCostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ingredient<T extends FoodIngredientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FoodIngredientDefaultArgs<ExtArgs>>): Prisma__FoodIngredientClient<$Result.GetResult<Prisma.$FoodIngredientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FoodIngredientCost model
   */
  interface FoodIngredientCostFieldRefs {
    readonly id: FieldRef<"FoodIngredientCost", 'Int'>
    readonly ingredientId: FieldRef<"FoodIngredientCost", 'Int'>
    readonly unitCost: FieldRef<"FoodIngredientCost", 'Decimal'>
    readonly effectiveDate: FieldRef<"FoodIngredientCost", 'DateTime'>
    readonly source: FieldRef<"FoodIngredientCost", 'String'>
    readonly createdAt: FieldRef<"FoodIngredientCost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FoodIngredientCost findUnique
   */
  export type FoodIngredientCostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodIngredientCost
     */
    select?: FoodIngredientCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodIngredientCost
     */
    omit?: FoodIngredientCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodIngredientCostInclude<ExtArgs> | null
    /**
     * Filter, which FoodIngredientCost to fetch.
     */
    where: FoodIngredientCostWhereUniqueInput
  }

  /**
   * FoodIngredientCost findUniqueOrThrow
   */
  export type FoodIngredientCostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodIngredientCost
     */
    select?: FoodIngredientCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodIngredientCost
     */
    omit?: FoodIngredientCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodIngredientCostInclude<ExtArgs> | null
    /**
     * Filter, which FoodIngredientCost to fetch.
     */
    where: FoodIngredientCostWhereUniqueInput
  }

  /**
   * FoodIngredientCost findFirst
   */
  export type FoodIngredientCostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodIngredientCost
     */
    select?: FoodIngredientCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodIngredientCost
     */
    omit?: FoodIngredientCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodIngredientCostInclude<ExtArgs> | null
    /**
     * Filter, which FoodIngredientCost to fetch.
     */
    where?: FoodIngredientCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodIngredientCosts to fetch.
     */
    orderBy?: FoodIngredientCostOrderByWithRelationInput | FoodIngredientCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodIngredientCosts.
     */
    cursor?: FoodIngredientCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodIngredientCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodIngredientCosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodIngredientCosts.
     */
    distinct?: FoodIngredientCostScalarFieldEnum | FoodIngredientCostScalarFieldEnum[]
  }

  /**
   * FoodIngredientCost findFirstOrThrow
   */
  export type FoodIngredientCostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodIngredientCost
     */
    select?: FoodIngredientCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodIngredientCost
     */
    omit?: FoodIngredientCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodIngredientCostInclude<ExtArgs> | null
    /**
     * Filter, which FoodIngredientCost to fetch.
     */
    where?: FoodIngredientCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodIngredientCosts to fetch.
     */
    orderBy?: FoodIngredientCostOrderByWithRelationInput | FoodIngredientCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodIngredientCosts.
     */
    cursor?: FoodIngredientCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodIngredientCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodIngredientCosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodIngredientCosts.
     */
    distinct?: FoodIngredientCostScalarFieldEnum | FoodIngredientCostScalarFieldEnum[]
  }

  /**
   * FoodIngredientCost findMany
   */
  export type FoodIngredientCostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodIngredientCost
     */
    select?: FoodIngredientCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodIngredientCost
     */
    omit?: FoodIngredientCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodIngredientCostInclude<ExtArgs> | null
    /**
     * Filter, which FoodIngredientCosts to fetch.
     */
    where?: FoodIngredientCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodIngredientCosts to fetch.
     */
    orderBy?: FoodIngredientCostOrderByWithRelationInput | FoodIngredientCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FoodIngredientCosts.
     */
    cursor?: FoodIngredientCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodIngredientCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodIngredientCosts.
     */
    skip?: number
    distinct?: FoodIngredientCostScalarFieldEnum | FoodIngredientCostScalarFieldEnum[]
  }

  /**
   * FoodIngredientCost create
   */
  export type FoodIngredientCostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodIngredientCost
     */
    select?: FoodIngredientCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodIngredientCost
     */
    omit?: FoodIngredientCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodIngredientCostInclude<ExtArgs> | null
    /**
     * The data needed to create a FoodIngredientCost.
     */
    data: XOR<FoodIngredientCostCreateInput, FoodIngredientCostUncheckedCreateInput>
  }

  /**
   * FoodIngredientCost createMany
   */
  export type FoodIngredientCostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FoodIngredientCosts.
     */
    data: FoodIngredientCostCreateManyInput | FoodIngredientCostCreateManyInput[]
  }

  /**
   * FoodIngredientCost createManyAndReturn
   */
  export type FoodIngredientCostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodIngredientCost
     */
    select?: FoodIngredientCostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodIngredientCost
     */
    omit?: FoodIngredientCostOmit<ExtArgs> | null
    /**
     * The data used to create many FoodIngredientCosts.
     */
    data: FoodIngredientCostCreateManyInput | FoodIngredientCostCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodIngredientCostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FoodIngredientCost update
   */
  export type FoodIngredientCostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodIngredientCost
     */
    select?: FoodIngredientCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodIngredientCost
     */
    omit?: FoodIngredientCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodIngredientCostInclude<ExtArgs> | null
    /**
     * The data needed to update a FoodIngredientCost.
     */
    data: XOR<FoodIngredientCostUpdateInput, FoodIngredientCostUncheckedUpdateInput>
    /**
     * Choose, which FoodIngredientCost to update.
     */
    where: FoodIngredientCostWhereUniqueInput
  }

  /**
   * FoodIngredientCost updateMany
   */
  export type FoodIngredientCostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FoodIngredientCosts.
     */
    data: XOR<FoodIngredientCostUpdateManyMutationInput, FoodIngredientCostUncheckedUpdateManyInput>
    /**
     * Filter which FoodIngredientCosts to update
     */
    where?: FoodIngredientCostWhereInput
    /**
     * Limit how many FoodIngredientCosts to update.
     */
    limit?: number
  }

  /**
   * FoodIngredientCost updateManyAndReturn
   */
  export type FoodIngredientCostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodIngredientCost
     */
    select?: FoodIngredientCostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodIngredientCost
     */
    omit?: FoodIngredientCostOmit<ExtArgs> | null
    /**
     * The data used to update FoodIngredientCosts.
     */
    data: XOR<FoodIngredientCostUpdateManyMutationInput, FoodIngredientCostUncheckedUpdateManyInput>
    /**
     * Filter which FoodIngredientCosts to update
     */
    where?: FoodIngredientCostWhereInput
    /**
     * Limit how many FoodIngredientCosts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodIngredientCostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FoodIngredientCost upsert
   */
  export type FoodIngredientCostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodIngredientCost
     */
    select?: FoodIngredientCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodIngredientCost
     */
    omit?: FoodIngredientCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodIngredientCostInclude<ExtArgs> | null
    /**
     * The filter to search for the FoodIngredientCost to update in case it exists.
     */
    where: FoodIngredientCostWhereUniqueInput
    /**
     * In case the FoodIngredientCost found by the `where` argument doesn't exist, create a new FoodIngredientCost with this data.
     */
    create: XOR<FoodIngredientCostCreateInput, FoodIngredientCostUncheckedCreateInput>
    /**
     * In case the FoodIngredientCost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoodIngredientCostUpdateInput, FoodIngredientCostUncheckedUpdateInput>
  }

  /**
   * FoodIngredientCost delete
   */
  export type FoodIngredientCostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodIngredientCost
     */
    select?: FoodIngredientCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodIngredientCost
     */
    omit?: FoodIngredientCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodIngredientCostInclude<ExtArgs> | null
    /**
     * Filter which FoodIngredientCost to delete.
     */
    where: FoodIngredientCostWhereUniqueInput
  }

  /**
   * FoodIngredientCost deleteMany
   */
  export type FoodIngredientCostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodIngredientCosts to delete
     */
    where?: FoodIngredientCostWhereInput
    /**
     * Limit how many FoodIngredientCosts to delete.
     */
    limit?: number
  }

  /**
   * FoodIngredientCost without action
   */
  export type FoodIngredientCostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodIngredientCost
     */
    select?: FoodIngredientCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodIngredientCost
     */
    omit?: FoodIngredientCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodIngredientCostInclude<ExtArgs> | null
  }


  /**
   * Model FoodRecipe
   */

  export type AggregateFoodRecipe = {
    _count: FoodRecipeCountAggregateOutputType | null
    _avg: FoodRecipeAvgAggregateOutputType | null
    _sum: FoodRecipeSumAggregateOutputType | null
    _min: FoodRecipeMinAggregateOutputType | null
    _max: FoodRecipeMaxAggregateOutputType | null
  }

  export type FoodRecipeAvgAggregateOutputType = {
    id: number | null
    yield: Decimal | null
    prepMinutes: Decimal | null
    dailyBlocks: number | null
  }

  export type FoodRecipeSumAggregateOutputType = {
    id: number | null
    yield: Decimal | null
    prepMinutes: Decimal | null
    dailyBlocks: number | null
  }

  export type FoodRecipeMinAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    mealType: $Enums.FoodMealType | null
    yield: Decimal | null
    yieldUnit: string | null
    isActive: boolean | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    prepMinutes: Decimal | null
    dailyBlocks: number | null
  }

  export type FoodRecipeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    mealType: $Enums.FoodMealType | null
    yield: Decimal | null
    yieldUnit: string | null
    isActive: boolean | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    prepMinutes: Decimal | null
    dailyBlocks: number | null
  }

  export type FoodRecipeCountAggregateOutputType = {
    id: number
    name: number
    code: number
    mealType: number
    yield: number
    yieldUnit: number
    isActive: number
    notes: number
    createdAt: number
    updatedAt: number
    prepMinutes: number
    dailyBlocks: number
    _all: number
  }


  export type FoodRecipeAvgAggregateInputType = {
    id?: true
    yield?: true
    prepMinutes?: true
    dailyBlocks?: true
  }

  export type FoodRecipeSumAggregateInputType = {
    id?: true
    yield?: true
    prepMinutes?: true
    dailyBlocks?: true
  }

  export type FoodRecipeMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    mealType?: true
    yield?: true
    yieldUnit?: true
    isActive?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    prepMinutes?: true
    dailyBlocks?: true
  }

  export type FoodRecipeMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    mealType?: true
    yield?: true
    yieldUnit?: true
    isActive?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    prepMinutes?: true
    dailyBlocks?: true
  }

  export type FoodRecipeCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    mealType?: true
    yield?: true
    yieldUnit?: true
    isActive?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    prepMinutes?: true
    dailyBlocks?: true
    _all?: true
  }

  export type FoodRecipeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodRecipe to aggregate.
     */
    where?: FoodRecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodRecipes to fetch.
     */
    orderBy?: FoodRecipeOrderByWithRelationInput | FoodRecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoodRecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodRecipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodRecipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FoodRecipes
    **/
    _count?: true | FoodRecipeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FoodRecipeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FoodRecipeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoodRecipeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoodRecipeMaxAggregateInputType
  }

  export type GetFoodRecipeAggregateType<T extends FoodRecipeAggregateArgs> = {
        [P in keyof T & keyof AggregateFoodRecipe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoodRecipe[P]>
      : GetScalarType<T[P], AggregateFoodRecipe[P]>
  }




  export type FoodRecipeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodRecipeWhereInput
    orderBy?: FoodRecipeOrderByWithAggregationInput | FoodRecipeOrderByWithAggregationInput[]
    by: FoodRecipeScalarFieldEnum[] | FoodRecipeScalarFieldEnum
    having?: FoodRecipeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoodRecipeCountAggregateInputType | true
    _avg?: FoodRecipeAvgAggregateInputType
    _sum?: FoodRecipeSumAggregateInputType
    _min?: FoodRecipeMinAggregateInputType
    _max?: FoodRecipeMaxAggregateInputType
  }

  export type FoodRecipeGroupByOutputType = {
    id: number
    name: string
    code: string | null
    mealType: $Enums.FoodMealType
    yield: Decimal
    yieldUnit: string | null
    isActive: boolean
    notes: string | null
    createdAt: Date
    updatedAt: Date
    prepMinutes: Decimal | null
    dailyBlocks: number | null
    _count: FoodRecipeCountAggregateOutputType | null
    _avg: FoodRecipeAvgAggregateOutputType | null
    _sum: FoodRecipeSumAggregateOutputType | null
    _min: FoodRecipeMinAggregateOutputType | null
    _max: FoodRecipeMaxAggregateOutputType | null
  }

  type GetFoodRecipeGroupByPayload<T extends FoodRecipeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoodRecipeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoodRecipeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoodRecipeGroupByOutputType[P]>
            : GetScalarType<T[P], FoodRecipeGroupByOutputType[P]>
        }
      >
    >


  export type FoodRecipeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    mealType?: boolean
    yield?: boolean
    yieldUnit?: boolean
    isActive?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    prepMinutes?: boolean
    dailyBlocks?: boolean
    items?: boolean | FoodRecipe$itemsArgs<ExtArgs>
    childItems?: boolean | FoodRecipe$childItemsArgs<ExtArgs>
    extraCosts?: boolean | FoodRecipe$extraCostsArgs<ExtArgs>
    mealPlanEntries?: boolean | FoodRecipe$mealPlanEntriesArgs<ExtArgs>
    _count?: boolean | FoodRecipeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodRecipe"]>

  export type FoodRecipeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    mealType?: boolean
    yield?: boolean
    yieldUnit?: boolean
    isActive?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    prepMinutes?: boolean
    dailyBlocks?: boolean
  }, ExtArgs["result"]["foodRecipe"]>

  export type FoodRecipeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    mealType?: boolean
    yield?: boolean
    yieldUnit?: boolean
    isActive?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    prepMinutes?: boolean
    dailyBlocks?: boolean
  }, ExtArgs["result"]["foodRecipe"]>

  export type FoodRecipeSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    mealType?: boolean
    yield?: boolean
    yieldUnit?: boolean
    isActive?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    prepMinutes?: boolean
    dailyBlocks?: boolean
  }

  export type FoodRecipeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "mealType" | "yield" | "yieldUnit" | "isActive" | "notes" | "createdAt" | "updatedAt" | "prepMinutes" | "dailyBlocks", ExtArgs["result"]["foodRecipe"]>
  export type FoodRecipeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | FoodRecipe$itemsArgs<ExtArgs>
    childItems?: boolean | FoodRecipe$childItemsArgs<ExtArgs>
    extraCosts?: boolean | FoodRecipe$extraCostsArgs<ExtArgs>
    mealPlanEntries?: boolean | FoodRecipe$mealPlanEntriesArgs<ExtArgs>
    _count?: boolean | FoodRecipeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FoodRecipeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FoodRecipeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FoodRecipePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FoodRecipe"
    objects: {
      items: Prisma.$FoodRecipeItemPayload<ExtArgs>[]
      childItems: Prisma.$FoodRecipeItemPayload<ExtArgs>[]
      extraCosts: Prisma.$FoodRecipeCostPayload<ExtArgs>[]
      mealPlanEntries: Prisma.$FoodMealPlanEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      code: string | null
      mealType: $Enums.FoodMealType
      yield: Prisma.Decimal
      yieldUnit: string | null
      isActive: boolean
      notes: string | null
      createdAt: Date
      updatedAt: Date
      prepMinutes: Prisma.Decimal | null
      dailyBlocks: number | null
    }, ExtArgs["result"]["foodRecipe"]>
    composites: {}
  }

  type FoodRecipeGetPayload<S extends boolean | null | undefined | FoodRecipeDefaultArgs> = $Result.GetResult<Prisma.$FoodRecipePayload, S>

  type FoodRecipeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FoodRecipeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FoodRecipeCountAggregateInputType | true
    }

  export interface FoodRecipeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FoodRecipe'], meta: { name: 'FoodRecipe' } }
    /**
     * Find zero or one FoodRecipe that matches the filter.
     * @param {FoodRecipeFindUniqueArgs} args - Arguments to find a FoodRecipe
     * @example
     * // Get one FoodRecipe
     * const foodRecipe = await prisma.foodRecipe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoodRecipeFindUniqueArgs>(args: SelectSubset<T, FoodRecipeFindUniqueArgs<ExtArgs>>): Prisma__FoodRecipeClient<$Result.GetResult<Prisma.$FoodRecipePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FoodRecipe that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FoodRecipeFindUniqueOrThrowArgs} args - Arguments to find a FoodRecipe
     * @example
     * // Get one FoodRecipe
     * const foodRecipe = await prisma.foodRecipe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoodRecipeFindUniqueOrThrowArgs>(args: SelectSubset<T, FoodRecipeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoodRecipeClient<$Result.GetResult<Prisma.$FoodRecipePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodRecipe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodRecipeFindFirstArgs} args - Arguments to find a FoodRecipe
     * @example
     * // Get one FoodRecipe
     * const foodRecipe = await prisma.foodRecipe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoodRecipeFindFirstArgs>(args?: SelectSubset<T, FoodRecipeFindFirstArgs<ExtArgs>>): Prisma__FoodRecipeClient<$Result.GetResult<Prisma.$FoodRecipePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodRecipe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodRecipeFindFirstOrThrowArgs} args - Arguments to find a FoodRecipe
     * @example
     * // Get one FoodRecipe
     * const foodRecipe = await prisma.foodRecipe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoodRecipeFindFirstOrThrowArgs>(args?: SelectSubset<T, FoodRecipeFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoodRecipeClient<$Result.GetResult<Prisma.$FoodRecipePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FoodRecipes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodRecipeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoodRecipes
     * const foodRecipes = await prisma.foodRecipe.findMany()
     * 
     * // Get first 10 FoodRecipes
     * const foodRecipes = await prisma.foodRecipe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foodRecipeWithIdOnly = await prisma.foodRecipe.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FoodRecipeFindManyArgs>(args?: SelectSubset<T, FoodRecipeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodRecipePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FoodRecipe.
     * @param {FoodRecipeCreateArgs} args - Arguments to create a FoodRecipe.
     * @example
     * // Create one FoodRecipe
     * const FoodRecipe = await prisma.foodRecipe.create({
     *   data: {
     *     // ... data to create a FoodRecipe
     *   }
     * })
     * 
     */
    create<T extends FoodRecipeCreateArgs>(args: SelectSubset<T, FoodRecipeCreateArgs<ExtArgs>>): Prisma__FoodRecipeClient<$Result.GetResult<Prisma.$FoodRecipePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FoodRecipes.
     * @param {FoodRecipeCreateManyArgs} args - Arguments to create many FoodRecipes.
     * @example
     * // Create many FoodRecipes
     * const foodRecipe = await prisma.foodRecipe.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoodRecipeCreateManyArgs>(args?: SelectSubset<T, FoodRecipeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FoodRecipes and returns the data saved in the database.
     * @param {FoodRecipeCreateManyAndReturnArgs} args - Arguments to create many FoodRecipes.
     * @example
     * // Create many FoodRecipes
     * const foodRecipe = await prisma.foodRecipe.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FoodRecipes and only return the `id`
     * const foodRecipeWithIdOnly = await prisma.foodRecipe.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FoodRecipeCreateManyAndReturnArgs>(args?: SelectSubset<T, FoodRecipeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodRecipePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FoodRecipe.
     * @param {FoodRecipeDeleteArgs} args - Arguments to delete one FoodRecipe.
     * @example
     * // Delete one FoodRecipe
     * const FoodRecipe = await prisma.foodRecipe.delete({
     *   where: {
     *     // ... filter to delete one FoodRecipe
     *   }
     * })
     * 
     */
    delete<T extends FoodRecipeDeleteArgs>(args: SelectSubset<T, FoodRecipeDeleteArgs<ExtArgs>>): Prisma__FoodRecipeClient<$Result.GetResult<Prisma.$FoodRecipePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FoodRecipe.
     * @param {FoodRecipeUpdateArgs} args - Arguments to update one FoodRecipe.
     * @example
     * // Update one FoodRecipe
     * const foodRecipe = await prisma.foodRecipe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoodRecipeUpdateArgs>(args: SelectSubset<T, FoodRecipeUpdateArgs<ExtArgs>>): Prisma__FoodRecipeClient<$Result.GetResult<Prisma.$FoodRecipePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FoodRecipes.
     * @param {FoodRecipeDeleteManyArgs} args - Arguments to filter FoodRecipes to delete.
     * @example
     * // Delete a few FoodRecipes
     * const { count } = await prisma.foodRecipe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoodRecipeDeleteManyArgs>(args?: SelectSubset<T, FoodRecipeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodRecipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodRecipeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoodRecipes
     * const foodRecipe = await prisma.foodRecipe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoodRecipeUpdateManyArgs>(args: SelectSubset<T, FoodRecipeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodRecipes and returns the data updated in the database.
     * @param {FoodRecipeUpdateManyAndReturnArgs} args - Arguments to update many FoodRecipes.
     * @example
     * // Update many FoodRecipes
     * const foodRecipe = await prisma.foodRecipe.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FoodRecipes and only return the `id`
     * const foodRecipeWithIdOnly = await prisma.foodRecipe.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FoodRecipeUpdateManyAndReturnArgs>(args: SelectSubset<T, FoodRecipeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodRecipePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FoodRecipe.
     * @param {FoodRecipeUpsertArgs} args - Arguments to update or create a FoodRecipe.
     * @example
     * // Update or create a FoodRecipe
     * const foodRecipe = await prisma.foodRecipe.upsert({
     *   create: {
     *     // ... data to create a FoodRecipe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoodRecipe we want to update
     *   }
     * })
     */
    upsert<T extends FoodRecipeUpsertArgs>(args: SelectSubset<T, FoodRecipeUpsertArgs<ExtArgs>>): Prisma__FoodRecipeClient<$Result.GetResult<Prisma.$FoodRecipePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FoodRecipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodRecipeCountArgs} args - Arguments to filter FoodRecipes to count.
     * @example
     * // Count the number of FoodRecipes
     * const count = await prisma.foodRecipe.count({
     *   where: {
     *     // ... the filter for the FoodRecipes we want to count
     *   }
     * })
    **/
    count<T extends FoodRecipeCountArgs>(
      args?: Subset<T, FoodRecipeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoodRecipeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FoodRecipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodRecipeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoodRecipeAggregateArgs>(args: Subset<T, FoodRecipeAggregateArgs>): Prisma.PrismaPromise<GetFoodRecipeAggregateType<T>>

    /**
     * Group by FoodRecipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodRecipeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoodRecipeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoodRecipeGroupByArgs['orderBy'] }
        : { orderBy?: FoodRecipeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoodRecipeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoodRecipeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FoodRecipe model
   */
  readonly fields: FoodRecipeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FoodRecipe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoodRecipeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends FoodRecipe$itemsArgs<ExtArgs> = {}>(args?: Subset<T, FoodRecipe$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodRecipeItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    childItems<T extends FoodRecipe$childItemsArgs<ExtArgs> = {}>(args?: Subset<T, FoodRecipe$childItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodRecipeItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    extraCosts<T extends FoodRecipe$extraCostsArgs<ExtArgs> = {}>(args?: Subset<T, FoodRecipe$extraCostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodRecipeCostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mealPlanEntries<T extends FoodRecipe$mealPlanEntriesArgs<ExtArgs> = {}>(args?: Subset<T, FoodRecipe$mealPlanEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodMealPlanEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FoodRecipe model
   */
  interface FoodRecipeFieldRefs {
    readonly id: FieldRef<"FoodRecipe", 'Int'>
    readonly name: FieldRef<"FoodRecipe", 'String'>
    readonly code: FieldRef<"FoodRecipe", 'String'>
    readonly mealType: FieldRef<"FoodRecipe", 'FoodMealType'>
    readonly yield: FieldRef<"FoodRecipe", 'Decimal'>
    readonly yieldUnit: FieldRef<"FoodRecipe", 'String'>
    readonly isActive: FieldRef<"FoodRecipe", 'Boolean'>
    readonly notes: FieldRef<"FoodRecipe", 'String'>
    readonly createdAt: FieldRef<"FoodRecipe", 'DateTime'>
    readonly updatedAt: FieldRef<"FoodRecipe", 'DateTime'>
    readonly prepMinutes: FieldRef<"FoodRecipe", 'Decimal'>
    readonly dailyBlocks: FieldRef<"FoodRecipe", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * FoodRecipe findUnique
   */
  export type FoodRecipeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipe
     */
    select?: FoodRecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipe
     */
    omit?: FoodRecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRecipeInclude<ExtArgs> | null
    /**
     * Filter, which FoodRecipe to fetch.
     */
    where: FoodRecipeWhereUniqueInput
  }

  /**
   * FoodRecipe findUniqueOrThrow
   */
  export type FoodRecipeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipe
     */
    select?: FoodRecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipe
     */
    omit?: FoodRecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRecipeInclude<ExtArgs> | null
    /**
     * Filter, which FoodRecipe to fetch.
     */
    where: FoodRecipeWhereUniqueInput
  }

  /**
   * FoodRecipe findFirst
   */
  export type FoodRecipeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipe
     */
    select?: FoodRecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipe
     */
    omit?: FoodRecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRecipeInclude<ExtArgs> | null
    /**
     * Filter, which FoodRecipe to fetch.
     */
    where?: FoodRecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodRecipes to fetch.
     */
    orderBy?: FoodRecipeOrderByWithRelationInput | FoodRecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodRecipes.
     */
    cursor?: FoodRecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodRecipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodRecipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodRecipes.
     */
    distinct?: FoodRecipeScalarFieldEnum | FoodRecipeScalarFieldEnum[]
  }

  /**
   * FoodRecipe findFirstOrThrow
   */
  export type FoodRecipeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipe
     */
    select?: FoodRecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipe
     */
    omit?: FoodRecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRecipeInclude<ExtArgs> | null
    /**
     * Filter, which FoodRecipe to fetch.
     */
    where?: FoodRecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodRecipes to fetch.
     */
    orderBy?: FoodRecipeOrderByWithRelationInput | FoodRecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodRecipes.
     */
    cursor?: FoodRecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodRecipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodRecipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodRecipes.
     */
    distinct?: FoodRecipeScalarFieldEnum | FoodRecipeScalarFieldEnum[]
  }

  /**
   * FoodRecipe findMany
   */
  export type FoodRecipeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipe
     */
    select?: FoodRecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipe
     */
    omit?: FoodRecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRecipeInclude<ExtArgs> | null
    /**
     * Filter, which FoodRecipes to fetch.
     */
    where?: FoodRecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodRecipes to fetch.
     */
    orderBy?: FoodRecipeOrderByWithRelationInput | FoodRecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FoodRecipes.
     */
    cursor?: FoodRecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodRecipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodRecipes.
     */
    skip?: number
    distinct?: FoodRecipeScalarFieldEnum | FoodRecipeScalarFieldEnum[]
  }

  /**
   * FoodRecipe create
   */
  export type FoodRecipeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipe
     */
    select?: FoodRecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipe
     */
    omit?: FoodRecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRecipeInclude<ExtArgs> | null
    /**
     * The data needed to create a FoodRecipe.
     */
    data: XOR<FoodRecipeCreateInput, FoodRecipeUncheckedCreateInput>
  }

  /**
   * FoodRecipe createMany
   */
  export type FoodRecipeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FoodRecipes.
     */
    data: FoodRecipeCreateManyInput | FoodRecipeCreateManyInput[]
  }

  /**
   * FoodRecipe createManyAndReturn
   */
  export type FoodRecipeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipe
     */
    select?: FoodRecipeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipe
     */
    omit?: FoodRecipeOmit<ExtArgs> | null
    /**
     * The data used to create many FoodRecipes.
     */
    data: FoodRecipeCreateManyInput | FoodRecipeCreateManyInput[]
  }

  /**
   * FoodRecipe update
   */
  export type FoodRecipeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipe
     */
    select?: FoodRecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipe
     */
    omit?: FoodRecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRecipeInclude<ExtArgs> | null
    /**
     * The data needed to update a FoodRecipe.
     */
    data: XOR<FoodRecipeUpdateInput, FoodRecipeUncheckedUpdateInput>
    /**
     * Choose, which FoodRecipe to update.
     */
    where: FoodRecipeWhereUniqueInput
  }

  /**
   * FoodRecipe updateMany
   */
  export type FoodRecipeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FoodRecipes.
     */
    data: XOR<FoodRecipeUpdateManyMutationInput, FoodRecipeUncheckedUpdateManyInput>
    /**
     * Filter which FoodRecipes to update
     */
    where?: FoodRecipeWhereInput
    /**
     * Limit how many FoodRecipes to update.
     */
    limit?: number
  }

  /**
   * FoodRecipe updateManyAndReturn
   */
  export type FoodRecipeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipe
     */
    select?: FoodRecipeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipe
     */
    omit?: FoodRecipeOmit<ExtArgs> | null
    /**
     * The data used to update FoodRecipes.
     */
    data: XOR<FoodRecipeUpdateManyMutationInput, FoodRecipeUncheckedUpdateManyInput>
    /**
     * Filter which FoodRecipes to update
     */
    where?: FoodRecipeWhereInput
    /**
     * Limit how many FoodRecipes to update.
     */
    limit?: number
  }

  /**
   * FoodRecipe upsert
   */
  export type FoodRecipeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipe
     */
    select?: FoodRecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipe
     */
    omit?: FoodRecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRecipeInclude<ExtArgs> | null
    /**
     * The filter to search for the FoodRecipe to update in case it exists.
     */
    where: FoodRecipeWhereUniqueInput
    /**
     * In case the FoodRecipe found by the `where` argument doesn't exist, create a new FoodRecipe with this data.
     */
    create: XOR<FoodRecipeCreateInput, FoodRecipeUncheckedCreateInput>
    /**
     * In case the FoodRecipe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoodRecipeUpdateInput, FoodRecipeUncheckedUpdateInput>
  }

  /**
   * FoodRecipe delete
   */
  export type FoodRecipeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipe
     */
    select?: FoodRecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipe
     */
    omit?: FoodRecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRecipeInclude<ExtArgs> | null
    /**
     * Filter which FoodRecipe to delete.
     */
    where: FoodRecipeWhereUniqueInput
  }

  /**
   * FoodRecipe deleteMany
   */
  export type FoodRecipeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodRecipes to delete
     */
    where?: FoodRecipeWhereInput
    /**
     * Limit how many FoodRecipes to delete.
     */
    limit?: number
  }

  /**
   * FoodRecipe.items
   */
  export type FoodRecipe$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipeItem
     */
    select?: FoodRecipeItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipeItem
     */
    omit?: FoodRecipeItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRecipeItemInclude<ExtArgs> | null
    where?: FoodRecipeItemWhereInput
    orderBy?: FoodRecipeItemOrderByWithRelationInput | FoodRecipeItemOrderByWithRelationInput[]
    cursor?: FoodRecipeItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoodRecipeItemScalarFieldEnum | FoodRecipeItemScalarFieldEnum[]
  }

  /**
   * FoodRecipe.childItems
   */
  export type FoodRecipe$childItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipeItem
     */
    select?: FoodRecipeItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipeItem
     */
    omit?: FoodRecipeItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRecipeItemInclude<ExtArgs> | null
    where?: FoodRecipeItemWhereInput
    orderBy?: FoodRecipeItemOrderByWithRelationInput | FoodRecipeItemOrderByWithRelationInput[]
    cursor?: FoodRecipeItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoodRecipeItemScalarFieldEnum | FoodRecipeItemScalarFieldEnum[]
  }

  /**
   * FoodRecipe.extraCosts
   */
  export type FoodRecipe$extraCostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipeCost
     */
    select?: FoodRecipeCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipeCost
     */
    omit?: FoodRecipeCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRecipeCostInclude<ExtArgs> | null
    where?: FoodRecipeCostWhereInput
    orderBy?: FoodRecipeCostOrderByWithRelationInput | FoodRecipeCostOrderByWithRelationInput[]
    cursor?: FoodRecipeCostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoodRecipeCostScalarFieldEnum | FoodRecipeCostScalarFieldEnum[]
  }

  /**
   * FoodRecipe.mealPlanEntries
   */
  export type FoodRecipe$mealPlanEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodMealPlanEntry
     */
    select?: FoodMealPlanEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodMealPlanEntry
     */
    omit?: FoodMealPlanEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodMealPlanEntryInclude<ExtArgs> | null
    where?: FoodMealPlanEntryWhereInput
    orderBy?: FoodMealPlanEntryOrderByWithRelationInput | FoodMealPlanEntryOrderByWithRelationInput[]
    cursor?: FoodMealPlanEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoodMealPlanEntryScalarFieldEnum | FoodMealPlanEntryScalarFieldEnum[]
  }

  /**
   * FoodRecipe without action
   */
  export type FoodRecipeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipe
     */
    select?: FoodRecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipe
     */
    omit?: FoodRecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRecipeInclude<ExtArgs> | null
  }


  /**
   * Model FoodRecipeItem
   */

  export type AggregateFoodRecipeItem = {
    _count: FoodRecipeItemCountAggregateOutputType | null
    _avg: FoodRecipeItemAvgAggregateOutputType | null
    _sum: FoodRecipeItemSumAggregateOutputType | null
    _min: FoodRecipeItemMinAggregateOutputType | null
    _max: FoodRecipeItemMaxAggregateOutputType | null
  }

  export type FoodRecipeItemAvgAggregateOutputType = {
    id: number | null
    recipeId: number | null
    ingredientId: number | null
    childRecipeId: number | null
    quantity: Decimal | null
    wastePct: Decimal | null
  }

  export type FoodRecipeItemSumAggregateOutputType = {
    id: number | null
    recipeId: number | null
    ingredientId: number | null
    childRecipeId: number | null
    quantity: Decimal | null
    wastePct: Decimal | null
  }

  export type FoodRecipeItemMinAggregateOutputType = {
    id: number | null
    recipeId: number | null
    ingredientId: number | null
    childRecipeId: number | null
    quantity: Decimal | null
    unit: string | null
    wastePct: Decimal | null
    notes: string | null
    createdAt: Date | null
  }

  export type FoodRecipeItemMaxAggregateOutputType = {
    id: number | null
    recipeId: number | null
    ingredientId: number | null
    childRecipeId: number | null
    quantity: Decimal | null
    unit: string | null
    wastePct: Decimal | null
    notes: string | null
    createdAt: Date | null
  }

  export type FoodRecipeItemCountAggregateOutputType = {
    id: number
    recipeId: number
    ingredientId: number
    childRecipeId: number
    quantity: number
    unit: number
    wastePct: number
    notes: number
    createdAt: number
    _all: number
  }


  export type FoodRecipeItemAvgAggregateInputType = {
    id?: true
    recipeId?: true
    ingredientId?: true
    childRecipeId?: true
    quantity?: true
    wastePct?: true
  }

  export type FoodRecipeItemSumAggregateInputType = {
    id?: true
    recipeId?: true
    ingredientId?: true
    childRecipeId?: true
    quantity?: true
    wastePct?: true
  }

  export type FoodRecipeItemMinAggregateInputType = {
    id?: true
    recipeId?: true
    ingredientId?: true
    childRecipeId?: true
    quantity?: true
    unit?: true
    wastePct?: true
    notes?: true
    createdAt?: true
  }

  export type FoodRecipeItemMaxAggregateInputType = {
    id?: true
    recipeId?: true
    ingredientId?: true
    childRecipeId?: true
    quantity?: true
    unit?: true
    wastePct?: true
    notes?: true
    createdAt?: true
  }

  export type FoodRecipeItemCountAggregateInputType = {
    id?: true
    recipeId?: true
    ingredientId?: true
    childRecipeId?: true
    quantity?: true
    unit?: true
    wastePct?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type FoodRecipeItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodRecipeItem to aggregate.
     */
    where?: FoodRecipeItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodRecipeItems to fetch.
     */
    orderBy?: FoodRecipeItemOrderByWithRelationInput | FoodRecipeItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoodRecipeItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodRecipeItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodRecipeItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FoodRecipeItems
    **/
    _count?: true | FoodRecipeItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FoodRecipeItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FoodRecipeItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoodRecipeItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoodRecipeItemMaxAggregateInputType
  }

  export type GetFoodRecipeItemAggregateType<T extends FoodRecipeItemAggregateArgs> = {
        [P in keyof T & keyof AggregateFoodRecipeItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoodRecipeItem[P]>
      : GetScalarType<T[P], AggregateFoodRecipeItem[P]>
  }




  export type FoodRecipeItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodRecipeItemWhereInput
    orderBy?: FoodRecipeItemOrderByWithAggregationInput | FoodRecipeItemOrderByWithAggregationInput[]
    by: FoodRecipeItemScalarFieldEnum[] | FoodRecipeItemScalarFieldEnum
    having?: FoodRecipeItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoodRecipeItemCountAggregateInputType | true
    _avg?: FoodRecipeItemAvgAggregateInputType
    _sum?: FoodRecipeItemSumAggregateInputType
    _min?: FoodRecipeItemMinAggregateInputType
    _max?: FoodRecipeItemMaxAggregateInputType
  }

  export type FoodRecipeItemGroupByOutputType = {
    id: number
    recipeId: number
    ingredientId: number | null
    childRecipeId: number | null
    quantity: Decimal
    unit: string | null
    wastePct: Decimal | null
    notes: string | null
    createdAt: Date
    _count: FoodRecipeItemCountAggregateOutputType | null
    _avg: FoodRecipeItemAvgAggregateOutputType | null
    _sum: FoodRecipeItemSumAggregateOutputType | null
    _min: FoodRecipeItemMinAggregateOutputType | null
    _max: FoodRecipeItemMaxAggregateOutputType | null
  }

  type GetFoodRecipeItemGroupByPayload<T extends FoodRecipeItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoodRecipeItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoodRecipeItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoodRecipeItemGroupByOutputType[P]>
            : GetScalarType<T[P], FoodRecipeItemGroupByOutputType[P]>
        }
      >
    >


  export type FoodRecipeItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    ingredientId?: boolean
    childRecipeId?: boolean
    quantity?: boolean
    unit?: boolean
    wastePct?: boolean
    notes?: boolean
    createdAt?: boolean
    recipe?: boolean | FoodRecipeDefaultArgs<ExtArgs>
    ingredient?: boolean | FoodRecipeItem$ingredientArgs<ExtArgs>
    childRecipe?: boolean | FoodRecipeItem$childRecipeArgs<ExtArgs>
  }, ExtArgs["result"]["foodRecipeItem"]>

  export type FoodRecipeItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    ingredientId?: boolean
    childRecipeId?: boolean
    quantity?: boolean
    unit?: boolean
    wastePct?: boolean
    notes?: boolean
    createdAt?: boolean
    recipe?: boolean | FoodRecipeDefaultArgs<ExtArgs>
    ingredient?: boolean | FoodRecipeItem$ingredientArgs<ExtArgs>
    childRecipe?: boolean | FoodRecipeItem$childRecipeArgs<ExtArgs>
  }, ExtArgs["result"]["foodRecipeItem"]>

  export type FoodRecipeItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    ingredientId?: boolean
    childRecipeId?: boolean
    quantity?: boolean
    unit?: boolean
    wastePct?: boolean
    notes?: boolean
    createdAt?: boolean
    recipe?: boolean | FoodRecipeDefaultArgs<ExtArgs>
    ingredient?: boolean | FoodRecipeItem$ingredientArgs<ExtArgs>
    childRecipe?: boolean | FoodRecipeItem$childRecipeArgs<ExtArgs>
  }, ExtArgs["result"]["foodRecipeItem"]>

  export type FoodRecipeItemSelectScalar = {
    id?: boolean
    recipeId?: boolean
    ingredientId?: boolean
    childRecipeId?: boolean
    quantity?: boolean
    unit?: boolean
    wastePct?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type FoodRecipeItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "recipeId" | "ingredientId" | "childRecipeId" | "quantity" | "unit" | "wastePct" | "notes" | "createdAt", ExtArgs["result"]["foodRecipeItem"]>
  export type FoodRecipeItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | FoodRecipeDefaultArgs<ExtArgs>
    ingredient?: boolean | FoodRecipeItem$ingredientArgs<ExtArgs>
    childRecipe?: boolean | FoodRecipeItem$childRecipeArgs<ExtArgs>
  }
  export type FoodRecipeItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | FoodRecipeDefaultArgs<ExtArgs>
    ingredient?: boolean | FoodRecipeItem$ingredientArgs<ExtArgs>
    childRecipe?: boolean | FoodRecipeItem$childRecipeArgs<ExtArgs>
  }
  export type FoodRecipeItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | FoodRecipeDefaultArgs<ExtArgs>
    ingredient?: boolean | FoodRecipeItem$ingredientArgs<ExtArgs>
    childRecipe?: boolean | FoodRecipeItem$childRecipeArgs<ExtArgs>
  }

  export type $FoodRecipeItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FoodRecipeItem"
    objects: {
      recipe: Prisma.$FoodRecipePayload<ExtArgs>
      ingredient: Prisma.$FoodIngredientPayload<ExtArgs> | null
      childRecipe: Prisma.$FoodRecipePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      recipeId: number
      ingredientId: number | null
      childRecipeId: number | null
      quantity: Prisma.Decimal
      unit: string | null
      wastePct: Prisma.Decimal | null
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["foodRecipeItem"]>
    composites: {}
  }

  type FoodRecipeItemGetPayload<S extends boolean | null | undefined | FoodRecipeItemDefaultArgs> = $Result.GetResult<Prisma.$FoodRecipeItemPayload, S>

  type FoodRecipeItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FoodRecipeItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FoodRecipeItemCountAggregateInputType | true
    }

  export interface FoodRecipeItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FoodRecipeItem'], meta: { name: 'FoodRecipeItem' } }
    /**
     * Find zero or one FoodRecipeItem that matches the filter.
     * @param {FoodRecipeItemFindUniqueArgs} args - Arguments to find a FoodRecipeItem
     * @example
     * // Get one FoodRecipeItem
     * const foodRecipeItem = await prisma.foodRecipeItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoodRecipeItemFindUniqueArgs>(args: SelectSubset<T, FoodRecipeItemFindUniqueArgs<ExtArgs>>): Prisma__FoodRecipeItemClient<$Result.GetResult<Prisma.$FoodRecipeItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FoodRecipeItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FoodRecipeItemFindUniqueOrThrowArgs} args - Arguments to find a FoodRecipeItem
     * @example
     * // Get one FoodRecipeItem
     * const foodRecipeItem = await prisma.foodRecipeItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoodRecipeItemFindUniqueOrThrowArgs>(args: SelectSubset<T, FoodRecipeItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoodRecipeItemClient<$Result.GetResult<Prisma.$FoodRecipeItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodRecipeItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodRecipeItemFindFirstArgs} args - Arguments to find a FoodRecipeItem
     * @example
     * // Get one FoodRecipeItem
     * const foodRecipeItem = await prisma.foodRecipeItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoodRecipeItemFindFirstArgs>(args?: SelectSubset<T, FoodRecipeItemFindFirstArgs<ExtArgs>>): Prisma__FoodRecipeItemClient<$Result.GetResult<Prisma.$FoodRecipeItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodRecipeItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodRecipeItemFindFirstOrThrowArgs} args - Arguments to find a FoodRecipeItem
     * @example
     * // Get one FoodRecipeItem
     * const foodRecipeItem = await prisma.foodRecipeItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoodRecipeItemFindFirstOrThrowArgs>(args?: SelectSubset<T, FoodRecipeItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoodRecipeItemClient<$Result.GetResult<Prisma.$FoodRecipeItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FoodRecipeItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodRecipeItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoodRecipeItems
     * const foodRecipeItems = await prisma.foodRecipeItem.findMany()
     * 
     * // Get first 10 FoodRecipeItems
     * const foodRecipeItems = await prisma.foodRecipeItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foodRecipeItemWithIdOnly = await prisma.foodRecipeItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FoodRecipeItemFindManyArgs>(args?: SelectSubset<T, FoodRecipeItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodRecipeItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FoodRecipeItem.
     * @param {FoodRecipeItemCreateArgs} args - Arguments to create a FoodRecipeItem.
     * @example
     * // Create one FoodRecipeItem
     * const FoodRecipeItem = await prisma.foodRecipeItem.create({
     *   data: {
     *     // ... data to create a FoodRecipeItem
     *   }
     * })
     * 
     */
    create<T extends FoodRecipeItemCreateArgs>(args: SelectSubset<T, FoodRecipeItemCreateArgs<ExtArgs>>): Prisma__FoodRecipeItemClient<$Result.GetResult<Prisma.$FoodRecipeItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FoodRecipeItems.
     * @param {FoodRecipeItemCreateManyArgs} args - Arguments to create many FoodRecipeItems.
     * @example
     * // Create many FoodRecipeItems
     * const foodRecipeItem = await prisma.foodRecipeItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoodRecipeItemCreateManyArgs>(args?: SelectSubset<T, FoodRecipeItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FoodRecipeItems and returns the data saved in the database.
     * @param {FoodRecipeItemCreateManyAndReturnArgs} args - Arguments to create many FoodRecipeItems.
     * @example
     * // Create many FoodRecipeItems
     * const foodRecipeItem = await prisma.foodRecipeItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FoodRecipeItems and only return the `id`
     * const foodRecipeItemWithIdOnly = await prisma.foodRecipeItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FoodRecipeItemCreateManyAndReturnArgs>(args?: SelectSubset<T, FoodRecipeItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodRecipeItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FoodRecipeItem.
     * @param {FoodRecipeItemDeleteArgs} args - Arguments to delete one FoodRecipeItem.
     * @example
     * // Delete one FoodRecipeItem
     * const FoodRecipeItem = await prisma.foodRecipeItem.delete({
     *   where: {
     *     // ... filter to delete one FoodRecipeItem
     *   }
     * })
     * 
     */
    delete<T extends FoodRecipeItemDeleteArgs>(args: SelectSubset<T, FoodRecipeItemDeleteArgs<ExtArgs>>): Prisma__FoodRecipeItemClient<$Result.GetResult<Prisma.$FoodRecipeItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FoodRecipeItem.
     * @param {FoodRecipeItemUpdateArgs} args - Arguments to update one FoodRecipeItem.
     * @example
     * // Update one FoodRecipeItem
     * const foodRecipeItem = await prisma.foodRecipeItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoodRecipeItemUpdateArgs>(args: SelectSubset<T, FoodRecipeItemUpdateArgs<ExtArgs>>): Prisma__FoodRecipeItemClient<$Result.GetResult<Prisma.$FoodRecipeItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FoodRecipeItems.
     * @param {FoodRecipeItemDeleteManyArgs} args - Arguments to filter FoodRecipeItems to delete.
     * @example
     * // Delete a few FoodRecipeItems
     * const { count } = await prisma.foodRecipeItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoodRecipeItemDeleteManyArgs>(args?: SelectSubset<T, FoodRecipeItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodRecipeItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodRecipeItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoodRecipeItems
     * const foodRecipeItem = await prisma.foodRecipeItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoodRecipeItemUpdateManyArgs>(args: SelectSubset<T, FoodRecipeItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodRecipeItems and returns the data updated in the database.
     * @param {FoodRecipeItemUpdateManyAndReturnArgs} args - Arguments to update many FoodRecipeItems.
     * @example
     * // Update many FoodRecipeItems
     * const foodRecipeItem = await prisma.foodRecipeItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FoodRecipeItems and only return the `id`
     * const foodRecipeItemWithIdOnly = await prisma.foodRecipeItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FoodRecipeItemUpdateManyAndReturnArgs>(args: SelectSubset<T, FoodRecipeItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodRecipeItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FoodRecipeItem.
     * @param {FoodRecipeItemUpsertArgs} args - Arguments to update or create a FoodRecipeItem.
     * @example
     * // Update or create a FoodRecipeItem
     * const foodRecipeItem = await prisma.foodRecipeItem.upsert({
     *   create: {
     *     // ... data to create a FoodRecipeItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoodRecipeItem we want to update
     *   }
     * })
     */
    upsert<T extends FoodRecipeItemUpsertArgs>(args: SelectSubset<T, FoodRecipeItemUpsertArgs<ExtArgs>>): Prisma__FoodRecipeItemClient<$Result.GetResult<Prisma.$FoodRecipeItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FoodRecipeItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodRecipeItemCountArgs} args - Arguments to filter FoodRecipeItems to count.
     * @example
     * // Count the number of FoodRecipeItems
     * const count = await prisma.foodRecipeItem.count({
     *   where: {
     *     // ... the filter for the FoodRecipeItems we want to count
     *   }
     * })
    **/
    count<T extends FoodRecipeItemCountArgs>(
      args?: Subset<T, FoodRecipeItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoodRecipeItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FoodRecipeItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodRecipeItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoodRecipeItemAggregateArgs>(args: Subset<T, FoodRecipeItemAggregateArgs>): Prisma.PrismaPromise<GetFoodRecipeItemAggregateType<T>>

    /**
     * Group by FoodRecipeItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodRecipeItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoodRecipeItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoodRecipeItemGroupByArgs['orderBy'] }
        : { orderBy?: FoodRecipeItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoodRecipeItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoodRecipeItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FoodRecipeItem model
   */
  readonly fields: FoodRecipeItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FoodRecipeItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoodRecipeItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recipe<T extends FoodRecipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FoodRecipeDefaultArgs<ExtArgs>>): Prisma__FoodRecipeClient<$Result.GetResult<Prisma.$FoodRecipePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ingredient<T extends FoodRecipeItem$ingredientArgs<ExtArgs> = {}>(args?: Subset<T, FoodRecipeItem$ingredientArgs<ExtArgs>>): Prisma__FoodIngredientClient<$Result.GetResult<Prisma.$FoodIngredientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    childRecipe<T extends FoodRecipeItem$childRecipeArgs<ExtArgs> = {}>(args?: Subset<T, FoodRecipeItem$childRecipeArgs<ExtArgs>>): Prisma__FoodRecipeClient<$Result.GetResult<Prisma.$FoodRecipePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FoodRecipeItem model
   */
  interface FoodRecipeItemFieldRefs {
    readonly id: FieldRef<"FoodRecipeItem", 'Int'>
    readonly recipeId: FieldRef<"FoodRecipeItem", 'Int'>
    readonly ingredientId: FieldRef<"FoodRecipeItem", 'Int'>
    readonly childRecipeId: FieldRef<"FoodRecipeItem", 'Int'>
    readonly quantity: FieldRef<"FoodRecipeItem", 'Decimal'>
    readonly unit: FieldRef<"FoodRecipeItem", 'String'>
    readonly wastePct: FieldRef<"FoodRecipeItem", 'Decimal'>
    readonly notes: FieldRef<"FoodRecipeItem", 'String'>
    readonly createdAt: FieldRef<"FoodRecipeItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FoodRecipeItem findUnique
   */
  export type FoodRecipeItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipeItem
     */
    select?: FoodRecipeItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipeItem
     */
    omit?: FoodRecipeItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRecipeItemInclude<ExtArgs> | null
    /**
     * Filter, which FoodRecipeItem to fetch.
     */
    where: FoodRecipeItemWhereUniqueInput
  }

  /**
   * FoodRecipeItem findUniqueOrThrow
   */
  export type FoodRecipeItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipeItem
     */
    select?: FoodRecipeItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipeItem
     */
    omit?: FoodRecipeItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRecipeItemInclude<ExtArgs> | null
    /**
     * Filter, which FoodRecipeItem to fetch.
     */
    where: FoodRecipeItemWhereUniqueInput
  }

  /**
   * FoodRecipeItem findFirst
   */
  export type FoodRecipeItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipeItem
     */
    select?: FoodRecipeItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipeItem
     */
    omit?: FoodRecipeItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRecipeItemInclude<ExtArgs> | null
    /**
     * Filter, which FoodRecipeItem to fetch.
     */
    where?: FoodRecipeItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodRecipeItems to fetch.
     */
    orderBy?: FoodRecipeItemOrderByWithRelationInput | FoodRecipeItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodRecipeItems.
     */
    cursor?: FoodRecipeItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodRecipeItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodRecipeItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodRecipeItems.
     */
    distinct?: FoodRecipeItemScalarFieldEnum | FoodRecipeItemScalarFieldEnum[]
  }

  /**
   * FoodRecipeItem findFirstOrThrow
   */
  export type FoodRecipeItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipeItem
     */
    select?: FoodRecipeItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipeItem
     */
    omit?: FoodRecipeItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRecipeItemInclude<ExtArgs> | null
    /**
     * Filter, which FoodRecipeItem to fetch.
     */
    where?: FoodRecipeItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodRecipeItems to fetch.
     */
    orderBy?: FoodRecipeItemOrderByWithRelationInput | FoodRecipeItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodRecipeItems.
     */
    cursor?: FoodRecipeItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodRecipeItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodRecipeItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodRecipeItems.
     */
    distinct?: FoodRecipeItemScalarFieldEnum | FoodRecipeItemScalarFieldEnum[]
  }

  /**
   * FoodRecipeItem findMany
   */
  export type FoodRecipeItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipeItem
     */
    select?: FoodRecipeItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipeItem
     */
    omit?: FoodRecipeItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRecipeItemInclude<ExtArgs> | null
    /**
     * Filter, which FoodRecipeItems to fetch.
     */
    where?: FoodRecipeItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodRecipeItems to fetch.
     */
    orderBy?: FoodRecipeItemOrderByWithRelationInput | FoodRecipeItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FoodRecipeItems.
     */
    cursor?: FoodRecipeItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodRecipeItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodRecipeItems.
     */
    skip?: number
    distinct?: FoodRecipeItemScalarFieldEnum | FoodRecipeItemScalarFieldEnum[]
  }

  /**
   * FoodRecipeItem create
   */
  export type FoodRecipeItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipeItem
     */
    select?: FoodRecipeItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipeItem
     */
    omit?: FoodRecipeItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRecipeItemInclude<ExtArgs> | null
    /**
     * The data needed to create a FoodRecipeItem.
     */
    data: XOR<FoodRecipeItemCreateInput, FoodRecipeItemUncheckedCreateInput>
  }

  /**
   * FoodRecipeItem createMany
   */
  export type FoodRecipeItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FoodRecipeItems.
     */
    data: FoodRecipeItemCreateManyInput | FoodRecipeItemCreateManyInput[]
  }

  /**
   * FoodRecipeItem createManyAndReturn
   */
  export type FoodRecipeItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipeItem
     */
    select?: FoodRecipeItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipeItem
     */
    omit?: FoodRecipeItemOmit<ExtArgs> | null
    /**
     * The data used to create many FoodRecipeItems.
     */
    data: FoodRecipeItemCreateManyInput | FoodRecipeItemCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRecipeItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FoodRecipeItem update
   */
  export type FoodRecipeItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipeItem
     */
    select?: FoodRecipeItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipeItem
     */
    omit?: FoodRecipeItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRecipeItemInclude<ExtArgs> | null
    /**
     * The data needed to update a FoodRecipeItem.
     */
    data: XOR<FoodRecipeItemUpdateInput, FoodRecipeItemUncheckedUpdateInput>
    /**
     * Choose, which FoodRecipeItem to update.
     */
    where: FoodRecipeItemWhereUniqueInput
  }

  /**
   * FoodRecipeItem updateMany
   */
  export type FoodRecipeItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FoodRecipeItems.
     */
    data: XOR<FoodRecipeItemUpdateManyMutationInput, FoodRecipeItemUncheckedUpdateManyInput>
    /**
     * Filter which FoodRecipeItems to update
     */
    where?: FoodRecipeItemWhereInput
    /**
     * Limit how many FoodRecipeItems to update.
     */
    limit?: number
  }

  /**
   * FoodRecipeItem updateManyAndReturn
   */
  export type FoodRecipeItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipeItem
     */
    select?: FoodRecipeItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipeItem
     */
    omit?: FoodRecipeItemOmit<ExtArgs> | null
    /**
     * The data used to update FoodRecipeItems.
     */
    data: XOR<FoodRecipeItemUpdateManyMutationInput, FoodRecipeItemUncheckedUpdateManyInput>
    /**
     * Filter which FoodRecipeItems to update
     */
    where?: FoodRecipeItemWhereInput
    /**
     * Limit how many FoodRecipeItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRecipeItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FoodRecipeItem upsert
   */
  export type FoodRecipeItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipeItem
     */
    select?: FoodRecipeItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipeItem
     */
    omit?: FoodRecipeItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRecipeItemInclude<ExtArgs> | null
    /**
     * The filter to search for the FoodRecipeItem to update in case it exists.
     */
    where: FoodRecipeItemWhereUniqueInput
    /**
     * In case the FoodRecipeItem found by the `where` argument doesn't exist, create a new FoodRecipeItem with this data.
     */
    create: XOR<FoodRecipeItemCreateInput, FoodRecipeItemUncheckedCreateInput>
    /**
     * In case the FoodRecipeItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoodRecipeItemUpdateInput, FoodRecipeItemUncheckedUpdateInput>
  }

  /**
   * FoodRecipeItem delete
   */
  export type FoodRecipeItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipeItem
     */
    select?: FoodRecipeItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipeItem
     */
    omit?: FoodRecipeItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRecipeItemInclude<ExtArgs> | null
    /**
     * Filter which FoodRecipeItem to delete.
     */
    where: FoodRecipeItemWhereUniqueInput
  }

  /**
   * FoodRecipeItem deleteMany
   */
  export type FoodRecipeItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodRecipeItems to delete
     */
    where?: FoodRecipeItemWhereInput
    /**
     * Limit how many FoodRecipeItems to delete.
     */
    limit?: number
  }

  /**
   * FoodRecipeItem.ingredient
   */
  export type FoodRecipeItem$ingredientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodIngredient
     */
    select?: FoodIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodIngredient
     */
    omit?: FoodIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodIngredientInclude<ExtArgs> | null
    where?: FoodIngredientWhereInput
  }

  /**
   * FoodRecipeItem.childRecipe
   */
  export type FoodRecipeItem$childRecipeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipe
     */
    select?: FoodRecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipe
     */
    omit?: FoodRecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRecipeInclude<ExtArgs> | null
    where?: FoodRecipeWhereInput
  }

  /**
   * FoodRecipeItem without action
   */
  export type FoodRecipeItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipeItem
     */
    select?: FoodRecipeItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipeItem
     */
    omit?: FoodRecipeItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRecipeItemInclude<ExtArgs> | null
  }


  /**
   * Model FoodRecipeCost
   */

  export type AggregateFoodRecipeCost = {
    _count: FoodRecipeCostCountAggregateOutputType | null
    _avg: FoodRecipeCostAvgAggregateOutputType | null
    _sum: FoodRecipeCostSumAggregateOutputType | null
    _min: FoodRecipeCostMinAggregateOutputType | null
    _max: FoodRecipeCostMaxAggregateOutputType | null
  }

  export type FoodRecipeCostAvgAggregateOutputType = {
    id: number | null
    recipeId: number | null
    amount: Decimal | null
    periodRations: Decimal | null
  }

  export type FoodRecipeCostSumAggregateOutputType = {
    id: number | null
    recipeId: number | null
    amount: Decimal | null
    periodRations: Decimal | null
  }

  export type FoodRecipeCostMinAggregateOutputType = {
    id: number | null
    recipeId: number | null
    label: string | null
    amount: Decimal | null
    costType: $Enums.FoodCostLineType | null
    period: $Enums.FoodCostPeriod | null
    periodRations: Decimal | null
    notes: string | null
    createdAt: Date | null
  }

  export type FoodRecipeCostMaxAggregateOutputType = {
    id: number | null
    recipeId: number | null
    label: string | null
    amount: Decimal | null
    costType: $Enums.FoodCostLineType | null
    period: $Enums.FoodCostPeriod | null
    periodRations: Decimal | null
    notes: string | null
    createdAt: Date | null
  }

  export type FoodRecipeCostCountAggregateOutputType = {
    id: number
    recipeId: number
    label: number
    amount: number
    costType: number
    period: number
    periodRations: number
    notes: number
    createdAt: number
    _all: number
  }


  export type FoodRecipeCostAvgAggregateInputType = {
    id?: true
    recipeId?: true
    amount?: true
    periodRations?: true
  }

  export type FoodRecipeCostSumAggregateInputType = {
    id?: true
    recipeId?: true
    amount?: true
    periodRations?: true
  }

  export type FoodRecipeCostMinAggregateInputType = {
    id?: true
    recipeId?: true
    label?: true
    amount?: true
    costType?: true
    period?: true
    periodRations?: true
    notes?: true
    createdAt?: true
  }

  export type FoodRecipeCostMaxAggregateInputType = {
    id?: true
    recipeId?: true
    label?: true
    amount?: true
    costType?: true
    period?: true
    periodRations?: true
    notes?: true
    createdAt?: true
  }

  export type FoodRecipeCostCountAggregateInputType = {
    id?: true
    recipeId?: true
    label?: true
    amount?: true
    costType?: true
    period?: true
    periodRations?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type FoodRecipeCostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodRecipeCost to aggregate.
     */
    where?: FoodRecipeCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodRecipeCosts to fetch.
     */
    orderBy?: FoodRecipeCostOrderByWithRelationInput | FoodRecipeCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoodRecipeCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodRecipeCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodRecipeCosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FoodRecipeCosts
    **/
    _count?: true | FoodRecipeCostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FoodRecipeCostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FoodRecipeCostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoodRecipeCostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoodRecipeCostMaxAggregateInputType
  }

  export type GetFoodRecipeCostAggregateType<T extends FoodRecipeCostAggregateArgs> = {
        [P in keyof T & keyof AggregateFoodRecipeCost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoodRecipeCost[P]>
      : GetScalarType<T[P], AggregateFoodRecipeCost[P]>
  }




  export type FoodRecipeCostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodRecipeCostWhereInput
    orderBy?: FoodRecipeCostOrderByWithAggregationInput | FoodRecipeCostOrderByWithAggregationInput[]
    by: FoodRecipeCostScalarFieldEnum[] | FoodRecipeCostScalarFieldEnum
    having?: FoodRecipeCostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoodRecipeCostCountAggregateInputType | true
    _avg?: FoodRecipeCostAvgAggregateInputType
    _sum?: FoodRecipeCostSumAggregateInputType
    _min?: FoodRecipeCostMinAggregateInputType
    _max?: FoodRecipeCostMaxAggregateInputType
  }

  export type FoodRecipeCostGroupByOutputType = {
    id: number
    recipeId: number
    label: string
    amount: Decimal
    costType: $Enums.FoodCostLineType
    period: $Enums.FoodCostPeriod
    periodRations: Decimal | null
    notes: string | null
    createdAt: Date
    _count: FoodRecipeCostCountAggregateOutputType | null
    _avg: FoodRecipeCostAvgAggregateOutputType | null
    _sum: FoodRecipeCostSumAggregateOutputType | null
    _min: FoodRecipeCostMinAggregateOutputType | null
    _max: FoodRecipeCostMaxAggregateOutputType | null
  }

  type GetFoodRecipeCostGroupByPayload<T extends FoodRecipeCostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoodRecipeCostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoodRecipeCostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoodRecipeCostGroupByOutputType[P]>
            : GetScalarType<T[P], FoodRecipeCostGroupByOutputType[P]>
        }
      >
    >


  export type FoodRecipeCostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    label?: boolean
    amount?: boolean
    costType?: boolean
    period?: boolean
    periodRations?: boolean
    notes?: boolean
    createdAt?: boolean
    recipe?: boolean | FoodRecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodRecipeCost"]>

  export type FoodRecipeCostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    label?: boolean
    amount?: boolean
    costType?: boolean
    period?: boolean
    periodRations?: boolean
    notes?: boolean
    createdAt?: boolean
    recipe?: boolean | FoodRecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodRecipeCost"]>

  export type FoodRecipeCostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    label?: boolean
    amount?: boolean
    costType?: boolean
    period?: boolean
    periodRations?: boolean
    notes?: boolean
    createdAt?: boolean
    recipe?: boolean | FoodRecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodRecipeCost"]>

  export type FoodRecipeCostSelectScalar = {
    id?: boolean
    recipeId?: boolean
    label?: boolean
    amount?: boolean
    costType?: boolean
    period?: boolean
    periodRations?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type FoodRecipeCostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "recipeId" | "label" | "amount" | "costType" | "period" | "periodRations" | "notes" | "createdAt", ExtArgs["result"]["foodRecipeCost"]>
  export type FoodRecipeCostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | FoodRecipeDefaultArgs<ExtArgs>
  }
  export type FoodRecipeCostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | FoodRecipeDefaultArgs<ExtArgs>
  }
  export type FoodRecipeCostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | FoodRecipeDefaultArgs<ExtArgs>
  }

  export type $FoodRecipeCostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FoodRecipeCost"
    objects: {
      recipe: Prisma.$FoodRecipePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      recipeId: number
      label: string
      amount: Prisma.Decimal
      costType: $Enums.FoodCostLineType
      period: $Enums.FoodCostPeriod
      periodRations: Prisma.Decimal | null
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["foodRecipeCost"]>
    composites: {}
  }

  type FoodRecipeCostGetPayload<S extends boolean | null | undefined | FoodRecipeCostDefaultArgs> = $Result.GetResult<Prisma.$FoodRecipeCostPayload, S>

  type FoodRecipeCostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FoodRecipeCostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FoodRecipeCostCountAggregateInputType | true
    }

  export interface FoodRecipeCostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FoodRecipeCost'], meta: { name: 'FoodRecipeCost' } }
    /**
     * Find zero or one FoodRecipeCost that matches the filter.
     * @param {FoodRecipeCostFindUniqueArgs} args - Arguments to find a FoodRecipeCost
     * @example
     * // Get one FoodRecipeCost
     * const foodRecipeCost = await prisma.foodRecipeCost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoodRecipeCostFindUniqueArgs>(args: SelectSubset<T, FoodRecipeCostFindUniqueArgs<ExtArgs>>): Prisma__FoodRecipeCostClient<$Result.GetResult<Prisma.$FoodRecipeCostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FoodRecipeCost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FoodRecipeCostFindUniqueOrThrowArgs} args - Arguments to find a FoodRecipeCost
     * @example
     * // Get one FoodRecipeCost
     * const foodRecipeCost = await prisma.foodRecipeCost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoodRecipeCostFindUniqueOrThrowArgs>(args: SelectSubset<T, FoodRecipeCostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoodRecipeCostClient<$Result.GetResult<Prisma.$FoodRecipeCostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodRecipeCost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodRecipeCostFindFirstArgs} args - Arguments to find a FoodRecipeCost
     * @example
     * // Get one FoodRecipeCost
     * const foodRecipeCost = await prisma.foodRecipeCost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoodRecipeCostFindFirstArgs>(args?: SelectSubset<T, FoodRecipeCostFindFirstArgs<ExtArgs>>): Prisma__FoodRecipeCostClient<$Result.GetResult<Prisma.$FoodRecipeCostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodRecipeCost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodRecipeCostFindFirstOrThrowArgs} args - Arguments to find a FoodRecipeCost
     * @example
     * // Get one FoodRecipeCost
     * const foodRecipeCost = await prisma.foodRecipeCost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoodRecipeCostFindFirstOrThrowArgs>(args?: SelectSubset<T, FoodRecipeCostFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoodRecipeCostClient<$Result.GetResult<Prisma.$FoodRecipeCostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FoodRecipeCosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodRecipeCostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoodRecipeCosts
     * const foodRecipeCosts = await prisma.foodRecipeCost.findMany()
     * 
     * // Get first 10 FoodRecipeCosts
     * const foodRecipeCosts = await prisma.foodRecipeCost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foodRecipeCostWithIdOnly = await prisma.foodRecipeCost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FoodRecipeCostFindManyArgs>(args?: SelectSubset<T, FoodRecipeCostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodRecipeCostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FoodRecipeCost.
     * @param {FoodRecipeCostCreateArgs} args - Arguments to create a FoodRecipeCost.
     * @example
     * // Create one FoodRecipeCost
     * const FoodRecipeCost = await prisma.foodRecipeCost.create({
     *   data: {
     *     // ... data to create a FoodRecipeCost
     *   }
     * })
     * 
     */
    create<T extends FoodRecipeCostCreateArgs>(args: SelectSubset<T, FoodRecipeCostCreateArgs<ExtArgs>>): Prisma__FoodRecipeCostClient<$Result.GetResult<Prisma.$FoodRecipeCostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FoodRecipeCosts.
     * @param {FoodRecipeCostCreateManyArgs} args - Arguments to create many FoodRecipeCosts.
     * @example
     * // Create many FoodRecipeCosts
     * const foodRecipeCost = await prisma.foodRecipeCost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoodRecipeCostCreateManyArgs>(args?: SelectSubset<T, FoodRecipeCostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FoodRecipeCosts and returns the data saved in the database.
     * @param {FoodRecipeCostCreateManyAndReturnArgs} args - Arguments to create many FoodRecipeCosts.
     * @example
     * // Create many FoodRecipeCosts
     * const foodRecipeCost = await prisma.foodRecipeCost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FoodRecipeCosts and only return the `id`
     * const foodRecipeCostWithIdOnly = await prisma.foodRecipeCost.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FoodRecipeCostCreateManyAndReturnArgs>(args?: SelectSubset<T, FoodRecipeCostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodRecipeCostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FoodRecipeCost.
     * @param {FoodRecipeCostDeleteArgs} args - Arguments to delete one FoodRecipeCost.
     * @example
     * // Delete one FoodRecipeCost
     * const FoodRecipeCost = await prisma.foodRecipeCost.delete({
     *   where: {
     *     // ... filter to delete one FoodRecipeCost
     *   }
     * })
     * 
     */
    delete<T extends FoodRecipeCostDeleteArgs>(args: SelectSubset<T, FoodRecipeCostDeleteArgs<ExtArgs>>): Prisma__FoodRecipeCostClient<$Result.GetResult<Prisma.$FoodRecipeCostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FoodRecipeCost.
     * @param {FoodRecipeCostUpdateArgs} args - Arguments to update one FoodRecipeCost.
     * @example
     * // Update one FoodRecipeCost
     * const foodRecipeCost = await prisma.foodRecipeCost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoodRecipeCostUpdateArgs>(args: SelectSubset<T, FoodRecipeCostUpdateArgs<ExtArgs>>): Prisma__FoodRecipeCostClient<$Result.GetResult<Prisma.$FoodRecipeCostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FoodRecipeCosts.
     * @param {FoodRecipeCostDeleteManyArgs} args - Arguments to filter FoodRecipeCosts to delete.
     * @example
     * // Delete a few FoodRecipeCosts
     * const { count } = await prisma.foodRecipeCost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoodRecipeCostDeleteManyArgs>(args?: SelectSubset<T, FoodRecipeCostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodRecipeCosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodRecipeCostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoodRecipeCosts
     * const foodRecipeCost = await prisma.foodRecipeCost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoodRecipeCostUpdateManyArgs>(args: SelectSubset<T, FoodRecipeCostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodRecipeCosts and returns the data updated in the database.
     * @param {FoodRecipeCostUpdateManyAndReturnArgs} args - Arguments to update many FoodRecipeCosts.
     * @example
     * // Update many FoodRecipeCosts
     * const foodRecipeCost = await prisma.foodRecipeCost.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FoodRecipeCosts and only return the `id`
     * const foodRecipeCostWithIdOnly = await prisma.foodRecipeCost.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FoodRecipeCostUpdateManyAndReturnArgs>(args: SelectSubset<T, FoodRecipeCostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodRecipeCostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FoodRecipeCost.
     * @param {FoodRecipeCostUpsertArgs} args - Arguments to update or create a FoodRecipeCost.
     * @example
     * // Update or create a FoodRecipeCost
     * const foodRecipeCost = await prisma.foodRecipeCost.upsert({
     *   create: {
     *     // ... data to create a FoodRecipeCost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoodRecipeCost we want to update
     *   }
     * })
     */
    upsert<T extends FoodRecipeCostUpsertArgs>(args: SelectSubset<T, FoodRecipeCostUpsertArgs<ExtArgs>>): Prisma__FoodRecipeCostClient<$Result.GetResult<Prisma.$FoodRecipeCostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FoodRecipeCosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodRecipeCostCountArgs} args - Arguments to filter FoodRecipeCosts to count.
     * @example
     * // Count the number of FoodRecipeCosts
     * const count = await prisma.foodRecipeCost.count({
     *   where: {
     *     // ... the filter for the FoodRecipeCosts we want to count
     *   }
     * })
    **/
    count<T extends FoodRecipeCostCountArgs>(
      args?: Subset<T, FoodRecipeCostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoodRecipeCostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FoodRecipeCost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodRecipeCostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoodRecipeCostAggregateArgs>(args: Subset<T, FoodRecipeCostAggregateArgs>): Prisma.PrismaPromise<GetFoodRecipeCostAggregateType<T>>

    /**
     * Group by FoodRecipeCost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodRecipeCostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoodRecipeCostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoodRecipeCostGroupByArgs['orderBy'] }
        : { orderBy?: FoodRecipeCostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoodRecipeCostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoodRecipeCostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FoodRecipeCost model
   */
  readonly fields: FoodRecipeCostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FoodRecipeCost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoodRecipeCostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recipe<T extends FoodRecipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FoodRecipeDefaultArgs<ExtArgs>>): Prisma__FoodRecipeClient<$Result.GetResult<Prisma.$FoodRecipePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FoodRecipeCost model
   */
  interface FoodRecipeCostFieldRefs {
    readonly id: FieldRef<"FoodRecipeCost", 'Int'>
    readonly recipeId: FieldRef<"FoodRecipeCost", 'Int'>
    readonly label: FieldRef<"FoodRecipeCost", 'String'>
    readonly amount: FieldRef<"FoodRecipeCost", 'Decimal'>
    readonly costType: FieldRef<"FoodRecipeCost", 'FoodCostLineType'>
    readonly period: FieldRef<"FoodRecipeCost", 'FoodCostPeriod'>
    readonly periodRations: FieldRef<"FoodRecipeCost", 'Decimal'>
    readonly notes: FieldRef<"FoodRecipeCost", 'String'>
    readonly createdAt: FieldRef<"FoodRecipeCost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FoodRecipeCost findUnique
   */
  export type FoodRecipeCostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipeCost
     */
    select?: FoodRecipeCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipeCost
     */
    omit?: FoodRecipeCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRecipeCostInclude<ExtArgs> | null
    /**
     * Filter, which FoodRecipeCost to fetch.
     */
    where: FoodRecipeCostWhereUniqueInput
  }

  /**
   * FoodRecipeCost findUniqueOrThrow
   */
  export type FoodRecipeCostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipeCost
     */
    select?: FoodRecipeCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipeCost
     */
    omit?: FoodRecipeCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRecipeCostInclude<ExtArgs> | null
    /**
     * Filter, which FoodRecipeCost to fetch.
     */
    where: FoodRecipeCostWhereUniqueInput
  }

  /**
   * FoodRecipeCost findFirst
   */
  export type FoodRecipeCostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipeCost
     */
    select?: FoodRecipeCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipeCost
     */
    omit?: FoodRecipeCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRecipeCostInclude<ExtArgs> | null
    /**
     * Filter, which FoodRecipeCost to fetch.
     */
    where?: FoodRecipeCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodRecipeCosts to fetch.
     */
    orderBy?: FoodRecipeCostOrderByWithRelationInput | FoodRecipeCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodRecipeCosts.
     */
    cursor?: FoodRecipeCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodRecipeCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodRecipeCosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodRecipeCosts.
     */
    distinct?: FoodRecipeCostScalarFieldEnum | FoodRecipeCostScalarFieldEnum[]
  }

  /**
   * FoodRecipeCost findFirstOrThrow
   */
  export type FoodRecipeCostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipeCost
     */
    select?: FoodRecipeCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipeCost
     */
    omit?: FoodRecipeCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRecipeCostInclude<ExtArgs> | null
    /**
     * Filter, which FoodRecipeCost to fetch.
     */
    where?: FoodRecipeCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodRecipeCosts to fetch.
     */
    orderBy?: FoodRecipeCostOrderByWithRelationInput | FoodRecipeCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodRecipeCosts.
     */
    cursor?: FoodRecipeCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodRecipeCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodRecipeCosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodRecipeCosts.
     */
    distinct?: FoodRecipeCostScalarFieldEnum | FoodRecipeCostScalarFieldEnum[]
  }

  /**
   * FoodRecipeCost findMany
   */
  export type FoodRecipeCostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipeCost
     */
    select?: FoodRecipeCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipeCost
     */
    omit?: FoodRecipeCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRecipeCostInclude<ExtArgs> | null
    /**
     * Filter, which FoodRecipeCosts to fetch.
     */
    where?: FoodRecipeCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodRecipeCosts to fetch.
     */
    orderBy?: FoodRecipeCostOrderByWithRelationInput | FoodRecipeCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FoodRecipeCosts.
     */
    cursor?: FoodRecipeCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodRecipeCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodRecipeCosts.
     */
    skip?: number
    distinct?: FoodRecipeCostScalarFieldEnum | FoodRecipeCostScalarFieldEnum[]
  }

  /**
   * FoodRecipeCost create
   */
  export type FoodRecipeCostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipeCost
     */
    select?: FoodRecipeCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipeCost
     */
    omit?: FoodRecipeCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRecipeCostInclude<ExtArgs> | null
    /**
     * The data needed to create a FoodRecipeCost.
     */
    data: XOR<FoodRecipeCostCreateInput, FoodRecipeCostUncheckedCreateInput>
  }

  /**
   * FoodRecipeCost createMany
   */
  export type FoodRecipeCostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FoodRecipeCosts.
     */
    data: FoodRecipeCostCreateManyInput | FoodRecipeCostCreateManyInput[]
  }

  /**
   * FoodRecipeCost createManyAndReturn
   */
  export type FoodRecipeCostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipeCost
     */
    select?: FoodRecipeCostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipeCost
     */
    omit?: FoodRecipeCostOmit<ExtArgs> | null
    /**
     * The data used to create many FoodRecipeCosts.
     */
    data: FoodRecipeCostCreateManyInput | FoodRecipeCostCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRecipeCostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FoodRecipeCost update
   */
  export type FoodRecipeCostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipeCost
     */
    select?: FoodRecipeCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipeCost
     */
    omit?: FoodRecipeCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRecipeCostInclude<ExtArgs> | null
    /**
     * The data needed to update a FoodRecipeCost.
     */
    data: XOR<FoodRecipeCostUpdateInput, FoodRecipeCostUncheckedUpdateInput>
    /**
     * Choose, which FoodRecipeCost to update.
     */
    where: FoodRecipeCostWhereUniqueInput
  }

  /**
   * FoodRecipeCost updateMany
   */
  export type FoodRecipeCostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FoodRecipeCosts.
     */
    data: XOR<FoodRecipeCostUpdateManyMutationInput, FoodRecipeCostUncheckedUpdateManyInput>
    /**
     * Filter which FoodRecipeCosts to update
     */
    where?: FoodRecipeCostWhereInput
    /**
     * Limit how many FoodRecipeCosts to update.
     */
    limit?: number
  }

  /**
   * FoodRecipeCost updateManyAndReturn
   */
  export type FoodRecipeCostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipeCost
     */
    select?: FoodRecipeCostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipeCost
     */
    omit?: FoodRecipeCostOmit<ExtArgs> | null
    /**
     * The data used to update FoodRecipeCosts.
     */
    data: XOR<FoodRecipeCostUpdateManyMutationInput, FoodRecipeCostUncheckedUpdateManyInput>
    /**
     * Filter which FoodRecipeCosts to update
     */
    where?: FoodRecipeCostWhereInput
    /**
     * Limit how many FoodRecipeCosts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRecipeCostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FoodRecipeCost upsert
   */
  export type FoodRecipeCostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipeCost
     */
    select?: FoodRecipeCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipeCost
     */
    omit?: FoodRecipeCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRecipeCostInclude<ExtArgs> | null
    /**
     * The filter to search for the FoodRecipeCost to update in case it exists.
     */
    where: FoodRecipeCostWhereUniqueInput
    /**
     * In case the FoodRecipeCost found by the `where` argument doesn't exist, create a new FoodRecipeCost with this data.
     */
    create: XOR<FoodRecipeCostCreateInput, FoodRecipeCostUncheckedCreateInput>
    /**
     * In case the FoodRecipeCost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoodRecipeCostUpdateInput, FoodRecipeCostUncheckedUpdateInput>
  }

  /**
   * FoodRecipeCost delete
   */
  export type FoodRecipeCostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipeCost
     */
    select?: FoodRecipeCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipeCost
     */
    omit?: FoodRecipeCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRecipeCostInclude<ExtArgs> | null
    /**
     * Filter which FoodRecipeCost to delete.
     */
    where: FoodRecipeCostWhereUniqueInput
  }

  /**
   * FoodRecipeCost deleteMany
   */
  export type FoodRecipeCostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodRecipeCosts to delete
     */
    where?: FoodRecipeCostWhereInput
    /**
     * Limit how many FoodRecipeCosts to delete.
     */
    limit?: number
  }

  /**
   * FoodRecipeCost without action
   */
  export type FoodRecipeCostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodRecipeCost
     */
    select?: FoodRecipeCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodRecipeCost
     */
    omit?: FoodRecipeCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodRecipeCostInclude<ExtArgs> | null
  }


  /**
   * Model FoodCostPool
   */

  export type AggregateFoodCostPool = {
    _count: FoodCostPoolCountAggregateOutputType | null
    _avg: FoodCostPoolAvgAggregateOutputType | null
    _sum: FoodCostPoolSumAggregateOutputType | null
    _min: FoodCostPoolMinAggregateOutputType | null
    _max: FoodCostPoolMaxAggregateOutputType | null
  }

  export type FoodCostPoolAvgAggregateOutputType = {
    id: number | null
    amount: Decimal | null
    periodRations: Decimal | null
    dailyBlocks: number | null
    timeMinutes: Decimal | null
  }

  export type FoodCostPoolSumAggregateOutputType = {
    id: number | null
    amount: Decimal | null
    periodRations: Decimal | null
    dailyBlocks: number | null
    timeMinutes: Decimal | null
  }

  export type FoodCostPoolMinAggregateOutputType = {
    id: number | null
    name: string | null
    type: $Enums.FoodCostPoolType | null
    amount: Decimal | null
    period: $Enums.FoodCostPeriod | null
    periodRations: Decimal | null
    appliesTo: $Enums.FoodMealType | null
    notes: string | null
    allocationMethod: $Enums.PoolAllocationMethod | null
    dailyBlocks: number | null
    timeMinutes: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FoodCostPoolMaxAggregateOutputType = {
    id: number | null
    name: string | null
    type: $Enums.FoodCostPoolType | null
    amount: Decimal | null
    period: $Enums.FoodCostPeriod | null
    periodRations: Decimal | null
    appliesTo: $Enums.FoodMealType | null
    notes: string | null
    allocationMethod: $Enums.PoolAllocationMethod | null
    dailyBlocks: number | null
    timeMinutes: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FoodCostPoolCountAggregateOutputType = {
    id: number
    name: number
    type: number
    amount: number
    period: number
    periodRations: number
    appliesTo: number
    notes: number
    allocationMethod: number
    dailyBlocks: number
    timeMinutes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FoodCostPoolAvgAggregateInputType = {
    id?: true
    amount?: true
    periodRations?: true
    dailyBlocks?: true
    timeMinutes?: true
  }

  export type FoodCostPoolSumAggregateInputType = {
    id?: true
    amount?: true
    periodRations?: true
    dailyBlocks?: true
    timeMinutes?: true
  }

  export type FoodCostPoolMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    amount?: true
    period?: true
    periodRations?: true
    appliesTo?: true
    notes?: true
    allocationMethod?: true
    dailyBlocks?: true
    timeMinutes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FoodCostPoolMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    amount?: true
    period?: true
    periodRations?: true
    appliesTo?: true
    notes?: true
    allocationMethod?: true
    dailyBlocks?: true
    timeMinutes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FoodCostPoolCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    amount?: true
    period?: true
    periodRations?: true
    appliesTo?: true
    notes?: true
    allocationMethod?: true
    dailyBlocks?: true
    timeMinutes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FoodCostPoolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodCostPool to aggregate.
     */
    where?: FoodCostPoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodCostPools to fetch.
     */
    orderBy?: FoodCostPoolOrderByWithRelationInput | FoodCostPoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoodCostPoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodCostPools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodCostPools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FoodCostPools
    **/
    _count?: true | FoodCostPoolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FoodCostPoolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FoodCostPoolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoodCostPoolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoodCostPoolMaxAggregateInputType
  }

  export type GetFoodCostPoolAggregateType<T extends FoodCostPoolAggregateArgs> = {
        [P in keyof T & keyof AggregateFoodCostPool]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoodCostPool[P]>
      : GetScalarType<T[P], AggregateFoodCostPool[P]>
  }




  export type FoodCostPoolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodCostPoolWhereInput
    orderBy?: FoodCostPoolOrderByWithAggregationInput | FoodCostPoolOrderByWithAggregationInput[]
    by: FoodCostPoolScalarFieldEnum[] | FoodCostPoolScalarFieldEnum
    having?: FoodCostPoolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoodCostPoolCountAggregateInputType | true
    _avg?: FoodCostPoolAvgAggregateInputType
    _sum?: FoodCostPoolSumAggregateInputType
    _min?: FoodCostPoolMinAggregateInputType
    _max?: FoodCostPoolMaxAggregateInputType
  }

  export type FoodCostPoolGroupByOutputType = {
    id: number
    name: string
    type: $Enums.FoodCostPoolType
    amount: Decimal
    period: $Enums.FoodCostPeriod
    periodRations: Decimal | null
    appliesTo: $Enums.FoodMealType | null
    notes: string | null
    allocationMethod: $Enums.PoolAllocationMethod
    dailyBlocks: number | null
    timeMinutes: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: FoodCostPoolCountAggregateOutputType | null
    _avg: FoodCostPoolAvgAggregateOutputType | null
    _sum: FoodCostPoolSumAggregateOutputType | null
    _min: FoodCostPoolMinAggregateOutputType | null
    _max: FoodCostPoolMaxAggregateOutputType | null
  }

  type GetFoodCostPoolGroupByPayload<T extends FoodCostPoolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoodCostPoolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoodCostPoolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoodCostPoolGroupByOutputType[P]>
            : GetScalarType<T[P], FoodCostPoolGroupByOutputType[P]>
        }
      >
    >


  export type FoodCostPoolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    amount?: boolean
    period?: boolean
    periodRations?: boolean
    appliesTo?: boolean
    notes?: boolean
    allocationMethod?: boolean
    dailyBlocks?: boolean
    timeMinutes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["foodCostPool"]>

  export type FoodCostPoolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    amount?: boolean
    period?: boolean
    periodRations?: boolean
    appliesTo?: boolean
    notes?: boolean
    allocationMethod?: boolean
    dailyBlocks?: boolean
    timeMinutes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["foodCostPool"]>

  export type FoodCostPoolSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    amount?: boolean
    period?: boolean
    periodRations?: boolean
    appliesTo?: boolean
    notes?: boolean
    allocationMethod?: boolean
    dailyBlocks?: boolean
    timeMinutes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["foodCostPool"]>

  export type FoodCostPoolSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    amount?: boolean
    period?: boolean
    periodRations?: boolean
    appliesTo?: boolean
    notes?: boolean
    allocationMethod?: boolean
    dailyBlocks?: boolean
    timeMinutes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FoodCostPoolOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "amount" | "period" | "periodRations" | "appliesTo" | "notes" | "allocationMethod" | "dailyBlocks" | "timeMinutes" | "createdAt" | "updatedAt", ExtArgs["result"]["foodCostPool"]>

  export type $FoodCostPoolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FoodCostPool"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      type: $Enums.FoodCostPoolType
      amount: Prisma.Decimal
      period: $Enums.FoodCostPeriod
      periodRations: Prisma.Decimal | null
      appliesTo: $Enums.FoodMealType | null
      notes: string | null
      allocationMethod: $Enums.PoolAllocationMethod
      dailyBlocks: number | null
      timeMinutes: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["foodCostPool"]>
    composites: {}
  }

  type FoodCostPoolGetPayload<S extends boolean | null | undefined | FoodCostPoolDefaultArgs> = $Result.GetResult<Prisma.$FoodCostPoolPayload, S>

  type FoodCostPoolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FoodCostPoolFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FoodCostPoolCountAggregateInputType | true
    }

  export interface FoodCostPoolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FoodCostPool'], meta: { name: 'FoodCostPool' } }
    /**
     * Find zero or one FoodCostPool that matches the filter.
     * @param {FoodCostPoolFindUniqueArgs} args - Arguments to find a FoodCostPool
     * @example
     * // Get one FoodCostPool
     * const foodCostPool = await prisma.foodCostPool.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoodCostPoolFindUniqueArgs>(args: SelectSubset<T, FoodCostPoolFindUniqueArgs<ExtArgs>>): Prisma__FoodCostPoolClient<$Result.GetResult<Prisma.$FoodCostPoolPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FoodCostPool that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FoodCostPoolFindUniqueOrThrowArgs} args - Arguments to find a FoodCostPool
     * @example
     * // Get one FoodCostPool
     * const foodCostPool = await prisma.foodCostPool.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoodCostPoolFindUniqueOrThrowArgs>(args: SelectSubset<T, FoodCostPoolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoodCostPoolClient<$Result.GetResult<Prisma.$FoodCostPoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodCostPool that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodCostPoolFindFirstArgs} args - Arguments to find a FoodCostPool
     * @example
     * // Get one FoodCostPool
     * const foodCostPool = await prisma.foodCostPool.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoodCostPoolFindFirstArgs>(args?: SelectSubset<T, FoodCostPoolFindFirstArgs<ExtArgs>>): Prisma__FoodCostPoolClient<$Result.GetResult<Prisma.$FoodCostPoolPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodCostPool that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodCostPoolFindFirstOrThrowArgs} args - Arguments to find a FoodCostPool
     * @example
     * // Get one FoodCostPool
     * const foodCostPool = await prisma.foodCostPool.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoodCostPoolFindFirstOrThrowArgs>(args?: SelectSubset<T, FoodCostPoolFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoodCostPoolClient<$Result.GetResult<Prisma.$FoodCostPoolPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FoodCostPools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodCostPoolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoodCostPools
     * const foodCostPools = await prisma.foodCostPool.findMany()
     * 
     * // Get first 10 FoodCostPools
     * const foodCostPools = await prisma.foodCostPool.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foodCostPoolWithIdOnly = await prisma.foodCostPool.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FoodCostPoolFindManyArgs>(args?: SelectSubset<T, FoodCostPoolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodCostPoolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FoodCostPool.
     * @param {FoodCostPoolCreateArgs} args - Arguments to create a FoodCostPool.
     * @example
     * // Create one FoodCostPool
     * const FoodCostPool = await prisma.foodCostPool.create({
     *   data: {
     *     // ... data to create a FoodCostPool
     *   }
     * })
     * 
     */
    create<T extends FoodCostPoolCreateArgs>(args: SelectSubset<T, FoodCostPoolCreateArgs<ExtArgs>>): Prisma__FoodCostPoolClient<$Result.GetResult<Prisma.$FoodCostPoolPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FoodCostPools.
     * @param {FoodCostPoolCreateManyArgs} args - Arguments to create many FoodCostPools.
     * @example
     * // Create many FoodCostPools
     * const foodCostPool = await prisma.foodCostPool.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoodCostPoolCreateManyArgs>(args?: SelectSubset<T, FoodCostPoolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FoodCostPools and returns the data saved in the database.
     * @param {FoodCostPoolCreateManyAndReturnArgs} args - Arguments to create many FoodCostPools.
     * @example
     * // Create many FoodCostPools
     * const foodCostPool = await prisma.foodCostPool.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FoodCostPools and only return the `id`
     * const foodCostPoolWithIdOnly = await prisma.foodCostPool.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FoodCostPoolCreateManyAndReturnArgs>(args?: SelectSubset<T, FoodCostPoolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodCostPoolPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FoodCostPool.
     * @param {FoodCostPoolDeleteArgs} args - Arguments to delete one FoodCostPool.
     * @example
     * // Delete one FoodCostPool
     * const FoodCostPool = await prisma.foodCostPool.delete({
     *   where: {
     *     // ... filter to delete one FoodCostPool
     *   }
     * })
     * 
     */
    delete<T extends FoodCostPoolDeleteArgs>(args: SelectSubset<T, FoodCostPoolDeleteArgs<ExtArgs>>): Prisma__FoodCostPoolClient<$Result.GetResult<Prisma.$FoodCostPoolPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FoodCostPool.
     * @param {FoodCostPoolUpdateArgs} args - Arguments to update one FoodCostPool.
     * @example
     * // Update one FoodCostPool
     * const foodCostPool = await prisma.foodCostPool.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoodCostPoolUpdateArgs>(args: SelectSubset<T, FoodCostPoolUpdateArgs<ExtArgs>>): Prisma__FoodCostPoolClient<$Result.GetResult<Prisma.$FoodCostPoolPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FoodCostPools.
     * @param {FoodCostPoolDeleteManyArgs} args - Arguments to filter FoodCostPools to delete.
     * @example
     * // Delete a few FoodCostPools
     * const { count } = await prisma.foodCostPool.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoodCostPoolDeleteManyArgs>(args?: SelectSubset<T, FoodCostPoolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodCostPools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodCostPoolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoodCostPools
     * const foodCostPool = await prisma.foodCostPool.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoodCostPoolUpdateManyArgs>(args: SelectSubset<T, FoodCostPoolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodCostPools and returns the data updated in the database.
     * @param {FoodCostPoolUpdateManyAndReturnArgs} args - Arguments to update many FoodCostPools.
     * @example
     * // Update many FoodCostPools
     * const foodCostPool = await prisma.foodCostPool.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FoodCostPools and only return the `id`
     * const foodCostPoolWithIdOnly = await prisma.foodCostPool.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FoodCostPoolUpdateManyAndReturnArgs>(args: SelectSubset<T, FoodCostPoolUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodCostPoolPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FoodCostPool.
     * @param {FoodCostPoolUpsertArgs} args - Arguments to update or create a FoodCostPool.
     * @example
     * // Update or create a FoodCostPool
     * const foodCostPool = await prisma.foodCostPool.upsert({
     *   create: {
     *     // ... data to create a FoodCostPool
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoodCostPool we want to update
     *   }
     * })
     */
    upsert<T extends FoodCostPoolUpsertArgs>(args: SelectSubset<T, FoodCostPoolUpsertArgs<ExtArgs>>): Prisma__FoodCostPoolClient<$Result.GetResult<Prisma.$FoodCostPoolPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FoodCostPools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodCostPoolCountArgs} args - Arguments to filter FoodCostPools to count.
     * @example
     * // Count the number of FoodCostPools
     * const count = await prisma.foodCostPool.count({
     *   where: {
     *     // ... the filter for the FoodCostPools we want to count
     *   }
     * })
    **/
    count<T extends FoodCostPoolCountArgs>(
      args?: Subset<T, FoodCostPoolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoodCostPoolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FoodCostPool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodCostPoolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoodCostPoolAggregateArgs>(args: Subset<T, FoodCostPoolAggregateArgs>): Prisma.PrismaPromise<GetFoodCostPoolAggregateType<T>>

    /**
     * Group by FoodCostPool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodCostPoolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoodCostPoolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoodCostPoolGroupByArgs['orderBy'] }
        : { orderBy?: FoodCostPoolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoodCostPoolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoodCostPoolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FoodCostPool model
   */
  readonly fields: FoodCostPoolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FoodCostPool.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoodCostPoolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FoodCostPool model
   */
  interface FoodCostPoolFieldRefs {
    readonly id: FieldRef<"FoodCostPool", 'Int'>
    readonly name: FieldRef<"FoodCostPool", 'String'>
    readonly type: FieldRef<"FoodCostPool", 'FoodCostPoolType'>
    readonly amount: FieldRef<"FoodCostPool", 'Decimal'>
    readonly period: FieldRef<"FoodCostPool", 'FoodCostPeriod'>
    readonly periodRations: FieldRef<"FoodCostPool", 'Decimal'>
    readonly appliesTo: FieldRef<"FoodCostPool", 'FoodMealType'>
    readonly notes: FieldRef<"FoodCostPool", 'String'>
    readonly allocationMethod: FieldRef<"FoodCostPool", 'PoolAllocationMethod'>
    readonly dailyBlocks: FieldRef<"FoodCostPool", 'Int'>
    readonly timeMinutes: FieldRef<"FoodCostPool", 'Decimal'>
    readonly createdAt: FieldRef<"FoodCostPool", 'DateTime'>
    readonly updatedAt: FieldRef<"FoodCostPool", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FoodCostPool findUnique
   */
  export type FoodCostPoolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodCostPool
     */
    select?: FoodCostPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodCostPool
     */
    omit?: FoodCostPoolOmit<ExtArgs> | null
    /**
     * Filter, which FoodCostPool to fetch.
     */
    where: FoodCostPoolWhereUniqueInput
  }

  /**
   * FoodCostPool findUniqueOrThrow
   */
  export type FoodCostPoolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodCostPool
     */
    select?: FoodCostPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodCostPool
     */
    omit?: FoodCostPoolOmit<ExtArgs> | null
    /**
     * Filter, which FoodCostPool to fetch.
     */
    where: FoodCostPoolWhereUniqueInput
  }

  /**
   * FoodCostPool findFirst
   */
  export type FoodCostPoolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodCostPool
     */
    select?: FoodCostPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodCostPool
     */
    omit?: FoodCostPoolOmit<ExtArgs> | null
    /**
     * Filter, which FoodCostPool to fetch.
     */
    where?: FoodCostPoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodCostPools to fetch.
     */
    orderBy?: FoodCostPoolOrderByWithRelationInput | FoodCostPoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodCostPools.
     */
    cursor?: FoodCostPoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodCostPools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodCostPools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodCostPools.
     */
    distinct?: FoodCostPoolScalarFieldEnum | FoodCostPoolScalarFieldEnum[]
  }

  /**
   * FoodCostPool findFirstOrThrow
   */
  export type FoodCostPoolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodCostPool
     */
    select?: FoodCostPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodCostPool
     */
    omit?: FoodCostPoolOmit<ExtArgs> | null
    /**
     * Filter, which FoodCostPool to fetch.
     */
    where?: FoodCostPoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodCostPools to fetch.
     */
    orderBy?: FoodCostPoolOrderByWithRelationInput | FoodCostPoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodCostPools.
     */
    cursor?: FoodCostPoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodCostPools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodCostPools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodCostPools.
     */
    distinct?: FoodCostPoolScalarFieldEnum | FoodCostPoolScalarFieldEnum[]
  }

  /**
   * FoodCostPool findMany
   */
  export type FoodCostPoolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodCostPool
     */
    select?: FoodCostPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodCostPool
     */
    omit?: FoodCostPoolOmit<ExtArgs> | null
    /**
     * Filter, which FoodCostPools to fetch.
     */
    where?: FoodCostPoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodCostPools to fetch.
     */
    orderBy?: FoodCostPoolOrderByWithRelationInput | FoodCostPoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FoodCostPools.
     */
    cursor?: FoodCostPoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodCostPools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodCostPools.
     */
    skip?: number
    distinct?: FoodCostPoolScalarFieldEnum | FoodCostPoolScalarFieldEnum[]
  }

  /**
   * FoodCostPool create
   */
  export type FoodCostPoolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodCostPool
     */
    select?: FoodCostPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodCostPool
     */
    omit?: FoodCostPoolOmit<ExtArgs> | null
    /**
     * The data needed to create a FoodCostPool.
     */
    data: XOR<FoodCostPoolCreateInput, FoodCostPoolUncheckedCreateInput>
  }

  /**
   * FoodCostPool createMany
   */
  export type FoodCostPoolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FoodCostPools.
     */
    data: FoodCostPoolCreateManyInput | FoodCostPoolCreateManyInput[]
  }

  /**
   * FoodCostPool createManyAndReturn
   */
  export type FoodCostPoolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodCostPool
     */
    select?: FoodCostPoolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodCostPool
     */
    omit?: FoodCostPoolOmit<ExtArgs> | null
    /**
     * The data used to create many FoodCostPools.
     */
    data: FoodCostPoolCreateManyInput | FoodCostPoolCreateManyInput[]
  }

  /**
   * FoodCostPool update
   */
  export type FoodCostPoolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodCostPool
     */
    select?: FoodCostPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodCostPool
     */
    omit?: FoodCostPoolOmit<ExtArgs> | null
    /**
     * The data needed to update a FoodCostPool.
     */
    data: XOR<FoodCostPoolUpdateInput, FoodCostPoolUncheckedUpdateInput>
    /**
     * Choose, which FoodCostPool to update.
     */
    where: FoodCostPoolWhereUniqueInput
  }

  /**
   * FoodCostPool updateMany
   */
  export type FoodCostPoolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FoodCostPools.
     */
    data: XOR<FoodCostPoolUpdateManyMutationInput, FoodCostPoolUncheckedUpdateManyInput>
    /**
     * Filter which FoodCostPools to update
     */
    where?: FoodCostPoolWhereInput
    /**
     * Limit how many FoodCostPools to update.
     */
    limit?: number
  }

  /**
   * FoodCostPool updateManyAndReturn
   */
  export type FoodCostPoolUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodCostPool
     */
    select?: FoodCostPoolSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodCostPool
     */
    omit?: FoodCostPoolOmit<ExtArgs> | null
    /**
     * The data used to update FoodCostPools.
     */
    data: XOR<FoodCostPoolUpdateManyMutationInput, FoodCostPoolUncheckedUpdateManyInput>
    /**
     * Filter which FoodCostPools to update
     */
    where?: FoodCostPoolWhereInput
    /**
     * Limit how many FoodCostPools to update.
     */
    limit?: number
  }

  /**
   * FoodCostPool upsert
   */
  export type FoodCostPoolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodCostPool
     */
    select?: FoodCostPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodCostPool
     */
    omit?: FoodCostPoolOmit<ExtArgs> | null
    /**
     * The filter to search for the FoodCostPool to update in case it exists.
     */
    where: FoodCostPoolWhereUniqueInput
    /**
     * In case the FoodCostPool found by the `where` argument doesn't exist, create a new FoodCostPool with this data.
     */
    create: XOR<FoodCostPoolCreateInput, FoodCostPoolUncheckedCreateInput>
    /**
     * In case the FoodCostPool was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoodCostPoolUpdateInput, FoodCostPoolUncheckedUpdateInput>
  }

  /**
   * FoodCostPool delete
   */
  export type FoodCostPoolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodCostPool
     */
    select?: FoodCostPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodCostPool
     */
    omit?: FoodCostPoolOmit<ExtArgs> | null
    /**
     * Filter which FoodCostPool to delete.
     */
    where: FoodCostPoolWhereUniqueInput
  }

  /**
   * FoodCostPool deleteMany
   */
  export type FoodCostPoolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodCostPools to delete
     */
    where?: FoodCostPoolWhereInput
    /**
     * Limit how many FoodCostPools to delete.
     */
    limit?: number
  }

  /**
   * FoodCostPool without action
   */
  export type FoodCostPoolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodCostPool
     */
    select?: FoodCostPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodCostPool
     */
    omit?: FoodCostPoolOmit<ExtArgs> | null
  }


  /**
   * Model FoodMealPlan
   */

  export type AggregateFoodMealPlan = {
    _count: FoodMealPlanCountAggregateOutputType | null
    _avg: FoodMealPlanAvgAggregateOutputType | null
    _sum: FoodMealPlanSumAggregateOutputType | null
    _min: FoodMealPlanMinAggregateOutputType | null
    _max: FoodMealPlanMaxAggregateOutputType | null
  }

  export type FoodMealPlanAvgAggregateOutputType = {
    id: number | null
  }

  export type FoodMealPlanSumAggregateOutputType = {
    id: number | null
  }

  export type FoodMealPlanMinAggregateOutputType = {
    id: number | null
    name: string | null
    weekStart: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FoodMealPlanMaxAggregateOutputType = {
    id: number | null
    name: string | null
    weekStart: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FoodMealPlanCountAggregateOutputType = {
    id: number
    name: number
    weekStart: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FoodMealPlanAvgAggregateInputType = {
    id?: true
  }

  export type FoodMealPlanSumAggregateInputType = {
    id?: true
  }

  export type FoodMealPlanMinAggregateInputType = {
    id?: true
    name?: true
    weekStart?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FoodMealPlanMaxAggregateInputType = {
    id?: true
    name?: true
    weekStart?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FoodMealPlanCountAggregateInputType = {
    id?: true
    name?: true
    weekStart?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FoodMealPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodMealPlan to aggregate.
     */
    where?: FoodMealPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodMealPlans to fetch.
     */
    orderBy?: FoodMealPlanOrderByWithRelationInput | FoodMealPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoodMealPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodMealPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodMealPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FoodMealPlans
    **/
    _count?: true | FoodMealPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FoodMealPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FoodMealPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoodMealPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoodMealPlanMaxAggregateInputType
  }

  export type GetFoodMealPlanAggregateType<T extends FoodMealPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateFoodMealPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoodMealPlan[P]>
      : GetScalarType<T[P], AggregateFoodMealPlan[P]>
  }




  export type FoodMealPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodMealPlanWhereInput
    orderBy?: FoodMealPlanOrderByWithAggregationInput | FoodMealPlanOrderByWithAggregationInput[]
    by: FoodMealPlanScalarFieldEnum[] | FoodMealPlanScalarFieldEnum
    having?: FoodMealPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoodMealPlanCountAggregateInputType | true
    _avg?: FoodMealPlanAvgAggregateInputType
    _sum?: FoodMealPlanSumAggregateInputType
    _min?: FoodMealPlanMinAggregateInputType
    _max?: FoodMealPlanMaxAggregateInputType
  }

  export type FoodMealPlanGroupByOutputType = {
    id: number
    name: string
    weekStart: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: FoodMealPlanCountAggregateOutputType | null
    _avg: FoodMealPlanAvgAggregateOutputType | null
    _sum: FoodMealPlanSumAggregateOutputType | null
    _min: FoodMealPlanMinAggregateOutputType | null
    _max: FoodMealPlanMaxAggregateOutputType | null
  }

  type GetFoodMealPlanGroupByPayload<T extends FoodMealPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoodMealPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoodMealPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoodMealPlanGroupByOutputType[P]>
            : GetScalarType<T[P], FoodMealPlanGroupByOutputType[P]>
        }
      >
    >


  export type FoodMealPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    weekStart?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    entries?: boolean | FoodMealPlan$entriesArgs<ExtArgs>
    _count?: boolean | FoodMealPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodMealPlan"]>

  export type FoodMealPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    weekStart?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["foodMealPlan"]>

  export type FoodMealPlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    weekStart?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["foodMealPlan"]>

  export type FoodMealPlanSelectScalar = {
    id?: boolean
    name?: boolean
    weekStart?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FoodMealPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "weekStart" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["foodMealPlan"]>
  export type FoodMealPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entries?: boolean | FoodMealPlan$entriesArgs<ExtArgs>
    _count?: boolean | FoodMealPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FoodMealPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FoodMealPlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FoodMealPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FoodMealPlan"
    objects: {
      entries: Prisma.$FoodMealPlanEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      weekStart: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["foodMealPlan"]>
    composites: {}
  }

  type FoodMealPlanGetPayload<S extends boolean | null | undefined | FoodMealPlanDefaultArgs> = $Result.GetResult<Prisma.$FoodMealPlanPayload, S>

  type FoodMealPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FoodMealPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FoodMealPlanCountAggregateInputType | true
    }

  export interface FoodMealPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FoodMealPlan'], meta: { name: 'FoodMealPlan' } }
    /**
     * Find zero or one FoodMealPlan that matches the filter.
     * @param {FoodMealPlanFindUniqueArgs} args - Arguments to find a FoodMealPlan
     * @example
     * // Get one FoodMealPlan
     * const foodMealPlan = await prisma.foodMealPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoodMealPlanFindUniqueArgs>(args: SelectSubset<T, FoodMealPlanFindUniqueArgs<ExtArgs>>): Prisma__FoodMealPlanClient<$Result.GetResult<Prisma.$FoodMealPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FoodMealPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FoodMealPlanFindUniqueOrThrowArgs} args - Arguments to find a FoodMealPlan
     * @example
     * // Get one FoodMealPlan
     * const foodMealPlan = await prisma.foodMealPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoodMealPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, FoodMealPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoodMealPlanClient<$Result.GetResult<Prisma.$FoodMealPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodMealPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodMealPlanFindFirstArgs} args - Arguments to find a FoodMealPlan
     * @example
     * // Get one FoodMealPlan
     * const foodMealPlan = await prisma.foodMealPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoodMealPlanFindFirstArgs>(args?: SelectSubset<T, FoodMealPlanFindFirstArgs<ExtArgs>>): Prisma__FoodMealPlanClient<$Result.GetResult<Prisma.$FoodMealPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodMealPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodMealPlanFindFirstOrThrowArgs} args - Arguments to find a FoodMealPlan
     * @example
     * // Get one FoodMealPlan
     * const foodMealPlan = await prisma.foodMealPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoodMealPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, FoodMealPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoodMealPlanClient<$Result.GetResult<Prisma.$FoodMealPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FoodMealPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodMealPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoodMealPlans
     * const foodMealPlans = await prisma.foodMealPlan.findMany()
     * 
     * // Get first 10 FoodMealPlans
     * const foodMealPlans = await prisma.foodMealPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foodMealPlanWithIdOnly = await prisma.foodMealPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FoodMealPlanFindManyArgs>(args?: SelectSubset<T, FoodMealPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodMealPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FoodMealPlan.
     * @param {FoodMealPlanCreateArgs} args - Arguments to create a FoodMealPlan.
     * @example
     * // Create one FoodMealPlan
     * const FoodMealPlan = await prisma.foodMealPlan.create({
     *   data: {
     *     // ... data to create a FoodMealPlan
     *   }
     * })
     * 
     */
    create<T extends FoodMealPlanCreateArgs>(args: SelectSubset<T, FoodMealPlanCreateArgs<ExtArgs>>): Prisma__FoodMealPlanClient<$Result.GetResult<Prisma.$FoodMealPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FoodMealPlans.
     * @param {FoodMealPlanCreateManyArgs} args - Arguments to create many FoodMealPlans.
     * @example
     * // Create many FoodMealPlans
     * const foodMealPlan = await prisma.foodMealPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoodMealPlanCreateManyArgs>(args?: SelectSubset<T, FoodMealPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FoodMealPlans and returns the data saved in the database.
     * @param {FoodMealPlanCreateManyAndReturnArgs} args - Arguments to create many FoodMealPlans.
     * @example
     * // Create many FoodMealPlans
     * const foodMealPlan = await prisma.foodMealPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FoodMealPlans and only return the `id`
     * const foodMealPlanWithIdOnly = await prisma.foodMealPlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FoodMealPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, FoodMealPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodMealPlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FoodMealPlan.
     * @param {FoodMealPlanDeleteArgs} args - Arguments to delete one FoodMealPlan.
     * @example
     * // Delete one FoodMealPlan
     * const FoodMealPlan = await prisma.foodMealPlan.delete({
     *   where: {
     *     // ... filter to delete one FoodMealPlan
     *   }
     * })
     * 
     */
    delete<T extends FoodMealPlanDeleteArgs>(args: SelectSubset<T, FoodMealPlanDeleteArgs<ExtArgs>>): Prisma__FoodMealPlanClient<$Result.GetResult<Prisma.$FoodMealPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FoodMealPlan.
     * @param {FoodMealPlanUpdateArgs} args - Arguments to update one FoodMealPlan.
     * @example
     * // Update one FoodMealPlan
     * const foodMealPlan = await prisma.foodMealPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoodMealPlanUpdateArgs>(args: SelectSubset<T, FoodMealPlanUpdateArgs<ExtArgs>>): Prisma__FoodMealPlanClient<$Result.GetResult<Prisma.$FoodMealPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FoodMealPlans.
     * @param {FoodMealPlanDeleteManyArgs} args - Arguments to filter FoodMealPlans to delete.
     * @example
     * // Delete a few FoodMealPlans
     * const { count } = await prisma.foodMealPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoodMealPlanDeleteManyArgs>(args?: SelectSubset<T, FoodMealPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodMealPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodMealPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoodMealPlans
     * const foodMealPlan = await prisma.foodMealPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoodMealPlanUpdateManyArgs>(args: SelectSubset<T, FoodMealPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodMealPlans and returns the data updated in the database.
     * @param {FoodMealPlanUpdateManyAndReturnArgs} args - Arguments to update many FoodMealPlans.
     * @example
     * // Update many FoodMealPlans
     * const foodMealPlan = await prisma.foodMealPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FoodMealPlans and only return the `id`
     * const foodMealPlanWithIdOnly = await prisma.foodMealPlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FoodMealPlanUpdateManyAndReturnArgs>(args: SelectSubset<T, FoodMealPlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodMealPlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FoodMealPlan.
     * @param {FoodMealPlanUpsertArgs} args - Arguments to update or create a FoodMealPlan.
     * @example
     * // Update or create a FoodMealPlan
     * const foodMealPlan = await prisma.foodMealPlan.upsert({
     *   create: {
     *     // ... data to create a FoodMealPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoodMealPlan we want to update
     *   }
     * })
     */
    upsert<T extends FoodMealPlanUpsertArgs>(args: SelectSubset<T, FoodMealPlanUpsertArgs<ExtArgs>>): Prisma__FoodMealPlanClient<$Result.GetResult<Prisma.$FoodMealPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FoodMealPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodMealPlanCountArgs} args - Arguments to filter FoodMealPlans to count.
     * @example
     * // Count the number of FoodMealPlans
     * const count = await prisma.foodMealPlan.count({
     *   where: {
     *     // ... the filter for the FoodMealPlans we want to count
     *   }
     * })
    **/
    count<T extends FoodMealPlanCountArgs>(
      args?: Subset<T, FoodMealPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoodMealPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FoodMealPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodMealPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoodMealPlanAggregateArgs>(args: Subset<T, FoodMealPlanAggregateArgs>): Prisma.PrismaPromise<GetFoodMealPlanAggregateType<T>>

    /**
     * Group by FoodMealPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodMealPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoodMealPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoodMealPlanGroupByArgs['orderBy'] }
        : { orderBy?: FoodMealPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoodMealPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoodMealPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FoodMealPlan model
   */
  readonly fields: FoodMealPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FoodMealPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoodMealPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    entries<T extends FoodMealPlan$entriesArgs<ExtArgs> = {}>(args?: Subset<T, FoodMealPlan$entriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodMealPlanEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FoodMealPlan model
   */
  interface FoodMealPlanFieldRefs {
    readonly id: FieldRef<"FoodMealPlan", 'Int'>
    readonly name: FieldRef<"FoodMealPlan", 'String'>
    readonly weekStart: FieldRef<"FoodMealPlan", 'DateTime'>
    readonly notes: FieldRef<"FoodMealPlan", 'String'>
    readonly createdAt: FieldRef<"FoodMealPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"FoodMealPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FoodMealPlan findUnique
   */
  export type FoodMealPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodMealPlan
     */
    select?: FoodMealPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodMealPlan
     */
    omit?: FoodMealPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodMealPlanInclude<ExtArgs> | null
    /**
     * Filter, which FoodMealPlan to fetch.
     */
    where: FoodMealPlanWhereUniqueInput
  }

  /**
   * FoodMealPlan findUniqueOrThrow
   */
  export type FoodMealPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodMealPlan
     */
    select?: FoodMealPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodMealPlan
     */
    omit?: FoodMealPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodMealPlanInclude<ExtArgs> | null
    /**
     * Filter, which FoodMealPlan to fetch.
     */
    where: FoodMealPlanWhereUniqueInput
  }

  /**
   * FoodMealPlan findFirst
   */
  export type FoodMealPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodMealPlan
     */
    select?: FoodMealPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodMealPlan
     */
    omit?: FoodMealPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodMealPlanInclude<ExtArgs> | null
    /**
     * Filter, which FoodMealPlan to fetch.
     */
    where?: FoodMealPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodMealPlans to fetch.
     */
    orderBy?: FoodMealPlanOrderByWithRelationInput | FoodMealPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodMealPlans.
     */
    cursor?: FoodMealPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodMealPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodMealPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodMealPlans.
     */
    distinct?: FoodMealPlanScalarFieldEnum | FoodMealPlanScalarFieldEnum[]
  }

  /**
   * FoodMealPlan findFirstOrThrow
   */
  export type FoodMealPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodMealPlan
     */
    select?: FoodMealPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodMealPlan
     */
    omit?: FoodMealPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodMealPlanInclude<ExtArgs> | null
    /**
     * Filter, which FoodMealPlan to fetch.
     */
    where?: FoodMealPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodMealPlans to fetch.
     */
    orderBy?: FoodMealPlanOrderByWithRelationInput | FoodMealPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodMealPlans.
     */
    cursor?: FoodMealPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodMealPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodMealPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodMealPlans.
     */
    distinct?: FoodMealPlanScalarFieldEnum | FoodMealPlanScalarFieldEnum[]
  }

  /**
   * FoodMealPlan findMany
   */
  export type FoodMealPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodMealPlan
     */
    select?: FoodMealPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodMealPlan
     */
    omit?: FoodMealPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodMealPlanInclude<ExtArgs> | null
    /**
     * Filter, which FoodMealPlans to fetch.
     */
    where?: FoodMealPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodMealPlans to fetch.
     */
    orderBy?: FoodMealPlanOrderByWithRelationInput | FoodMealPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FoodMealPlans.
     */
    cursor?: FoodMealPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodMealPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodMealPlans.
     */
    skip?: number
    distinct?: FoodMealPlanScalarFieldEnum | FoodMealPlanScalarFieldEnum[]
  }

  /**
   * FoodMealPlan create
   */
  export type FoodMealPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodMealPlan
     */
    select?: FoodMealPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodMealPlan
     */
    omit?: FoodMealPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodMealPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a FoodMealPlan.
     */
    data: XOR<FoodMealPlanCreateInput, FoodMealPlanUncheckedCreateInput>
  }

  /**
   * FoodMealPlan createMany
   */
  export type FoodMealPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FoodMealPlans.
     */
    data: FoodMealPlanCreateManyInput | FoodMealPlanCreateManyInput[]
  }

  /**
   * FoodMealPlan createManyAndReturn
   */
  export type FoodMealPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodMealPlan
     */
    select?: FoodMealPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodMealPlan
     */
    omit?: FoodMealPlanOmit<ExtArgs> | null
    /**
     * The data used to create many FoodMealPlans.
     */
    data: FoodMealPlanCreateManyInput | FoodMealPlanCreateManyInput[]
  }

  /**
   * FoodMealPlan update
   */
  export type FoodMealPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodMealPlan
     */
    select?: FoodMealPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodMealPlan
     */
    omit?: FoodMealPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodMealPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a FoodMealPlan.
     */
    data: XOR<FoodMealPlanUpdateInput, FoodMealPlanUncheckedUpdateInput>
    /**
     * Choose, which FoodMealPlan to update.
     */
    where: FoodMealPlanWhereUniqueInput
  }

  /**
   * FoodMealPlan updateMany
   */
  export type FoodMealPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FoodMealPlans.
     */
    data: XOR<FoodMealPlanUpdateManyMutationInput, FoodMealPlanUncheckedUpdateManyInput>
    /**
     * Filter which FoodMealPlans to update
     */
    where?: FoodMealPlanWhereInput
    /**
     * Limit how many FoodMealPlans to update.
     */
    limit?: number
  }

  /**
   * FoodMealPlan updateManyAndReturn
   */
  export type FoodMealPlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodMealPlan
     */
    select?: FoodMealPlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodMealPlan
     */
    omit?: FoodMealPlanOmit<ExtArgs> | null
    /**
     * The data used to update FoodMealPlans.
     */
    data: XOR<FoodMealPlanUpdateManyMutationInput, FoodMealPlanUncheckedUpdateManyInput>
    /**
     * Filter which FoodMealPlans to update
     */
    where?: FoodMealPlanWhereInput
    /**
     * Limit how many FoodMealPlans to update.
     */
    limit?: number
  }

  /**
   * FoodMealPlan upsert
   */
  export type FoodMealPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodMealPlan
     */
    select?: FoodMealPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodMealPlan
     */
    omit?: FoodMealPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodMealPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the FoodMealPlan to update in case it exists.
     */
    where: FoodMealPlanWhereUniqueInput
    /**
     * In case the FoodMealPlan found by the `where` argument doesn't exist, create a new FoodMealPlan with this data.
     */
    create: XOR<FoodMealPlanCreateInput, FoodMealPlanUncheckedCreateInput>
    /**
     * In case the FoodMealPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoodMealPlanUpdateInput, FoodMealPlanUncheckedUpdateInput>
  }

  /**
   * FoodMealPlan delete
   */
  export type FoodMealPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodMealPlan
     */
    select?: FoodMealPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodMealPlan
     */
    omit?: FoodMealPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodMealPlanInclude<ExtArgs> | null
    /**
     * Filter which FoodMealPlan to delete.
     */
    where: FoodMealPlanWhereUniqueInput
  }

  /**
   * FoodMealPlan deleteMany
   */
  export type FoodMealPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodMealPlans to delete
     */
    where?: FoodMealPlanWhereInput
    /**
     * Limit how many FoodMealPlans to delete.
     */
    limit?: number
  }

  /**
   * FoodMealPlan.entries
   */
  export type FoodMealPlan$entriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodMealPlanEntry
     */
    select?: FoodMealPlanEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodMealPlanEntry
     */
    omit?: FoodMealPlanEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodMealPlanEntryInclude<ExtArgs> | null
    where?: FoodMealPlanEntryWhereInput
    orderBy?: FoodMealPlanEntryOrderByWithRelationInput | FoodMealPlanEntryOrderByWithRelationInput[]
    cursor?: FoodMealPlanEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoodMealPlanEntryScalarFieldEnum | FoodMealPlanEntryScalarFieldEnum[]
  }

  /**
   * FoodMealPlan without action
   */
  export type FoodMealPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodMealPlan
     */
    select?: FoodMealPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodMealPlan
     */
    omit?: FoodMealPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodMealPlanInclude<ExtArgs> | null
  }


  /**
   * Model FoodMealPlanEntry
   */

  export type AggregateFoodMealPlanEntry = {
    _count: FoodMealPlanEntryCountAggregateOutputType | null
    _avg: FoodMealPlanEntryAvgAggregateOutputType | null
    _sum: FoodMealPlanEntrySumAggregateOutputType | null
    _min: FoodMealPlanEntryMinAggregateOutputType | null
    _max: FoodMealPlanEntryMaxAggregateOutputType | null
  }

  export type FoodMealPlanEntryAvgAggregateOutputType = {
    id: number | null
    planId: number | null
    dayIndex: number | null
    recipeId: number | null
    servings: Decimal | null
  }

  export type FoodMealPlanEntrySumAggregateOutputType = {
    id: number | null
    planId: number | null
    dayIndex: number | null
    recipeId: number | null
    servings: Decimal | null
  }

  export type FoodMealPlanEntryMinAggregateOutputType = {
    id: number | null
    planId: number | null
    dayIndex: number | null
    mealType: $Enums.FoodMealType | null
    recipeId: number | null
    servings: Decimal | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FoodMealPlanEntryMaxAggregateOutputType = {
    id: number | null
    planId: number | null
    dayIndex: number | null
    mealType: $Enums.FoodMealType | null
    recipeId: number | null
    servings: Decimal | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FoodMealPlanEntryCountAggregateOutputType = {
    id: number
    planId: number
    dayIndex: number
    mealType: number
    recipeId: number
    servings: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FoodMealPlanEntryAvgAggregateInputType = {
    id?: true
    planId?: true
    dayIndex?: true
    recipeId?: true
    servings?: true
  }

  export type FoodMealPlanEntrySumAggregateInputType = {
    id?: true
    planId?: true
    dayIndex?: true
    recipeId?: true
    servings?: true
  }

  export type FoodMealPlanEntryMinAggregateInputType = {
    id?: true
    planId?: true
    dayIndex?: true
    mealType?: true
    recipeId?: true
    servings?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FoodMealPlanEntryMaxAggregateInputType = {
    id?: true
    planId?: true
    dayIndex?: true
    mealType?: true
    recipeId?: true
    servings?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FoodMealPlanEntryCountAggregateInputType = {
    id?: true
    planId?: true
    dayIndex?: true
    mealType?: true
    recipeId?: true
    servings?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FoodMealPlanEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodMealPlanEntry to aggregate.
     */
    where?: FoodMealPlanEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodMealPlanEntries to fetch.
     */
    orderBy?: FoodMealPlanEntryOrderByWithRelationInput | FoodMealPlanEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoodMealPlanEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodMealPlanEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodMealPlanEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FoodMealPlanEntries
    **/
    _count?: true | FoodMealPlanEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FoodMealPlanEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FoodMealPlanEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoodMealPlanEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoodMealPlanEntryMaxAggregateInputType
  }

  export type GetFoodMealPlanEntryAggregateType<T extends FoodMealPlanEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateFoodMealPlanEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoodMealPlanEntry[P]>
      : GetScalarType<T[P], AggregateFoodMealPlanEntry[P]>
  }




  export type FoodMealPlanEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodMealPlanEntryWhereInput
    orderBy?: FoodMealPlanEntryOrderByWithAggregationInput | FoodMealPlanEntryOrderByWithAggregationInput[]
    by: FoodMealPlanEntryScalarFieldEnum[] | FoodMealPlanEntryScalarFieldEnum
    having?: FoodMealPlanEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoodMealPlanEntryCountAggregateInputType | true
    _avg?: FoodMealPlanEntryAvgAggregateInputType
    _sum?: FoodMealPlanEntrySumAggregateInputType
    _min?: FoodMealPlanEntryMinAggregateInputType
    _max?: FoodMealPlanEntryMaxAggregateInputType
  }

  export type FoodMealPlanEntryGroupByOutputType = {
    id: number
    planId: number
    dayIndex: number
    mealType: $Enums.FoodMealType
    recipeId: number
    servings: Decimal
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: FoodMealPlanEntryCountAggregateOutputType | null
    _avg: FoodMealPlanEntryAvgAggregateOutputType | null
    _sum: FoodMealPlanEntrySumAggregateOutputType | null
    _min: FoodMealPlanEntryMinAggregateOutputType | null
    _max: FoodMealPlanEntryMaxAggregateOutputType | null
  }

  type GetFoodMealPlanEntryGroupByPayload<T extends FoodMealPlanEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoodMealPlanEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoodMealPlanEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoodMealPlanEntryGroupByOutputType[P]>
            : GetScalarType<T[P], FoodMealPlanEntryGroupByOutputType[P]>
        }
      >
    >


  export type FoodMealPlanEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    dayIndex?: boolean
    mealType?: boolean
    recipeId?: boolean
    servings?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | FoodMealPlanDefaultArgs<ExtArgs>
    recipe?: boolean | FoodRecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodMealPlanEntry"]>

  export type FoodMealPlanEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    dayIndex?: boolean
    mealType?: boolean
    recipeId?: boolean
    servings?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | FoodMealPlanDefaultArgs<ExtArgs>
    recipe?: boolean | FoodRecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodMealPlanEntry"]>

  export type FoodMealPlanEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    dayIndex?: boolean
    mealType?: boolean
    recipeId?: boolean
    servings?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | FoodMealPlanDefaultArgs<ExtArgs>
    recipe?: boolean | FoodRecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodMealPlanEntry"]>

  export type FoodMealPlanEntrySelectScalar = {
    id?: boolean
    planId?: boolean
    dayIndex?: boolean
    mealType?: boolean
    recipeId?: boolean
    servings?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FoodMealPlanEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "planId" | "dayIndex" | "mealType" | "recipeId" | "servings" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["foodMealPlanEntry"]>
  export type FoodMealPlanEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | FoodMealPlanDefaultArgs<ExtArgs>
    recipe?: boolean | FoodRecipeDefaultArgs<ExtArgs>
  }
  export type FoodMealPlanEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | FoodMealPlanDefaultArgs<ExtArgs>
    recipe?: boolean | FoodRecipeDefaultArgs<ExtArgs>
  }
  export type FoodMealPlanEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | FoodMealPlanDefaultArgs<ExtArgs>
    recipe?: boolean | FoodRecipeDefaultArgs<ExtArgs>
  }

  export type $FoodMealPlanEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FoodMealPlanEntry"
    objects: {
      plan: Prisma.$FoodMealPlanPayload<ExtArgs>
      recipe: Prisma.$FoodRecipePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      planId: number
      dayIndex: number
      mealType: $Enums.FoodMealType
      recipeId: number
      servings: Prisma.Decimal
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["foodMealPlanEntry"]>
    composites: {}
  }

  type FoodMealPlanEntryGetPayload<S extends boolean | null | undefined | FoodMealPlanEntryDefaultArgs> = $Result.GetResult<Prisma.$FoodMealPlanEntryPayload, S>

  type FoodMealPlanEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FoodMealPlanEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FoodMealPlanEntryCountAggregateInputType | true
    }

  export interface FoodMealPlanEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FoodMealPlanEntry'], meta: { name: 'FoodMealPlanEntry' } }
    /**
     * Find zero or one FoodMealPlanEntry that matches the filter.
     * @param {FoodMealPlanEntryFindUniqueArgs} args - Arguments to find a FoodMealPlanEntry
     * @example
     * // Get one FoodMealPlanEntry
     * const foodMealPlanEntry = await prisma.foodMealPlanEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoodMealPlanEntryFindUniqueArgs>(args: SelectSubset<T, FoodMealPlanEntryFindUniqueArgs<ExtArgs>>): Prisma__FoodMealPlanEntryClient<$Result.GetResult<Prisma.$FoodMealPlanEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FoodMealPlanEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FoodMealPlanEntryFindUniqueOrThrowArgs} args - Arguments to find a FoodMealPlanEntry
     * @example
     * // Get one FoodMealPlanEntry
     * const foodMealPlanEntry = await prisma.foodMealPlanEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoodMealPlanEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, FoodMealPlanEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoodMealPlanEntryClient<$Result.GetResult<Prisma.$FoodMealPlanEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodMealPlanEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodMealPlanEntryFindFirstArgs} args - Arguments to find a FoodMealPlanEntry
     * @example
     * // Get one FoodMealPlanEntry
     * const foodMealPlanEntry = await prisma.foodMealPlanEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoodMealPlanEntryFindFirstArgs>(args?: SelectSubset<T, FoodMealPlanEntryFindFirstArgs<ExtArgs>>): Prisma__FoodMealPlanEntryClient<$Result.GetResult<Prisma.$FoodMealPlanEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodMealPlanEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodMealPlanEntryFindFirstOrThrowArgs} args - Arguments to find a FoodMealPlanEntry
     * @example
     * // Get one FoodMealPlanEntry
     * const foodMealPlanEntry = await prisma.foodMealPlanEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoodMealPlanEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, FoodMealPlanEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoodMealPlanEntryClient<$Result.GetResult<Prisma.$FoodMealPlanEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FoodMealPlanEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodMealPlanEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoodMealPlanEntries
     * const foodMealPlanEntries = await prisma.foodMealPlanEntry.findMany()
     * 
     * // Get first 10 FoodMealPlanEntries
     * const foodMealPlanEntries = await prisma.foodMealPlanEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foodMealPlanEntryWithIdOnly = await prisma.foodMealPlanEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FoodMealPlanEntryFindManyArgs>(args?: SelectSubset<T, FoodMealPlanEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodMealPlanEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FoodMealPlanEntry.
     * @param {FoodMealPlanEntryCreateArgs} args - Arguments to create a FoodMealPlanEntry.
     * @example
     * // Create one FoodMealPlanEntry
     * const FoodMealPlanEntry = await prisma.foodMealPlanEntry.create({
     *   data: {
     *     // ... data to create a FoodMealPlanEntry
     *   }
     * })
     * 
     */
    create<T extends FoodMealPlanEntryCreateArgs>(args: SelectSubset<T, FoodMealPlanEntryCreateArgs<ExtArgs>>): Prisma__FoodMealPlanEntryClient<$Result.GetResult<Prisma.$FoodMealPlanEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FoodMealPlanEntries.
     * @param {FoodMealPlanEntryCreateManyArgs} args - Arguments to create many FoodMealPlanEntries.
     * @example
     * // Create many FoodMealPlanEntries
     * const foodMealPlanEntry = await prisma.foodMealPlanEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoodMealPlanEntryCreateManyArgs>(args?: SelectSubset<T, FoodMealPlanEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FoodMealPlanEntries and returns the data saved in the database.
     * @param {FoodMealPlanEntryCreateManyAndReturnArgs} args - Arguments to create many FoodMealPlanEntries.
     * @example
     * // Create many FoodMealPlanEntries
     * const foodMealPlanEntry = await prisma.foodMealPlanEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FoodMealPlanEntries and only return the `id`
     * const foodMealPlanEntryWithIdOnly = await prisma.foodMealPlanEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FoodMealPlanEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, FoodMealPlanEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodMealPlanEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FoodMealPlanEntry.
     * @param {FoodMealPlanEntryDeleteArgs} args - Arguments to delete one FoodMealPlanEntry.
     * @example
     * // Delete one FoodMealPlanEntry
     * const FoodMealPlanEntry = await prisma.foodMealPlanEntry.delete({
     *   where: {
     *     // ... filter to delete one FoodMealPlanEntry
     *   }
     * })
     * 
     */
    delete<T extends FoodMealPlanEntryDeleteArgs>(args: SelectSubset<T, FoodMealPlanEntryDeleteArgs<ExtArgs>>): Prisma__FoodMealPlanEntryClient<$Result.GetResult<Prisma.$FoodMealPlanEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FoodMealPlanEntry.
     * @param {FoodMealPlanEntryUpdateArgs} args - Arguments to update one FoodMealPlanEntry.
     * @example
     * // Update one FoodMealPlanEntry
     * const foodMealPlanEntry = await prisma.foodMealPlanEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoodMealPlanEntryUpdateArgs>(args: SelectSubset<T, FoodMealPlanEntryUpdateArgs<ExtArgs>>): Prisma__FoodMealPlanEntryClient<$Result.GetResult<Prisma.$FoodMealPlanEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FoodMealPlanEntries.
     * @param {FoodMealPlanEntryDeleteManyArgs} args - Arguments to filter FoodMealPlanEntries to delete.
     * @example
     * // Delete a few FoodMealPlanEntries
     * const { count } = await prisma.foodMealPlanEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoodMealPlanEntryDeleteManyArgs>(args?: SelectSubset<T, FoodMealPlanEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodMealPlanEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodMealPlanEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoodMealPlanEntries
     * const foodMealPlanEntry = await prisma.foodMealPlanEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoodMealPlanEntryUpdateManyArgs>(args: SelectSubset<T, FoodMealPlanEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodMealPlanEntries and returns the data updated in the database.
     * @param {FoodMealPlanEntryUpdateManyAndReturnArgs} args - Arguments to update many FoodMealPlanEntries.
     * @example
     * // Update many FoodMealPlanEntries
     * const foodMealPlanEntry = await prisma.foodMealPlanEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FoodMealPlanEntries and only return the `id`
     * const foodMealPlanEntryWithIdOnly = await prisma.foodMealPlanEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FoodMealPlanEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, FoodMealPlanEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodMealPlanEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FoodMealPlanEntry.
     * @param {FoodMealPlanEntryUpsertArgs} args - Arguments to update or create a FoodMealPlanEntry.
     * @example
     * // Update or create a FoodMealPlanEntry
     * const foodMealPlanEntry = await prisma.foodMealPlanEntry.upsert({
     *   create: {
     *     // ... data to create a FoodMealPlanEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoodMealPlanEntry we want to update
     *   }
     * })
     */
    upsert<T extends FoodMealPlanEntryUpsertArgs>(args: SelectSubset<T, FoodMealPlanEntryUpsertArgs<ExtArgs>>): Prisma__FoodMealPlanEntryClient<$Result.GetResult<Prisma.$FoodMealPlanEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FoodMealPlanEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodMealPlanEntryCountArgs} args - Arguments to filter FoodMealPlanEntries to count.
     * @example
     * // Count the number of FoodMealPlanEntries
     * const count = await prisma.foodMealPlanEntry.count({
     *   where: {
     *     // ... the filter for the FoodMealPlanEntries we want to count
     *   }
     * })
    **/
    count<T extends FoodMealPlanEntryCountArgs>(
      args?: Subset<T, FoodMealPlanEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoodMealPlanEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FoodMealPlanEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodMealPlanEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoodMealPlanEntryAggregateArgs>(args: Subset<T, FoodMealPlanEntryAggregateArgs>): Prisma.PrismaPromise<GetFoodMealPlanEntryAggregateType<T>>

    /**
     * Group by FoodMealPlanEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodMealPlanEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoodMealPlanEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoodMealPlanEntryGroupByArgs['orderBy'] }
        : { orderBy?: FoodMealPlanEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoodMealPlanEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoodMealPlanEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FoodMealPlanEntry model
   */
  readonly fields: FoodMealPlanEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FoodMealPlanEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoodMealPlanEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends FoodMealPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FoodMealPlanDefaultArgs<ExtArgs>>): Prisma__FoodMealPlanClient<$Result.GetResult<Prisma.$FoodMealPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    recipe<T extends FoodRecipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FoodRecipeDefaultArgs<ExtArgs>>): Prisma__FoodRecipeClient<$Result.GetResult<Prisma.$FoodRecipePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FoodMealPlanEntry model
   */
  interface FoodMealPlanEntryFieldRefs {
    readonly id: FieldRef<"FoodMealPlanEntry", 'Int'>
    readonly planId: FieldRef<"FoodMealPlanEntry", 'Int'>
    readonly dayIndex: FieldRef<"FoodMealPlanEntry", 'Int'>
    readonly mealType: FieldRef<"FoodMealPlanEntry", 'FoodMealType'>
    readonly recipeId: FieldRef<"FoodMealPlanEntry", 'Int'>
    readonly servings: FieldRef<"FoodMealPlanEntry", 'Decimal'>
    readonly notes: FieldRef<"FoodMealPlanEntry", 'String'>
    readonly createdAt: FieldRef<"FoodMealPlanEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"FoodMealPlanEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FoodMealPlanEntry findUnique
   */
  export type FoodMealPlanEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodMealPlanEntry
     */
    select?: FoodMealPlanEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodMealPlanEntry
     */
    omit?: FoodMealPlanEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodMealPlanEntryInclude<ExtArgs> | null
    /**
     * Filter, which FoodMealPlanEntry to fetch.
     */
    where: FoodMealPlanEntryWhereUniqueInput
  }

  /**
   * FoodMealPlanEntry findUniqueOrThrow
   */
  export type FoodMealPlanEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodMealPlanEntry
     */
    select?: FoodMealPlanEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodMealPlanEntry
     */
    omit?: FoodMealPlanEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodMealPlanEntryInclude<ExtArgs> | null
    /**
     * Filter, which FoodMealPlanEntry to fetch.
     */
    where: FoodMealPlanEntryWhereUniqueInput
  }

  /**
   * FoodMealPlanEntry findFirst
   */
  export type FoodMealPlanEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodMealPlanEntry
     */
    select?: FoodMealPlanEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodMealPlanEntry
     */
    omit?: FoodMealPlanEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodMealPlanEntryInclude<ExtArgs> | null
    /**
     * Filter, which FoodMealPlanEntry to fetch.
     */
    where?: FoodMealPlanEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodMealPlanEntries to fetch.
     */
    orderBy?: FoodMealPlanEntryOrderByWithRelationInput | FoodMealPlanEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodMealPlanEntries.
     */
    cursor?: FoodMealPlanEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodMealPlanEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodMealPlanEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodMealPlanEntries.
     */
    distinct?: FoodMealPlanEntryScalarFieldEnum | FoodMealPlanEntryScalarFieldEnum[]
  }

  /**
   * FoodMealPlanEntry findFirstOrThrow
   */
  export type FoodMealPlanEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodMealPlanEntry
     */
    select?: FoodMealPlanEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodMealPlanEntry
     */
    omit?: FoodMealPlanEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodMealPlanEntryInclude<ExtArgs> | null
    /**
     * Filter, which FoodMealPlanEntry to fetch.
     */
    where?: FoodMealPlanEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodMealPlanEntries to fetch.
     */
    orderBy?: FoodMealPlanEntryOrderByWithRelationInput | FoodMealPlanEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodMealPlanEntries.
     */
    cursor?: FoodMealPlanEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodMealPlanEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodMealPlanEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodMealPlanEntries.
     */
    distinct?: FoodMealPlanEntryScalarFieldEnum | FoodMealPlanEntryScalarFieldEnum[]
  }

  /**
   * FoodMealPlanEntry findMany
   */
  export type FoodMealPlanEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodMealPlanEntry
     */
    select?: FoodMealPlanEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodMealPlanEntry
     */
    omit?: FoodMealPlanEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodMealPlanEntryInclude<ExtArgs> | null
    /**
     * Filter, which FoodMealPlanEntries to fetch.
     */
    where?: FoodMealPlanEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodMealPlanEntries to fetch.
     */
    orderBy?: FoodMealPlanEntryOrderByWithRelationInput | FoodMealPlanEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FoodMealPlanEntries.
     */
    cursor?: FoodMealPlanEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodMealPlanEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodMealPlanEntries.
     */
    skip?: number
    distinct?: FoodMealPlanEntryScalarFieldEnum | FoodMealPlanEntryScalarFieldEnum[]
  }

  /**
   * FoodMealPlanEntry create
   */
  export type FoodMealPlanEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodMealPlanEntry
     */
    select?: FoodMealPlanEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodMealPlanEntry
     */
    omit?: FoodMealPlanEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodMealPlanEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a FoodMealPlanEntry.
     */
    data: XOR<FoodMealPlanEntryCreateInput, FoodMealPlanEntryUncheckedCreateInput>
  }

  /**
   * FoodMealPlanEntry createMany
   */
  export type FoodMealPlanEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FoodMealPlanEntries.
     */
    data: FoodMealPlanEntryCreateManyInput | FoodMealPlanEntryCreateManyInput[]
  }

  /**
   * FoodMealPlanEntry createManyAndReturn
   */
  export type FoodMealPlanEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodMealPlanEntry
     */
    select?: FoodMealPlanEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodMealPlanEntry
     */
    omit?: FoodMealPlanEntryOmit<ExtArgs> | null
    /**
     * The data used to create many FoodMealPlanEntries.
     */
    data: FoodMealPlanEntryCreateManyInput | FoodMealPlanEntryCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodMealPlanEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FoodMealPlanEntry update
   */
  export type FoodMealPlanEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodMealPlanEntry
     */
    select?: FoodMealPlanEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodMealPlanEntry
     */
    omit?: FoodMealPlanEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodMealPlanEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a FoodMealPlanEntry.
     */
    data: XOR<FoodMealPlanEntryUpdateInput, FoodMealPlanEntryUncheckedUpdateInput>
    /**
     * Choose, which FoodMealPlanEntry to update.
     */
    where: FoodMealPlanEntryWhereUniqueInput
  }

  /**
   * FoodMealPlanEntry updateMany
   */
  export type FoodMealPlanEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FoodMealPlanEntries.
     */
    data: XOR<FoodMealPlanEntryUpdateManyMutationInput, FoodMealPlanEntryUncheckedUpdateManyInput>
    /**
     * Filter which FoodMealPlanEntries to update
     */
    where?: FoodMealPlanEntryWhereInput
    /**
     * Limit how many FoodMealPlanEntries to update.
     */
    limit?: number
  }

  /**
   * FoodMealPlanEntry updateManyAndReturn
   */
  export type FoodMealPlanEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodMealPlanEntry
     */
    select?: FoodMealPlanEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodMealPlanEntry
     */
    omit?: FoodMealPlanEntryOmit<ExtArgs> | null
    /**
     * The data used to update FoodMealPlanEntries.
     */
    data: XOR<FoodMealPlanEntryUpdateManyMutationInput, FoodMealPlanEntryUncheckedUpdateManyInput>
    /**
     * Filter which FoodMealPlanEntries to update
     */
    where?: FoodMealPlanEntryWhereInput
    /**
     * Limit how many FoodMealPlanEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodMealPlanEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FoodMealPlanEntry upsert
   */
  export type FoodMealPlanEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodMealPlanEntry
     */
    select?: FoodMealPlanEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodMealPlanEntry
     */
    omit?: FoodMealPlanEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodMealPlanEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the FoodMealPlanEntry to update in case it exists.
     */
    where: FoodMealPlanEntryWhereUniqueInput
    /**
     * In case the FoodMealPlanEntry found by the `where` argument doesn't exist, create a new FoodMealPlanEntry with this data.
     */
    create: XOR<FoodMealPlanEntryCreateInput, FoodMealPlanEntryUncheckedCreateInput>
    /**
     * In case the FoodMealPlanEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoodMealPlanEntryUpdateInput, FoodMealPlanEntryUncheckedUpdateInput>
  }

  /**
   * FoodMealPlanEntry delete
   */
  export type FoodMealPlanEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodMealPlanEntry
     */
    select?: FoodMealPlanEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodMealPlanEntry
     */
    omit?: FoodMealPlanEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodMealPlanEntryInclude<ExtArgs> | null
    /**
     * Filter which FoodMealPlanEntry to delete.
     */
    where: FoodMealPlanEntryWhereUniqueInput
  }

  /**
   * FoodMealPlanEntry deleteMany
   */
  export type FoodMealPlanEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodMealPlanEntries to delete
     */
    where?: FoodMealPlanEntryWhereInput
    /**
     * Limit how many FoodMealPlanEntries to delete.
     */
    limit?: number
  }

  /**
   * FoodMealPlanEntry without action
   */
  export type FoodMealPlanEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodMealPlanEntry
     */
    select?: FoodMealPlanEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodMealPlanEntry
     */
    omit?: FoodMealPlanEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodMealPlanEntryInclude<ExtArgs> | null
  }


  /**
   * Model QuotationProcess
   */

  export type AggregateQuotationProcess = {
    _count: QuotationProcessCountAggregateOutputType | null
    _avg: QuotationProcessAvgAggregateOutputType | null
    _sum: QuotationProcessSumAggregateOutputType | null
    _min: QuotationProcessMinAggregateOutputType | null
    _max: QuotationProcessMaxAggregateOutputType | null
  }

  export type QuotationProcessAvgAggregateOutputType = {
    id: number | null
    exchangeRate: Decimal | null
    targetMarginPct: Decimal | null
    baselineFileId: number | null
  }

  export type QuotationProcessSumAggregateOutputType = {
    id: number | null
    exchangeRate: Decimal | null
    targetMarginPct: Decimal | null
    baselineFileId: number | null
  }

  export type QuotationProcessMinAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    status: $Enums.QuotationProcessStatus | null
    baseCurrency: string | null
    targetCurrency: string | null
    exchangeRate: Decimal | null
    targetMarginPct: Decimal | null
    baselineFileId: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuotationProcessMaxAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    status: $Enums.QuotationProcessStatus | null
    baseCurrency: string | null
    targetCurrency: string | null
    exchangeRate: Decimal | null
    targetMarginPct: Decimal | null
    baselineFileId: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuotationProcessCountAggregateOutputType = {
    id: number
    name: number
    code: number
    status: number
    baseCurrency: number
    targetCurrency: number
    exchangeRate: number
    targetMarginPct: number
    baselineFileId: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuotationProcessAvgAggregateInputType = {
    id?: true
    exchangeRate?: true
    targetMarginPct?: true
    baselineFileId?: true
  }

  export type QuotationProcessSumAggregateInputType = {
    id?: true
    exchangeRate?: true
    targetMarginPct?: true
    baselineFileId?: true
  }

  export type QuotationProcessMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    status?: true
    baseCurrency?: true
    targetCurrency?: true
    exchangeRate?: true
    targetMarginPct?: true
    baselineFileId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuotationProcessMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    status?: true
    baseCurrency?: true
    targetCurrency?: true
    exchangeRate?: true
    targetMarginPct?: true
    baselineFileId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuotationProcessCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    status?: true
    baseCurrency?: true
    targetCurrency?: true
    exchangeRate?: true
    targetMarginPct?: true
    baselineFileId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuotationProcessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuotationProcess to aggregate.
     */
    where?: QuotationProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotationProcesses to fetch.
     */
    orderBy?: QuotationProcessOrderByWithRelationInput | QuotationProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuotationProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotationProcesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotationProcesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuotationProcesses
    **/
    _count?: true | QuotationProcessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuotationProcessAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuotationProcessSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuotationProcessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuotationProcessMaxAggregateInputType
  }

  export type GetQuotationProcessAggregateType<T extends QuotationProcessAggregateArgs> = {
        [P in keyof T & keyof AggregateQuotationProcess]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuotationProcess[P]>
      : GetScalarType<T[P], AggregateQuotationProcess[P]>
  }




  export type QuotationProcessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotationProcessWhereInput
    orderBy?: QuotationProcessOrderByWithAggregationInput | QuotationProcessOrderByWithAggregationInput[]
    by: QuotationProcessScalarFieldEnum[] | QuotationProcessScalarFieldEnum
    having?: QuotationProcessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuotationProcessCountAggregateInputType | true
    _avg?: QuotationProcessAvgAggregateInputType
    _sum?: QuotationProcessSumAggregateInputType
    _min?: QuotationProcessMinAggregateInputType
    _max?: QuotationProcessMaxAggregateInputType
  }

  export type QuotationProcessGroupByOutputType = {
    id: number
    name: string
    code: string | null
    status: $Enums.QuotationProcessStatus
    baseCurrency: string
    targetCurrency: string | null
    exchangeRate: Decimal | null
    targetMarginPct: Decimal | null
    baselineFileId: number | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: QuotationProcessCountAggregateOutputType | null
    _avg: QuotationProcessAvgAggregateOutputType | null
    _sum: QuotationProcessSumAggregateOutputType | null
    _min: QuotationProcessMinAggregateOutputType | null
    _max: QuotationProcessMaxAggregateOutputType | null
  }

  type GetQuotationProcessGroupByPayload<T extends QuotationProcessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuotationProcessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuotationProcessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuotationProcessGroupByOutputType[P]>
            : GetScalarType<T[P], QuotationProcessGroupByOutputType[P]>
        }
      >
    >


  export type QuotationProcessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    status?: boolean
    baseCurrency?: boolean
    targetCurrency?: boolean
    exchangeRate?: boolean
    targetMarginPct?: boolean
    baselineFileId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    baselineFile?: boolean | QuotationProcess$baselineFileArgs<ExtArgs>
    baselines?: boolean | QuotationProcess$baselinesArgs<ExtArgs>
    quotations?: boolean | QuotationProcess$quotationsArgs<ExtArgs>
    purchaseOrders?: boolean | QuotationProcess$purchaseOrdersArgs<ExtArgs>
    deliveryLogs?: boolean | QuotationProcess$deliveryLogsArgs<ExtArgs>
    _count?: boolean | QuotationProcessCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quotationProcess"]>

  export type QuotationProcessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    status?: boolean
    baseCurrency?: boolean
    targetCurrency?: boolean
    exchangeRate?: boolean
    targetMarginPct?: boolean
    baselineFileId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    baselineFile?: boolean | QuotationProcess$baselineFileArgs<ExtArgs>
  }, ExtArgs["result"]["quotationProcess"]>

  export type QuotationProcessSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    status?: boolean
    baseCurrency?: boolean
    targetCurrency?: boolean
    exchangeRate?: boolean
    targetMarginPct?: boolean
    baselineFileId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    baselineFile?: boolean | QuotationProcess$baselineFileArgs<ExtArgs>
  }, ExtArgs["result"]["quotationProcess"]>

  export type QuotationProcessSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    status?: boolean
    baseCurrency?: boolean
    targetCurrency?: boolean
    exchangeRate?: boolean
    targetMarginPct?: boolean
    baselineFileId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuotationProcessOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "status" | "baseCurrency" | "targetCurrency" | "exchangeRate" | "targetMarginPct" | "baselineFileId" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["quotationProcess"]>
  export type QuotationProcessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    baselineFile?: boolean | QuotationProcess$baselineFileArgs<ExtArgs>
    baselines?: boolean | QuotationProcess$baselinesArgs<ExtArgs>
    quotations?: boolean | QuotationProcess$quotationsArgs<ExtArgs>
    purchaseOrders?: boolean | QuotationProcess$purchaseOrdersArgs<ExtArgs>
    deliveryLogs?: boolean | QuotationProcess$deliveryLogsArgs<ExtArgs>
    _count?: boolean | QuotationProcessCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuotationProcessIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    baselineFile?: boolean | QuotationProcess$baselineFileArgs<ExtArgs>
  }
  export type QuotationProcessIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    baselineFile?: boolean | QuotationProcess$baselineFileArgs<ExtArgs>
  }

  export type $QuotationProcessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuotationProcess"
    objects: {
      baselineFile: Prisma.$QuotationAttachmentPayload<ExtArgs> | null
      baselines: Prisma.$QuotationBaselineItemPayload<ExtArgs>[]
      quotations: Prisma.$QuotationPayload<ExtArgs>[]
      purchaseOrders: Prisma.$PurchaseOrderLogPayload<ExtArgs>[]
      deliveryLogs: Prisma.$PurchaseDeliveryLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      code: string | null
      status: $Enums.QuotationProcessStatus
      baseCurrency: string
      targetCurrency: string | null
      exchangeRate: Prisma.Decimal | null
      targetMarginPct: Prisma.Decimal | null
      baselineFileId: number | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["quotationProcess"]>
    composites: {}
  }

  type QuotationProcessGetPayload<S extends boolean | null | undefined | QuotationProcessDefaultArgs> = $Result.GetResult<Prisma.$QuotationProcessPayload, S>

  type QuotationProcessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuotationProcessFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuotationProcessCountAggregateInputType | true
    }

  export interface QuotationProcessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuotationProcess'], meta: { name: 'QuotationProcess' } }
    /**
     * Find zero or one QuotationProcess that matches the filter.
     * @param {QuotationProcessFindUniqueArgs} args - Arguments to find a QuotationProcess
     * @example
     * // Get one QuotationProcess
     * const quotationProcess = await prisma.quotationProcess.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuotationProcessFindUniqueArgs>(args: SelectSubset<T, QuotationProcessFindUniqueArgs<ExtArgs>>): Prisma__QuotationProcessClient<$Result.GetResult<Prisma.$QuotationProcessPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuotationProcess that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuotationProcessFindUniqueOrThrowArgs} args - Arguments to find a QuotationProcess
     * @example
     * // Get one QuotationProcess
     * const quotationProcess = await prisma.quotationProcess.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuotationProcessFindUniqueOrThrowArgs>(args: SelectSubset<T, QuotationProcessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuotationProcessClient<$Result.GetResult<Prisma.$QuotationProcessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuotationProcess that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationProcessFindFirstArgs} args - Arguments to find a QuotationProcess
     * @example
     * // Get one QuotationProcess
     * const quotationProcess = await prisma.quotationProcess.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuotationProcessFindFirstArgs>(args?: SelectSubset<T, QuotationProcessFindFirstArgs<ExtArgs>>): Prisma__QuotationProcessClient<$Result.GetResult<Prisma.$QuotationProcessPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuotationProcess that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationProcessFindFirstOrThrowArgs} args - Arguments to find a QuotationProcess
     * @example
     * // Get one QuotationProcess
     * const quotationProcess = await prisma.quotationProcess.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuotationProcessFindFirstOrThrowArgs>(args?: SelectSubset<T, QuotationProcessFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuotationProcessClient<$Result.GetResult<Prisma.$QuotationProcessPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuotationProcesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationProcessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuotationProcesses
     * const quotationProcesses = await prisma.quotationProcess.findMany()
     * 
     * // Get first 10 QuotationProcesses
     * const quotationProcesses = await prisma.quotationProcess.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quotationProcessWithIdOnly = await prisma.quotationProcess.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuotationProcessFindManyArgs>(args?: SelectSubset<T, QuotationProcessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationProcessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuotationProcess.
     * @param {QuotationProcessCreateArgs} args - Arguments to create a QuotationProcess.
     * @example
     * // Create one QuotationProcess
     * const QuotationProcess = await prisma.quotationProcess.create({
     *   data: {
     *     // ... data to create a QuotationProcess
     *   }
     * })
     * 
     */
    create<T extends QuotationProcessCreateArgs>(args: SelectSubset<T, QuotationProcessCreateArgs<ExtArgs>>): Prisma__QuotationProcessClient<$Result.GetResult<Prisma.$QuotationProcessPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuotationProcesses.
     * @param {QuotationProcessCreateManyArgs} args - Arguments to create many QuotationProcesses.
     * @example
     * // Create many QuotationProcesses
     * const quotationProcess = await prisma.quotationProcess.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuotationProcessCreateManyArgs>(args?: SelectSubset<T, QuotationProcessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuotationProcesses and returns the data saved in the database.
     * @param {QuotationProcessCreateManyAndReturnArgs} args - Arguments to create many QuotationProcesses.
     * @example
     * // Create many QuotationProcesses
     * const quotationProcess = await prisma.quotationProcess.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuotationProcesses and only return the `id`
     * const quotationProcessWithIdOnly = await prisma.quotationProcess.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuotationProcessCreateManyAndReturnArgs>(args?: SelectSubset<T, QuotationProcessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationProcessPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuotationProcess.
     * @param {QuotationProcessDeleteArgs} args - Arguments to delete one QuotationProcess.
     * @example
     * // Delete one QuotationProcess
     * const QuotationProcess = await prisma.quotationProcess.delete({
     *   where: {
     *     // ... filter to delete one QuotationProcess
     *   }
     * })
     * 
     */
    delete<T extends QuotationProcessDeleteArgs>(args: SelectSubset<T, QuotationProcessDeleteArgs<ExtArgs>>): Prisma__QuotationProcessClient<$Result.GetResult<Prisma.$QuotationProcessPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuotationProcess.
     * @param {QuotationProcessUpdateArgs} args - Arguments to update one QuotationProcess.
     * @example
     * // Update one QuotationProcess
     * const quotationProcess = await prisma.quotationProcess.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuotationProcessUpdateArgs>(args: SelectSubset<T, QuotationProcessUpdateArgs<ExtArgs>>): Prisma__QuotationProcessClient<$Result.GetResult<Prisma.$QuotationProcessPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuotationProcesses.
     * @param {QuotationProcessDeleteManyArgs} args - Arguments to filter QuotationProcesses to delete.
     * @example
     * // Delete a few QuotationProcesses
     * const { count } = await prisma.quotationProcess.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuotationProcessDeleteManyArgs>(args?: SelectSubset<T, QuotationProcessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuotationProcesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationProcessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuotationProcesses
     * const quotationProcess = await prisma.quotationProcess.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuotationProcessUpdateManyArgs>(args: SelectSubset<T, QuotationProcessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuotationProcesses and returns the data updated in the database.
     * @param {QuotationProcessUpdateManyAndReturnArgs} args - Arguments to update many QuotationProcesses.
     * @example
     * // Update many QuotationProcesses
     * const quotationProcess = await prisma.quotationProcess.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuotationProcesses and only return the `id`
     * const quotationProcessWithIdOnly = await prisma.quotationProcess.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuotationProcessUpdateManyAndReturnArgs>(args: SelectSubset<T, QuotationProcessUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationProcessPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuotationProcess.
     * @param {QuotationProcessUpsertArgs} args - Arguments to update or create a QuotationProcess.
     * @example
     * // Update or create a QuotationProcess
     * const quotationProcess = await prisma.quotationProcess.upsert({
     *   create: {
     *     // ... data to create a QuotationProcess
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuotationProcess we want to update
     *   }
     * })
     */
    upsert<T extends QuotationProcessUpsertArgs>(args: SelectSubset<T, QuotationProcessUpsertArgs<ExtArgs>>): Prisma__QuotationProcessClient<$Result.GetResult<Prisma.$QuotationProcessPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuotationProcesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationProcessCountArgs} args - Arguments to filter QuotationProcesses to count.
     * @example
     * // Count the number of QuotationProcesses
     * const count = await prisma.quotationProcess.count({
     *   where: {
     *     // ... the filter for the QuotationProcesses we want to count
     *   }
     * })
    **/
    count<T extends QuotationProcessCountArgs>(
      args?: Subset<T, QuotationProcessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuotationProcessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuotationProcess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationProcessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuotationProcessAggregateArgs>(args: Subset<T, QuotationProcessAggregateArgs>): Prisma.PrismaPromise<GetQuotationProcessAggregateType<T>>

    /**
     * Group by QuotationProcess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationProcessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuotationProcessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuotationProcessGroupByArgs['orderBy'] }
        : { orderBy?: QuotationProcessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuotationProcessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuotationProcessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuotationProcess model
   */
  readonly fields: QuotationProcessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuotationProcess.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuotationProcessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    baselineFile<T extends QuotationProcess$baselineFileArgs<ExtArgs> = {}>(args?: Subset<T, QuotationProcess$baselineFileArgs<ExtArgs>>): Prisma__QuotationAttachmentClient<$Result.GetResult<Prisma.$QuotationAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    baselines<T extends QuotationProcess$baselinesArgs<ExtArgs> = {}>(args?: Subset<T, QuotationProcess$baselinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationBaselineItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quotations<T extends QuotationProcess$quotationsArgs<ExtArgs> = {}>(args?: Subset<T, QuotationProcess$quotationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseOrders<T extends QuotationProcess$purchaseOrdersArgs<ExtArgs> = {}>(args?: Subset<T, QuotationProcess$purchaseOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deliveryLogs<T extends QuotationProcess$deliveryLogsArgs<ExtArgs> = {}>(args?: Subset<T, QuotationProcess$deliveryLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseDeliveryLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuotationProcess model
   */
  interface QuotationProcessFieldRefs {
    readonly id: FieldRef<"QuotationProcess", 'Int'>
    readonly name: FieldRef<"QuotationProcess", 'String'>
    readonly code: FieldRef<"QuotationProcess", 'String'>
    readonly status: FieldRef<"QuotationProcess", 'QuotationProcessStatus'>
    readonly baseCurrency: FieldRef<"QuotationProcess", 'String'>
    readonly targetCurrency: FieldRef<"QuotationProcess", 'String'>
    readonly exchangeRate: FieldRef<"QuotationProcess", 'Decimal'>
    readonly targetMarginPct: FieldRef<"QuotationProcess", 'Decimal'>
    readonly baselineFileId: FieldRef<"QuotationProcess", 'Int'>
    readonly notes: FieldRef<"QuotationProcess", 'String'>
    readonly createdAt: FieldRef<"QuotationProcess", 'DateTime'>
    readonly updatedAt: FieldRef<"QuotationProcess", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuotationProcess findUnique
   */
  export type QuotationProcessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationProcess
     */
    select?: QuotationProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationProcess
     */
    omit?: QuotationProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationProcessInclude<ExtArgs> | null
    /**
     * Filter, which QuotationProcess to fetch.
     */
    where: QuotationProcessWhereUniqueInput
  }

  /**
   * QuotationProcess findUniqueOrThrow
   */
  export type QuotationProcessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationProcess
     */
    select?: QuotationProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationProcess
     */
    omit?: QuotationProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationProcessInclude<ExtArgs> | null
    /**
     * Filter, which QuotationProcess to fetch.
     */
    where: QuotationProcessWhereUniqueInput
  }

  /**
   * QuotationProcess findFirst
   */
  export type QuotationProcessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationProcess
     */
    select?: QuotationProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationProcess
     */
    omit?: QuotationProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationProcessInclude<ExtArgs> | null
    /**
     * Filter, which QuotationProcess to fetch.
     */
    where?: QuotationProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotationProcesses to fetch.
     */
    orderBy?: QuotationProcessOrderByWithRelationInput | QuotationProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuotationProcesses.
     */
    cursor?: QuotationProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotationProcesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotationProcesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuotationProcesses.
     */
    distinct?: QuotationProcessScalarFieldEnum | QuotationProcessScalarFieldEnum[]
  }

  /**
   * QuotationProcess findFirstOrThrow
   */
  export type QuotationProcessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationProcess
     */
    select?: QuotationProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationProcess
     */
    omit?: QuotationProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationProcessInclude<ExtArgs> | null
    /**
     * Filter, which QuotationProcess to fetch.
     */
    where?: QuotationProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotationProcesses to fetch.
     */
    orderBy?: QuotationProcessOrderByWithRelationInput | QuotationProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuotationProcesses.
     */
    cursor?: QuotationProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotationProcesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotationProcesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuotationProcesses.
     */
    distinct?: QuotationProcessScalarFieldEnum | QuotationProcessScalarFieldEnum[]
  }

  /**
   * QuotationProcess findMany
   */
  export type QuotationProcessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationProcess
     */
    select?: QuotationProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationProcess
     */
    omit?: QuotationProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationProcessInclude<ExtArgs> | null
    /**
     * Filter, which QuotationProcesses to fetch.
     */
    where?: QuotationProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotationProcesses to fetch.
     */
    orderBy?: QuotationProcessOrderByWithRelationInput | QuotationProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuotationProcesses.
     */
    cursor?: QuotationProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotationProcesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotationProcesses.
     */
    skip?: number
    distinct?: QuotationProcessScalarFieldEnum | QuotationProcessScalarFieldEnum[]
  }

  /**
   * QuotationProcess create
   */
  export type QuotationProcessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationProcess
     */
    select?: QuotationProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationProcess
     */
    omit?: QuotationProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationProcessInclude<ExtArgs> | null
    /**
     * The data needed to create a QuotationProcess.
     */
    data: XOR<QuotationProcessCreateInput, QuotationProcessUncheckedCreateInput>
  }

  /**
   * QuotationProcess createMany
   */
  export type QuotationProcessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuotationProcesses.
     */
    data: QuotationProcessCreateManyInput | QuotationProcessCreateManyInput[]
  }

  /**
   * QuotationProcess createManyAndReturn
   */
  export type QuotationProcessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationProcess
     */
    select?: QuotationProcessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationProcess
     */
    omit?: QuotationProcessOmit<ExtArgs> | null
    /**
     * The data used to create many QuotationProcesses.
     */
    data: QuotationProcessCreateManyInput | QuotationProcessCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationProcessIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuotationProcess update
   */
  export type QuotationProcessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationProcess
     */
    select?: QuotationProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationProcess
     */
    omit?: QuotationProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationProcessInclude<ExtArgs> | null
    /**
     * The data needed to update a QuotationProcess.
     */
    data: XOR<QuotationProcessUpdateInput, QuotationProcessUncheckedUpdateInput>
    /**
     * Choose, which QuotationProcess to update.
     */
    where: QuotationProcessWhereUniqueInput
  }

  /**
   * QuotationProcess updateMany
   */
  export type QuotationProcessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuotationProcesses.
     */
    data: XOR<QuotationProcessUpdateManyMutationInput, QuotationProcessUncheckedUpdateManyInput>
    /**
     * Filter which QuotationProcesses to update
     */
    where?: QuotationProcessWhereInput
    /**
     * Limit how many QuotationProcesses to update.
     */
    limit?: number
  }

  /**
   * QuotationProcess updateManyAndReturn
   */
  export type QuotationProcessUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationProcess
     */
    select?: QuotationProcessSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationProcess
     */
    omit?: QuotationProcessOmit<ExtArgs> | null
    /**
     * The data used to update QuotationProcesses.
     */
    data: XOR<QuotationProcessUpdateManyMutationInput, QuotationProcessUncheckedUpdateManyInput>
    /**
     * Filter which QuotationProcesses to update
     */
    where?: QuotationProcessWhereInput
    /**
     * Limit how many QuotationProcesses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationProcessIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuotationProcess upsert
   */
  export type QuotationProcessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationProcess
     */
    select?: QuotationProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationProcess
     */
    omit?: QuotationProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationProcessInclude<ExtArgs> | null
    /**
     * The filter to search for the QuotationProcess to update in case it exists.
     */
    where: QuotationProcessWhereUniqueInput
    /**
     * In case the QuotationProcess found by the `where` argument doesn't exist, create a new QuotationProcess with this data.
     */
    create: XOR<QuotationProcessCreateInput, QuotationProcessUncheckedCreateInput>
    /**
     * In case the QuotationProcess was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuotationProcessUpdateInput, QuotationProcessUncheckedUpdateInput>
  }

  /**
   * QuotationProcess delete
   */
  export type QuotationProcessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationProcess
     */
    select?: QuotationProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationProcess
     */
    omit?: QuotationProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationProcessInclude<ExtArgs> | null
    /**
     * Filter which QuotationProcess to delete.
     */
    where: QuotationProcessWhereUniqueInput
  }

  /**
   * QuotationProcess deleteMany
   */
  export type QuotationProcessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuotationProcesses to delete
     */
    where?: QuotationProcessWhereInput
    /**
     * Limit how many QuotationProcesses to delete.
     */
    limit?: number
  }

  /**
   * QuotationProcess.baselineFile
   */
  export type QuotationProcess$baselineFileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationAttachment
     */
    select?: QuotationAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationAttachment
     */
    omit?: QuotationAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationAttachmentInclude<ExtArgs> | null
    where?: QuotationAttachmentWhereInput
  }

  /**
   * QuotationProcess.baselines
   */
  export type QuotationProcess$baselinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationBaselineItem
     */
    select?: QuotationBaselineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationBaselineItem
     */
    omit?: QuotationBaselineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationBaselineItemInclude<ExtArgs> | null
    where?: QuotationBaselineItemWhereInput
    orderBy?: QuotationBaselineItemOrderByWithRelationInput | QuotationBaselineItemOrderByWithRelationInput[]
    cursor?: QuotationBaselineItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuotationBaselineItemScalarFieldEnum | QuotationBaselineItemScalarFieldEnum[]
  }

  /**
   * QuotationProcess.quotations
   */
  export type QuotationProcess$quotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    where?: QuotationWhereInput
    orderBy?: QuotationOrderByWithRelationInput | QuotationOrderByWithRelationInput[]
    cursor?: QuotationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuotationScalarFieldEnum | QuotationScalarFieldEnum[]
  }

  /**
   * QuotationProcess.purchaseOrders
   */
  export type QuotationProcess$purchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLog
     */
    select?: PurchaseOrderLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLog
     */
    omit?: PurchaseOrderLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLogInclude<ExtArgs> | null
    where?: PurchaseOrderLogWhereInput
    orderBy?: PurchaseOrderLogOrderByWithRelationInput | PurchaseOrderLogOrderByWithRelationInput[]
    cursor?: PurchaseOrderLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderLogScalarFieldEnum | PurchaseOrderLogScalarFieldEnum[]
  }

  /**
   * QuotationProcess.deliveryLogs
   */
  export type QuotationProcess$deliveryLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseDeliveryLog
     */
    select?: PurchaseDeliveryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseDeliveryLog
     */
    omit?: PurchaseDeliveryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseDeliveryLogInclude<ExtArgs> | null
    where?: PurchaseDeliveryLogWhereInput
    orderBy?: PurchaseDeliveryLogOrderByWithRelationInput | PurchaseDeliveryLogOrderByWithRelationInput[]
    cursor?: PurchaseDeliveryLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseDeliveryLogScalarFieldEnum | PurchaseDeliveryLogScalarFieldEnum[]
  }

  /**
   * QuotationProcess without action
   */
  export type QuotationProcessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationProcess
     */
    select?: QuotationProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationProcess
     */
    omit?: QuotationProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationProcessInclude<ExtArgs> | null
  }


  /**
   * Model QuotationBaselineItem
   */

  export type AggregateQuotationBaselineItem = {
    _count: QuotationBaselineItemCountAggregateOutputType | null
    _avg: QuotationBaselineItemAvgAggregateOutputType | null
    _sum: QuotationBaselineItemSumAggregateOutputType | null
    _min: QuotationBaselineItemMinAggregateOutputType | null
    _max: QuotationBaselineItemMaxAggregateOutputType | null
  }

  export type QuotationBaselineItemAvgAggregateOutputType = {
    id: number | null
    processId: number | null
    materialId: number | null
    quantity: Decimal | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
  }

  export type QuotationBaselineItemSumAggregateOutputType = {
    id: number | null
    processId: number | null
    materialId: number | null
    quantity: Decimal | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
  }

  export type QuotationBaselineItemMinAggregateOutputType = {
    id: number | null
    processId: number | null
    materialId: number | null
    sheetName: string | null
    sectionPath: string | null
    itemCode: string | null
    description: string | null
    unit: string | null
    quantity: Decimal | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuotationBaselineItemMaxAggregateOutputType = {
    id: number | null
    processId: number | null
    materialId: number | null
    sheetName: string | null
    sectionPath: string | null
    itemCode: string | null
    description: string | null
    unit: string | null
    quantity: Decimal | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuotationBaselineItemCountAggregateOutputType = {
    id: number
    processId: number
    materialId: number
    sheetName: number
    sectionPath: number
    itemCode: number
    description: number
    unit: number
    quantity: number
    unitPrice: number
    totalPrice: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuotationBaselineItemAvgAggregateInputType = {
    id?: true
    processId?: true
    materialId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type QuotationBaselineItemSumAggregateInputType = {
    id?: true
    processId?: true
    materialId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type QuotationBaselineItemMinAggregateInputType = {
    id?: true
    processId?: true
    materialId?: true
    sheetName?: true
    sectionPath?: true
    itemCode?: true
    description?: true
    unit?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuotationBaselineItemMaxAggregateInputType = {
    id?: true
    processId?: true
    materialId?: true
    sheetName?: true
    sectionPath?: true
    itemCode?: true
    description?: true
    unit?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuotationBaselineItemCountAggregateInputType = {
    id?: true
    processId?: true
    materialId?: true
    sheetName?: true
    sectionPath?: true
    itemCode?: true
    description?: true
    unit?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuotationBaselineItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuotationBaselineItem to aggregate.
     */
    where?: QuotationBaselineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotationBaselineItems to fetch.
     */
    orderBy?: QuotationBaselineItemOrderByWithRelationInput | QuotationBaselineItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuotationBaselineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotationBaselineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotationBaselineItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuotationBaselineItems
    **/
    _count?: true | QuotationBaselineItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuotationBaselineItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuotationBaselineItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuotationBaselineItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuotationBaselineItemMaxAggregateInputType
  }

  export type GetQuotationBaselineItemAggregateType<T extends QuotationBaselineItemAggregateArgs> = {
        [P in keyof T & keyof AggregateQuotationBaselineItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuotationBaselineItem[P]>
      : GetScalarType<T[P], AggregateQuotationBaselineItem[P]>
  }




  export type QuotationBaselineItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotationBaselineItemWhereInput
    orderBy?: QuotationBaselineItemOrderByWithAggregationInput | QuotationBaselineItemOrderByWithAggregationInput[]
    by: QuotationBaselineItemScalarFieldEnum[] | QuotationBaselineItemScalarFieldEnum
    having?: QuotationBaselineItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuotationBaselineItemCountAggregateInputType | true
    _avg?: QuotationBaselineItemAvgAggregateInputType
    _sum?: QuotationBaselineItemSumAggregateInputType
    _min?: QuotationBaselineItemMinAggregateInputType
    _max?: QuotationBaselineItemMaxAggregateInputType
  }

  export type QuotationBaselineItemGroupByOutputType = {
    id: number
    processId: number
    materialId: number | null
    sheetName: string | null
    sectionPath: string | null
    itemCode: string | null
    description: string
    unit: string | null
    quantity: Decimal | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: QuotationBaselineItemCountAggregateOutputType | null
    _avg: QuotationBaselineItemAvgAggregateOutputType | null
    _sum: QuotationBaselineItemSumAggregateOutputType | null
    _min: QuotationBaselineItemMinAggregateOutputType | null
    _max: QuotationBaselineItemMaxAggregateOutputType | null
  }

  type GetQuotationBaselineItemGroupByPayload<T extends QuotationBaselineItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuotationBaselineItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuotationBaselineItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuotationBaselineItemGroupByOutputType[P]>
            : GetScalarType<T[P], QuotationBaselineItemGroupByOutputType[P]>
        }
      >
    >


  export type QuotationBaselineItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    processId?: boolean
    materialId?: boolean
    sheetName?: boolean
    sectionPath?: boolean
    itemCode?: boolean
    description?: boolean
    unit?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    process?: boolean | QuotationProcessDefaultArgs<ExtArgs>
    material?: boolean | QuotationBaselineItem$materialArgs<ExtArgs>
    quoteItems?: boolean | QuotationBaselineItem$quoteItemsArgs<ExtArgs>
    orderLines?: boolean | QuotationBaselineItem$orderLinesArgs<ExtArgs>
    deliveryItems?: boolean | QuotationBaselineItem$deliveryItemsArgs<ExtArgs>
    _count?: boolean | QuotationBaselineItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quotationBaselineItem"]>

  export type QuotationBaselineItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    processId?: boolean
    materialId?: boolean
    sheetName?: boolean
    sectionPath?: boolean
    itemCode?: boolean
    description?: boolean
    unit?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    process?: boolean | QuotationProcessDefaultArgs<ExtArgs>
    material?: boolean | QuotationBaselineItem$materialArgs<ExtArgs>
  }, ExtArgs["result"]["quotationBaselineItem"]>

  export type QuotationBaselineItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    processId?: boolean
    materialId?: boolean
    sheetName?: boolean
    sectionPath?: boolean
    itemCode?: boolean
    description?: boolean
    unit?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    process?: boolean | QuotationProcessDefaultArgs<ExtArgs>
    material?: boolean | QuotationBaselineItem$materialArgs<ExtArgs>
  }, ExtArgs["result"]["quotationBaselineItem"]>

  export type QuotationBaselineItemSelectScalar = {
    id?: boolean
    processId?: boolean
    materialId?: boolean
    sheetName?: boolean
    sectionPath?: boolean
    itemCode?: boolean
    description?: boolean
    unit?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuotationBaselineItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "processId" | "materialId" | "sheetName" | "sectionPath" | "itemCode" | "description" | "unit" | "quantity" | "unitPrice" | "totalPrice" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["quotationBaselineItem"]>
  export type QuotationBaselineItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    process?: boolean | QuotationProcessDefaultArgs<ExtArgs>
    material?: boolean | QuotationBaselineItem$materialArgs<ExtArgs>
    quoteItems?: boolean | QuotationBaselineItem$quoteItemsArgs<ExtArgs>
    orderLines?: boolean | QuotationBaselineItem$orderLinesArgs<ExtArgs>
    deliveryItems?: boolean | QuotationBaselineItem$deliveryItemsArgs<ExtArgs>
    _count?: boolean | QuotationBaselineItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuotationBaselineItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    process?: boolean | QuotationProcessDefaultArgs<ExtArgs>
    material?: boolean | QuotationBaselineItem$materialArgs<ExtArgs>
  }
  export type QuotationBaselineItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    process?: boolean | QuotationProcessDefaultArgs<ExtArgs>
    material?: boolean | QuotationBaselineItem$materialArgs<ExtArgs>
  }

  export type $QuotationBaselineItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuotationBaselineItem"
    objects: {
      process: Prisma.$QuotationProcessPayload<ExtArgs>
      material: Prisma.$MaterialPayload<ExtArgs> | null
      quoteItems: Prisma.$QuotationItemPayload<ExtArgs>[]
      orderLines: Prisma.$PurchaseOrderLinePayload<ExtArgs>[]
      deliveryItems: Prisma.$PurchaseDeliveryItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      processId: number
      materialId: number | null
      sheetName: string | null
      sectionPath: string | null
      itemCode: string | null
      description: string
      unit: string | null
      quantity: Prisma.Decimal | null
      unitPrice: Prisma.Decimal | null
      totalPrice: Prisma.Decimal | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["quotationBaselineItem"]>
    composites: {}
  }

  type QuotationBaselineItemGetPayload<S extends boolean | null | undefined | QuotationBaselineItemDefaultArgs> = $Result.GetResult<Prisma.$QuotationBaselineItemPayload, S>

  type QuotationBaselineItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuotationBaselineItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuotationBaselineItemCountAggregateInputType | true
    }

  export interface QuotationBaselineItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuotationBaselineItem'], meta: { name: 'QuotationBaselineItem' } }
    /**
     * Find zero or one QuotationBaselineItem that matches the filter.
     * @param {QuotationBaselineItemFindUniqueArgs} args - Arguments to find a QuotationBaselineItem
     * @example
     * // Get one QuotationBaselineItem
     * const quotationBaselineItem = await prisma.quotationBaselineItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuotationBaselineItemFindUniqueArgs>(args: SelectSubset<T, QuotationBaselineItemFindUniqueArgs<ExtArgs>>): Prisma__QuotationBaselineItemClient<$Result.GetResult<Prisma.$QuotationBaselineItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuotationBaselineItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuotationBaselineItemFindUniqueOrThrowArgs} args - Arguments to find a QuotationBaselineItem
     * @example
     * // Get one QuotationBaselineItem
     * const quotationBaselineItem = await prisma.quotationBaselineItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuotationBaselineItemFindUniqueOrThrowArgs>(args: SelectSubset<T, QuotationBaselineItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuotationBaselineItemClient<$Result.GetResult<Prisma.$QuotationBaselineItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuotationBaselineItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationBaselineItemFindFirstArgs} args - Arguments to find a QuotationBaselineItem
     * @example
     * // Get one QuotationBaselineItem
     * const quotationBaselineItem = await prisma.quotationBaselineItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuotationBaselineItemFindFirstArgs>(args?: SelectSubset<T, QuotationBaselineItemFindFirstArgs<ExtArgs>>): Prisma__QuotationBaselineItemClient<$Result.GetResult<Prisma.$QuotationBaselineItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuotationBaselineItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationBaselineItemFindFirstOrThrowArgs} args - Arguments to find a QuotationBaselineItem
     * @example
     * // Get one QuotationBaselineItem
     * const quotationBaselineItem = await prisma.quotationBaselineItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuotationBaselineItemFindFirstOrThrowArgs>(args?: SelectSubset<T, QuotationBaselineItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuotationBaselineItemClient<$Result.GetResult<Prisma.$QuotationBaselineItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuotationBaselineItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationBaselineItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuotationBaselineItems
     * const quotationBaselineItems = await prisma.quotationBaselineItem.findMany()
     * 
     * // Get first 10 QuotationBaselineItems
     * const quotationBaselineItems = await prisma.quotationBaselineItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quotationBaselineItemWithIdOnly = await prisma.quotationBaselineItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuotationBaselineItemFindManyArgs>(args?: SelectSubset<T, QuotationBaselineItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationBaselineItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuotationBaselineItem.
     * @param {QuotationBaselineItemCreateArgs} args - Arguments to create a QuotationBaselineItem.
     * @example
     * // Create one QuotationBaselineItem
     * const QuotationBaselineItem = await prisma.quotationBaselineItem.create({
     *   data: {
     *     // ... data to create a QuotationBaselineItem
     *   }
     * })
     * 
     */
    create<T extends QuotationBaselineItemCreateArgs>(args: SelectSubset<T, QuotationBaselineItemCreateArgs<ExtArgs>>): Prisma__QuotationBaselineItemClient<$Result.GetResult<Prisma.$QuotationBaselineItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuotationBaselineItems.
     * @param {QuotationBaselineItemCreateManyArgs} args - Arguments to create many QuotationBaselineItems.
     * @example
     * // Create many QuotationBaselineItems
     * const quotationBaselineItem = await prisma.quotationBaselineItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuotationBaselineItemCreateManyArgs>(args?: SelectSubset<T, QuotationBaselineItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuotationBaselineItems and returns the data saved in the database.
     * @param {QuotationBaselineItemCreateManyAndReturnArgs} args - Arguments to create many QuotationBaselineItems.
     * @example
     * // Create many QuotationBaselineItems
     * const quotationBaselineItem = await prisma.quotationBaselineItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuotationBaselineItems and only return the `id`
     * const quotationBaselineItemWithIdOnly = await prisma.quotationBaselineItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuotationBaselineItemCreateManyAndReturnArgs>(args?: SelectSubset<T, QuotationBaselineItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationBaselineItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuotationBaselineItem.
     * @param {QuotationBaselineItemDeleteArgs} args - Arguments to delete one QuotationBaselineItem.
     * @example
     * // Delete one QuotationBaselineItem
     * const QuotationBaselineItem = await prisma.quotationBaselineItem.delete({
     *   where: {
     *     // ... filter to delete one QuotationBaselineItem
     *   }
     * })
     * 
     */
    delete<T extends QuotationBaselineItemDeleteArgs>(args: SelectSubset<T, QuotationBaselineItemDeleteArgs<ExtArgs>>): Prisma__QuotationBaselineItemClient<$Result.GetResult<Prisma.$QuotationBaselineItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuotationBaselineItem.
     * @param {QuotationBaselineItemUpdateArgs} args - Arguments to update one QuotationBaselineItem.
     * @example
     * // Update one QuotationBaselineItem
     * const quotationBaselineItem = await prisma.quotationBaselineItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuotationBaselineItemUpdateArgs>(args: SelectSubset<T, QuotationBaselineItemUpdateArgs<ExtArgs>>): Prisma__QuotationBaselineItemClient<$Result.GetResult<Prisma.$QuotationBaselineItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuotationBaselineItems.
     * @param {QuotationBaselineItemDeleteManyArgs} args - Arguments to filter QuotationBaselineItems to delete.
     * @example
     * // Delete a few QuotationBaselineItems
     * const { count } = await prisma.quotationBaselineItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuotationBaselineItemDeleteManyArgs>(args?: SelectSubset<T, QuotationBaselineItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuotationBaselineItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationBaselineItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuotationBaselineItems
     * const quotationBaselineItem = await prisma.quotationBaselineItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuotationBaselineItemUpdateManyArgs>(args: SelectSubset<T, QuotationBaselineItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuotationBaselineItems and returns the data updated in the database.
     * @param {QuotationBaselineItemUpdateManyAndReturnArgs} args - Arguments to update many QuotationBaselineItems.
     * @example
     * // Update many QuotationBaselineItems
     * const quotationBaselineItem = await prisma.quotationBaselineItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuotationBaselineItems and only return the `id`
     * const quotationBaselineItemWithIdOnly = await prisma.quotationBaselineItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuotationBaselineItemUpdateManyAndReturnArgs>(args: SelectSubset<T, QuotationBaselineItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationBaselineItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuotationBaselineItem.
     * @param {QuotationBaselineItemUpsertArgs} args - Arguments to update or create a QuotationBaselineItem.
     * @example
     * // Update or create a QuotationBaselineItem
     * const quotationBaselineItem = await prisma.quotationBaselineItem.upsert({
     *   create: {
     *     // ... data to create a QuotationBaselineItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuotationBaselineItem we want to update
     *   }
     * })
     */
    upsert<T extends QuotationBaselineItemUpsertArgs>(args: SelectSubset<T, QuotationBaselineItemUpsertArgs<ExtArgs>>): Prisma__QuotationBaselineItemClient<$Result.GetResult<Prisma.$QuotationBaselineItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuotationBaselineItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationBaselineItemCountArgs} args - Arguments to filter QuotationBaselineItems to count.
     * @example
     * // Count the number of QuotationBaselineItems
     * const count = await prisma.quotationBaselineItem.count({
     *   where: {
     *     // ... the filter for the QuotationBaselineItems we want to count
     *   }
     * })
    **/
    count<T extends QuotationBaselineItemCountArgs>(
      args?: Subset<T, QuotationBaselineItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuotationBaselineItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuotationBaselineItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationBaselineItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuotationBaselineItemAggregateArgs>(args: Subset<T, QuotationBaselineItemAggregateArgs>): Prisma.PrismaPromise<GetQuotationBaselineItemAggregateType<T>>

    /**
     * Group by QuotationBaselineItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationBaselineItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuotationBaselineItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuotationBaselineItemGroupByArgs['orderBy'] }
        : { orderBy?: QuotationBaselineItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuotationBaselineItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuotationBaselineItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuotationBaselineItem model
   */
  readonly fields: QuotationBaselineItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuotationBaselineItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuotationBaselineItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    process<T extends QuotationProcessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuotationProcessDefaultArgs<ExtArgs>>): Prisma__QuotationProcessClient<$Result.GetResult<Prisma.$QuotationProcessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    material<T extends QuotationBaselineItem$materialArgs<ExtArgs> = {}>(args?: Subset<T, QuotationBaselineItem$materialArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    quoteItems<T extends QuotationBaselineItem$quoteItemsArgs<ExtArgs> = {}>(args?: Subset<T, QuotationBaselineItem$quoteItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderLines<T extends QuotationBaselineItem$orderLinesArgs<ExtArgs> = {}>(args?: Subset<T, QuotationBaselineItem$orderLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deliveryItems<T extends QuotationBaselineItem$deliveryItemsArgs<ExtArgs> = {}>(args?: Subset<T, QuotationBaselineItem$deliveryItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseDeliveryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuotationBaselineItem model
   */
  interface QuotationBaselineItemFieldRefs {
    readonly id: FieldRef<"QuotationBaselineItem", 'Int'>
    readonly processId: FieldRef<"QuotationBaselineItem", 'Int'>
    readonly materialId: FieldRef<"QuotationBaselineItem", 'Int'>
    readonly sheetName: FieldRef<"QuotationBaselineItem", 'String'>
    readonly sectionPath: FieldRef<"QuotationBaselineItem", 'String'>
    readonly itemCode: FieldRef<"QuotationBaselineItem", 'String'>
    readonly description: FieldRef<"QuotationBaselineItem", 'String'>
    readonly unit: FieldRef<"QuotationBaselineItem", 'String'>
    readonly quantity: FieldRef<"QuotationBaselineItem", 'Decimal'>
    readonly unitPrice: FieldRef<"QuotationBaselineItem", 'Decimal'>
    readonly totalPrice: FieldRef<"QuotationBaselineItem", 'Decimal'>
    readonly metadata: FieldRef<"QuotationBaselineItem", 'Json'>
    readonly createdAt: FieldRef<"QuotationBaselineItem", 'DateTime'>
    readonly updatedAt: FieldRef<"QuotationBaselineItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuotationBaselineItem findUnique
   */
  export type QuotationBaselineItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationBaselineItem
     */
    select?: QuotationBaselineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationBaselineItem
     */
    omit?: QuotationBaselineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationBaselineItemInclude<ExtArgs> | null
    /**
     * Filter, which QuotationBaselineItem to fetch.
     */
    where: QuotationBaselineItemWhereUniqueInput
  }

  /**
   * QuotationBaselineItem findUniqueOrThrow
   */
  export type QuotationBaselineItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationBaselineItem
     */
    select?: QuotationBaselineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationBaselineItem
     */
    omit?: QuotationBaselineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationBaselineItemInclude<ExtArgs> | null
    /**
     * Filter, which QuotationBaselineItem to fetch.
     */
    where: QuotationBaselineItemWhereUniqueInput
  }

  /**
   * QuotationBaselineItem findFirst
   */
  export type QuotationBaselineItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationBaselineItem
     */
    select?: QuotationBaselineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationBaselineItem
     */
    omit?: QuotationBaselineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationBaselineItemInclude<ExtArgs> | null
    /**
     * Filter, which QuotationBaselineItem to fetch.
     */
    where?: QuotationBaselineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotationBaselineItems to fetch.
     */
    orderBy?: QuotationBaselineItemOrderByWithRelationInput | QuotationBaselineItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuotationBaselineItems.
     */
    cursor?: QuotationBaselineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotationBaselineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotationBaselineItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuotationBaselineItems.
     */
    distinct?: QuotationBaselineItemScalarFieldEnum | QuotationBaselineItemScalarFieldEnum[]
  }

  /**
   * QuotationBaselineItem findFirstOrThrow
   */
  export type QuotationBaselineItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationBaselineItem
     */
    select?: QuotationBaselineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationBaselineItem
     */
    omit?: QuotationBaselineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationBaselineItemInclude<ExtArgs> | null
    /**
     * Filter, which QuotationBaselineItem to fetch.
     */
    where?: QuotationBaselineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotationBaselineItems to fetch.
     */
    orderBy?: QuotationBaselineItemOrderByWithRelationInput | QuotationBaselineItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuotationBaselineItems.
     */
    cursor?: QuotationBaselineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotationBaselineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotationBaselineItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuotationBaselineItems.
     */
    distinct?: QuotationBaselineItemScalarFieldEnum | QuotationBaselineItemScalarFieldEnum[]
  }

  /**
   * QuotationBaselineItem findMany
   */
  export type QuotationBaselineItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationBaselineItem
     */
    select?: QuotationBaselineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationBaselineItem
     */
    omit?: QuotationBaselineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationBaselineItemInclude<ExtArgs> | null
    /**
     * Filter, which QuotationBaselineItems to fetch.
     */
    where?: QuotationBaselineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotationBaselineItems to fetch.
     */
    orderBy?: QuotationBaselineItemOrderByWithRelationInput | QuotationBaselineItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuotationBaselineItems.
     */
    cursor?: QuotationBaselineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotationBaselineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotationBaselineItems.
     */
    skip?: number
    distinct?: QuotationBaselineItemScalarFieldEnum | QuotationBaselineItemScalarFieldEnum[]
  }

  /**
   * QuotationBaselineItem create
   */
  export type QuotationBaselineItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationBaselineItem
     */
    select?: QuotationBaselineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationBaselineItem
     */
    omit?: QuotationBaselineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationBaselineItemInclude<ExtArgs> | null
    /**
     * The data needed to create a QuotationBaselineItem.
     */
    data: XOR<QuotationBaselineItemCreateInput, QuotationBaselineItemUncheckedCreateInput>
  }

  /**
   * QuotationBaselineItem createMany
   */
  export type QuotationBaselineItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuotationBaselineItems.
     */
    data: QuotationBaselineItemCreateManyInput | QuotationBaselineItemCreateManyInput[]
  }

  /**
   * QuotationBaselineItem createManyAndReturn
   */
  export type QuotationBaselineItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationBaselineItem
     */
    select?: QuotationBaselineItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationBaselineItem
     */
    omit?: QuotationBaselineItemOmit<ExtArgs> | null
    /**
     * The data used to create many QuotationBaselineItems.
     */
    data: QuotationBaselineItemCreateManyInput | QuotationBaselineItemCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationBaselineItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuotationBaselineItem update
   */
  export type QuotationBaselineItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationBaselineItem
     */
    select?: QuotationBaselineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationBaselineItem
     */
    omit?: QuotationBaselineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationBaselineItemInclude<ExtArgs> | null
    /**
     * The data needed to update a QuotationBaselineItem.
     */
    data: XOR<QuotationBaselineItemUpdateInput, QuotationBaselineItemUncheckedUpdateInput>
    /**
     * Choose, which QuotationBaselineItem to update.
     */
    where: QuotationBaselineItemWhereUniqueInput
  }

  /**
   * QuotationBaselineItem updateMany
   */
  export type QuotationBaselineItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuotationBaselineItems.
     */
    data: XOR<QuotationBaselineItemUpdateManyMutationInput, QuotationBaselineItemUncheckedUpdateManyInput>
    /**
     * Filter which QuotationBaselineItems to update
     */
    where?: QuotationBaselineItemWhereInput
    /**
     * Limit how many QuotationBaselineItems to update.
     */
    limit?: number
  }

  /**
   * QuotationBaselineItem updateManyAndReturn
   */
  export type QuotationBaselineItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationBaselineItem
     */
    select?: QuotationBaselineItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationBaselineItem
     */
    omit?: QuotationBaselineItemOmit<ExtArgs> | null
    /**
     * The data used to update QuotationBaselineItems.
     */
    data: XOR<QuotationBaselineItemUpdateManyMutationInput, QuotationBaselineItemUncheckedUpdateManyInput>
    /**
     * Filter which QuotationBaselineItems to update
     */
    where?: QuotationBaselineItemWhereInput
    /**
     * Limit how many QuotationBaselineItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationBaselineItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuotationBaselineItem upsert
   */
  export type QuotationBaselineItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationBaselineItem
     */
    select?: QuotationBaselineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationBaselineItem
     */
    omit?: QuotationBaselineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationBaselineItemInclude<ExtArgs> | null
    /**
     * The filter to search for the QuotationBaselineItem to update in case it exists.
     */
    where: QuotationBaselineItemWhereUniqueInput
    /**
     * In case the QuotationBaselineItem found by the `where` argument doesn't exist, create a new QuotationBaselineItem with this data.
     */
    create: XOR<QuotationBaselineItemCreateInput, QuotationBaselineItemUncheckedCreateInput>
    /**
     * In case the QuotationBaselineItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuotationBaselineItemUpdateInput, QuotationBaselineItemUncheckedUpdateInput>
  }

  /**
   * QuotationBaselineItem delete
   */
  export type QuotationBaselineItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationBaselineItem
     */
    select?: QuotationBaselineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationBaselineItem
     */
    omit?: QuotationBaselineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationBaselineItemInclude<ExtArgs> | null
    /**
     * Filter which QuotationBaselineItem to delete.
     */
    where: QuotationBaselineItemWhereUniqueInput
  }

  /**
   * QuotationBaselineItem deleteMany
   */
  export type QuotationBaselineItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuotationBaselineItems to delete
     */
    where?: QuotationBaselineItemWhereInput
    /**
     * Limit how many QuotationBaselineItems to delete.
     */
    limit?: number
  }

  /**
   * QuotationBaselineItem.material
   */
  export type QuotationBaselineItem$materialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    where?: MaterialWhereInput
  }

  /**
   * QuotationBaselineItem.quoteItems
   */
  export type QuotationBaselineItem$quoteItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationItem
     */
    select?: QuotationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationItem
     */
    omit?: QuotationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationItemInclude<ExtArgs> | null
    where?: QuotationItemWhereInput
    orderBy?: QuotationItemOrderByWithRelationInput | QuotationItemOrderByWithRelationInput[]
    cursor?: QuotationItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuotationItemScalarFieldEnum | QuotationItemScalarFieldEnum[]
  }

  /**
   * QuotationBaselineItem.orderLines
   */
  export type QuotationBaselineItem$orderLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    where?: PurchaseOrderLineWhereInput
    orderBy?: PurchaseOrderLineOrderByWithRelationInput | PurchaseOrderLineOrderByWithRelationInput[]
    cursor?: PurchaseOrderLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderLineScalarFieldEnum | PurchaseOrderLineScalarFieldEnum[]
  }

  /**
   * QuotationBaselineItem.deliveryItems
   */
  export type QuotationBaselineItem$deliveryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseDeliveryItem
     */
    select?: PurchaseDeliveryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseDeliveryItem
     */
    omit?: PurchaseDeliveryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseDeliveryItemInclude<ExtArgs> | null
    where?: PurchaseDeliveryItemWhereInput
    orderBy?: PurchaseDeliveryItemOrderByWithRelationInput | PurchaseDeliveryItemOrderByWithRelationInput[]
    cursor?: PurchaseDeliveryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseDeliveryItemScalarFieldEnum | PurchaseDeliveryItemScalarFieldEnum[]
  }

  /**
   * QuotationBaselineItem without action
   */
  export type QuotationBaselineItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationBaselineItem
     */
    select?: QuotationBaselineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationBaselineItem
     */
    omit?: QuotationBaselineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationBaselineItemInclude<ExtArgs> | null
  }


  /**
   * Model Quotation
   */

  export type AggregateQuotation = {
    _count: QuotationCountAggregateOutputType | null
    _avg: QuotationAvgAggregateOutputType | null
    _sum: QuotationSumAggregateOutputType | null
    _min: QuotationMinAggregateOutputType | null
    _max: QuotationMaxAggregateOutputType | null
  }

  export type QuotationAvgAggregateOutputType = {
    id: number | null
    processId: number | null
    proveedorId: number | null
    exchangeRate: Decimal | null
    totalAmount: Decimal | null
    totalAmountPen: Decimal | null
    qualityScore: number | null
  }

  export type QuotationSumAggregateOutputType = {
    id: number | null
    processId: number | null
    proveedorId: number | null
    exchangeRate: Decimal | null
    totalAmount: Decimal | null
    totalAmountPen: Decimal | null
    qualityScore: number | null
  }

  export type QuotationMinAggregateOutputType = {
    id: number | null
    processId: number | null
    proveedorId: number | null
    supplierName: string | null
    currency: string | null
    exchangeRate: Decimal | null
    submittedAt: Date | null
    status: $Enums.QuotationStatus | null
    totalAmount: Decimal | null
    totalAmountPen: Decimal | null
    qualityScore: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuotationMaxAggregateOutputType = {
    id: number | null
    processId: number | null
    proveedorId: number | null
    supplierName: string | null
    currency: string | null
    exchangeRate: Decimal | null
    submittedAt: Date | null
    status: $Enums.QuotationStatus | null
    totalAmount: Decimal | null
    totalAmountPen: Decimal | null
    qualityScore: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuotationCountAggregateOutputType = {
    id: number
    processId: number
    proveedorId: number
    supplierName: number
    currency: number
    exchangeRate: number
    submittedAt: number
    status: number
    totalAmount: number
    totalAmountPen: number
    qualityScore: number
    notes: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuotationAvgAggregateInputType = {
    id?: true
    processId?: true
    proveedorId?: true
    exchangeRate?: true
    totalAmount?: true
    totalAmountPen?: true
    qualityScore?: true
  }

  export type QuotationSumAggregateInputType = {
    id?: true
    processId?: true
    proveedorId?: true
    exchangeRate?: true
    totalAmount?: true
    totalAmountPen?: true
    qualityScore?: true
  }

  export type QuotationMinAggregateInputType = {
    id?: true
    processId?: true
    proveedorId?: true
    supplierName?: true
    currency?: true
    exchangeRate?: true
    submittedAt?: true
    status?: true
    totalAmount?: true
    totalAmountPen?: true
    qualityScore?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuotationMaxAggregateInputType = {
    id?: true
    processId?: true
    proveedorId?: true
    supplierName?: true
    currency?: true
    exchangeRate?: true
    submittedAt?: true
    status?: true
    totalAmount?: true
    totalAmountPen?: true
    qualityScore?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuotationCountAggregateInputType = {
    id?: true
    processId?: true
    proveedorId?: true
    supplierName?: true
    currency?: true
    exchangeRate?: true
    submittedAt?: true
    status?: true
    totalAmount?: true
    totalAmountPen?: true
    qualityScore?: true
    notes?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuotationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quotation to aggregate.
     */
    where?: QuotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotations to fetch.
     */
    orderBy?: QuotationOrderByWithRelationInput | QuotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quotations
    **/
    _count?: true | QuotationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuotationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuotationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuotationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuotationMaxAggregateInputType
  }

  export type GetQuotationAggregateType<T extends QuotationAggregateArgs> = {
        [P in keyof T & keyof AggregateQuotation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuotation[P]>
      : GetScalarType<T[P], AggregateQuotation[P]>
  }




  export type QuotationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotationWhereInput
    orderBy?: QuotationOrderByWithAggregationInput | QuotationOrderByWithAggregationInput[]
    by: QuotationScalarFieldEnum[] | QuotationScalarFieldEnum
    having?: QuotationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuotationCountAggregateInputType | true
    _avg?: QuotationAvgAggregateInputType
    _sum?: QuotationSumAggregateInputType
    _min?: QuotationMinAggregateInputType
    _max?: QuotationMaxAggregateInputType
  }

  export type QuotationGroupByOutputType = {
    id: number
    processId: number
    proveedorId: number | null
    supplierName: string | null
    currency: string
    exchangeRate: Decimal | null
    submittedAt: Date | null
    status: $Enums.QuotationStatus
    totalAmount: Decimal | null
    totalAmountPen: Decimal | null
    qualityScore: number | null
    notes: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: QuotationCountAggregateOutputType | null
    _avg: QuotationAvgAggregateOutputType | null
    _sum: QuotationSumAggregateOutputType | null
    _min: QuotationMinAggregateOutputType | null
    _max: QuotationMaxAggregateOutputType | null
  }

  type GetQuotationGroupByPayload<T extends QuotationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuotationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuotationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuotationGroupByOutputType[P]>
            : GetScalarType<T[P], QuotationGroupByOutputType[P]>
        }
      >
    >


  export type QuotationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    processId?: boolean
    proveedorId?: boolean
    supplierName?: boolean
    currency?: boolean
    exchangeRate?: boolean
    submittedAt?: boolean
    status?: boolean
    totalAmount?: boolean
    totalAmountPen?: boolean
    qualityScore?: boolean
    notes?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    process?: boolean | QuotationProcessDefaultArgs<ExtArgs>
    proveedor?: boolean | Quotation$proveedorArgs<ExtArgs>
    items?: boolean | Quotation$itemsArgs<ExtArgs>
    attachments?: boolean | Quotation$attachmentsArgs<ExtArgs>
    purchaseOrders?: boolean | Quotation$purchaseOrdersArgs<ExtArgs>
    _count?: boolean | QuotationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quotation"]>

  export type QuotationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    processId?: boolean
    proveedorId?: boolean
    supplierName?: boolean
    currency?: boolean
    exchangeRate?: boolean
    submittedAt?: boolean
    status?: boolean
    totalAmount?: boolean
    totalAmountPen?: boolean
    qualityScore?: boolean
    notes?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    process?: boolean | QuotationProcessDefaultArgs<ExtArgs>
    proveedor?: boolean | Quotation$proveedorArgs<ExtArgs>
  }, ExtArgs["result"]["quotation"]>

  export type QuotationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    processId?: boolean
    proveedorId?: boolean
    supplierName?: boolean
    currency?: boolean
    exchangeRate?: boolean
    submittedAt?: boolean
    status?: boolean
    totalAmount?: boolean
    totalAmountPen?: boolean
    qualityScore?: boolean
    notes?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    process?: boolean | QuotationProcessDefaultArgs<ExtArgs>
    proveedor?: boolean | Quotation$proveedorArgs<ExtArgs>
  }, ExtArgs["result"]["quotation"]>

  export type QuotationSelectScalar = {
    id?: boolean
    processId?: boolean
    proveedorId?: boolean
    supplierName?: boolean
    currency?: boolean
    exchangeRate?: boolean
    submittedAt?: boolean
    status?: boolean
    totalAmount?: boolean
    totalAmountPen?: boolean
    qualityScore?: boolean
    notes?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuotationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "processId" | "proveedorId" | "supplierName" | "currency" | "exchangeRate" | "submittedAt" | "status" | "totalAmount" | "totalAmountPen" | "qualityScore" | "notes" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["quotation"]>
  export type QuotationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    process?: boolean | QuotationProcessDefaultArgs<ExtArgs>
    proveedor?: boolean | Quotation$proveedorArgs<ExtArgs>
    items?: boolean | Quotation$itemsArgs<ExtArgs>
    attachments?: boolean | Quotation$attachmentsArgs<ExtArgs>
    purchaseOrders?: boolean | Quotation$purchaseOrdersArgs<ExtArgs>
    _count?: boolean | QuotationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuotationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    process?: boolean | QuotationProcessDefaultArgs<ExtArgs>
    proveedor?: boolean | Quotation$proveedorArgs<ExtArgs>
  }
  export type QuotationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    process?: boolean | QuotationProcessDefaultArgs<ExtArgs>
    proveedor?: boolean | Quotation$proveedorArgs<ExtArgs>
  }

  export type $QuotationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Quotation"
    objects: {
      process: Prisma.$QuotationProcessPayload<ExtArgs>
      proveedor: Prisma.$ProveedorPayload<ExtArgs> | null
      items: Prisma.$QuotationItemPayload<ExtArgs>[]
      attachments: Prisma.$QuotationAttachmentPayload<ExtArgs>[]
      purchaseOrders: Prisma.$PurchaseOrderLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      processId: number
      proveedorId: number | null
      supplierName: string | null
      currency: string
      exchangeRate: Prisma.Decimal | null
      submittedAt: Date | null
      status: $Enums.QuotationStatus
      totalAmount: Prisma.Decimal | null
      totalAmountPen: Prisma.Decimal | null
      qualityScore: number | null
      notes: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["quotation"]>
    composites: {}
  }

  type QuotationGetPayload<S extends boolean | null | undefined | QuotationDefaultArgs> = $Result.GetResult<Prisma.$QuotationPayload, S>

  type QuotationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuotationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuotationCountAggregateInputType | true
    }

  export interface QuotationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Quotation'], meta: { name: 'Quotation' } }
    /**
     * Find zero or one Quotation that matches the filter.
     * @param {QuotationFindUniqueArgs} args - Arguments to find a Quotation
     * @example
     * // Get one Quotation
     * const quotation = await prisma.quotation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuotationFindUniqueArgs>(args: SelectSubset<T, QuotationFindUniqueArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Quotation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuotationFindUniqueOrThrowArgs} args - Arguments to find a Quotation
     * @example
     * // Get one Quotation
     * const quotation = await prisma.quotation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuotationFindUniqueOrThrowArgs>(args: SelectSubset<T, QuotationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quotation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationFindFirstArgs} args - Arguments to find a Quotation
     * @example
     * // Get one Quotation
     * const quotation = await prisma.quotation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuotationFindFirstArgs>(args?: SelectSubset<T, QuotationFindFirstArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quotation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationFindFirstOrThrowArgs} args - Arguments to find a Quotation
     * @example
     * // Get one Quotation
     * const quotation = await prisma.quotation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuotationFindFirstOrThrowArgs>(args?: SelectSubset<T, QuotationFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Quotations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quotations
     * const quotations = await prisma.quotation.findMany()
     * 
     * // Get first 10 Quotations
     * const quotations = await prisma.quotation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quotationWithIdOnly = await prisma.quotation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuotationFindManyArgs>(args?: SelectSubset<T, QuotationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Quotation.
     * @param {QuotationCreateArgs} args - Arguments to create a Quotation.
     * @example
     * // Create one Quotation
     * const Quotation = await prisma.quotation.create({
     *   data: {
     *     // ... data to create a Quotation
     *   }
     * })
     * 
     */
    create<T extends QuotationCreateArgs>(args: SelectSubset<T, QuotationCreateArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Quotations.
     * @param {QuotationCreateManyArgs} args - Arguments to create many Quotations.
     * @example
     * // Create many Quotations
     * const quotation = await prisma.quotation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuotationCreateManyArgs>(args?: SelectSubset<T, QuotationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Quotations and returns the data saved in the database.
     * @param {QuotationCreateManyAndReturnArgs} args - Arguments to create many Quotations.
     * @example
     * // Create many Quotations
     * const quotation = await prisma.quotation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Quotations and only return the `id`
     * const quotationWithIdOnly = await prisma.quotation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuotationCreateManyAndReturnArgs>(args?: SelectSubset<T, QuotationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Quotation.
     * @param {QuotationDeleteArgs} args - Arguments to delete one Quotation.
     * @example
     * // Delete one Quotation
     * const Quotation = await prisma.quotation.delete({
     *   where: {
     *     // ... filter to delete one Quotation
     *   }
     * })
     * 
     */
    delete<T extends QuotationDeleteArgs>(args: SelectSubset<T, QuotationDeleteArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Quotation.
     * @param {QuotationUpdateArgs} args - Arguments to update one Quotation.
     * @example
     * // Update one Quotation
     * const quotation = await prisma.quotation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuotationUpdateArgs>(args: SelectSubset<T, QuotationUpdateArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Quotations.
     * @param {QuotationDeleteManyArgs} args - Arguments to filter Quotations to delete.
     * @example
     * // Delete a few Quotations
     * const { count } = await prisma.quotation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuotationDeleteManyArgs>(args?: SelectSubset<T, QuotationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quotations
     * const quotation = await prisma.quotation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuotationUpdateManyArgs>(args: SelectSubset<T, QuotationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quotations and returns the data updated in the database.
     * @param {QuotationUpdateManyAndReturnArgs} args - Arguments to update many Quotations.
     * @example
     * // Update many Quotations
     * const quotation = await prisma.quotation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Quotations and only return the `id`
     * const quotationWithIdOnly = await prisma.quotation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuotationUpdateManyAndReturnArgs>(args: SelectSubset<T, QuotationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Quotation.
     * @param {QuotationUpsertArgs} args - Arguments to update or create a Quotation.
     * @example
     * // Update or create a Quotation
     * const quotation = await prisma.quotation.upsert({
     *   create: {
     *     // ... data to create a Quotation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quotation we want to update
     *   }
     * })
     */
    upsert<T extends QuotationUpsertArgs>(args: SelectSubset<T, QuotationUpsertArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Quotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationCountArgs} args - Arguments to filter Quotations to count.
     * @example
     * // Count the number of Quotations
     * const count = await prisma.quotation.count({
     *   where: {
     *     // ... the filter for the Quotations we want to count
     *   }
     * })
    **/
    count<T extends QuotationCountArgs>(
      args?: Subset<T, QuotationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuotationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuotationAggregateArgs>(args: Subset<T, QuotationAggregateArgs>): Prisma.PrismaPromise<GetQuotationAggregateType<T>>

    /**
     * Group by Quotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuotationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuotationGroupByArgs['orderBy'] }
        : { orderBy?: QuotationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuotationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuotationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Quotation model
   */
  readonly fields: QuotationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Quotation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuotationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    process<T extends QuotationProcessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuotationProcessDefaultArgs<ExtArgs>>): Prisma__QuotationProcessClient<$Result.GetResult<Prisma.$QuotationProcessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    proveedor<T extends Quotation$proveedorArgs<ExtArgs> = {}>(args?: Subset<T, Quotation$proveedorArgs<ExtArgs>>): Prisma__ProveedorClient<$Result.GetResult<Prisma.$ProveedorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends Quotation$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Quotation$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attachments<T extends Quotation$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Quotation$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseOrders<T extends Quotation$purchaseOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Quotation$purchaseOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Quotation model
   */
  interface QuotationFieldRefs {
    readonly id: FieldRef<"Quotation", 'Int'>
    readonly processId: FieldRef<"Quotation", 'Int'>
    readonly proveedorId: FieldRef<"Quotation", 'Int'>
    readonly supplierName: FieldRef<"Quotation", 'String'>
    readonly currency: FieldRef<"Quotation", 'String'>
    readonly exchangeRate: FieldRef<"Quotation", 'Decimal'>
    readonly submittedAt: FieldRef<"Quotation", 'DateTime'>
    readonly status: FieldRef<"Quotation", 'QuotationStatus'>
    readonly totalAmount: FieldRef<"Quotation", 'Decimal'>
    readonly totalAmountPen: FieldRef<"Quotation", 'Decimal'>
    readonly qualityScore: FieldRef<"Quotation", 'Int'>
    readonly notes: FieldRef<"Quotation", 'String'>
    readonly metadata: FieldRef<"Quotation", 'Json'>
    readonly createdAt: FieldRef<"Quotation", 'DateTime'>
    readonly updatedAt: FieldRef<"Quotation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Quotation findUnique
   */
  export type QuotationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * Filter, which Quotation to fetch.
     */
    where: QuotationWhereUniqueInput
  }

  /**
   * Quotation findUniqueOrThrow
   */
  export type QuotationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * Filter, which Quotation to fetch.
     */
    where: QuotationWhereUniqueInput
  }

  /**
   * Quotation findFirst
   */
  export type QuotationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * Filter, which Quotation to fetch.
     */
    where?: QuotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotations to fetch.
     */
    orderBy?: QuotationOrderByWithRelationInput | QuotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quotations.
     */
    cursor?: QuotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quotations.
     */
    distinct?: QuotationScalarFieldEnum | QuotationScalarFieldEnum[]
  }

  /**
   * Quotation findFirstOrThrow
   */
  export type QuotationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * Filter, which Quotation to fetch.
     */
    where?: QuotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotations to fetch.
     */
    orderBy?: QuotationOrderByWithRelationInput | QuotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quotations.
     */
    cursor?: QuotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quotations.
     */
    distinct?: QuotationScalarFieldEnum | QuotationScalarFieldEnum[]
  }

  /**
   * Quotation findMany
   */
  export type QuotationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * Filter, which Quotations to fetch.
     */
    where?: QuotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotations to fetch.
     */
    orderBy?: QuotationOrderByWithRelationInput | QuotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quotations.
     */
    cursor?: QuotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotations.
     */
    skip?: number
    distinct?: QuotationScalarFieldEnum | QuotationScalarFieldEnum[]
  }

  /**
   * Quotation create
   */
  export type QuotationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * The data needed to create a Quotation.
     */
    data: XOR<QuotationCreateInput, QuotationUncheckedCreateInput>
  }

  /**
   * Quotation createMany
   */
  export type QuotationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Quotations.
     */
    data: QuotationCreateManyInput | QuotationCreateManyInput[]
  }

  /**
   * Quotation createManyAndReturn
   */
  export type QuotationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * The data used to create many Quotations.
     */
    data: QuotationCreateManyInput | QuotationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quotation update
   */
  export type QuotationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * The data needed to update a Quotation.
     */
    data: XOR<QuotationUpdateInput, QuotationUncheckedUpdateInput>
    /**
     * Choose, which Quotation to update.
     */
    where: QuotationWhereUniqueInput
  }

  /**
   * Quotation updateMany
   */
  export type QuotationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Quotations.
     */
    data: XOR<QuotationUpdateManyMutationInput, QuotationUncheckedUpdateManyInput>
    /**
     * Filter which Quotations to update
     */
    where?: QuotationWhereInput
    /**
     * Limit how many Quotations to update.
     */
    limit?: number
  }

  /**
   * Quotation updateManyAndReturn
   */
  export type QuotationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * The data used to update Quotations.
     */
    data: XOR<QuotationUpdateManyMutationInput, QuotationUncheckedUpdateManyInput>
    /**
     * Filter which Quotations to update
     */
    where?: QuotationWhereInput
    /**
     * Limit how many Quotations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quotation upsert
   */
  export type QuotationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * The filter to search for the Quotation to update in case it exists.
     */
    where: QuotationWhereUniqueInput
    /**
     * In case the Quotation found by the `where` argument doesn't exist, create a new Quotation with this data.
     */
    create: XOR<QuotationCreateInput, QuotationUncheckedCreateInput>
    /**
     * In case the Quotation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuotationUpdateInput, QuotationUncheckedUpdateInput>
  }

  /**
   * Quotation delete
   */
  export type QuotationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * Filter which Quotation to delete.
     */
    where: QuotationWhereUniqueInput
  }

  /**
   * Quotation deleteMany
   */
  export type QuotationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quotations to delete
     */
    where?: QuotationWhereInput
    /**
     * Limit how many Quotations to delete.
     */
    limit?: number
  }

  /**
   * Quotation.proveedor
   */
  export type Quotation$proveedorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proveedor
     */
    select?: ProveedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proveedor
     */
    omit?: ProveedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProveedorInclude<ExtArgs> | null
    where?: ProveedorWhereInput
  }

  /**
   * Quotation.items
   */
  export type Quotation$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationItem
     */
    select?: QuotationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationItem
     */
    omit?: QuotationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationItemInclude<ExtArgs> | null
    where?: QuotationItemWhereInput
    orderBy?: QuotationItemOrderByWithRelationInput | QuotationItemOrderByWithRelationInput[]
    cursor?: QuotationItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuotationItemScalarFieldEnum | QuotationItemScalarFieldEnum[]
  }

  /**
   * Quotation.attachments
   */
  export type Quotation$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationAttachment
     */
    select?: QuotationAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationAttachment
     */
    omit?: QuotationAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationAttachmentInclude<ExtArgs> | null
    where?: QuotationAttachmentWhereInput
    orderBy?: QuotationAttachmentOrderByWithRelationInput | QuotationAttachmentOrderByWithRelationInput[]
    cursor?: QuotationAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuotationAttachmentScalarFieldEnum | QuotationAttachmentScalarFieldEnum[]
  }

  /**
   * Quotation.purchaseOrders
   */
  export type Quotation$purchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLog
     */
    select?: PurchaseOrderLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLog
     */
    omit?: PurchaseOrderLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLogInclude<ExtArgs> | null
    where?: PurchaseOrderLogWhereInput
    orderBy?: PurchaseOrderLogOrderByWithRelationInput | PurchaseOrderLogOrderByWithRelationInput[]
    cursor?: PurchaseOrderLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderLogScalarFieldEnum | PurchaseOrderLogScalarFieldEnum[]
  }

  /**
   * Quotation without action
   */
  export type QuotationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
  }


  /**
   * Model QuotationItem
   */

  export type AggregateQuotationItem = {
    _count: QuotationItemCountAggregateOutputType | null
    _avg: QuotationItemAvgAggregateOutputType | null
    _sum: QuotationItemSumAggregateOutputType | null
    _min: QuotationItemMinAggregateOutputType | null
    _max: QuotationItemMaxAggregateOutputType | null
  }

  export type QuotationItemAvgAggregateOutputType = {
    id: number | null
    quotationId: number | null
    baselineItemId: number | null
    materialId: number | null
    sourceRow: number | null
    quantity: Decimal | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    normalizedPrice: Decimal | null
    matchScore: number | null
  }

  export type QuotationItemSumAggregateOutputType = {
    id: number | null
    quotationId: number | null
    baselineItemId: number | null
    materialId: number | null
    sourceRow: number | null
    quantity: Decimal | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    normalizedPrice: Decimal | null
    matchScore: number | null
  }

  export type QuotationItemMinAggregateOutputType = {
    id: number | null
    quotationId: number | null
    baselineItemId: number | null
    materialId: number | null
    sourceRow: number | null
    itemCode: string | null
    description: string | null
    unit: string | null
    quantity: Decimal | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    currency: string | null
    normalizedPrice: Decimal | null
    matchScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuotationItemMaxAggregateOutputType = {
    id: number | null
    quotationId: number | null
    baselineItemId: number | null
    materialId: number | null
    sourceRow: number | null
    itemCode: string | null
    description: string | null
    unit: string | null
    quantity: Decimal | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    currency: string | null
    normalizedPrice: Decimal | null
    matchScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuotationItemCountAggregateOutputType = {
    id: number
    quotationId: number
    baselineItemId: number
    materialId: number
    sourceRow: number
    itemCode: number
    description: number
    unit: number
    quantity: number
    unitPrice: number
    totalPrice: number
    currency: number
    normalizedPrice: number
    matchScore: number
    extraAttributes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuotationItemAvgAggregateInputType = {
    id?: true
    quotationId?: true
    baselineItemId?: true
    materialId?: true
    sourceRow?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    normalizedPrice?: true
    matchScore?: true
  }

  export type QuotationItemSumAggregateInputType = {
    id?: true
    quotationId?: true
    baselineItemId?: true
    materialId?: true
    sourceRow?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    normalizedPrice?: true
    matchScore?: true
  }

  export type QuotationItemMinAggregateInputType = {
    id?: true
    quotationId?: true
    baselineItemId?: true
    materialId?: true
    sourceRow?: true
    itemCode?: true
    description?: true
    unit?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    currency?: true
    normalizedPrice?: true
    matchScore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuotationItemMaxAggregateInputType = {
    id?: true
    quotationId?: true
    baselineItemId?: true
    materialId?: true
    sourceRow?: true
    itemCode?: true
    description?: true
    unit?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    currency?: true
    normalizedPrice?: true
    matchScore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuotationItemCountAggregateInputType = {
    id?: true
    quotationId?: true
    baselineItemId?: true
    materialId?: true
    sourceRow?: true
    itemCode?: true
    description?: true
    unit?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    currency?: true
    normalizedPrice?: true
    matchScore?: true
    extraAttributes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuotationItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuotationItem to aggregate.
     */
    where?: QuotationItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotationItems to fetch.
     */
    orderBy?: QuotationItemOrderByWithRelationInput | QuotationItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuotationItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotationItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotationItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuotationItems
    **/
    _count?: true | QuotationItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuotationItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuotationItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuotationItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuotationItemMaxAggregateInputType
  }

  export type GetQuotationItemAggregateType<T extends QuotationItemAggregateArgs> = {
        [P in keyof T & keyof AggregateQuotationItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuotationItem[P]>
      : GetScalarType<T[P], AggregateQuotationItem[P]>
  }




  export type QuotationItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotationItemWhereInput
    orderBy?: QuotationItemOrderByWithAggregationInput | QuotationItemOrderByWithAggregationInput[]
    by: QuotationItemScalarFieldEnum[] | QuotationItemScalarFieldEnum
    having?: QuotationItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuotationItemCountAggregateInputType | true
    _avg?: QuotationItemAvgAggregateInputType
    _sum?: QuotationItemSumAggregateInputType
    _min?: QuotationItemMinAggregateInputType
    _max?: QuotationItemMaxAggregateInputType
  }

  export type QuotationItemGroupByOutputType = {
    id: number
    quotationId: number
    baselineItemId: number | null
    materialId: number | null
    sourceRow: number | null
    itemCode: string | null
    description: string
    unit: string | null
    quantity: Decimal | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    currency: string | null
    normalizedPrice: Decimal | null
    matchScore: number | null
    extraAttributes: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: QuotationItemCountAggregateOutputType | null
    _avg: QuotationItemAvgAggregateOutputType | null
    _sum: QuotationItemSumAggregateOutputType | null
    _min: QuotationItemMinAggregateOutputType | null
    _max: QuotationItemMaxAggregateOutputType | null
  }

  type GetQuotationItemGroupByPayload<T extends QuotationItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuotationItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuotationItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuotationItemGroupByOutputType[P]>
            : GetScalarType<T[P], QuotationItemGroupByOutputType[P]>
        }
      >
    >


  export type QuotationItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quotationId?: boolean
    baselineItemId?: boolean
    materialId?: boolean
    sourceRow?: boolean
    itemCode?: boolean
    description?: boolean
    unit?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    currency?: boolean
    normalizedPrice?: boolean
    matchScore?: boolean
    extraAttributes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quotation?: boolean | QuotationDefaultArgs<ExtArgs>
    baselineItem?: boolean | QuotationItem$baselineItemArgs<ExtArgs>
    material?: boolean | QuotationItem$materialArgs<ExtArgs>
  }, ExtArgs["result"]["quotationItem"]>

  export type QuotationItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quotationId?: boolean
    baselineItemId?: boolean
    materialId?: boolean
    sourceRow?: boolean
    itemCode?: boolean
    description?: boolean
    unit?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    currency?: boolean
    normalizedPrice?: boolean
    matchScore?: boolean
    extraAttributes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quotation?: boolean | QuotationDefaultArgs<ExtArgs>
    baselineItem?: boolean | QuotationItem$baselineItemArgs<ExtArgs>
    material?: boolean | QuotationItem$materialArgs<ExtArgs>
  }, ExtArgs["result"]["quotationItem"]>

  export type QuotationItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quotationId?: boolean
    baselineItemId?: boolean
    materialId?: boolean
    sourceRow?: boolean
    itemCode?: boolean
    description?: boolean
    unit?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    currency?: boolean
    normalizedPrice?: boolean
    matchScore?: boolean
    extraAttributes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quotation?: boolean | QuotationDefaultArgs<ExtArgs>
    baselineItem?: boolean | QuotationItem$baselineItemArgs<ExtArgs>
    material?: boolean | QuotationItem$materialArgs<ExtArgs>
  }, ExtArgs["result"]["quotationItem"]>

  export type QuotationItemSelectScalar = {
    id?: boolean
    quotationId?: boolean
    baselineItemId?: boolean
    materialId?: boolean
    sourceRow?: boolean
    itemCode?: boolean
    description?: boolean
    unit?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    currency?: boolean
    normalizedPrice?: boolean
    matchScore?: boolean
    extraAttributes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuotationItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quotationId" | "baselineItemId" | "materialId" | "sourceRow" | "itemCode" | "description" | "unit" | "quantity" | "unitPrice" | "totalPrice" | "currency" | "normalizedPrice" | "matchScore" | "extraAttributes" | "createdAt" | "updatedAt", ExtArgs["result"]["quotationItem"]>
  export type QuotationItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quotation?: boolean | QuotationDefaultArgs<ExtArgs>
    baselineItem?: boolean | QuotationItem$baselineItemArgs<ExtArgs>
    material?: boolean | QuotationItem$materialArgs<ExtArgs>
  }
  export type QuotationItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quotation?: boolean | QuotationDefaultArgs<ExtArgs>
    baselineItem?: boolean | QuotationItem$baselineItemArgs<ExtArgs>
    material?: boolean | QuotationItem$materialArgs<ExtArgs>
  }
  export type QuotationItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quotation?: boolean | QuotationDefaultArgs<ExtArgs>
    baselineItem?: boolean | QuotationItem$baselineItemArgs<ExtArgs>
    material?: boolean | QuotationItem$materialArgs<ExtArgs>
  }

  export type $QuotationItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuotationItem"
    objects: {
      quotation: Prisma.$QuotationPayload<ExtArgs>
      baselineItem: Prisma.$QuotationBaselineItemPayload<ExtArgs> | null
      material: Prisma.$MaterialPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      quotationId: number
      baselineItemId: number | null
      materialId: number | null
      sourceRow: number | null
      itemCode: string | null
      description: string
      unit: string | null
      quantity: Prisma.Decimal | null
      unitPrice: Prisma.Decimal | null
      totalPrice: Prisma.Decimal | null
      currency: string | null
      normalizedPrice: Prisma.Decimal | null
      matchScore: number | null
      extraAttributes: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["quotationItem"]>
    composites: {}
  }

  type QuotationItemGetPayload<S extends boolean | null | undefined | QuotationItemDefaultArgs> = $Result.GetResult<Prisma.$QuotationItemPayload, S>

  type QuotationItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuotationItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuotationItemCountAggregateInputType | true
    }

  export interface QuotationItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuotationItem'], meta: { name: 'QuotationItem' } }
    /**
     * Find zero or one QuotationItem that matches the filter.
     * @param {QuotationItemFindUniqueArgs} args - Arguments to find a QuotationItem
     * @example
     * // Get one QuotationItem
     * const quotationItem = await prisma.quotationItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuotationItemFindUniqueArgs>(args: SelectSubset<T, QuotationItemFindUniqueArgs<ExtArgs>>): Prisma__QuotationItemClient<$Result.GetResult<Prisma.$QuotationItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuotationItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuotationItemFindUniqueOrThrowArgs} args - Arguments to find a QuotationItem
     * @example
     * // Get one QuotationItem
     * const quotationItem = await prisma.quotationItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuotationItemFindUniqueOrThrowArgs>(args: SelectSubset<T, QuotationItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuotationItemClient<$Result.GetResult<Prisma.$QuotationItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuotationItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationItemFindFirstArgs} args - Arguments to find a QuotationItem
     * @example
     * // Get one QuotationItem
     * const quotationItem = await prisma.quotationItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuotationItemFindFirstArgs>(args?: SelectSubset<T, QuotationItemFindFirstArgs<ExtArgs>>): Prisma__QuotationItemClient<$Result.GetResult<Prisma.$QuotationItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuotationItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationItemFindFirstOrThrowArgs} args - Arguments to find a QuotationItem
     * @example
     * // Get one QuotationItem
     * const quotationItem = await prisma.quotationItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuotationItemFindFirstOrThrowArgs>(args?: SelectSubset<T, QuotationItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuotationItemClient<$Result.GetResult<Prisma.$QuotationItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuotationItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuotationItems
     * const quotationItems = await prisma.quotationItem.findMany()
     * 
     * // Get first 10 QuotationItems
     * const quotationItems = await prisma.quotationItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quotationItemWithIdOnly = await prisma.quotationItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuotationItemFindManyArgs>(args?: SelectSubset<T, QuotationItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuotationItem.
     * @param {QuotationItemCreateArgs} args - Arguments to create a QuotationItem.
     * @example
     * // Create one QuotationItem
     * const QuotationItem = await prisma.quotationItem.create({
     *   data: {
     *     // ... data to create a QuotationItem
     *   }
     * })
     * 
     */
    create<T extends QuotationItemCreateArgs>(args: SelectSubset<T, QuotationItemCreateArgs<ExtArgs>>): Prisma__QuotationItemClient<$Result.GetResult<Prisma.$QuotationItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuotationItems.
     * @param {QuotationItemCreateManyArgs} args - Arguments to create many QuotationItems.
     * @example
     * // Create many QuotationItems
     * const quotationItem = await prisma.quotationItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuotationItemCreateManyArgs>(args?: SelectSubset<T, QuotationItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuotationItems and returns the data saved in the database.
     * @param {QuotationItemCreateManyAndReturnArgs} args - Arguments to create many QuotationItems.
     * @example
     * // Create many QuotationItems
     * const quotationItem = await prisma.quotationItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuotationItems and only return the `id`
     * const quotationItemWithIdOnly = await prisma.quotationItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuotationItemCreateManyAndReturnArgs>(args?: SelectSubset<T, QuotationItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuotationItem.
     * @param {QuotationItemDeleteArgs} args - Arguments to delete one QuotationItem.
     * @example
     * // Delete one QuotationItem
     * const QuotationItem = await prisma.quotationItem.delete({
     *   where: {
     *     // ... filter to delete one QuotationItem
     *   }
     * })
     * 
     */
    delete<T extends QuotationItemDeleteArgs>(args: SelectSubset<T, QuotationItemDeleteArgs<ExtArgs>>): Prisma__QuotationItemClient<$Result.GetResult<Prisma.$QuotationItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuotationItem.
     * @param {QuotationItemUpdateArgs} args - Arguments to update one QuotationItem.
     * @example
     * // Update one QuotationItem
     * const quotationItem = await prisma.quotationItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuotationItemUpdateArgs>(args: SelectSubset<T, QuotationItemUpdateArgs<ExtArgs>>): Prisma__QuotationItemClient<$Result.GetResult<Prisma.$QuotationItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuotationItems.
     * @param {QuotationItemDeleteManyArgs} args - Arguments to filter QuotationItems to delete.
     * @example
     * // Delete a few QuotationItems
     * const { count } = await prisma.quotationItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuotationItemDeleteManyArgs>(args?: SelectSubset<T, QuotationItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuotationItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuotationItems
     * const quotationItem = await prisma.quotationItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuotationItemUpdateManyArgs>(args: SelectSubset<T, QuotationItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuotationItems and returns the data updated in the database.
     * @param {QuotationItemUpdateManyAndReturnArgs} args - Arguments to update many QuotationItems.
     * @example
     * // Update many QuotationItems
     * const quotationItem = await prisma.quotationItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuotationItems and only return the `id`
     * const quotationItemWithIdOnly = await prisma.quotationItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuotationItemUpdateManyAndReturnArgs>(args: SelectSubset<T, QuotationItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuotationItem.
     * @param {QuotationItemUpsertArgs} args - Arguments to update or create a QuotationItem.
     * @example
     * // Update or create a QuotationItem
     * const quotationItem = await prisma.quotationItem.upsert({
     *   create: {
     *     // ... data to create a QuotationItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuotationItem we want to update
     *   }
     * })
     */
    upsert<T extends QuotationItemUpsertArgs>(args: SelectSubset<T, QuotationItemUpsertArgs<ExtArgs>>): Prisma__QuotationItemClient<$Result.GetResult<Prisma.$QuotationItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuotationItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationItemCountArgs} args - Arguments to filter QuotationItems to count.
     * @example
     * // Count the number of QuotationItems
     * const count = await prisma.quotationItem.count({
     *   where: {
     *     // ... the filter for the QuotationItems we want to count
     *   }
     * })
    **/
    count<T extends QuotationItemCountArgs>(
      args?: Subset<T, QuotationItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuotationItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuotationItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuotationItemAggregateArgs>(args: Subset<T, QuotationItemAggregateArgs>): Prisma.PrismaPromise<GetQuotationItemAggregateType<T>>

    /**
     * Group by QuotationItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuotationItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuotationItemGroupByArgs['orderBy'] }
        : { orderBy?: QuotationItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuotationItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuotationItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuotationItem model
   */
  readonly fields: QuotationItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuotationItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuotationItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quotation<T extends QuotationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuotationDefaultArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    baselineItem<T extends QuotationItem$baselineItemArgs<ExtArgs> = {}>(args?: Subset<T, QuotationItem$baselineItemArgs<ExtArgs>>): Prisma__QuotationBaselineItemClient<$Result.GetResult<Prisma.$QuotationBaselineItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    material<T extends QuotationItem$materialArgs<ExtArgs> = {}>(args?: Subset<T, QuotationItem$materialArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuotationItem model
   */
  interface QuotationItemFieldRefs {
    readonly id: FieldRef<"QuotationItem", 'Int'>
    readonly quotationId: FieldRef<"QuotationItem", 'Int'>
    readonly baselineItemId: FieldRef<"QuotationItem", 'Int'>
    readonly materialId: FieldRef<"QuotationItem", 'Int'>
    readonly sourceRow: FieldRef<"QuotationItem", 'Int'>
    readonly itemCode: FieldRef<"QuotationItem", 'String'>
    readonly description: FieldRef<"QuotationItem", 'String'>
    readonly unit: FieldRef<"QuotationItem", 'String'>
    readonly quantity: FieldRef<"QuotationItem", 'Decimal'>
    readonly unitPrice: FieldRef<"QuotationItem", 'Decimal'>
    readonly totalPrice: FieldRef<"QuotationItem", 'Decimal'>
    readonly currency: FieldRef<"QuotationItem", 'String'>
    readonly normalizedPrice: FieldRef<"QuotationItem", 'Decimal'>
    readonly matchScore: FieldRef<"QuotationItem", 'Float'>
    readonly extraAttributes: FieldRef<"QuotationItem", 'Json'>
    readonly createdAt: FieldRef<"QuotationItem", 'DateTime'>
    readonly updatedAt: FieldRef<"QuotationItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuotationItem findUnique
   */
  export type QuotationItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationItem
     */
    select?: QuotationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationItem
     */
    omit?: QuotationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationItemInclude<ExtArgs> | null
    /**
     * Filter, which QuotationItem to fetch.
     */
    where: QuotationItemWhereUniqueInput
  }

  /**
   * QuotationItem findUniqueOrThrow
   */
  export type QuotationItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationItem
     */
    select?: QuotationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationItem
     */
    omit?: QuotationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationItemInclude<ExtArgs> | null
    /**
     * Filter, which QuotationItem to fetch.
     */
    where: QuotationItemWhereUniqueInput
  }

  /**
   * QuotationItem findFirst
   */
  export type QuotationItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationItem
     */
    select?: QuotationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationItem
     */
    omit?: QuotationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationItemInclude<ExtArgs> | null
    /**
     * Filter, which QuotationItem to fetch.
     */
    where?: QuotationItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotationItems to fetch.
     */
    orderBy?: QuotationItemOrderByWithRelationInput | QuotationItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuotationItems.
     */
    cursor?: QuotationItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotationItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotationItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuotationItems.
     */
    distinct?: QuotationItemScalarFieldEnum | QuotationItemScalarFieldEnum[]
  }

  /**
   * QuotationItem findFirstOrThrow
   */
  export type QuotationItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationItem
     */
    select?: QuotationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationItem
     */
    omit?: QuotationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationItemInclude<ExtArgs> | null
    /**
     * Filter, which QuotationItem to fetch.
     */
    where?: QuotationItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotationItems to fetch.
     */
    orderBy?: QuotationItemOrderByWithRelationInput | QuotationItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuotationItems.
     */
    cursor?: QuotationItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotationItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotationItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuotationItems.
     */
    distinct?: QuotationItemScalarFieldEnum | QuotationItemScalarFieldEnum[]
  }

  /**
   * QuotationItem findMany
   */
  export type QuotationItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationItem
     */
    select?: QuotationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationItem
     */
    omit?: QuotationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationItemInclude<ExtArgs> | null
    /**
     * Filter, which QuotationItems to fetch.
     */
    where?: QuotationItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotationItems to fetch.
     */
    orderBy?: QuotationItemOrderByWithRelationInput | QuotationItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuotationItems.
     */
    cursor?: QuotationItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotationItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotationItems.
     */
    skip?: number
    distinct?: QuotationItemScalarFieldEnum | QuotationItemScalarFieldEnum[]
  }

  /**
   * QuotationItem create
   */
  export type QuotationItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationItem
     */
    select?: QuotationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationItem
     */
    omit?: QuotationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationItemInclude<ExtArgs> | null
    /**
     * The data needed to create a QuotationItem.
     */
    data: XOR<QuotationItemCreateInput, QuotationItemUncheckedCreateInput>
  }

  /**
   * QuotationItem createMany
   */
  export type QuotationItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuotationItems.
     */
    data: QuotationItemCreateManyInput | QuotationItemCreateManyInput[]
  }

  /**
   * QuotationItem createManyAndReturn
   */
  export type QuotationItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationItem
     */
    select?: QuotationItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationItem
     */
    omit?: QuotationItemOmit<ExtArgs> | null
    /**
     * The data used to create many QuotationItems.
     */
    data: QuotationItemCreateManyInput | QuotationItemCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuotationItem update
   */
  export type QuotationItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationItem
     */
    select?: QuotationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationItem
     */
    omit?: QuotationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationItemInclude<ExtArgs> | null
    /**
     * The data needed to update a QuotationItem.
     */
    data: XOR<QuotationItemUpdateInput, QuotationItemUncheckedUpdateInput>
    /**
     * Choose, which QuotationItem to update.
     */
    where: QuotationItemWhereUniqueInput
  }

  /**
   * QuotationItem updateMany
   */
  export type QuotationItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuotationItems.
     */
    data: XOR<QuotationItemUpdateManyMutationInput, QuotationItemUncheckedUpdateManyInput>
    /**
     * Filter which QuotationItems to update
     */
    where?: QuotationItemWhereInput
    /**
     * Limit how many QuotationItems to update.
     */
    limit?: number
  }

  /**
   * QuotationItem updateManyAndReturn
   */
  export type QuotationItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationItem
     */
    select?: QuotationItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationItem
     */
    omit?: QuotationItemOmit<ExtArgs> | null
    /**
     * The data used to update QuotationItems.
     */
    data: XOR<QuotationItemUpdateManyMutationInput, QuotationItemUncheckedUpdateManyInput>
    /**
     * Filter which QuotationItems to update
     */
    where?: QuotationItemWhereInput
    /**
     * Limit how many QuotationItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuotationItem upsert
   */
  export type QuotationItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationItem
     */
    select?: QuotationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationItem
     */
    omit?: QuotationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationItemInclude<ExtArgs> | null
    /**
     * The filter to search for the QuotationItem to update in case it exists.
     */
    where: QuotationItemWhereUniqueInput
    /**
     * In case the QuotationItem found by the `where` argument doesn't exist, create a new QuotationItem with this data.
     */
    create: XOR<QuotationItemCreateInput, QuotationItemUncheckedCreateInput>
    /**
     * In case the QuotationItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuotationItemUpdateInput, QuotationItemUncheckedUpdateInput>
  }

  /**
   * QuotationItem delete
   */
  export type QuotationItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationItem
     */
    select?: QuotationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationItem
     */
    omit?: QuotationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationItemInclude<ExtArgs> | null
    /**
     * Filter which QuotationItem to delete.
     */
    where: QuotationItemWhereUniqueInput
  }

  /**
   * QuotationItem deleteMany
   */
  export type QuotationItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuotationItems to delete
     */
    where?: QuotationItemWhereInput
    /**
     * Limit how many QuotationItems to delete.
     */
    limit?: number
  }

  /**
   * QuotationItem.baselineItem
   */
  export type QuotationItem$baselineItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationBaselineItem
     */
    select?: QuotationBaselineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationBaselineItem
     */
    omit?: QuotationBaselineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationBaselineItemInclude<ExtArgs> | null
    where?: QuotationBaselineItemWhereInput
  }

  /**
   * QuotationItem.material
   */
  export type QuotationItem$materialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    where?: MaterialWhereInput
  }

  /**
   * QuotationItem without action
   */
  export type QuotationItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationItem
     */
    select?: QuotationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationItem
     */
    omit?: QuotationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationItemInclude<ExtArgs> | null
  }


  /**
   * Model QuotationAttachment
   */

  export type AggregateQuotationAttachment = {
    _count: QuotationAttachmentCountAggregateOutputType | null
    _avg: QuotationAttachmentAvgAggregateOutputType | null
    _sum: QuotationAttachmentSumAggregateOutputType | null
    _min: QuotationAttachmentMinAggregateOutputType | null
    _max: QuotationAttachmentMaxAggregateOutputType | null
  }

  export type QuotationAttachmentAvgAggregateOutputType = {
    id: number | null
    quotationId: number | null
    sizeBytes: number | null
  }

  export type QuotationAttachmentSumAggregateOutputType = {
    id: number | null
    quotationId: number | null
    sizeBytes: number | null
  }

  export type QuotationAttachmentMinAggregateOutputType = {
    id: number | null
    quotationId: number | null
    type: $Enums.QuotationAttachmentType | null
    originalName: string | null
    storagePath: string | null
    mimeType: string | null
    sizeBytes: number | null
    checksum: string | null
    parsed: boolean | null
    parsedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuotationAttachmentMaxAggregateOutputType = {
    id: number | null
    quotationId: number | null
    type: $Enums.QuotationAttachmentType | null
    originalName: string | null
    storagePath: string | null
    mimeType: string | null
    sizeBytes: number | null
    checksum: string | null
    parsed: boolean | null
    parsedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuotationAttachmentCountAggregateOutputType = {
    id: number
    quotationId: number
    type: number
    originalName: number
    storagePath: number
    mimeType: number
    sizeBytes: number
    checksum: number
    parsed: number
    parsedAt: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuotationAttachmentAvgAggregateInputType = {
    id?: true
    quotationId?: true
    sizeBytes?: true
  }

  export type QuotationAttachmentSumAggregateInputType = {
    id?: true
    quotationId?: true
    sizeBytes?: true
  }

  export type QuotationAttachmentMinAggregateInputType = {
    id?: true
    quotationId?: true
    type?: true
    originalName?: true
    storagePath?: true
    mimeType?: true
    sizeBytes?: true
    checksum?: true
    parsed?: true
    parsedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuotationAttachmentMaxAggregateInputType = {
    id?: true
    quotationId?: true
    type?: true
    originalName?: true
    storagePath?: true
    mimeType?: true
    sizeBytes?: true
    checksum?: true
    parsed?: true
    parsedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuotationAttachmentCountAggregateInputType = {
    id?: true
    quotationId?: true
    type?: true
    originalName?: true
    storagePath?: true
    mimeType?: true
    sizeBytes?: true
    checksum?: true
    parsed?: true
    parsedAt?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuotationAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuotationAttachment to aggregate.
     */
    where?: QuotationAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotationAttachments to fetch.
     */
    orderBy?: QuotationAttachmentOrderByWithRelationInput | QuotationAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuotationAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotationAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotationAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuotationAttachments
    **/
    _count?: true | QuotationAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuotationAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuotationAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuotationAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuotationAttachmentMaxAggregateInputType
  }

  export type GetQuotationAttachmentAggregateType<T extends QuotationAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateQuotationAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuotationAttachment[P]>
      : GetScalarType<T[P], AggregateQuotationAttachment[P]>
  }




  export type QuotationAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotationAttachmentWhereInput
    orderBy?: QuotationAttachmentOrderByWithAggregationInput | QuotationAttachmentOrderByWithAggregationInput[]
    by: QuotationAttachmentScalarFieldEnum[] | QuotationAttachmentScalarFieldEnum
    having?: QuotationAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuotationAttachmentCountAggregateInputType | true
    _avg?: QuotationAttachmentAvgAggregateInputType
    _sum?: QuotationAttachmentSumAggregateInputType
    _min?: QuotationAttachmentMinAggregateInputType
    _max?: QuotationAttachmentMaxAggregateInputType
  }

  export type QuotationAttachmentGroupByOutputType = {
    id: number
    quotationId: number | null
    type: $Enums.QuotationAttachmentType
    originalName: string
    storagePath: string
    mimeType: string | null
    sizeBytes: number | null
    checksum: string | null
    parsed: boolean
    parsedAt: Date | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: QuotationAttachmentCountAggregateOutputType | null
    _avg: QuotationAttachmentAvgAggregateOutputType | null
    _sum: QuotationAttachmentSumAggregateOutputType | null
    _min: QuotationAttachmentMinAggregateOutputType | null
    _max: QuotationAttachmentMaxAggregateOutputType | null
  }

  type GetQuotationAttachmentGroupByPayload<T extends QuotationAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuotationAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuotationAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuotationAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], QuotationAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type QuotationAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quotationId?: boolean
    type?: boolean
    originalName?: boolean
    storagePath?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    checksum?: boolean
    parsed?: boolean
    parsedAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quotation?: boolean | QuotationAttachment$quotationArgs<ExtArgs>
    process?: boolean | QuotationAttachment$processArgs<ExtArgs>
  }, ExtArgs["result"]["quotationAttachment"]>

  export type QuotationAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quotationId?: boolean
    type?: boolean
    originalName?: boolean
    storagePath?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    checksum?: boolean
    parsed?: boolean
    parsedAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quotation?: boolean | QuotationAttachment$quotationArgs<ExtArgs>
  }, ExtArgs["result"]["quotationAttachment"]>

  export type QuotationAttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quotationId?: boolean
    type?: boolean
    originalName?: boolean
    storagePath?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    checksum?: boolean
    parsed?: boolean
    parsedAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quotation?: boolean | QuotationAttachment$quotationArgs<ExtArgs>
  }, ExtArgs["result"]["quotationAttachment"]>

  export type QuotationAttachmentSelectScalar = {
    id?: boolean
    quotationId?: boolean
    type?: boolean
    originalName?: boolean
    storagePath?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    checksum?: boolean
    parsed?: boolean
    parsedAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuotationAttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quotationId" | "type" | "originalName" | "storagePath" | "mimeType" | "sizeBytes" | "checksum" | "parsed" | "parsedAt" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["quotationAttachment"]>
  export type QuotationAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quotation?: boolean | QuotationAttachment$quotationArgs<ExtArgs>
    process?: boolean | QuotationAttachment$processArgs<ExtArgs>
  }
  export type QuotationAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quotation?: boolean | QuotationAttachment$quotationArgs<ExtArgs>
  }
  export type QuotationAttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quotation?: boolean | QuotationAttachment$quotationArgs<ExtArgs>
  }

  export type $QuotationAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuotationAttachment"
    objects: {
      quotation: Prisma.$QuotationPayload<ExtArgs> | null
      process: Prisma.$QuotationProcessPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      quotationId: number | null
      type: $Enums.QuotationAttachmentType
      originalName: string
      storagePath: string
      mimeType: string | null
      sizeBytes: number | null
      checksum: string | null
      parsed: boolean
      parsedAt: Date | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["quotationAttachment"]>
    composites: {}
  }

  type QuotationAttachmentGetPayload<S extends boolean | null | undefined | QuotationAttachmentDefaultArgs> = $Result.GetResult<Prisma.$QuotationAttachmentPayload, S>

  type QuotationAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuotationAttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuotationAttachmentCountAggregateInputType | true
    }

  export interface QuotationAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuotationAttachment'], meta: { name: 'QuotationAttachment' } }
    /**
     * Find zero or one QuotationAttachment that matches the filter.
     * @param {QuotationAttachmentFindUniqueArgs} args - Arguments to find a QuotationAttachment
     * @example
     * // Get one QuotationAttachment
     * const quotationAttachment = await prisma.quotationAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuotationAttachmentFindUniqueArgs>(args: SelectSubset<T, QuotationAttachmentFindUniqueArgs<ExtArgs>>): Prisma__QuotationAttachmentClient<$Result.GetResult<Prisma.$QuotationAttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuotationAttachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuotationAttachmentFindUniqueOrThrowArgs} args - Arguments to find a QuotationAttachment
     * @example
     * // Get one QuotationAttachment
     * const quotationAttachment = await prisma.quotationAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuotationAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, QuotationAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuotationAttachmentClient<$Result.GetResult<Prisma.$QuotationAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuotationAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationAttachmentFindFirstArgs} args - Arguments to find a QuotationAttachment
     * @example
     * // Get one QuotationAttachment
     * const quotationAttachment = await prisma.quotationAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuotationAttachmentFindFirstArgs>(args?: SelectSubset<T, QuotationAttachmentFindFirstArgs<ExtArgs>>): Prisma__QuotationAttachmentClient<$Result.GetResult<Prisma.$QuotationAttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuotationAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationAttachmentFindFirstOrThrowArgs} args - Arguments to find a QuotationAttachment
     * @example
     * // Get one QuotationAttachment
     * const quotationAttachment = await prisma.quotationAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuotationAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, QuotationAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuotationAttachmentClient<$Result.GetResult<Prisma.$QuotationAttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuotationAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuotationAttachments
     * const quotationAttachments = await prisma.quotationAttachment.findMany()
     * 
     * // Get first 10 QuotationAttachments
     * const quotationAttachments = await prisma.quotationAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quotationAttachmentWithIdOnly = await prisma.quotationAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuotationAttachmentFindManyArgs>(args?: SelectSubset<T, QuotationAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuotationAttachment.
     * @param {QuotationAttachmentCreateArgs} args - Arguments to create a QuotationAttachment.
     * @example
     * // Create one QuotationAttachment
     * const QuotationAttachment = await prisma.quotationAttachment.create({
     *   data: {
     *     // ... data to create a QuotationAttachment
     *   }
     * })
     * 
     */
    create<T extends QuotationAttachmentCreateArgs>(args: SelectSubset<T, QuotationAttachmentCreateArgs<ExtArgs>>): Prisma__QuotationAttachmentClient<$Result.GetResult<Prisma.$QuotationAttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuotationAttachments.
     * @param {QuotationAttachmentCreateManyArgs} args - Arguments to create many QuotationAttachments.
     * @example
     * // Create many QuotationAttachments
     * const quotationAttachment = await prisma.quotationAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuotationAttachmentCreateManyArgs>(args?: SelectSubset<T, QuotationAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuotationAttachments and returns the data saved in the database.
     * @param {QuotationAttachmentCreateManyAndReturnArgs} args - Arguments to create many QuotationAttachments.
     * @example
     * // Create many QuotationAttachments
     * const quotationAttachment = await prisma.quotationAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuotationAttachments and only return the `id`
     * const quotationAttachmentWithIdOnly = await prisma.quotationAttachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuotationAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, QuotationAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationAttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuotationAttachment.
     * @param {QuotationAttachmentDeleteArgs} args - Arguments to delete one QuotationAttachment.
     * @example
     * // Delete one QuotationAttachment
     * const QuotationAttachment = await prisma.quotationAttachment.delete({
     *   where: {
     *     // ... filter to delete one QuotationAttachment
     *   }
     * })
     * 
     */
    delete<T extends QuotationAttachmentDeleteArgs>(args: SelectSubset<T, QuotationAttachmentDeleteArgs<ExtArgs>>): Prisma__QuotationAttachmentClient<$Result.GetResult<Prisma.$QuotationAttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuotationAttachment.
     * @param {QuotationAttachmentUpdateArgs} args - Arguments to update one QuotationAttachment.
     * @example
     * // Update one QuotationAttachment
     * const quotationAttachment = await prisma.quotationAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuotationAttachmentUpdateArgs>(args: SelectSubset<T, QuotationAttachmentUpdateArgs<ExtArgs>>): Prisma__QuotationAttachmentClient<$Result.GetResult<Prisma.$QuotationAttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuotationAttachments.
     * @param {QuotationAttachmentDeleteManyArgs} args - Arguments to filter QuotationAttachments to delete.
     * @example
     * // Delete a few QuotationAttachments
     * const { count } = await prisma.quotationAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuotationAttachmentDeleteManyArgs>(args?: SelectSubset<T, QuotationAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuotationAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuotationAttachments
     * const quotationAttachment = await prisma.quotationAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuotationAttachmentUpdateManyArgs>(args: SelectSubset<T, QuotationAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuotationAttachments and returns the data updated in the database.
     * @param {QuotationAttachmentUpdateManyAndReturnArgs} args - Arguments to update many QuotationAttachments.
     * @example
     * // Update many QuotationAttachments
     * const quotationAttachment = await prisma.quotationAttachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuotationAttachments and only return the `id`
     * const quotationAttachmentWithIdOnly = await prisma.quotationAttachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuotationAttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, QuotationAttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationAttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuotationAttachment.
     * @param {QuotationAttachmentUpsertArgs} args - Arguments to update or create a QuotationAttachment.
     * @example
     * // Update or create a QuotationAttachment
     * const quotationAttachment = await prisma.quotationAttachment.upsert({
     *   create: {
     *     // ... data to create a QuotationAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuotationAttachment we want to update
     *   }
     * })
     */
    upsert<T extends QuotationAttachmentUpsertArgs>(args: SelectSubset<T, QuotationAttachmentUpsertArgs<ExtArgs>>): Prisma__QuotationAttachmentClient<$Result.GetResult<Prisma.$QuotationAttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuotationAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationAttachmentCountArgs} args - Arguments to filter QuotationAttachments to count.
     * @example
     * // Count the number of QuotationAttachments
     * const count = await prisma.quotationAttachment.count({
     *   where: {
     *     // ... the filter for the QuotationAttachments we want to count
     *   }
     * })
    **/
    count<T extends QuotationAttachmentCountArgs>(
      args?: Subset<T, QuotationAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuotationAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuotationAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuotationAttachmentAggregateArgs>(args: Subset<T, QuotationAttachmentAggregateArgs>): Prisma.PrismaPromise<GetQuotationAttachmentAggregateType<T>>

    /**
     * Group by QuotationAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuotationAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuotationAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: QuotationAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuotationAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuotationAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuotationAttachment model
   */
  readonly fields: QuotationAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuotationAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuotationAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quotation<T extends QuotationAttachment$quotationArgs<ExtArgs> = {}>(args?: Subset<T, QuotationAttachment$quotationArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    process<T extends QuotationAttachment$processArgs<ExtArgs> = {}>(args?: Subset<T, QuotationAttachment$processArgs<ExtArgs>>): Prisma__QuotationProcessClient<$Result.GetResult<Prisma.$QuotationProcessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuotationAttachment model
   */
  interface QuotationAttachmentFieldRefs {
    readonly id: FieldRef<"QuotationAttachment", 'Int'>
    readonly quotationId: FieldRef<"QuotationAttachment", 'Int'>
    readonly type: FieldRef<"QuotationAttachment", 'QuotationAttachmentType'>
    readonly originalName: FieldRef<"QuotationAttachment", 'String'>
    readonly storagePath: FieldRef<"QuotationAttachment", 'String'>
    readonly mimeType: FieldRef<"QuotationAttachment", 'String'>
    readonly sizeBytes: FieldRef<"QuotationAttachment", 'Int'>
    readonly checksum: FieldRef<"QuotationAttachment", 'String'>
    readonly parsed: FieldRef<"QuotationAttachment", 'Boolean'>
    readonly parsedAt: FieldRef<"QuotationAttachment", 'DateTime'>
    readonly metadata: FieldRef<"QuotationAttachment", 'Json'>
    readonly createdAt: FieldRef<"QuotationAttachment", 'DateTime'>
    readonly updatedAt: FieldRef<"QuotationAttachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuotationAttachment findUnique
   */
  export type QuotationAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationAttachment
     */
    select?: QuotationAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationAttachment
     */
    omit?: QuotationAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which QuotationAttachment to fetch.
     */
    where: QuotationAttachmentWhereUniqueInput
  }

  /**
   * QuotationAttachment findUniqueOrThrow
   */
  export type QuotationAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationAttachment
     */
    select?: QuotationAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationAttachment
     */
    omit?: QuotationAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which QuotationAttachment to fetch.
     */
    where: QuotationAttachmentWhereUniqueInput
  }

  /**
   * QuotationAttachment findFirst
   */
  export type QuotationAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationAttachment
     */
    select?: QuotationAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationAttachment
     */
    omit?: QuotationAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which QuotationAttachment to fetch.
     */
    where?: QuotationAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotationAttachments to fetch.
     */
    orderBy?: QuotationAttachmentOrderByWithRelationInput | QuotationAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuotationAttachments.
     */
    cursor?: QuotationAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotationAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotationAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuotationAttachments.
     */
    distinct?: QuotationAttachmentScalarFieldEnum | QuotationAttachmentScalarFieldEnum[]
  }

  /**
   * QuotationAttachment findFirstOrThrow
   */
  export type QuotationAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationAttachment
     */
    select?: QuotationAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationAttachment
     */
    omit?: QuotationAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which QuotationAttachment to fetch.
     */
    where?: QuotationAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotationAttachments to fetch.
     */
    orderBy?: QuotationAttachmentOrderByWithRelationInput | QuotationAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuotationAttachments.
     */
    cursor?: QuotationAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotationAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotationAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuotationAttachments.
     */
    distinct?: QuotationAttachmentScalarFieldEnum | QuotationAttachmentScalarFieldEnum[]
  }

  /**
   * QuotationAttachment findMany
   */
  export type QuotationAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationAttachment
     */
    select?: QuotationAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationAttachment
     */
    omit?: QuotationAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which QuotationAttachments to fetch.
     */
    where?: QuotationAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotationAttachments to fetch.
     */
    orderBy?: QuotationAttachmentOrderByWithRelationInput | QuotationAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuotationAttachments.
     */
    cursor?: QuotationAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotationAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotationAttachments.
     */
    skip?: number
    distinct?: QuotationAttachmentScalarFieldEnum | QuotationAttachmentScalarFieldEnum[]
  }

  /**
   * QuotationAttachment create
   */
  export type QuotationAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationAttachment
     */
    select?: QuotationAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationAttachment
     */
    omit?: QuotationAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a QuotationAttachment.
     */
    data: XOR<QuotationAttachmentCreateInput, QuotationAttachmentUncheckedCreateInput>
  }

  /**
   * QuotationAttachment createMany
   */
  export type QuotationAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuotationAttachments.
     */
    data: QuotationAttachmentCreateManyInput | QuotationAttachmentCreateManyInput[]
  }

  /**
   * QuotationAttachment createManyAndReturn
   */
  export type QuotationAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationAttachment
     */
    select?: QuotationAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationAttachment
     */
    omit?: QuotationAttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many QuotationAttachments.
     */
    data: QuotationAttachmentCreateManyInput | QuotationAttachmentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuotationAttachment update
   */
  export type QuotationAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationAttachment
     */
    select?: QuotationAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationAttachment
     */
    omit?: QuotationAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a QuotationAttachment.
     */
    data: XOR<QuotationAttachmentUpdateInput, QuotationAttachmentUncheckedUpdateInput>
    /**
     * Choose, which QuotationAttachment to update.
     */
    where: QuotationAttachmentWhereUniqueInput
  }

  /**
   * QuotationAttachment updateMany
   */
  export type QuotationAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuotationAttachments.
     */
    data: XOR<QuotationAttachmentUpdateManyMutationInput, QuotationAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which QuotationAttachments to update
     */
    where?: QuotationAttachmentWhereInput
    /**
     * Limit how many QuotationAttachments to update.
     */
    limit?: number
  }

  /**
   * QuotationAttachment updateManyAndReturn
   */
  export type QuotationAttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationAttachment
     */
    select?: QuotationAttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationAttachment
     */
    omit?: QuotationAttachmentOmit<ExtArgs> | null
    /**
     * The data used to update QuotationAttachments.
     */
    data: XOR<QuotationAttachmentUpdateManyMutationInput, QuotationAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which QuotationAttachments to update
     */
    where?: QuotationAttachmentWhereInput
    /**
     * Limit how many QuotationAttachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationAttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuotationAttachment upsert
   */
  export type QuotationAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationAttachment
     */
    select?: QuotationAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationAttachment
     */
    omit?: QuotationAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the QuotationAttachment to update in case it exists.
     */
    where: QuotationAttachmentWhereUniqueInput
    /**
     * In case the QuotationAttachment found by the `where` argument doesn't exist, create a new QuotationAttachment with this data.
     */
    create: XOR<QuotationAttachmentCreateInput, QuotationAttachmentUncheckedCreateInput>
    /**
     * In case the QuotationAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuotationAttachmentUpdateInput, QuotationAttachmentUncheckedUpdateInput>
  }

  /**
   * QuotationAttachment delete
   */
  export type QuotationAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationAttachment
     */
    select?: QuotationAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationAttachment
     */
    omit?: QuotationAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationAttachmentInclude<ExtArgs> | null
    /**
     * Filter which QuotationAttachment to delete.
     */
    where: QuotationAttachmentWhereUniqueInput
  }

  /**
   * QuotationAttachment deleteMany
   */
  export type QuotationAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuotationAttachments to delete
     */
    where?: QuotationAttachmentWhereInput
    /**
     * Limit how many QuotationAttachments to delete.
     */
    limit?: number
  }

  /**
   * QuotationAttachment.quotation
   */
  export type QuotationAttachment$quotationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    where?: QuotationWhereInput
  }

  /**
   * QuotationAttachment.process
   */
  export type QuotationAttachment$processArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationProcess
     */
    select?: QuotationProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationProcess
     */
    omit?: QuotationProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationProcessInclude<ExtArgs> | null
    where?: QuotationProcessWhereInput
  }

  /**
   * QuotationAttachment without action
   */
  export type QuotationAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationAttachment
     */
    select?: QuotationAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationAttachment
     */
    omit?: QuotationAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseOrderLog
   */

  export type AggregatePurchaseOrderLog = {
    _count: PurchaseOrderLogCountAggregateOutputType | null
    _avg: PurchaseOrderLogAvgAggregateOutputType | null
    _sum: PurchaseOrderLogSumAggregateOutputType | null
    _min: PurchaseOrderLogMinAggregateOutputType | null
    _max: PurchaseOrderLogMaxAggregateOutputType | null
  }

  export type PurchaseOrderLogAvgAggregateOutputType = {
    id: number | null
    processId: number | null
    quotationId: number | null
    supplierId: number | null
    sequence: number | null
    subtotal: Decimal | null
    discount: Decimal | null
    netSubtotal: Decimal | null
    igv: Decimal | null
    total: Decimal | null
  }

  export type PurchaseOrderLogSumAggregateOutputType = {
    id: number | null
    processId: number | null
    quotationId: number | null
    supplierId: number | null
    sequence: number | null
    subtotal: Decimal | null
    discount: Decimal | null
    netSubtotal: Decimal | null
    igv: Decimal | null
    total: Decimal | null
  }

  export type PurchaseOrderLogMinAggregateOutputType = {
    id: number | null
    processId: number | null
    quotationId: number | null
    supplierId: number | null
    supplierName: string | null
    orderNumber: string | null
    sequence: number | null
    issueDate: Date | null
    currency: string | null
    subtotal: Decimal | null
    discount: Decimal | null
    netSubtotal: Decimal | null
    igv: Decimal | null
    total: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseOrderLogMaxAggregateOutputType = {
    id: number | null
    processId: number | null
    quotationId: number | null
    supplierId: number | null
    supplierName: string | null
    orderNumber: string | null
    sequence: number | null
    issueDate: Date | null
    currency: string | null
    subtotal: Decimal | null
    discount: Decimal | null
    netSubtotal: Decimal | null
    igv: Decimal | null
    total: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseOrderLogCountAggregateOutputType = {
    id: number
    processId: number
    quotationId: number
    supplierId: number
    supplierName: number
    orderNumber: number
    sequence: number
    issueDate: number
    currency: number
    subtotal: number
    discount: number
    netSubtotal: number
    igv: number
    total: number
    totalsJson: number
    itemsJson: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseOrderLogAvgAggregateInputType = {
    id?: true
    processId?: true
    quotationId?: true
    supplierId?: true
    sequence?: true
    subtotal?: true
    discount?: true
    netSubtotal?: true
    igv?: true
    total?: true
  }

  export type PurchaseOrderLogSumAggregateInputType = {
    id?: true
    processId?: true
    quotationId?: true
    supplierId?: true
    sequence?: true
    subtotal?: true
    discount?: true
    netSubtotal?: true
    igv?: true
    total?: true
  }

  export type PurchaseOrderLogMinAggregateInputType = {
    id?: true
    processId?: true
    quotationId?: true
    supplierId?: true
    supplierName?: true
    orderNumber?: true
    sequence?: true
    issueDate?: true
    currency?: true
    subtotal?: true
    discount?: true
    netSubtotal?: true
    igv?: true
    total?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseOrderLogMaxAggregateInputType = {
    id?: true
    processId?: true
    quotationId?: true
    supplierId?: true
    supplierName?: true
    orderNumber?: true
    sequence?: true
    issueDate?: true
    currency?: true
    subtotal?: true
    discount?: true
    netSubtotal?: true
    igv?: true
    total?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseOrderLogCountAggregateInputType = {
    id?: true
    processId?: true
    quotationId?: true
    supplierId?: true
    supplierName?: true
    orderNumber?: true
    sequence?: true
    issueDate?: true
    currency?: true
    subtotal?: true
    discount?: true
    netSubtotal?: true
    igv?: true
    total?: true
    totalsJson?: true
    itemsJson?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseOrderLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrderLog to aggregate.
     */
    where?: PurchaseOrderLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderLogs to fetch.
     */
    orderBy?: PurchaseOrderLogOrderByWithRelationInput | PurchaseOrderLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseOrderLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseOrderLogs
    **/
    _count?: true | PurchaseOrderLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseOrderLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseOrderLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseOrderLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseOrderLogMaxAggregateInputType
  }

  export type GetPurchaseOrderLogAggregateType<T extends PurchaseOrderLogAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseOrderLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseOrderLog[P]>
      : GetScalarType<T[P], AggregatePurchaseOrderLog[P]>
  }




  export type PurchaseOrderLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderLogWhereInput
    orderBy?: PurchaseOrderLogOrderByWithAggregationInput | PurchaseOrderLogOrderByWithAggregationInput[]
    by: PurchaseOrderLogScalarFieldEnum[] | PurchaseOrderLogScalarFieldEnum
    having?: PurchaseOrderLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseOrderLogCountAggregateInputType | true
    _avg?: PurchaseOrderLogAvgAggregateInputType
    _sum?: PurchaseOrderLogSumAggregateInputType
    _min?: PurchaseOrderLogMinAggregateInputType
    _max?: PurchaseOrderLogMaxAggregateInputType
  }

  export type PurchaseOrderLogGroupByOutputType = {
    id: number
    processId: number
    quotationId: number | null
    supplierId: number | null
    supplierName: string
    orderNumber: string
    sequence: number
    issueDate: Date
    currency: string
    subtotal: Decimal | null
    discount: Decimal | null
    netSubtotal: Decimal | null
    igv: Decimal | null
    total: Decimal | null
    totalsJson: JsonValue | null
    itemsJson: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: PurchaseOrderLogCountAggregateOutputType | null
    _avg: PurchaseOrderLogAvgAggregateOutputType | null
    _sum: PurchaseOrderLogSumAggregateOutputType | null
    _min: PurchaseOrderLogMinAggregateOutputType | null
    _max: PurchaseOrderLogMaxAggregateOutputType | null
  }

  type GetPurchaseOrderLogGroupByPayload<T extends PurchaseOrderLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseOrderLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseOrderLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseOrderLogGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseOrderLogGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseOrderLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    processId?: boolean
    quotationId?: boolean
    supplierId?: boolean
    supplierName?: boolean
    orderNumber?: boolean
    sequence?: boolean
    issueDate?: boolean
    currency?: boolean
    subtotal?: boolean
    discount?: boolean
    netSubtotal?: boolean
    igv?: boolean
    total?: boolean
    totalsJson?: boolean
    itemsJson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    process?: boolean | QuotationProcessDefaultArgs<ExtArgs>
    quotation?: boolean | PurchaseOrderLog$quotationArgs<ExtArgs>
    lines?: boolean | PurchaseOrderLog$linesArgs<ExtArgs>
    deliveries?: boolean | PurchaseOrderLog$deliveriesArgs<ExtArgs>
    _count?: boolean | PurchaseOrderLogCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrderLog"]>

  export type PurchaseOrderLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    processId?: boolean
    quotationId?: boolean
    supplierId?: boolean
    supplierName?: boolean
    orderNumber?: boolean
    sequence?: boolean
    issueDate?: boolean
    currency?: boolean
    subtotal?: boolean
    discount?: boolean
    netSubtotal?: boolean
    igv?: boolean
    total?: boolean
    totalsJson?: boolean
    itemsJson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    process?: boolean | QuotationProcessDefaultArgs<ExtArgs>
    quotation?: boolean | PurchaseOrderLog$quotationArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrderLog"]>

  export type PurchaseOrderLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    processId?: boolean
    quotationId?: boolean
    supplierId?: boolean
    supplierName?: boolean
    orderNumber?: boolean
    sequence?: boolean
    issueDate?: boolean
    currency?: boolean
    subtotal?: boolean
    discount?: boolean
    netSubtotal?: boolean
    igv?: boolean
    total?: boolean
    totalsJson?: boolean
    itemsJson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    process?: boolean | QuotationProcessDefaultArgs<ExtArgs>
    quotation?: boolean | PurchaseOrderLog$quotationArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrderLog"]>

  export type PurchaseOrderLogSelectScalar = {
    id?: boolean
    processId?: boolean
    quotationId?: boolean
    supplierId?: boolean
    supplierName?: boolean
    orderNumber?: boolean
    sequence?: boolean
    issueDate?: boolean
    currency?: boolean
    subtotal?: boolean
    discount?: boolean
    netSubtotal?: boolean
    igv?: boolean
    total?: boolean
    totalsJson?: boolean
    itemsJson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseOrderLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "processId" | "quotationId" | "supplierId" | "supplierName" | "orderNumber" | "sequence" | "issueDate" | "currency" | "subtotal" | "discount" | "netSubtotal" | "igv" | "total" | "totalsJson" | "itemsJson" | "createdAt" | "updatedAt", ExtArgs["result"]["purchaseOrderLog"]>
  export type PurchaseOrderLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    process?: boolean | QuotationProcessDefaultArgs<ExtArgs>
    quotation?: boolean | PurchaseOrderLog$quotationArgs<ExtArgs>
    lines?: boolean | PurchaseOrderLog$linesArgs<ExtArgs>
    deliveries?: boolean | PurchaseOrderLog$deliveriesArgs<ExtArgs>
    _count?: boolean | PurchaseOrderLogCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    process?: boolean | QuotationProcessDefaultArgs<ExtArgs>
    quotation?: boolean | PurchaseOrderLog$quotationArgs<ExtArgs>
  }
  export type PurchaseOrderLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    process?: boolean | QuotationProcessDefaultArgs<ExtArgs>
    quotation?: boolean | PurchaseOrderLog$quotationArgs<ExtArgs>
  }

  export type $PurchaseOrderLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseOrderLog"
    objects: {
      process: Prisma.$QuotationProcessPayload<ExtArgs>
      quotation: Prisma.$QuotationPayload<ExtArgs> | null
      lines: Prisma.$PurchaseOrderLinePayload<ExtArgs>[]
      deliveries: Prisma.$PurchaseDeliveryLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      processId: number
      quotationId: number | null
      supplierId: number | null
      supplierName: string
      orderNumber: string
      sequence: number
      issueDate: Date
      currency: string
      subtotal: Prisma.Decimal | null
      discount: Prisma.Decimal | null
      netSubtotal: Prisma.Decimal | null
      igv: Prisma.Decimal | null
      total: Prisma.Decimal | null
      totalsJson: Prisma.JsonValue | null
      itemsJson: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchaseOrderLog"]>
    composites: {}
  }

  type PurchaseOrderLogGetPayload<S extends boolean | null | undefined | PurchaseOrderLogDefaultArgs> = $Result.GetResult<Prisma.$PurchaseOrderLogPayload, S>

  type PurchaseOrderLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseOrderLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseOrderLogCountAggregateInputType | true
    }

  export interface PurchaseOrderLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseOrderLog'], meta: { name: 'PurchaseOrderLog' } }
    /**
     * Find zero or one PurchaseOrderLog that matches the filter.
     * @param {PurchaseOrderLogFindUniqueArgs} args - Arguments to find a PurchaseOrderLog
     * @example
     * // Get one PurchaseOrderLog
     * const purchaseOrderLog = await prisma.purchaseOrderLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseOrderLogFindUniqueArgs>(args: SelectSubset<T, PurchaseOrderLogFindUniqueArgs<ExtArgs>>): Prisma__PurchaseOrderLogClient<$Result.GetResult<Prisma.$PurchaseOrderLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseOrderLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseOrderLogFindUniqueOrThrowArgs} args - Arguments to find a PurchaseOrderLog
     * @example
     * // Get one PurchaseOrderLog
     * const purchaseOrderLog = await prisma.purchaseOrderLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseOrderLogFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseOrderLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderLogClient<$Result.GetResult<Prisma.$PurchaseOrderLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrderLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderLogFindFirstArgs} args - Arguments to find a PurchaseOrderLog
     * @example
     * // Get one PurchaseOrderLog
     * const purchaseOrderLog = await prisma.purchaseOrderLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseOrderLogFindFirstArgs>(args?: SelectSubset<T, PurchaseOrderLogFindFirstArgs<ExtArgs>>): Prisma__PurchaseOrderLogClient<$Result.GetResult<Prisma.$PurchaseOrderLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrderLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderLogFindFirstOrThrowArgs} args - Arguments to find a PurchaseOrderLog
     * @example
     * // Get one PurchaseOrderLog
     * const purchaseOrderLog = await prisma.purchaseOrderLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseOrderLogFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseOrderLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderLogClient<$Result.GetResult<Prisma.$PurchaseOrderLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseOrderLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseOrderLogs
     * const purchaseOrderLogs = await prisma.purchaseOrderLog.findMany()
     * 
     * // Get first 10 PurchaseOrderLogs
     * const purchaseOrderLogs = await prisma.purchaseOrderLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseOrderLogWithIdOnly = await prisma.purchaseOrderLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseOrderLogFindManyArgs>(args?: SelectSubset<T, PurchaseOrderLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseOrderLog.
     * @param {PurchaseOrderLogCreateArgs} args - Arguments to create a PurchaseOrderLog.
     * @example
     * // Create one PurchaseOrderLog
     * const PurchaseOrderLog = await prisma.purchaseOrderLog.create({
     *   data: {
     *     // ... data to create a PurchaseOrderLog
     *   }
     * })
     * 
     */
    create<T extends PurchaseOrderLogCreateArgs>(args: SelectSubset<T, PurchaseOrderLogCreateArgs<ExtArgs>>): Prisma__PurchaseOrderLogClient<$Result.GetResult<Prisma.$PurchaseOrderLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseOrderLogs.
     * @param {PurchaseOrderLogCreateManyArgs} args - Arguments to create many PurchaseOrderLogs.
     * @example
     * // Create many PurchaseOrderLogs
     * const purchaseOrderLog = await prisma.purchaseOrderLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseOrderLogCreateManyArgs>(args?: SelectSubset<T, PurchaseOrderLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseOrderLogs and returns the data saved in the database.
     * @param {PurchaseOrderLogCreateManyAndReturnArgs} args - Arguments to create many PurchaseOrderLogs.
     * @example
     * // Create many PurchaseOrderLogs
     * const purchaseOrderLog = await prisma.purchaseOrderLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseOrderLogs and only return the `id`
     * const purchaseOrderLogWithIdOnly = await prisma.purchaseOrderLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseOrderLogCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseOrderLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseOrderLog.
     * @param {PurchaseOrderLogDeleteArgs} args - Arguments to delete one PurchaseOrderLog.
     * @example
     * // Delete one PurchaseOrderLog
     * const PurchaseOrderLog = await prisma.purchaseOrderLog.delete({
     *   where: {
     *     // ... filter to delete one PurchaseOrderLog
     *   }
     * })
     * 
     */
    delete<T extends PurchaseOrderLogDeleteArgs>(args: SelectSubset<T, PurchaseOrderLogDeleteArgs<ExtArgs>>): Prisma__PurchaseOrderLogClient<$Result.GetResult<Prisma.$PurchaseOrderLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseOrderLog.
     * @param {PurchaseOrderLogUpdateArgs} args - Arguments to update one PurchaseOrderLog.
     * @example
     * // Update one PurchaseOrderLog
     * const purchaseOrderLog = await prisma.purchaseOrderLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseOrderLogUpdateArgs>(args: SelectSubset<T, PurchaseOrderLogUpdateArgs<ExtArgs>>): Prisma__PurchaseOrderLogClient<$Result.GetResult<Prisma.$PurchaseOrderLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseOrderLogs.
     * @param {PurchaseOrderLogDeleteManyArgs} args - Arguments to filter PurchaseOrderLogs to delete.
     * @example
     * // Delete a few PurchaseOrderLogs
     * const { count } = await prisma.purchaseOrderLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseOrderLogDeleteManyArgs>(args?: SelectSubset<T, PurchaseOrderLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrderLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseOrderLogs
     * const purchaseOrderLog = await prisma.purchaseOrderLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseOrderLogUpdateManyArgs>(args: SelectSubset<T, PurchaseOrderLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrderLogs and returns the data updated in the database.
     * @param {PurchaseOrderLogUpdateManyAndReturnArgs} args - Arguments to update many PurchaseOrderLogs.
     * @example
     * // Update many PurchaseOrderLogs
     * const purchaseOrderLog = await prisma.purchaseOrderLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseOrderLogs and only return the `id`
     * const purchaseOrderLogWithIdOnly = await prisma.purchaseOrderLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseOrderLogUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseOrderLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseOrderLog.
     * @param {PurchaseOrderLogUpsertArgs} args - Arguments to update or create a PurchaseOrderLog.
     * @example
     * // Update or create a PurchaseOrderLog
     * const purchaseOrderLog = await prisma.purchaseOrderLog.upsert({
     *   create: {
     *     // ... data to create a PurchaseOrderLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseOrderLog we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseOrderLogUpsertArgs>(args: SelectSubset<T, PurchaseOrderLogUpsertArgs<ExtArgs>>): Prisma__PurchaseOrderLogClient<$Result.GetResult<Prisma.$PurchaseOrderLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseOrderLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderLogCountArgs} args - Arguments to filter PurchaseOrderLogs to count.
     * @example
     * // Count the number of PurchaseOrderLogs
     * const count = await prisma.purchaseOrderLog.count({
     *   where: {
     *     // ... the filter for the PurchaseOrderLogs we want to count
     *   }
     * })
    **/
    count<T extends PurchaseOrderLogCountArgs>(
      args?: Subset<T, PurchaseOrderLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseOrderLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseOrderLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseOrderLogAggregateArgs>(args: Subset<T, PurchaseOrderLogAggregateArgs>): Prisma.PrismaPromise<GetPurchaseOrderLogAggregateType<T>>

    /**
     * Group by PurchaseOrderLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseOrderLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseOrderLogGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseOrderLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseOrderLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseOrderLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseOrderLog model
   */
  readonly fields: PurchaseOrderLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseOrderLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseOrderLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    process<T extends QuotationProcessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuotationProcessDefaultArgs<ExtArgs>>): Prisma__QuotationProcessClient<$Result.GetResult<Prisma.$QuotationProcessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    quotation<T extends PurchaseOrderLog$quotationArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrderLog$quotationArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lines<T extends PurchaseOrderLog$linesArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrderLog$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deliveries<T extends PurchaseOrderLog$deliveriesArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrderLog$deliveriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseDeliveryLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseOrderLog model
   */
  interface PurchaseOrderLogFieldRefs {
    readonly id: FieldRef<"PurchaseOrderLog", 'Int'>
    readonly processId: FieldRef<"PurchaseOrderLog", 'Int'>
    readonly quotationId: FieldRef<"PurchaseOrderLog", 'Int'>
    readonly supplierId: FieldRef<"PurchaseOrderLog", 'Int'>
    readonly supplierName: FieldRef<"PurchaseOrderLog", 'String'>
    readonly orderNumber: FieldRef<"PurchaseOrderLog", 'String'>
    readonly sequence: FieldRef<"PurchaseOrderLog", 'Int'>
    readonly issueDate: FieldRef<"PurchaseOrderLog", 'DateTime'>
    readonly currency: FieldRef<"PurchaseOrderLog", 'String'>
    readonly subtotal: FieldRef<"PurchaseOrderLog", 'Decimal'>
    readonly discount: FieldRef<"PurchaseOrderLog", 'Decimal'>
    readonly netSubtotal: FieldRef<"PurchaseOrderLog", 'Decimal'>
    readonly igv: FieldRef<"PurchaseOrderLog", 'Decimal'>
    readonly total: FieldRef<"PurchaseOrderLog", 'Decimal'>
    readonly totalsJson: FieldRef<"PurchaseOrderLog", 'Json'>
    readonly itemsJson: FieldRef<"PurchaseOrderLog", 'Json'>
    readonly createdAt: FieldRef<"PurchaseOrderLog", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseOrderLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseOrderLog findUnique
   */
  export type PurchaseOrderLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLog
     */
    select?: PurchaseOrderLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLog
     */
    omit?: PurchaseOrderLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLogInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderLog to fetch.
     */
    where: PurchaseOrderLogWhereUniqueInput
  }

  /**
   * PurchaseOrderLog findUniqueOrThrow
   */
  export type PurchaseOrderLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLog
     */
    select?: PurchaseOrderLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLog
     */
    omit?: PurchaseOrderLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLogInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderLog to fetch.
     */
    where: PurchaseOrderLogWhereUniqueInput
  }

  /**
   * PurchaseOrderLog findFirst
   */
  export type PurchaseOrderLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLog
     */
    select?: PurchaseOrderLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLog
     */
    omit?: PurchaseOrderLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLogInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderLog to fetch.
     */
    where?: PurchaseOrderLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderLogs to fetch.
     */
    orderBy?: PurchaseOrderLogOrderByWithRelationInput | PurchaseOrderLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrderLogs.
     */
    cursor?: PurchaseOrderLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrderLogs.
     */
    distinct?: PurchaseOrderLogScalarFieldEnum | PurchaseOrderLogScalarFieldEnum[]
  }

  /**
   * PurchaseOrderLog findFirstOrThrow
   */
  export type PurchaseOrderLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLog
     */
    select?: PurchaseOrderLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLog
     */
    omit?: PurchaseOrderLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLogInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderLog to fetch.
     */
    where?: PurchaseOrderLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderLogs to fetch.
     */
    orderBy?: PurchaseOrderLogOrderByWithRelationInput | PurchaseOrderLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrderLogs.
     */
    cursor?: PurchaseOrderLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrderLogs.
     */
    distinct?: PurchaseOrderLogScalarFieldEnum | PurchaseOrderLogScalarFieldEnum[]
  }

  /**
   * PurchaseOrderLog findMany
   */
  export type PurchaseOrderLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLog
     */
    select?: PurchaseOrderLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLog
     */
    omit?: PurchaseOrderLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLogInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderLogs to fetch.
     */
    where?: PurchaseOrderLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderLogs to fetch.
     */
    orderBy?: PurchaseOrderLogOrderByWithRelationInput | PurchaseOrderLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseOrderLogs.
     */
    cursor?: PurchaseOrderLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderLogs.
     */
    skip?: number
    distinct?: PurchaseOrderLogScalarFieldEnum | PurchaseOrderLogScalarFieldEnum[]
  }

  /**
   * PurchaseOrderLog create
   */
  export type PurchaseOrderLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLog
     */
    select?: PurchaseOrderLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLog
     */
    omit?: PurchaseOrderLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLogInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseOrderLog.
     */
    data: XOR<PurchaseOrderLogCreateInput, PurchaseOrderLogUncheckedCreateInput>
  }

  /**
   * PurchaseOrderLog createMany
   */
  export type PurchaseOrderLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseOrderLogs.
     */
    data: PurchaseOrderLogCreateManyInput | PurchaseOrderLogCreateManyInput[]
  }

  /**
   * PurchaseOrderLog createManyAndReturn
   */
  export type PurchaseOrderLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLog
     */
    select?: PurchaseOrderLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLog
     */
    omit?: PurchaseOrderLogOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseOrderLogs.
     */
    data: PurchaseOrderLogCreateManyInput | PurchaseOrderLogCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrderLog update
   */
  export type PurchaseOrderLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLog
     */
    select?: PurchaseOrderLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLog
     */
    omit?: PurchaseOrderLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLogInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseOrderLog.
     */
    data: XOR<PurchaseOrderLogUpdateInput, PurchaseOrderLogUncheckedUpdateInput>
    /**
     * Choose, which PurchaseOrderLog to update.
     */
    where: PurchaseOrderLogWhereUniqueInput
  }

  /**
   * PurchaseOrderLog updateMany
   */
  export type PurchaseOrderLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseOrderLogs.
     */
    data: XOR<PurchaseOrderLogUpdateManyMutationInput, PurchaseOrderLogUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrderLogs to update
     */
    where?: PurchaseOrderLogWhereInput
    /**
     * Limit how many PurchaseOrderLogs to update.
     */
    limit?: number
  }

  /**
   * PurchaseOrderLog updateManyAndReturn
   */
  export type PurchaseOrderLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLog
     */
    select?: PurchaseOrderLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLog
     */
    omit?: PurchaseOrderLogOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseOrderLogs.
     */
    data: XOR<PurchaseOrderLogUpdateManyMutationInput, PurchaseOrderLogUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrderLogs to update
     */
    where?: PurchaseOrderLogWhereInput
    /**
     * Limit how many PurchaseOrderLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrderLog upsert
   */
  export type PurchaseOrderLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLog
     */
    select?: PurchaseOrderLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLog
     */
    omit?: PurchaseOrderLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLogInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseOrderLog to update in case it exists.
     */
    where: PurchaseOrderLogWhereUniqueInput
    /**
     * In case the PurchaseOrderLog found by the `where` argument doesn't exist, create a new PurchaseOrderLog with this data.
     */
    create: XOR<PurchaseOrderLogCreateInput, PurchaseOrderLogUncheckedCreateInput>
    /**
     * In case the PurchaseOrderLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseOrderLogUpdateInput, PurchaseOrderLogUncheckedUpdateInput>
  }

  /**
   * PurchaseOrderLog delete
   */
  export type PurchaseOrderLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLog
     */
    select?: PurchaseOrderLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLog
     */
    omit?: PurchaseOrderLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLogInclude<ExtArgs> | null
    /**
     * Filter which PurchaseOrderLog to delete.
     */
    where: PurchaseOrderLogWhereUniqueInput
  }

  /**
   * PurchaseOrderLog deleteMany
   */
  export type PurchaseOrderLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrderLogs to delete
     */
    where?: PurchaseOrderLogWhereInput
    /**
     * Limit how many PurchaseOrderLogs to delete.
     */
    limit?: number
  }

  /**
   * PurchaseOrderLog.quotation
   */
  export type PurchaseOrderLog$quotationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    where?: QuotationWhereInput
  }

  /**
   * PurchaseOrderLog.lines
   */
  export type PurchaseOrderLog$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    where?: PurchaseOrderLineWhereInput
    orderBy?: PurchaseOrderLineOrderByWithRelationInput | PurchaseOrderLineOrderByWithRelationInput[]
    cursor?: PurchaseOrderLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderLineScalarFieldEnum | PurchaseOrderLineScalarFieldEnum[]
  }

  /**
   * PurchaseOrderLog.deliveries
   */
  export type PurchaseOrderLog$deliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseDeliveryLog
     */
    select?: PurchaseDeliveryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseDeliveryLog
     */
    omit?: PurchaseDeliveryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseDeliveryLogInclude<ExtArgs> | null
    where?: PurchaseDeliveryLogWhereInput
    orderBy?: PurchaseDeliveryLogOrderByWithRelationInput | PurchaseDeliveryLogOrderByWithRelationInput[]
    cursor?: PurchaseDeliveryLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseDeliveryLogScalarFieldEnum | PurchaseDeliveryLogScalarFieldEnum[]
  }

  /**
   * PurchaseOrderLog without action
   */
  export type PurchaseOrderLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLog
     */
    select?: PurchaseOrderLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLog
     */
    omit?: PurchaseOrderLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLogInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseOrderLine
   */

  export type AggregatePurchaseOrderLine = {
    _count: PurchaseOrderLineCountAggregateOutputType | null
    _avg: PurchaseOrderLineAvgAggregateOutputType | null
    _sum: PurchaseOrderLineSumAggregateOutputType | null
    _min: PurchaseOrderLineMinAggregateOutputType | null
    _max: PurchaseOrderLineMaxAggregateOutputType | null
  }

  export type PurchaseOrderLineAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
    baselineId: number | null
    quantity: Decimal | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
  }

  export type PurchaseOrderLineSumAggregateOutputType = {
    id: number | null
    orderId: number | null
    baselineId: number | null
    quantity: Decimal | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
  }

  export type PurchaseOrderLineMinAggregateOutputType = {
    id: number | null
    orderId: number | null
    baselineId: number | null
    description: string | null
    unit: string | null
    quantity: Decimal | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseOrderLineMaxAggregateOutputType = {
    id: number | null
    orderId: number | null
    baselineId: number | null
    description: string | null
    unit: string | null
    quantity: Decimal | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseOrderLineCountAggregateOutputType = {
    id: number
    orderId: number
    baselineId: number
    description: number
    unit: number
    quantity: number
    unitPrice: number
    totalPrice: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseOrderLineAvgAggregateInputType = {
    id?: true
    orderId?: true
    baselineId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type PurchaseOrderLineSumAggregateInputType = {
    id?: true
    orderId?: true
    baselineId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type PurchaseOrderLineMinAggregateInputType = {
    id?: true
    orderId?: true
    baselineId?: true
    description?: true
    unit?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseOrderLineMaxAggregateInputType = {
    id?: true
    orderId?: true
    baselineId?: true
    description?: true
    unit?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseOrderLineCountAggregateInputType = {
    id?: true
    orderId?: true
    baselineId?: true
    description?: true
    unit?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseOrderLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrderLine to aggregate.
     */
    where?: PurchaseOrderLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderLines to fetch.
     */
    orderBy?: PurchaseOrderLineOrderByWithRelationInput | PurchaseOrderLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseOrderLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseOrderLines
    **/
    _count?: true | PurchaseOrderLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseOrderLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseOrderLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseOrderLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseOrderLineMaxAggregateInputType
  }

  export type GetPurchaseOrderLineAggregateType<T extends PurchaseOrderLineAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseOrderLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseOrderLine[P]>
      : GetScalarType<T[P], AggregatePurchaseOrderLine[P]>
  }




  export type PurchaseOrderLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderLineWhereInput
    orderBy?: PurchaseOrderLineOrderByWithAggregationInput | PurchaseOrderLineOrderByWithAggregationInput[]
    by: PurchaseOrderLineScalarFieldEnum[] | PurchaseOrderLineScalarFieldEnum
    having?: PurchaseOrderLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseOrderLineCountAggregateInputType | true
    _avg?: PurchaseOrderLineAvgAggregateInputType
    _sum?: PurchaseOrderLineSumAggregateInputType
    _min?: PurchaseOrderLineMinAggregateInputType
    _max?: PurchaseOrderLineMaxAggregateInputType
  }

  export type PurchaseOrderLineGroupByOutputType = {
    id: number
    orderId: number
    baselineId: number | null
    description: string
    unit: string | null
    quantity: Decimal | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: PurchaseOrderLineCountAggregateOutputType | null
    _avg: PurchaseOrderLineAvgAggregateOutputType | null
    _sum: PurchaseOrderLineSumAggregateOutputType | null
    _min: PurchaseOrderLineMinAggregateOutputType | null
    _max: PurchaseOrderLineMaxAggregateOutputType | null
  }

  type GetPurchaseOrderLineGroupByPayload<T extends PurchaseOrderLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseOrderLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseOrderLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseOrderLineGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseOrderLineGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseOrderLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    baselineId?: boolean
    description?: boolean
    unit?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | PurchaseOrderLogDefaultArgs<ExtArgs>
    baseline?: boolean | PurchaseOrderLine$baselineArgs<ExtArgs>
    deliveries?: boolean | PurchaseOrderLine$deliveriesArgs<ExtArgs>
    _count?: boolean | PurchaseOrderLineCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrderLine"]>

  export type PurchaseOrderLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    baselineId?: boolean
    description?: boolean
    unit?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | PurchaseOrderLogDefaultArgs<ExtArgs>
    baseline?: boolean | PurchaseOrderLine$baselineArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrderLine"]>

  export type PurchaseOrderLineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    baselineId?: boolean
    description?: boolean
    unit?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | PurchaseOrderLogDefaultArgs<ExtArgs>
    baseline?: boolean | PurchaseOrderLine$baselineArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrderLine"]>

  export type PurchaseOrderLineSelectScalar = {
    id?: boolean
    orderId?: boolean
    baselineId?: boolean
    description?: boolean
    unit?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseOrderLineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "baselineId" | "description" | "unit" | "quantity" | "unitPrice" | "totalPrice" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["purchaseOrderLine"]>
  export type PurchaseOrderLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | PurchaseOrderLogDefaultArgs<ExtArgs>
    baseline?: boolean | PurchaseOrderLine$baselineArgs<ExtArgs>
    deliveries?: boolean | PurchaseOrderLine$deliveriesArgs<ExtArgs>
    _count?: boolean | PurchaseOrderLineCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | PurchaseOrderLogDefaultArgs<ExtArgs>
    baseline?: boolean | PurchaseOrderLine$baselineArgs<ExtArgs>
  }
  export type PurchaseOrderLineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | PurchaseOrderLogDefaultArgs<ExtArgs>
    baseline?: boolean | PurchaseOrderLine$baselineArgs<ExtArgs>
  }

  export type $PurchaseOrderLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseOrderLine"
    objects: {
      order: Prisma.$PurchaseOrderLogPayload<ExtArgs>
      baseline: Prisma.$QuotationBaselineItemPayload<ExtArgs> | null
      deliveries: Prisma.$PurchaseDeliveryItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderId: number
      baselineId: number | null
      description: string
      unit: string | null
      quantity: Prisma.Decimal | null
      unitPrice: Prisma.Decimal | null
      totalPrice: Prisma.Decimal | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchaseOrderLine"]>
    composites: {}
  }

  type PurchaseOrderLineGetPayload<S extends boolean | null | undefined | PurchaseOrderLineDefaultArgs> = $Result.GetResult<Prisma.$PurchaseOrderLinePayload, S>

  type PurchaseOrderLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseOrderLineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseOrderLineCountAggregateInputType | true
    }

  export interface PurchaseOrderLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseOrderLine'], meta: { name: 'PurchaseOrderLine' } }
    /**
     * Find zero or one PurchaseOrderLine that matches the filter.
     * @param {PurchaseOrderLineFindUniqueArgs} args - Arguments to find a PurchaseOrderLine
     * @example
     * // Get one PurchaseOrderLine
     * const purchaseOrderLine = await prisma.purchaseOrderLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseOrderLineFindUniqueArgs>(args: SelectSubset<T, PurchaseOrderLineFindUniqueArgs<ExtArgs>>): Prisma__PurchaseOrderLineClient<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseOrderLine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseOrderLineFindUniqueOrThrowArgs} args - Arguments to find a PurchaseOrderLine
     * @example
     * // Get one PurchaseOrderLine
     * const purchaseOrderLine = await prisma.purchaseOrderLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseOrderLineFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseOrderLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderLineClient<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrderLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderLineFindFirstArgs} args - Arguments to find a PurchaseOrderLine
     * @example
     * // Get one PurchaseOrderLine
     * const purchaseOrderLine = await prisma.purchaseOrderLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseOrderLineFindFirstArgs>(args?: SelectSubset<T, PurchaseOrderLineFindFirstArgs<ExtArgs>>): Prisma__PurchaseOrderLineClient<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrderLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderLineFindFirstOrThrowArgs} args - Arguments to find a PurchaseOrderLine
     * @example
     * // Get one PurchaseOrderLine
     * const purchaseOrderLine = await prisma.purchaseOrderLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseOrderLineFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseOrderLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderLineClient<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseOrderLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseOrderLines
     * const purchaseOrderLines = await prisma.purchaseOrderLine.findMany()
     * 
     * // Get first 10 PurchaseOrderLines
     * const purchaseOrderLines = await prisma.purchaseOrderLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseOrderLineWithIdOnly = await prisma.purchaseOrderLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseOrderLineFindManyArgs>(args?: SelectSubset<T, PurchaseOrderLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseOrderLine.
     * @param {PurchaseOrderLineCreateArgs} args - Arguments to create a PurchaseOrderLine.
     * @example
     * // Create one PurchaseOrderLine
     * const PurchaseOrderLine = await prisma.purchaseOrderLine.create({
     *   data: {
     *     // ... data to create a PurchaseOrderLine
     *   }
     * })
     * 
     */
    create<T extends PurchaseOrderLineCreateArgs>(args: SelectSubset<T, PurchaseOrderLineCreateArgs<ExtArgs>>): Prisma__PurchaseOrderLineClient<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseOrderLines.
     * @param {PurchaseOrderLineCreateManyArgs} args - Arguments to create many PurchaseOrderLines.
     * @example
     * // Create many PurchaseOrderLines
     * const purchaseOrderLine = await prisma.purchaseOrderLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseOrderLineCreateManyArgs>(args?: SelectSubset<T, PurchaseOrderLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseOrderLines and returns the data saved in the database.
     * @param {PurchaseOrderLineCreateManyAndReturnArgs} args - Arguments to create many PurchaseOrderLines.
     * @example
     * // Create many PurchaseOrderLines
     * const purchaseOrderLine = await prisma.purchaseOrderLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseOrderLines and only return the `id`
     * const purchaseOrderLineWithIdOnly = await prisma.purchaseOrderLine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseOrderLineCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseOrderLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseOrderLine.
     * @param {PurchaseOrderLineDeleteArgs} args - Arguments to delete one PurchaseOrderLine.
     * @example
     * // Delete one PurchaseOrderLine
     * const PurchaseOrderLine = await prisma.purchaseOrderLine.delete({
     *   where: {
     *     // ... filter to delete one PurchaseOrderLine
     *   }
     * })
     * 
     */
    delete<T extends PurchaseOrderLineDeleteArgs>(args: SelectSubset<T, PurchaseOrderLineDeleteArgs<ExtArgs>>): Prisma__PurchaseOrderLineClient<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseOrderLine.
     * @param {PurchaseOrderLineUpdateArgs} args - Arguments to update one PurchaseOrderLine.
     * @example
     * // Update one PurchaseOrderLine
     * const purchaseOrderLine = await prisma.purchaseOrderLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseOrderLineUpdateArgs>(args: SelectSubset<T, PurchaseOrderLineUpdateArgs<ExtArgs>>): Prisma__PurchaseOrderLineClient<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseOrderLines.
     * @param {PurchaseOrderLineDeleteManyArgs} args - Arguments to filter PurchaseOrderLines to delete.
     * @example
     * // Delete a few PurchaseOrderLines
     * const { count } = await prisma.purchaseOrderLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseOrderLineDeleteManyArgs>(args?: SelectSubset<T, PurchaseOrderLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrderLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseOrderLines
     * const purchaseOrderLine = await prisma.purchaseOrderLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseOrderLineUpdateManyArgs>(args: SelectSubset<T, PurchaseOrderLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrderLines and returns the data updated in the database.
     * @param {PurchaseOrderLineUpdateManyAndReturnArgs} args - Arguments to update many PurchaseOrderLines.
     * @example
     * // Update many PurchaseOrderLines
     * const purchaseOrderLine = await prisma.purchaseOrderLine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseOrderLines and only return the `id`
     * const purchaseOrderLineWithIdOnly = await prisma.purchaseOrderLine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseOrderLineUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseOrderLineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseOrderLine.
     * @param {PurchaseOrderLineUpsertArgs} args - Arguments to update or create a PurchaseOrderLine.
     * @example
     * // Update or create a PurchaseOrderLine
     * const purchaseOrderLine = await prisma.purchaseOrderLine.upsert({
     *   create: {
     *     // ... data to create a PurchaseOrderLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseOrderLine we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseOrderLineUpsertArgs>(args: SelectSubset<T, PurchaseOrderLineUpsertArgs<ExtArgs>>): Prisma__PurchaseOrderLineClient<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseOrderLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderLineCountArgs} args - Arguments to filter PurchaseOrderLines to count.
     * @example
     * // Count the number of PurchaseOrderLines
     * const count = await prisma.purchaseOrderLine.count({
     *   where: {
     *     // ... the filter for the PurchaseOrderLines we want to count
     *   }
     * })
    **/
    count<T extends PurchaseOrderLineCountArgs>(
      args?: Subset<T, PurchaseOrderLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseOrderLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseOrderLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseOrderLineAggregateArgs>(args: Subset<T, PurchaseOrderLineAggregateArgs>): Prisma.PrismaPromise<GetPurchaseOrderLineAggregateType<T>>

    /**
     * Group by PurchaseOrderLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseOrderLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseOrderLineGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseOrderLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseOrderLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseOrderLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseOrderLine model
   */
  readonly fields: PurchaseOrderLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseOrderLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseOrderLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends PurchaseOrderLogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrderLogDefaultArgs<ExtArgs>>): Prisma__PurchaseOrderLogClient<$Result.GetResult<Prisma.$PurchaseOrderLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    baseline<T extends PurchaseOrderLine$baselineArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrderLine$baselineArgs<ExtArgs>>): Prisma__QuotationBaselineItemClient<$Result.GetResult<Prisma.$QuotationBaselineItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    deliveries<T extends PurchaseOrderLine$deliveriesArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrderLine$deliveriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseDeliveryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseOrderLine model
   */
  interface PurchaseOrderLineFieldRefs {
    readonly id: FieldRef<"PurchaseOrderLine", 'Int'>
    readonly orderId: FieldRef<"PurchaseOrderLine", 'Int'>
    readonly baselineId: FieldRef<"PurchaseOrderLine", 'Int'>
    readonly description: FieldRef<"PurchaseOrderLine", 'String'>
    readonly unit: FieldRef<"PurchaseOrderLine", 'String'>
    readonly quantity: FieldRef<"PurchaseOrderLine", 'Decimal'>
    readonly unitPrice: FieldRef<"PurchaseOrderLine", 'Decimal'>
    readonly totalPrice: FieldRef<"PurchaseOrderLine", 'Decimal'>
    readonly metadata: FieldRef<"PurchaseOrderLine", 'Json'>
    readonly createdAt: FieldRef<"PurchaseOrderLine", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseOrderLine", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseOrderLine findUnique
   */
  export type PurchaseOrderLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderLine to fetch.
     */
    where: PurchaseOrderLineWhereUniqueInput
  }

  /**
   * PurchaseOrderLine findUniqueOrThrow
   */
  export type PurchaseOrderLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderLine to fetch.
     */
    where: PurchaseOrderLineWhereUniqueInput
  }

  /**
   * PurchaseOrderLine findFirst
   */
  export type PurchaseOrderLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderLine to fetch.
     */
    where?: PurchaseOrderLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderLines to fetch.
     */
    orderBy?: PurchaseOrderLineOrderByWithRelationInput | PurchaseOrderLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrderLines.
     */
    cursor?: PurchaseOrderLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrderLines.
     */
    distinct?: PurchaseOrderLineScalarFieldEnum | PurchaseOrderLineScalarFieldEnum[]
  }

  /**
   * PurchaseOrderLine findFirstOrThrow
   */
  export type PurchaseOrderLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderLine to fetch.
     */
    where?: PurchaseOrderLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderLines to fetch.
     */
    orderBy?: PurchaseOrderLineOrderByWithRelationInput | PurchaseOrderLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrderLines.
     */
    cursor?: PurchaseOrderLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrderLines.
     */
    distinct?: PurchaseOrderLineScalarFieldEnum | PurchaseOrderLineScalarFieldEnum[]
  }

  /**
   * PurchaseOrderLine findMany
   */
  export type PurchaseOrderLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderLines to fetch.
     */
    where?: PurchaseOrderLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderLines to fetch.
     */
    orderBy?: PurchaseOrderLineOrderByWithRelationInput | PurchaseOrderLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseOrderLines.
     */
    cursor?: PurchaseOrderLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderLines.
     */
    skip?: number
    distinct?: PurchaseOrderLineScalarFieldEnum | PurchaseOrderLineScalarFieldEnum[]
  }

  /**
   * PurchaseOrderLine create
   */
  export type PurchaseOrderLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseOrderLine.
     */
    data: XOR<PurchaseOrderLineCreateInput, PurchaseOrderLineUncheckedCreateInput>
  }

  /**
   * PurchaseOrderLine createMany
   */
  export type PurchaseOrderLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseOrderLines.
     */
    data: PurchaseOrderLineCreateManyInput | PurchaseOrderLineCreateManyInput[]
  }

  /**
   * PurchaseOrderLine createManyAndReturn
   */
  export type PurchaseOrderLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseOrderLines.
     */
    data: PurchaseOrderLineCreateManyInput | PurchaseOrderLineCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrderLine update
   */
  export type PurchaseOrderLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseOrderLine.
     */
    data: XOR<PurchaseOrderLineUpdateInput, PurchaseOrderLineUncheckedUpdateInput>
    /**
     * Choose, which PurchaseOrderLine to update.
     */
    where: PurchaseOrderLineWhereUniqueInput
  }

  /**
   * PurchaseOrderLine updateMany
   */
  export type PurchaseOrderLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseOrderLines.
     */
    data: XOR<PurchaseOrderLineUpdateManyMutationInput, PurchaseOrderLineUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrderLines to update
     */
    where?: PurchaseOrderLineWhereInput
    /**
     * Limit how many PurchaseOrderLines to update.
     */
    limit?: number
  }

  /**
   * PurchaseOrderLine updateManyAndReturn
   */
  export type PurchaseOrderLineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseOrderLines.
     */
    data: XOR<PurchaseOrderLineUpdateManyMutationInput, PurchaseOrderLineUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrderLines to update
     */
    where?: PurchaseOrderLineWhereInput
    /**
     * Limit how many PurchaseOrderLines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrderLine upsert
   */
  export type PurchaseOrderLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseOrderLine to update in case it exists.
     */
    where: PurchaseOrderLineWhereUniqueInput
    /**
     * In case the PurchaseOrderLine found by the `where` argument doesn't exist, create a new PurchaseOrderLine with this data.
     */
    create: XOR<PurchaseOrderLineCreateInput, PurchaseOrderLineUncheckedCreateInput>
    /**
     * In case the PurchaseOrderLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseOrderLineUpdateInput, PurchaseOrderLineUncheckedUpdateInput>
  }

  /**
   * PurchaseOrderLine delete
   */
  export type PurchaseOrderLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    /**
     * Filter which PurchaseOrderLine to delete.
     */
    where: PurchaseOrderLineWhereUniqueInput
  }

  /**
   * PurchaseOrderLine deleteMany
   */
  export type PurchaseOrderLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrderLines to delete
     */
    where?: PurchaseOrderLineWhereInput
    /**
     * Limit how many PurchaseOrderLines to delete.
     */
    limit?: number
  }

  /**
   * PurchaseOrderLine.baseline
   */
  export type PurchaseOrderLine$baselineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationBaselineItem
     */
    select?: QuotationBaselineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationBaselineItem
     */
    omit?: QuotationBaselineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationBaselineItemInclude<ExtArgs> | null
    where?: QuotationBaselineItemWhereInput
  }

  /**
   * PurchaseOrderLine.deliveries
   */
  export type PurchaseOrderLine$deliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseDeliveryItem
     */
    select?: PurchaseDeliveryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseDeliveryItem
     */
    omit?: PurchaseDeliveryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseDeliveryItemInclude<ExtArgs> | null
    where?: PurchaseDeliveryItemWhereInput
    orderBy?: PurchaseDeliveryItemOrderByWithRelationInput | PurchaseDeliveryItemOrderByWithRelationInput[]
    cursor?: PurchaseDeliveryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseDeliveryItemScalarFieldEnum | PurchaseDeliveryItemScalarFieldEnum[]
  }

  /**
   * PurchaseOrderLine without action
   */
  export type PurchaseOrderLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseDeliveryLog
   */

  export type AggregatePurchaseDeliveryLog = {
    _count: PurchaseDeliveryLogCountAggregateOutputType | null
    _avg: PurchaseDeliveryLogAvgAggregateOutputType | null
    _sum: PurchaseDeliveryLogSumAggregateOutputType | null
    _min: PurchaseDeliveryLogMinAggregateOutputType | null
    _max: PurchaseDeliveryLogMaxAggregateOutputType | null
  }

  export type PurchaseDeliveryLogAvgAggregateOutputType = {
    id: number | null
    processId: number | null
    orderId: number | null
    proveedorId: number | null
  }

  export type PurchaseDeliveryLogSumAggregateOutputType = {
    id: number | null
    processId: number | null
    orderId: number | null
    proveedorId: number | null
  }

  export type PurchaseDeliveryLogMinAggregateOutputType = {
    id: number | null
    processId: number | null
    orderId: number | null
    proveedorId: number | null
    supplierName: string | null
    guideNumber: string | null
    date: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseDeliveryLogMaxAggregateOutputType = {
    id: number | null
    processId: number | null
    orderId: number | null
    proveedorId: number | null
    supplierName: string | null
    guideNumber: string | null
    date: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseDeliveryLogCountAggregateOutputType = {
    id: number
    processId: number
    orderId: number
    proveedorId: number
    supplierName: number
    guideNumber: number
    date: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseDeliveryLogAvgAggregateInputType = {
    id?: true
    processId?: true
    orderId?: true
    proveedorId?: true
  }

  export type PurchaseDeliveryLogSumAggregateInputType = {
    id?: true
    processId?: true
    orderId?: true
    proveedorId?: true
  }

  export type PurchaseDeliveryLogMinAggregateInputType = {
    id?: true
    processId?: true
    orderId?: true
    proveedorId?: true
    supplierName?: true
    guideNumber?: true
    date?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseDeliveryLogMaxAggregateInputType = {
    id?: true
    processId?: true
    orderId?: true
    proveedorId?: true
    supplierName?: true
    guideNumber?: true
    date?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseDeliveryLogCountAggregateInputType = {
    id?: true
    processId?: true
    orderId?: true
    proveedorId?: true
    supplierName?: true
    guideNumber?: true
    date?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseDeliveryLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseDeliveryLog to aggregate.
     */
    where?: PurchaseDeliveryLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseDeliveryLogs to fetch.
     */
    orderBy?: PurchaseDeliveryLogOrderByWithRelationInput | PurchaseDeliveryLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseDeliveryLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseDeliveryLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseDeliveryLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseDeliveryLogs
    **/
    _count?: true | PurchaseDeliveryLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseDeliveryLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseDeliveryLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseDeliveryLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseDeliveryLogMaxAggregateInputType
  }

  export type GetPurchaseDeliveryLogAggregateType<T extends PurchaseDeliveryLogAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseDeliveryLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseDeliveryLog[P]>
      : GetScalarType<T[P], AggregatePurchaseDeliveryLog[P]>
  }




  export type PurchaseDeliveryLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseDeliveryLogWhereInput
    orderBy?: PurchaseDeliveryLogOrderByWithAggregationInput | PurchaseDeliveryLogOrderByWithAggregationInput[]
    by: PurchaseDeliveryLogScalarFieldEnum[] | PurchaseDeliveryLogScalarFieldEnum
    having?: PurchaseDeliveryLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseDeliveryLogCountAggregateInputType | true
    _avg?: PurchaseDeliveryLogAvgAggregateInputType
    _sum?: PurchaseDeliveryLogSumAggregateInputType
    _min?: PurchaseDeliveryLogMinAggregateInputType
    _max?: PurchaseDeliveryLogMaxAggregateInputType
  }

  export type PurchaseDeliveryLogGroupByOutputType = {
    id: number
    processId: number
    orderId: number | null
    proveedorId: number | null
    supplierName: string | null
    guideNumber: string | null
    date: Date
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: PurchaseDeliveryLogCountAggregateOutputType | null
    _avg: PurchaseDeliveryLogAvgAggregateOutputType | null
    _sum: PurchaseDeliveryLogSumAggregateOutputType | null
    _min: PurchaseDeliveryLogMinAggregateOutputType | null
    _max: PurchaseDeliveryLogMaxAggregateOutputType | null
  }

  type GetPurchaseDeliveryLogGroupByPayload<T extends PurchaseDeliveryLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseDeliveryLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseDeliveryLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseDeliveryLogGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseDeliveryLogGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseDeliveryLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    processId?: boolean
    orderId?: boolean
    proveedorId?: boolean
    supplierName?: boolean
    guideNumber?: boolean
    date?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    process?: boolean | QuotationProcessDefaultArgs<ExtArgs>
    order?: boolean | PurchaseDeliveryLog$orderArgs<ExtArgs>
    proveedor?: boolean | PurchaseDeliveryLog$proveedorArgs<ExtArgs>
    items?: boolean | PurchaseDeliveryLog$itemsArgs<ExtArgs>
    _count?: boolean | PurchaseDeliveryLogCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseDeliveryLog"]>

  export type PurchaseDeliveryLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    processId?: boolean
    orderId?: boolean
    proveedorId?: boolean
    supplierName?: boolean
    guideNumber?: boolean
    date?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    process?: boolean | QuotationProcessDefaultArgs<ExtArgs>
    order?: boolean | PurchaseDeliveryLog$orderArgs<ExtArgs>
    proveedor?: boolean | PurchaseDeliveryLog$proveedorArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseDeliveryLog"]>

  export type PurchaseDeliveryLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    processId?: boolean
    orderId?: boolean
    proveedorId?: boolean
    supplierName?: boolean
    guideNumber?: boolean
    date?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    process?: boolean | QuotationProcessDefaultArgs<ExtArgs>
    order?: boolean | PurchaseDeliveryLog$orderArgs<ExtArgs>
    proveedor?: boolean | PurchaseDeliveryLog$proveedorArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseDeliveryLog"]>

  export type PurchaseDeliveryLogSelectScalar = {
    id?: boolean
    processId?: boolean
    orderId?: boolean
    proveedorId?: boolean
    supplierName?: boolean
    guideNumber?: boolean
    date?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseDeliveryLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "processId" | "orderId" | "proveedorId" | "supplierName" | "guideNumber" | "date" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["purchaseDeliveryLog"]>
  export type PurchaseDeliveryLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    process?: boolean | QuotationProcessDefaultArgs<ExtArgs>
    order?: boolean | PurchaseDeliveryLog$orderArgs<ExtArgs>
    proveedor?: boolean | PurchaseDeliveryLog$proveedorArgs<ExtArgs>
    items?: boolean | PurchaseDeliveryLog$itemsArgs<ExtArgs>
    _count?: boolean | PurchaseDeliveryLogCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchaseDeliveryLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    process?: boolean | QuotationProcessDefaultArgs<ExtArgs>
    order?: boolean | PurchaseDeliveryLog$orderArgs<ExtArgs>
    proveedor?: boolean | PurchaseDeliveryLog$proveedorArgs<ExtArgs>
  }
  export type PurchaseDeliveryLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    process?: boolean | QuotationProcessDefaultArgs<ExtArgs>
    order?: boolean | PurchaseDeliveryLog$orderArgs<ExtArgs>
    proveedor?: boolean | PurchaseDeliveryLog$proveedorArgs<ExtArgs>
  }

  export type $PurchaseDeliveryLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseDeliveryLog"
    objects: {
      process: Prisma.$QuotationProcessPayload<ExtArgs>
      order: Prisma.$PurchaseOrderLogPayload<ExtArgs> | null
      proveedor: Prisma.$ProveedorPayload<ExtArgs> | null
      items: Prisma.$PurchaseDeliveryItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      processId: number
      orderId: number | null
      proveedorId: number | null
      supplierName: string | null
      guideNumber: string | null
      date: Date
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchaseDeliveryLog"]>
    composites: {}
  }

  type PurchaseDeliveryLogGetPayload<S extends boolean | null | undefined | PurchaseDeliveryLogDefaultArgs> = $Result.GetResult<Prisma.$PurchaseDeliveryLogPayload, S>

  type PurchaseDeliveryLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseDeliveryLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseDeliveryLogCountAggregateInputType | true
    }

  export interface PurchaseDeliveryLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseDeliveryLog'], meta: { name: 'PurchaseDeliveryLog' } }
    /**
     * Find zero or one PurchaseDeliveryLog that matches the filter.
     * @param {PurchaseDeliveryLogFindUniqueArgs} args - Arguments to find a PurchaseDeliveryLog
     * @example
     * // Get one PurchaseDeliveryLog
     * const purchaseDeliveryLog = await prisma.purchaseDeliveryLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseDeliveryLogFindUniqueArgs>(args: SelectSubset<T, PurchaseDeliveryLogFindUniqueArgs<ExtArgs>>): Prisma__PurchaseDeliveryLogClient<$Result.GetResult<Prisma.$PurchaseDeliveryLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseDeliveryLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseDeliveryLogFindUniqueOrThrowArgs} args - Arguments to find a PurchaseDeliveryLog
     * @example
     * // Get one PurchaseDeliveryLog
     * const purchaseDeliveryLog = await prisma.purchaseDeliveryLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseDeliveryLogFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseDeliveryLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseDeliveryLogClient<$Result.GetResult<Prisma.$PurchaseDeliveryLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseDeliveryLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseDeliveryLogFindFirstArgs} args - Arguments to find a PurchaseDeliveryLog
     * @example
     * // Get one PurchaseDeliveryLog
     * const purchaseDeliveryLog = await prisma.purchaseDeliveryLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseDeliveryLogFindFirstArgs>(args?: SelectSubset<T, PurchaseDeliveryLogFindFirstArgs<ExtArgs>>): Prisma__PurchaseDeliveryLogClient<$Result.GetResult<Prisma.$PurchaseDeliveryLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseDeliveryLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseDeliveryLogFindFirstOrThrowArgs} args - Arguments to find a PurchaseDeliveryLog
     * @example
     * // Get one PurchaseDeliveryLog
     * const purchaseDeliveryLog = await prisma.purchaseDeliveryLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseDeliveryLogFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseDeliveryLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseDeliveryLogClient<$Result.GetResult<Prisma.$PurchaseDeliveryLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseDeliveryLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseDeliveryLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseDeliveryLogs
     * const purchaseDeliveryLogs = await prisma.purchaseDeliveryLog.findMany()
     * 
     * // Get first 10 PurchaseDeliveryLogs
     * const purchaseDeliveryLogs = await prisma.purchaseDeliveryLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseDeliveryLogWithIdOnly = await prisma.purchaseDeliveryLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseDeliveryLogFindManyArgs>(args?: SelectSubset<T, PurchaseDeliveryLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseDeliveryLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseDeliveryLog.
     * @param {PurchaseDeliveryLogCreateArgs} args - Arguments to create a PurchaseDeliveryLog.
     * @example
     * // Create one PurchaseDeliveryLog
     * const PurchaseDeliveryLog = await prisma.purchaseDeliveryLog.create({
     *   data: {
     *     // ... data to create a PurchaseDeliveryLog
     *   }
     * })
     * 
     */
    create<T extends PurchaseDeliveryLogCreateArgs>(args: SelectSubset<T, PurchaseDeliveryLogCreateArgs<ExtArgs>>): Prisma__PurchaseDeliveryLogClient<$Result.GetResult<Prisma.$PurchaseDeliveryLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseDeliveryLogs.
     * @param {PurchaseDeliveryLogCreateManyArgs} args - Arguments to create many PurchaseDeliveryLogs.
     * @example
     * // Create many PurchaseDeliveryLogs
     * const purchaseDeliveryLog = await prisma.purchaseDeliveryLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseDeliveryLogCreateManyArgs>(args?: SelectSubset<T, PurchaseDeliveryLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseDeliveryLogs and returns the data saved in the database.
     * @param {PurchaseDeliveryLogCreateManyAndReturnArgs} args - Arguments to create many PurchaseDeliveryLogs.
     * @example
     * // Create many PurchaseDeliveryLogs
     * const purchaseDeliveryLog = await prisma.purchaseDeliveryLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseDeliveryLogs and only return the `id`
     * const purchaseDeliveryLogWithIdOnly = await prisma.purchaseDeliveryLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseDeliveryLogCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseDeliveryLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseDeliveryLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseDeliveryLog.
     * @param {PurchaseDeliveryLogDeleteArgs} args - Arguments to delete one PurchaseDeliveryLog.
     * @example
     * // Delete one PurchaseDeliveryLog
     * const PurchaseDeliveryLog = await prisma.purchaseDeliveryLog.delete({
     *   where: {
     *     // ... filter to delete one PurchaseDeliveryLog
     *   }
     * })
     * 
     */
    delete<T extends PurchaseDeliveryLogDeleteArgs>(args: SelectSubset<T, PurchaseDeliveryLogDeleteArgs<ExtArgs>>): Prisma__PurchaseDeliveryLogClient<$Result.GetResult<Prisma.$PurchaseDeliveryLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseDeliveryLog.
     * @param {PurchaseDeliveryLogUpdateArgs} args - Arguments to update one PurchaseDeliveryLog.
     * @example
     * // Update one PurchaseDeliveryLog
     * const purchaseDeliveryLog = await prisma.purchaseDeliveryLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseDeliveryLogUpdateArgs>(args: SelectSubset<T, PurchaseDeliveryLogUpdateArgs<ExtArgs>>): Prisma__PurchaseDeliveryLogClient<$Result.GetResult<Prisma.$PurchaseDeliveryLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseDeliveryLogs.
     * @param {PurchaseDeliveryLogDeleteManyArgs} args - Arguments to filter PurchaseDeliveryLogs to delete.
     * @example
     * // Delete a few PurchaseDeliveryLogs
     * const { count } = await prisma.purchaseDeliveryLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseDeliveryLogDeleteManyArgs>(args?: SelectSubset<T, PurchaseDeliveryLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseDeliveryLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseDeliveryLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseDeliveryLogs
     * const purchaseDeliveryLog = await prisma.purchaseDeliveryLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseDeliveryLogUpdateManyArgs>(args: SelectSubset<T, PurchaseDeliveryLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseDeliveryLogs and returns the data updated in the database.
     * @param {PurchaseDeliveryLogUpdateManyAndReturnArgs} args - Arguments to update many PurchaseDeliveryLogs.
     * @example
     * // Update many PurchaseDeliveryLogs
     * const purchaseDeliveryLog = await prisma.purchaseDeliveryLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseDeliveryLogs and only return the `id`
     * const purchaseDeliveryLogWithIdOnly = await prisma.purchaseDeliveryLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseDeliveryLogUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseDeliveryLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseDeliveryLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseDeliveryLog.
     * @param {PurchaseDeliveryLogUpsertArgs} args - Arguments to update or create a PurchaseDeliveryLog.
     * @example
     * // Update or create a PurchaseDeliveryLog
     * const purchaseDeliveryLog = await prisma.purchaseDeliveryLog.upsert({
     *   create: {
     *     // ... data to create a PurchaseDeliveryLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseDeliveryLog we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseDeliveryLogUpsertArgs>(args: SelectSubset<T, PurchaseDeliveryLogUpsertArgs<ExtArgs>>): Prisma__PurchaseDeliveryLogClient<$Result.GetResult<Prisma.$PurchaseDeliveryLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseDeliveryLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseDeliveryLogCountArgs} args - Arguments to filter PurchaseDeliveryLogs to count.
     * @example
     * // Count the number of PurchaseDeliveryLogs
     * const count = await prisma.purchaseDeliveryLog.count({
     *   where: {
     *     // ... the filter for the PurchaseDeliveryLogs we want to count
     *   }
     * })
    **/
    count<T extends PurchaseDeliveryLogCountArgs>(
      args?: Subset<T, PurchaseDeliveryLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseDeliveryLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseDeliveryLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseDeliveryLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseDeliveryLogAggregateArgs>(args: Subset<T, PurchaseDeliveryLogAggregateArgs>): Prisma.PrismaPromise<GetPurchaseDeliveryLogAggregateType<T>>

    /**
     * Group by PurchaseDeliveryLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseDeliveryLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseDeliveryLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseDeliveryLogGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseDeliveryLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseDeliveryLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseDeliveryLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseDeliveryLog model
   */
  readonly fields: PurchaseDeliveryLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseDeliveryLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseDeliveryLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    process<T extends QuotationProcessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuotationProcessDefaultArgs<ExtArgs>>): Prisma__QuotationProcessClient<$Result.GetResult<Prisma.$QuotationProcessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order<T extends PurchaseDeliveryLog$orderArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseDeliveryLog$orderArgs<ExtArgs>>): Prisma__PurchaseOrderLogClient<$Result.GetResult<Prisma.$PurchaseOrderLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    proveedor<T extends PurchaseDeliveryLog$proveedorArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseDeliveryLog$proveedorArgs<ExtArgs>>): Prisma__ProveedorClient<$Result.GetResult<Prisma.$ProveedorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends PurchaseDeliveryLog$itemsArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseDeliveryLog$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseDeliveryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseDeliveryLog model
   */
  interface PurchaseDeliveryLogFieldRefs {
    readonly id: FieldRef<"PurchaseDeliveryLog", 'Int'>
    readonly processId: FieldRef<"PurchaseDeliveryLog", 'Int'>
    readonly orderId: FieldRef<"PurchaseDeliveryLog", 'Int'>
    readonly proveedorId: FieldRef<"PurchaseDeliveryLog", 'Int'>
    readonly supplierName: FieldRef<"PurchaseDeliveryLog", 'String'>
    readonly guideNumber: FieldRef<"PurchaseDeliveryLog", 'String'>
    readonly date: FieldRef<"PurchaseDeliveryLog", 'DateTime'>
    readonly notes: FieldRef<"PurchaseDeliveryLog", 'String'>
    readonly createdAt: FieldRef<"PurchaseDeliveryLog", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseDeliveryLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseDeliveryLog findUnique
   */
  export type PurchaseDeliveryLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseDeliveryLog
     */
    select?: PurchaseDeliveryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseDeliveryLog
     */
    omit?: PurchaseDeliveryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseDeliveryLogInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseDeliveryLog to fetch.
     */
    where: PurchaseDeliveryLogWhereUniqueInput
  }

  /**
   * PurchaseDeliveryLog findUniqueOrThrow
   */
  export type PurchaseDeliveryLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseDeliveryLog
     */
    select?: PurchaseDeliveryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseDeliveryLog
     */
    omit?: PurchaseDeliveryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseDeliveryLogInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseDeliveryLog to fetch.
     */
    where: PurchaseDeliveryLogWhereUniqueInput
  }

  /**
   * PurchaseDeliveryLog findFirst
   */
  export type PurchaseDeliveryLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseDeliveryLog
     */
    select?: PurchaseDeliveryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseDeliveryLog
     */
    omit?: PurchaseDeliveryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseDeliveryLogInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseDeliveryLog to fetch.
     */
    where?: PurchaseDeliveryLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseDeliveryLogs to fetch.
     */
    orderBy?: PurchaseDeliveryLogOrderByWithRelationInput | PurchaseDeliveryLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseDeliveryLogs.
     */
    cursor?: PurchaseDeliveryLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseDeliveryLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseDeliveryLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseDeliveryLogs.
     */
    distinct?: PurchaseDeliveryLogScalarFieldEnum | PurchaseDeliveryLogScalarFieldEnum[]
  }

  /**
   * PurchaseDeliveryLog findFirstOrThrow
   */
  export type PurchaseDeliveryLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseDeliveryLog
     */
    select?: PurchaseDeliveryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseDeliveryLog
     */
    omit?: PurchaseDeliveryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseDeliveryLogInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseDeliveryLog to fetch.
     */
    where?: PurchaseDeliveryLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseDeliveryLogs to fetch.
     */
    orderBy?: PurchaseDeliveryLogOrderByWithRelationInput | PurchaseDeliveryLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseDeliveryLogs.
     */
    cursor?: PurchaseDeliveryLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseDeliveryLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseDeliveryLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseDeliveryLogs.
     */
    distinct?: PurchaseDeliveryLogScalarFieldEnum | PurchaseDeliveryLogScalarFieldEnum[]
  }

  /**
   * PurchaseDeliveryLog findMany
   */
  export type PurchaseDeliveryLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseDeliveryLog
     */
    select?: PurchaseDeliveryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseDeliveryLog
     */
    omit?: PurchaseDeliveryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseDeliveryLogInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseDeliveryLogs to fetch.
     */
    where?: PurchaseDeliveryLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseDeliveryLogs to fetch.
     */
    orderBy?: PurchaseDeliveryLogOrderByWithRelationInput | PurchaseDeliveryLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseDeliveryLogs.
     */
    cursor?: PurchaseDeliveryLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseDeliveryLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseDeliveryLogs.
     */
    skip?: number
    distinct?: PurchaseDeliveryLogScalarFieldEnum | PurchaseDeliveryLogScalarFieldEnum[]
  }

  /**
   * PurchaseDeliveryLog create
   */
  export type PurchaseDeliveryLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseDeliveryLog
     */
    select?: PurchaseDeliveryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseDeliveryLog
     */
    omit?: PurchaseDeliveryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseDeliveryLogInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseDeliveryLog.
     */
    data: XOR<PurchaseDeliveryLogCreateInput, PurchaseDeliveryLogUncheckedCreateInput>
  }

  /**
   * PurchaseDeliveryLog createMany
   */
  export type PurchaseDeliveryLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseDeliveryLogs.
     */
    data: PurchaseDeliveryLogCreateManyInput | PurchaseDeliveryLogCreateManyInput[]
  }

  /**
   * PurchaseDeliveryLog createManyAndReturn
   */
  export type PurchaseDeliveryLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseDeliveryLog
     */
    select?: PurchaseDeliveryLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseDeliveryLog
     */
    omit?: PurchaseDeliveryLogOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseDeliveryLogs.
     */
    data: PurchaseDeliveryLogCreateManyInput | PurchaseDeliveryLogCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseDeliveryLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseDeliveryLog update
   */
  export type PurchaseDeliveryLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseDeliveryLog
     */
    select?: PurchaseDeliveryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseDeliveryLog
     */
    omit?: PurchaseDeliveryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseDeliveryLogInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseDeliveryLog.
     */
    data: XOR<PurchaseDeliveryLogUpdateInput, PurchaseDeliveryLogUncheckedUpdateInput>
    /**
     * Choose, which PurchaseDeliveryLog to update.
     */
    where: PurchaseDeliveryLogWhereUniqueInput
  }

  /**
   * PurchaseDeliveryLog updateMany
   */
  export type PurchaseDeliveryLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseDeliveryLogs.
     */
    data: XOR<PurchaseDeliveryLogUpdateManyMutationInput, PurchaseDeliveryLogUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseDeliveryLogs to update
     */
    where?: PurchaseDeliveryLogWhereInput
    /**
     * Limit how many PurchaseDeliveryLogs to update.
     */
    limit?: number
  }

  /**
   * PurchaseDeliveryLog updateManyAndReturn
   */
  export type PurchaseDeliveryLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseDeliveryLog
     */
    select?: PurchaseDeliveryLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseDeliveryLog
     */
    omit?: PurchaseDeliveryLogOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseDeliveryLogs.
     */
    data: XOR<PurchaseDeliveryLogUpdateManyMutationInput, PurchaseDeliveryLogUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseDeliveryLogs to update
     */
    where?: PurchaseDeliveryLogWhereInput
    /**
     * Limit how many PurchaseDeliveryLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseDeliveryLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseDeliveryLog upsert
   */
  export type PurchaseDeliveryLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseDeliveryLog
     */
    select?: PurchaseDeliveryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseDeliveryLog
     */
    omit?: PurchaseDeliveryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseDeliveryLogInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseDeliveryLog to update in case it exists.
     */
    where: PurchaseDeliveryLogWhereUniqueInput
    /**
     * In case the PurchaseDeliveryLog found by the `where` argument doesn't exist, create a new PurchaseDeliveryLog with this data.
     */
    create: XOR<PurchaseDeliveryLogCreateInput, PurchaseDeliveryLogUncheckedCreateInput>
    /**
     * In case the PurchaseDeliveryLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseDeliveryLogUpdateInput, PurchaseDeliveryLogUncheckedUpdateInput>
  }

  /**
   * PurchaseDeliveryLog delete
   */
  export type PurchaseDeliveryLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseDeliveryLog
     */
    select?: PurchaseDeliveryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseDeliveryLog
     */
    omit?: PurchaseDeliveryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseDeliveryLogInclude<ExtArgs> | null
    /**
     * Filter which PurchaseDeliveryLog to delete.
     */
    where: PurchaseDeliveryLogWhereUniqueInput
  }

  /**
   * PurchaseDeliveryLog deleteMany
   */
  export type PurchaseDeliveryLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseDeliveryLogs to delete
     */
    where?: PurchaseDeliveryLogWhereInput
    /**
     * Limit how many PurchaseDeliveryLogs to delete.
     */
    limit?: number
  }

  /**
   * PurchaseDeliveryLog.order
   */
  export type PurchaseDeliveryLog$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLog
     */
    select?: PurchaseOrderLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLog
     */
    omit?: PurchaseOrderLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLogInclude<ExtArgs> | null
    where?: PurchaseOrderLogWhereInput
  }

  /**
   * PurchaseDeliveryLog.proveedor
   */
  export type PurchaseDeliveryLog$proveedorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proveedor
     */
    select?: ProveedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proveedor
     */
    omit?: ProveedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProveedorInclude<ExtArgs> | null
    where?: ProveedorWhereInput
  }

  /**
   * PurchaseDeliveryLog.items
   */
  export type PurchaseDeliveryLog$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseDeliveryItem
     */
    select?: PurchaseDeliveryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseDeliveryItem
     */
    omit?: PurchaseDeliveryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseDeliveryItemInclude<ExtArgs> | null
    where?: PurchaseDeliveryItemWhereInput
    orderBy?: PurchaseDeliveryItemOrderByWithRelationInput | PurchaseDeliveryItemOrderByWithRelationInput[]
    cursor?: PurchaseDeliveryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseDeliveryItemScalarFieldEnum | PurchaseDeliveryItemScalarFieldEnum[]
  }

  /**
   * PurchaseDeliveryLog without action
   */
  export type PurchaseDeliveryLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseDeliveryLog
     */
    select?: PurchaseDeliveryLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseDeliveryLog
     */
    omit?: PurchaseDeliveryLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseDeliveryLogInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseDeliveryItem
   */

  export type AggregatePurchaseDeliveryItem = {
    _count: PurchaseDeliveryItemCountAggregateOutputType | null
    _avg: PurchaseDeliveryItemAvgAggregateOutputType | null
    _sum: PurchaseDeliveryItemSumAggregateOutputType | null
    _min: PurchaseDeliveryItemMinAggregateOutputType | null
    _max: PurchaseDeliveryItemMaxAggregateOutputType | null
  }

  export type PurchaseDeliveryItemAvgAggregateOutputType = {
    id: number | null
    deliveryId: number | null
    orderLineId: number | null
    baselineId: number | null
    quantity: Decimal | null
  }

  export type PurchaseDeliveryItemSumAggregateOutputType = {
    id: number | null
    deliveryId: number | null
    orderLineId: number | null
    baselineId: number | null
    quantity: Decimal | null
  }

  export type PurchaseDeliveryItemMinAggregateOutputType = {
    id: number | null
    deliveryId: number | null
    orderLineId: number | null
    baselineId: number | null
    description: string | null
    unit: string | null
    quantity: Decimal | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseDeliveryItemMaxAggregateOutputType = {
    id: number | null
    deliveryId: number | null
    orderLineId: number | null
    baselineId: number | null
    description: string | null
    unit: string | null
    quantity: Decimal | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseDeliveryItemCountAggregateOutputType = {
    id: number
    deliveryId: number
    orderLineId: number
    baselineId: number
    description: number
    unit: number
    quantity: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseDeliveryItemAvgAggregateInputType = {
    id?: true
    deliveryId?: true
    orderLineId?: true
    baselineId?: true
    quantity?: true
  }

  export type PurchaseDeliveryItemSumAggregateInputType = {
    id?: true
    deliveryId?: true
    orderLineId?: true
    baselineId?: true
    quantity?: true
  }

  export type PurchaseDeliveryItemMinAggregateInputType = {
    id?: true
    deliveryId?: true
    orderLineId?: true
    baselineId?: true
    description?: true
    unit?: true
    quantity?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseDeliveryItemMaxAggregateInputType = {
    id?: true
    deliveryId?: true
    orderLineId?: true
    baselineId?: true
    description?: true
    unit?: true
    quantity?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseDeliveryItemCountAggregateInputType = {
    id?: true
    deliveryId?: true
    orderLineId?: true
    baselineId?: true
    description?: true
    unit?: true
    quantity?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseDeliveryItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseDeliveryItem to aggregate.
     */
    where?: PurchaseDeliveryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseDeliveryItems to fetch.
     */
    orderBy?: PurchaseDeliveryItemOrderByWithRelationInput | PurchaseDeliveryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseDeliveryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseDeliveryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseDeliveryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseDeliveryItems
    **/
    _count?: true | PurchaseDeliveryItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseDeliveryItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseDeliveryItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseDeliveryItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseDeliveryItemMaxAggregateInputType
  }

  export type GetPurchaseDeliveryItemAggregateType<T extends PurchaseDeliveryItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseDeliveryItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseDeliveryItem[P]>
      : GetScalarType<T[P], AggregatePurchaseDeliveryItem[P]>
  }




  export type PurchaseDeliveryItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseDeliveryItemWhereInput
    orderBy?: PurchaseDeliveryItemOrderByWithAggregationInput | PurchaseDeliveryItemOrderByWithAggregationInput[]
    by: PurchaseDeliveryItemScalarFieldEnum[] | PurchaseDeliveryItemScalarFieldEnum
    having?: PurchaseDeliveryItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseDeliveryItemCountAggregateInputType | true
    _avg?: PurchaseDeliveryItemAvgAggregateInputType
    _sum?: PurchaseDeliveryItemSumAggregateInputType
    _min?: PurchaseDeliveryItemMinAggregateInputType
    _max?: PurchaseDeliveryItemMaxAggregateInputType
  }

  export type PurchaseDeliveryItemGroupByOutputType = {
    id: number
    deliveryId: number
    orderLineId: number | null
    baselineId: number | null
    description: string
    unit: string | null
    quantity: Decimal | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: PurchaseDeliveryItemCountAggregateOutputType | null
    _avg: PurchaseDeliveryItemAvgAggregateOutputType | null
    _sum: PurchaseDeliveryItemSumAggregateOutputType | null
    _min: PurchaseDeliveryItemMinAggregateOutputType | null
    _max: PurchaseDeliveryItemMaxAggregateOutputType | null
  }

  type GetPurchaseDeliveryItemGroupByPayload<T extends PurchaseDeliveryItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseDeliveryItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseDeliveryItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseDeliveryItemGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseDeliveryItemGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseDeliveryItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deliveryId?: boolean
    orderLineId?: boolean
    baselineId?: boolean
    description?: boolean
    unit?: boolean
    quantity?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    delivery?: boolean | PurchaseDeliveryLogDefaultArgs<ExtArgs>
    orderLine?: boolean | PurchaseDeliveryItem$orderLineArgs<ExtArgs>
    baseline?: boolean | PurchaseDeliveryItem$baselineArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseDeliveryItem"]>

  export type PurchaseDeliveryItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deliveryId?: boolean
    orderLineId?: boolean
    baselineId?: boolean
    description?: boolean
    unit?: boolean
    quantity?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    delivery?: boolean | PurchaseDeliveryLogDefaultArgs<ExtArgs>
    orderLine?: boolean | PurchaseDeliveryItem$orderLineArgs<ExtArgs>
    baseline?: boolean | PurchaseDeliveryItem$baselineArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseDeliveryItem"]>

  export type PurchaseDeliveryItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deliveryId?: boolean
    orderLineId?: boolean
    baselineId?: boolean
    description?: boolean
    unit?: boolean
    quantity?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    delivery?: boolean | PurchaseDeliveryLogDefaultArgs<ExtArgs>
    orderLine?: boolean | PurchaseDeliveryItem$orderLineArgs<ExtArgs>
    baseline?: boolean | PurchaseDeliveryItem$baselineArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseDeliveryItem"]>

  export type PurchaseDeliveryItemSelectScalar = {
    id?: boolean
    deliveryId?: boolean
    orderLineId?: boolean
    baselineId?: boolean
    description?: boolean
    unit?: boolean
    quantity?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseDeliveryItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "deliveryId" | "orderLineId" | "baselineId" | "description" | "unit" | "quantity" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["purchaseDeliveryItem"]>
  export type PurchaseDeliveryItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    delivery?: boolean | PurchaseDeliveryLogDefaultArgs<ExtArgs>
    orderLine?: boolean | PurchaseDeliveryItem$orderLineArgs<ExtArgs>
    baseline?: boolean | PurchaseDeliveryItem$baselineArgs<ExtArgs>
  }
  export type PurchaseDeliveryItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    delivery?: boolean | PurchaseDeliveryLogDefaultArgs<ExtArgs>
    orderLine?: boolean | PurchaseDeliveryItem$orderLineArgs<ExtArgs>
    baseline?: boolean | PurchaseDeliveryItem$baselineArgs<ExtArgs>
  }
  export type PurchaseDeliveryItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    delivery?: boolean | PurchaseDeliveryLogDefaultArgs<ExtArgs>
    orderLine?: boolean | PurchaseDeliveryItem$orderLineArgs<ExtArgs>
    baseline?: boolean | PurchaseDeliveryItem$baselineArgs<ExtArgs>
  }

  export type $PurchaseDeliveryItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseDeliveryItem"
    objects: {
      delivery: Prisma.$PurchaseDeliveryLogPayload<ExtArgs>
      orderLine: Prisma.$PurchaseOrderLinePayload<ExtArgs> | null
      baseline: Prisma.$QuotationBaselineItemPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      deliveryId: number
      orderLineId: number | null
      baselineId: number | null
      description: string
      unit: string | null
      quantity: Prisma.Decimal | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchaseDeliveryItem"]>
    composites: {}
  }

  type PurchaseDeliveryItemGetPayload<S extends boolean | null | undefined | PurchaseDeliveryItemDefaultArgs> = $Result.GetResult<Prisma.$PurchaseDeliveryItemPayload, S>

  type PurchaseDeliveryItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseDeliveryItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseDeliveryItemCountAggregateInputType | true
    }

  export interface PurchaseDeliveryItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseDeliveryItem'], meta: { name: 'PurchaseDeliveryItem' } }
    /**
     * Find zero or one PurchaseDeliveryItem that matches the filter.
     * @param {PurchaseDeliveryItemFindUniqueArgs} args - Arguments to find a PurchaseDeliveryItem
     * @example
     * // Get one PurchaseDeliveryItem
     * const purchaseDeliveryItem = await prisma.purchaseDeliveryItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseDeliveryItemFindUniqueArgs>(args: SelectSubset<T, PurchaseDeliveryItemFindUniqueArgs<ExtArgs>>): Prisma__PurchaseDeliveryItemClient<$Result.GetResult<Prisma.$PurchaseDeliveryItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseDeliveryItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseDeliveryItemFindUniqueOrThrowArgs} args - Arguments to find a PurchaseDeliveryItem
     * @example
     * // Get one PurchaseDeliveryItem
     * const purchaseDeliveryItem = await prisma.purchaseDeliveryItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseDeliveryItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseDeliveryItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseDeliveryItemClient<$Result.GetResult<Prisma.$PurchaseDeliveryItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseDeliveryItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseDeliveryItemFindFirstArgs} args - Arguments to find a PurchaseDeliveryItem
     * @example
     * // Get one PurchaseDeliveryItem
     * const purchaseDeliveryItem = await prisma.purchaseDeliveryItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseDeliveryItemFindFirstArgs>(args?: SelectSubset<T, PurchaseDeliveryItemFindFirstArgs<ExtArgs>>): Prisma__PurchaseDeliveryItemClient<$Result.GetResult<Prisma.$PurchaseDeliveryItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseDeliveryItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseDeliveryItemFindFirstOrThrowArgs} args - Arguments to find a PurchaseDeliveryItem
     * @example
     * // Get one PurchaseDeliveryItem
     * const purchaseDeliveryItem = await prisma.purchaseDeliveryItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseDeliveryItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseDeliveryItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseDeliveryItemClient<$Result.GetResult<Prisma.$PurchaseDeliveryItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseDeliveryItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseDeliveryItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseDeliveryItems
     * const purchaseDeliveryItems = await prisma.purchaseDeliveryItem.findMany()
     * 
     * // Get first 10 PurchaseDeliveryItems
     * const purchaseDeliveryItems = await prisma.purchaseDeliveryItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseDeliveryItemWithIdOnly = await prisma.purchaseDeliveryItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseDeliveryItemFindManyArgs>(args?: SelectSubset<T, PurchaseDeliveryItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseDeliveryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseDeliveryItem.
     * @param {PurchaseDeliveryItemCreateArgs} args - Arguments to create a PurchaseDeliveryItem.
     * @example
     * // Create one PurchaseDeliveryItem
     * const PurchaseDeliveryItem = await prisma.purchaseDeliveryItem.create({
     *   data: {
     *     // ... data to create a PurchaseDeliveryItem
     *   }
     * })
     * 
     */
    create<T extends PurchaseDeliveryItemCreateArgs>(args: SelectSubset<T, PurchaseDeliveryItemCreateArgs<ExtArgs>>): Prisma__PurchaseDeliveryItemClient<$Result.GetResult<Prisma.$PurchaseDeliveryItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseDeliveryItems.
     * @param {PurchaseDeliveryItemCreateManyArgs} args - Arguments to create many PurchaseDeliveryItems.
     * @example
     * // Create many PurchaseDeliveryItems
     * const purchaseDeliveryItem = await prisma.purchaseDeliveryItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseDeliveryItemCreateManyArgs>(args?: SelectSubset<T, PurchaseDeliveryItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseDeliveryItems and returns the data saved in the database.
     * @param {PurchaseDeliveryItemCreateManyAndReturnArgs} args - Arguments to create many PurchaseDeliveryItems.
     * @example
     * // Create many PurchaseDeliveryItems
     * const purchaseDeliveryItem = await prisma.purchaseDeliveryItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseDeliveryItems and only return the `id`
     * const purchaseDeliveryItemWithIdOnly = await prisma.purchaseDeliveryItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseDeliveryItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseDeliveryItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseDeliveryItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseDeliveryItem.
     * @param {PurchaseDeliveryItemDeleteArgs} args - Arguments to delete one PurchaseDeliveryItem.
     * @example
     * // Delete one PurchaseDeliveryItem
     * const PurchaseDeliveryItem = await prisma.purchaseDeliveryItem.delete({
     *   where: {
     *     // ... filter to delete one PurchaseDeliveryItem
     *   }
     * })
     * 
     */
    delete<T extends PurchaseDeliveryItemDeleteArgs>(args: SelectSubset<T, PurchaseDeliveryItemDeleteArgs<ExtArgs>>): Prisma__PurchaseDeliveryItemClient<$Result.GetResult<Prisma.$PurchaseDeliveryItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseDeliveryItem.
     * @param {PurchaseDeliveryItemUpdateArgs} args - Arguments to update one PurchaseDeliveryItem.
     * @example
     * // Update one PurchaseDeliveryItem
     * const purchaseDeliveryItem = await prisma.purchaseDeliveryItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseDeliveryItemUpdateArgs>(args: SelectSubset<T, PurchaseDeliveryItemUpdateArgs<ExtArgs>>): Prisma__PurchaseDeliveryItemClient<$Result.GetResult<Prisma.$PurchaseDeliveryItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseDeliveryItems.
     * @param {PurchaseDeliveryItemDeleteManyArgs} args - Arguments to filter PurchaseDeliveryItems to delete.
     * @example
     * // Delete a few PurchaseDeliveryItems
     * const { count } = await prisma.purchaseDeliveryItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseDeliveryItemDeleteManyArgs>(args?: SelectSubset<T, PurchaseDeliveryItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseDeliveryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseDeliveryItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseDeliveryItems
     * const purchaseDeliveryItem = await prisma.purchaseDeliveryItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseDeliveryItemUpdateManyArgs>(args: SelectSubset<T, PurchaseDeliveryItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseDeliveryItems and returns the data updated in the database.
     * @param {PurchaseDeliveryItemUpdateManyAndReturnArgs} args - Arguments to update many PurchaseDeliveryItems.
     * @example
     * // Update many PurchaseDeliveryItems
     * const purchaseDeliveryItem = await prisma.purchaseDeliveryItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseDeliveryItems and only return the `id`
     * const purchaseDeliveryItemWithIdOnly = await prisma.purchaseDeliveryItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseDeliveryItemUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseDeliveryItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseDeliveryItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseDeliveryItem.
     * @param {PurchaseDeliveryItemUpsertArgs} args - Arguments to update or create a PurchaseDeliveryItem.
     * @example
     * // Update or create a PurchaseDeliveryItem
     * const purchaseDeliveryItem = await prisma.purchaseDeliveryItem.upsert({
     *   create: {
     *     // ... data to create a PurchaseDeliveryItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseDeliveryItem we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseDeliveryItemUpsertArgs>(args: SelectSubset<T, PurchaseDeliveryItemUpsertArgs<ExtArgs>>): Prisma__PurchaseDeliveryItemClient<$Result.GetResult<Prisma.$PurchaseDeliveryItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseDeliveryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseDeliveryItemCountArgs} args - Arguments to filter PurchaseDeliveryItems to count.
     * @example
     * // Count the number of PurchaseDeliveryItems
     * const count = await prisma.purchaseDeliveryItem.count({
     *   where: {
     *     // ... the filter for the PurchaseDeliveryItems we want to count
     *   }
     * })
    **/
    count<T extends PurchaseDeliveryItemCountArgs>(
      args?: Subset<T, PurchaseDeliveryItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseDeliveryItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseDeliveryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseDeliveryItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseDeliveryItemAggregateArgs>(args: Subset<T, PurchaseDeliveryItemAggregateArgs>): Prisma.PrismaPromise<GetPurchaseDeliveryItemAggregateType<T>>

    /**
     * Group by PurchaseDeliveryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseDeliveryItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseDeliveryItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseDeliveryItemGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseDeliveryItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseDeliveryItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseDeliveryItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseDeliveryItem model
   */
  readonly fields: PurchaseDeliveryItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseDeliveryItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseDeliveryItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    delivery<T extends PurchaseDeliveryLogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseDeliveryLogDefaultArgs<ExtArgs>>): Prisma__PurchaseDeliveryLogClient<$Result.GetResult<Prisma.$PurchaseDeliveryLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    orderLine<T extends PurchaseDeliveryItem$orderLineArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseDeliveryItem$orderLineArgs<ExtArgs>>): Prisma__PurchaseOrderLineClient<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    baseline<T extends PurchaseDeliveryItem$baselineArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseDeliveryItem$baselineArgs<ExtArgs>>): Prisma__QuotationBaselineItemClient<$Result.GetResult<Prisma.$QuotationBaselineItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseDeliveryItem model
   */
  interface PurchaseDeliveryItemFieldRefs {
    readonly id: FieldRef<"PurchaseDeliveryItem", 'Int'>
    readonly deliveryId: FieldRef<"PurchaseDeliveryItem", 'Int'>
    readonly orderLineId: FieldRef<"PurchaseDeliveryItem", 'Int'>
    readonly baselineId: FieldRef<"PurchaseDeliveryItem", 'Int'>
    readonly description: FieldRef<"PurchaseDeliveryItem", 'String'>
    readonly unit: FieldRef<"PurchaseDeliveryItem", 'String'>
    readonly quantity: FieldRef<"PurchaseDeliveryItem", 'Decimal'>
    readonly notes: FieldRef<"PurchaseDeliveryItem", 'String'>
    readonly createdAt: FieldRef<"PurchaseDeliveryItem", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseDeliveryItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseDeliveryItem findUnique
   */
  export type PurchaseDeliveryItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseDeliveryItem
     */
    select?: PurchaseDeliveryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseDeliveryItem
     */
    omit?: PurchaseDeliveryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseDeliveryItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseDeliveryItem to fetch.
     */
    where: PurchaseDeliveryItemWhereUniqueInput
  }

  /**
   * PurchaseDeliveryItem findUniqueOrThrow
   */
  export type PurchaseDeliveryItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseDeliveryItem
     */
    select?: PurchaseDeliveryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseDeliveryItem
     */
    omit?: PurchaseDeliveryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseDeliveryItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseDeliveryItem to fetch.
     */
    where: PurchaseDeliveryItemWhereUniqueInput
  }

  /**
   * PurchaseDeliveryItem findFirst
   */
  export type PurchaseDeliveryItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseDeliveryItem
     */
    select?: PurchaseDeliveryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseDeliveryItem
     */
    omit?: PurchaseDeliveryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseDeliveryItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseDeliveryItem to fetch.
     */
    where?: PurchaseDeliveryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseDeliveryItems to fetch.
     */
    orderBy?: PurchaseDeliveryItemOrderByWithRelationInput | PurchaseDeliveryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseDeliveryItems.
     */
    cursor?: PurchaseDeliveryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseDeliveryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseDeliveryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseDeliveryItems.
     */
    distinct?: PurchaseDeliveryItemScalarFieldEnum | PurchaseDeliveryItemScalarFieldEnum[]
  }

  /**
   * PurchaseDeliveryItem findFirstOrThrow
   */
  export type PurchaseDeliveryItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseDeliveryItem
     */
    select?: PurchaseDeliveryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseDeliveryItem
     */
    omit?: PurchaseDeliveryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseDeliveryItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseDeliveryItem to fetch.
     */
    where?: PurchaseDeliveryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseDeliveryItems to fetch.
     */
    orderBy?: PurchaseDeliveryItemOrderByWithRelationInput | PurchaseDeliveryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseDeliveryItems.
     */
    cursor?: PurchaseDeliveryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseDeliveryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseDeliveryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseDeliveryItems.
     */
    distinct?: PurchaseDeliveryItemScalarFieldEnum | PurchaseDeliveryItemScalarFieldEnum[]
  }

  /**
   * PurchaseDeliveryItem findMany
   */
  export type PurchaseDeliveryItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseDeliveryItem
     */
    select?: PurchaseDeliveryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseDeliveryItem
     */
    omit?: PurchaseDeliveryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseDeliveryItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseDeliveryItems to fetch.
     */
    where?: PurchaseDeliveryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseDeliveryItems to fetch.
     */
    orderBy?: PurchaseDeliveryItemOrderByWithRelationInput | PurchaseDeliveryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseDeliveryItems.
     */
    cursor?: PurchaseDeliveryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseDeliveryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseDeliveryItems.
     */
    skip?: number
    distinct?: PurchaseDeliveryItemScalarFieldEnum | PurchaseDeliveryItemScalarFieldEnum[]
  }

  /**
   * PurchaseDeliveryItem create
   */
  export type PurchaseDeliveryItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseDeliveryItem
     */
    select?: PurchaseDeliveryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseDeliveryItem
     */
    omit?: PurchaseDeliveryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseDeliveryItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseDeliveryItem.
     */
    data: XOR<PurchaseDeliveryItemCreateInput, PurchaseDeliveryItemUncheckedCreateInput>
  }

  /**
   * PurchaseDeliveryItem createMany
   */
  export type PurchaseDeliveryItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseDeliveryItems.
     */
    data: PurchaseDeliveryItemCreateManyInput | PurchaseDeliveryItemCreateManyInput[]
  }

  /**
   * PurchaseDeliveryItem createManyAndReturn
   */
  export type PurchaseDeliveryItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseDeliveryItem
     */
    select?: PurchaseDeliveryItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseDeliveryItem
     */
    omit?: PurchaseDeliveryItemOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseDeliveryItems.
     */
    data: PurchaseDeliveryItemCreateManyInput | PurchaseDeliveryItemCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseDeliveryItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseDeliveryItem update
   */
  export type PurchaseDeliveryItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseDeliveryItem
     */
    select?: PurchaseDeliveryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseDeliveryItem
     */
    omit?: PurchaseDeliveryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseDeliveryItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseDeliveryItem.
     */
    data: XOR<PurchaseDeliveryItemUpdateInput, PurchaseDeliveryItemUncheckedUpdateInput>
    /**
     * Choose, which PurchaseDeliveryItem to update.
     */
    where: PurchaseDeliveryItemWhereUniqueInput
  }

  /**
   * PurchaseDeliveryItem updateMany
   */
  export type PurchaseDeliveryItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseDeliveryItems.
     */
    data: XOR<PurchaseDeliveryItemUpdateManyMutationInput, PurchaseDeliveryItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseDeliveryItems to update
     */
    where?: PurchaseDeliveryItemWhereInput
    /**
     * Limit how many PurchaseDeliveryItems to update.
     */
    limit?: number
  }

  /**
   * PurchaseDeliveryItem updateManyAndReturn
   */
  export type PurchaseDeliveryItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseDeliveryItem
     */
    select?: PurchaseDeliveryItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseDeliveryItem
     */
    omit?: PurchaseDeliveryItemOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseDeliveryItems.
     */
    data: XOR<PurchaseDeliveryItemUpdateManyMutationInput, PurchaseDeliveryItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseDeliveryItems to update
     */
    where?: PurchaseDeliveryItemWhereInput
    /**
     * Limit how many PurchaseDeliveryItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseDeliveryItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseDeliveryItem upsert
   */
  export type PurchaseDeliveryItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseDeliveryItem
     */
    select?: PurchaseDeliveryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseDeliveryItem
     */
    omit?: PurchaseDeliveryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseDeliveryItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseDeliveryItem to update in case it exists.
     */
    where: PurchaseDeliveryItemWhereUniqueInput
    /**
     * In case the PurchaseDeliveryItem found by the `where` argument doesn't exist, create a new PurchaseDeliveryItem with this data.
     */
    create: XOR<PurchaseDeliveryItemCreateInput, PurchaseDeliveryItemUncheckedCreateInput>
    /**
     * In case the PurchaseDeliveryItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseDeliveryItemUpdateInput, PurchaseDeliveryItemUncheckedUpdateInput>
  }

  /**
   * PurchaseDeliveryItem delete
   */
  export type PurchaseDeliveryItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseDeliveryItem
     */
    select?: PurchaseDeliveryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseDeliveryItem
     */
    omit?: PurchaseDeliveryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseDeliveryItemInclude<ExtArgs> | null
    /**
     * Filter which PurchaseDeliveryItem to delete.
     */
    where: PurchaseDeliveryItemWhereUniqueInput
  }

  /**
   * PurchaseDeliveryItem deleteMany
   */
  export type PurchaseDeliveryItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseDeliveryItems to delete
     */
    where?: PurchaseDeliveryItemWhereInput
    /**
     * Limit how many PurchaseDeliveryItems to delete.
     */
    limit?: number
  }

  /**
   * PurchaseDeliveryItem.orderLine
   */
  export type PurchaseDeliveryItem$orderLineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    where?: PurchaseOrderLineWhereInput
  }

  /**
   * PurchaseDeliveryItem.baseline
   */
  export type PurchaseDeliveryItem$baselineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationBaselineItem
     */
    select?: QuotationBaselineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotationBaselineItem
     */
    omit?: QuotationBaselineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationBaselineItemInclude<ExtArgs> | null
    where?: QuotationBaselineItemWhereInput
  }

  /**
   * PurchaseDeliveryItem without action
   */
  export type PurchaseDeliveryItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseDeliveryItem
     */
    select?: PurchaseDeliveryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseDeliveryItem
     */
    omit?: PurchaseDeliveryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseDeliveryItemInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ObraScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code'
  };

  export type ObraScalarFieldEnum = (typeof ObraScalarFieldEnum)[keyof typeof ObraScalarFieldEnum]


  export const MaterialScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    unit: 'unit',
    groupId: 'groupId',
    minStock: 'minStock',
    reorderQuantity: 'reorderQuantity',
    allowNegative: 'allowNegative',
    isCompanyAsset: 'isCompanyAsset',
    assetStatus: 'assetStatus',
    assetResponsible: 'assetResponsible'
  };

  export type MaterialScalarFieldEnum = (typeof MaterialScalarFieldEnum)[keyof typeof MaterialScalarFieldEnum]


  export const ProveedorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    ruc: 'ruc',
    phone: 'phone'
  };

  export type ProveedorScalarFieldEnum = (typeof ProveedorScalarFieldEnum)[keyof typeof ProveedorScalarFieldEnum]


  export const FrenteScalarFieldEnum: {
    id: 'id',
    name: 'name',
    obraId: 'obraId'
  };

  export type FrenteScalarFieldEnum = (typeof FrenteScalarFieldEnum)[keyof typeof FrenteScalarFieldEnum]


  export const MaterialGroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    parentId: 'parentId',
    color: 'color',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MaterialGroupScalarFieldEnum = (typeof MaterialGroupScalarFieldEnum)[keyof typeof MaterialGroupScalarFieldEnum]


  export const MoveScalarFieldEnum: {
    id: 'id',
    obraId: 'obraId',
    frenteId: 'frenteId',
    materialId: 'materialId',
    proveedorId: 'proveedorId',
    type: 'type',
    quantity: 'quantity',
    unitCost: 'unitCost',
    totalCost: 'totalCost',
    date: 'date',
    note: 'note',
    docType: 'docType',
    docSerie: 'docSerie',
    docNumero: 'docNumero',
    igvRate: 'igvRate',
    isTaxable: 'isTaxable',
    responsible: 'responsible',
    assetStatus: 'assetStatus'
  };

  export type MoveScalarFieldEnum = (typeof MoveScalarFieldEnum)[keyof typeof MoveScalarFieldEnum]


  export const ExpenseCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    kind: 'kind'
  };

  export type ExpenseCategoryScalarFieldEnum = (typeof ExpenseCategoryScalarFieldEnum)[keyof typeof ExpenseCategoryScalarFieldEnum]


  export const IncomeScalarFieldEnum: {
    id: 'id',
    obraId: 'obraId',
    frenteId: 'frenteId',
    date: 'date',
    description: 'description',
    docType: 'docType',
    docSerie: 'docSerie',
    docNumero: 'docNumero',
    status: 'status',
    igvRate: 'igvRate',
    isTaxable: 'isTaxable',
    base: 'base',
    igv: 'igv',
    total: 'total',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IncomeScalarFieldEnum = (typeof IncomeScalarFieldEnum)[keyof typeof IncomeScalarFieldEnum]


  export const ExpenseScalarFieldEnum: {
    id: 'id',
    obraId: 'obraId',
    frenteId: 'frenteId',
    proveedorId: 'proveedorId',
    materialId: 'materialId',
    categoryId: 'categoryId',
    moveId: 'moveId',
    docType: 'docType',
    docSerie: 'docSerie',
    docNumero: 'docNumero',
    date: 'date',
    description: 'description',
    spentBy: 'spentBy',
    type: 'type',
    variableType: 'variableType',
    quantity: 'quantity',
    unitCost: 'unitCost',
    igvRate: 'igvRate',
    isTaxable: 'isTaxable',
    base: 'base',
    igv: 'igv',
    total: 'total',
    paymentMethod: 'paymentMethod',
    paidAt: 'paidAt',
    status: 'status',
    reminderIntervalDays: 'reminderIntervalDays',
    reminderNextDate: 'reminderNextDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExpenseScalarFieldEnum = (typeof ExpenseScalarFieldEnum)[keyof typeof ExpenseScalarFieldEnum]


  export const DailyCashRenditionScalarFieldEnum: {
    id: 'id',
    date: 'date',
    obraId: 'obraId',
    openingBalance: 'openingBalance',
    received: 'received',
    spent: 'spent',
    personalContribution: 'personalContribution',
    balance: 'balance',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DailyCashRenditionScalarFieldEnum = (typeof DailyCashRenditionScalarFieldEnum)[keyof typeof DailyCashRenditionScalarFieldEnum]


  export const DailyCashExpenseScalarFieldEnum: {
    id: 'id',
    renditionId: 'renditionId',
    description: 'description',
    amount: 'amount',
    personalAmount: 'personalAmount',
    paidWithPersonal: 'paidWithPersonal',
    createdAt: 'createdAt'
  };

  export type DailyCashExpenseScalarFieldEnum = (typeof DailyCashExpenseScalarFieldEnum)[keyof typeof DailyCashExpenseScalarFieldEnum]


  export const AdminSettingScalarFieldEnum: {
    id: 'id',
    deletePasswordHash: 'deletePasswordHash',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminSettingScalarFieldEnum = (typeof AdminSettingScalarFieldEnum)[keyof typeof AdminSettingScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    firstName: 'firstName',
    lastName: 'lastName',
    documentType: 'documentType',
    documentNumber: 'documentNumber',
    position: 'position',
    phone: 'phone',
    email: 'email',
    bankType: 'bankType',
    accountNumber: 'accountNumber',
    cci: 'cci',
    startDate: 'startDate',
    endDate: 'endDate',
    baseSalary: 'baseSalary',
    dailyHours: 'dailyHours',
    pensionSystem: 'pensionSystem',
    pensionRate: 'pensionRate',
    healthRate: 'healthRate',
    isActive: 'isActive',
    area: 'area',
    obraId: 'obraId',
    notes: 'notes',
    absenceSundayPenalty: 'absenceSundayPenalty',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const EmployeeAccumulationPaymentScalarFieldEnum: {
    employeeId: 'employeeId',
    paid: 'paid',
    paidAt: 'paidAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmployeeAccumulationPaymentScalarFieldEnum = (typeof EmployeeAccumulationPaymentScalarFieldEnum)[keyof typeof EmployeeAccumulationPaymentScalarFieldEnum]


  export const AttendanceRecordScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    date: 'date',
    status: 'status',
    minutesLate: 'minutesLate',
    permissionHours: 'permissionHours',
    extraHours: 'extraHours',
    permissionPaid: 'permissionPaid',
    holidayWorked: 'holidayWorked',
    holidayCount: 'holidayCount',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AttendanceRecordScalarFieldEnum = (typeof AttendanceRecordScalarFieldEnum)[keyof typeof AttendanceRecordScalarFieldEnum]


  export const PayrollPeriodScalarFieldEnum: {
    id: 'id',
    obraId: 'obraId',
    month: 'month',
    year: 'year',
    startDate: 'startDate',
    endDate: 'endDate',
    workingDays: 'workingDays',
    status: 'status',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PayrollPeriodScalarFieldEnum = (typeof PayrollPeriodScalarFieldEnum)[keyof typeof PayrollPeriodScalarFieldEnum]


  export const PayrollEntryScalarFieldEnum: {
    id: 'id',
    periodId: 'periodId',
    employeeId: 'employeeId',
    baseSalary: 'baseSalary',
    dailyRate: 'dailyRate',
    hourlyRate: 'hourlyRate',
    workedDays: 'workedDays',
    absenceDays: 'absenceDays',
    tardinessMinutes: 'tardinessMinutes',
    permissionHours: 'permissionHours',
    overtimeHours: 'overtimeHours',
    bonusesTotal: 'bonusesTotal',
    deductionsTotal: 'deductionsTotal',
    pensionAmount: 'pensionAmount',
    healthAmount: 'healthAmount',
    grossEarnings: 'grossEarnings',
    netPay: 'netPay',
    permissionDays: 'permissionDays',
    holidayDays: 'holidayDays',
    holidayBonus: 'holidayBonus',
    details: 'details',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PayrollEntryScalarFieldEnum = (typeof PayrollEntryScalarFieldEnum)[keyof typeof PayrollEntryScalarFieldEnum]


  export const PayrollAdjustmentScalarFieldEnum: {
    id: 'id',
    entryId: 'entryId',
    type: 'type',
    concept: 'concept',
    amount: 'amount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PayrollAdjustmentScalarFieldEnum = (typeof PayrollAdjustmentScalarFieldEnum)[keyof typeof PayrollAdjustmentScalarFieldEnum]


  export const PartnerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PartnerScalarFieldEnum = (typeof PartnerScalarFieldEnum)[keyof typeof PartnerScalarFieldEnum]


  export const PartnerLoanScalarFieldEnum: {
    id: 'id',
    date: 'date',
    giverId: 'giverId',
    receiverId: 'receiverId',
    amount: 'amount',
    note: 'note',
    status: 'status',
    financeRefs: 'financeRefs',
    closeDate: 'closeDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PartnerLoanScalarFieldEnum = (typeof PartnerLoanScalarFieldEnum)[keyof typeof PartnerLoanScalarFieldEnum]


  export const FoodIngredientScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    unit: 'unit',
    defaultWastePct: 'defaultWastePct',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FoodIngredientScalarFieldEnum = (typeof FoodIngredientScalarFieldEnum)[keyof typeof FoodIngredientScalarFieldEnum]


  export const FoodIngredientCostScalarFieldEnum: {
    id: 'id',
    ingredientId: 'ingredientId',
    unitCost: 'unitCost',
    effectiveDate: 'effectiveDate',
    source: 'source',
    createdAt: 'createdAt'
  };

  export type FoodIngredientCostScalarFieldEnum = (typeof FoodIngredientCostScalarFieldEnum)[keyof typeof FoodIngredientCostScalarFieldEnum]


  export const FoodRecipeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    mealType: 'mealType',
    yield: 'yield',
    yieldUnit: 'yieldUnit',
    isActive: 'isActive',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    prepMinutes: 'prepMinutes',
    dailyBlocks: 'dailyBlocks'
  };

  export type FoodRecipeScalarFieldEnum = (typeof FoodRecipeScalarFieldEnum)[keyof typeof FoodRecipeScalarFieldEnum]


  export const FoodRecipeItemScalarFieldEnum: {
    id: 'id',
    recipeId: 'recipeId',
    ingredientId: 'ingredientId',
    childRecipeId: 'childRecipeId',
    quantity: 'quantity',
    unit: 'unit',
    wastePct: 'wastePct',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type FoodRecipeItemScalarFieldEnum = (typeof FoodRecipeItemScalarFieldEnum)[keyof typeof FoodRecipeItemScalarFieldEnum]


  export const FoodRecipeCostScalarFieldEnum: {
    id: 'id',
    recipeId: 'recipeId',
    label: 'label',
    amount: 'amount',
    costType: 'costType',
    period: 'period',
    periodRations: 'periodRations',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type FoodRecipeCostScalarFieldEnum = (typeof FoodRecipeCostScalarFieldEnum)[keyof typeof FoodRecipeCostScalarFieldEnum]


  export const FoodCostPoolScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    amount: 'amount',
    period: 'period',
    periodRations: 'periodRations',
    appliesTo: 'appliesTo',
    notes: 'notes',
    allocationMethod: 'allocationMethod',
    dailyBlocks: 'dailyBlocks',
    timeMinutes: 'timeMinutes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FoodCostPoolScalarFieldEnum = (typeof FoodCostPoolScalarFieldEnum)[keyof typeof FoodCostPoolScalarFieldEnum]


  export const FoodMealPlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    weekStart: 'weekStart',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FoodMealPlanScalarFieldEnum = (typeof FoodMealPlanScalarFieldEnum)[keyof typeof FoodMealPlanScalarFieldEnum]


  export const FoodMealPlanEntryScalarFieldEnum: {
    id: 'id',
    planId: 'planId',
    dayIndex: 'dayIndex',
    mealType: 'mealType',
    recipeId: 'recipeId',
    servings: 'servings',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FoodMealPlanEntryScalarFieldEnum = (typeof FoodMealPlanEntryScalarFieldEnum)[keyof typeof FoodMealPlanEntryScalarFieldEnum]


  export const QuotationProcessScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    status: 'status',
    baseCurrency: 'baseCurrency',
    targetCurrency: 'targetCurrency',
    exchangeRate: 'exchangeRate',
    targetMarginPct: 'targetMarginPct',
    baselineFileId: 'baselineFileId',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuotationProcessScalarFieldEnum = (typeof QuotationProcessScalarFieldEnum)[keyof typeof QuotationProcessScalarFieldEnum]


  export const QuotationBaselineItemScalarFieldEnum: {
    id: 'id',
    processId: 'processId',
    materialId: 'materialId',
    sheetName: 'sheetName',
    sectionPath: 'sectionPath',
    itemCode: 'itemCode',
    description: 'description',
    unit: 'unit',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    totalPrice: 'totalPrice',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuotationBaselineItemScalarFieldEnum = (typeof QuotationBaselineItemScalarFieldEnum)[keyof typeof QuotationBaselineItemScalarFieldEnum]


  export const QuotationScalarFieldEnum: {
    id: 'id',
    processId: 'processId',
    proveedorId: 'proveedorId',
    supplierName: 'supplierName',
    currency: 'currency',
    exchangeRate: 'exchangeRate',
    submittedAt: 'submittedAt',
    status: 'status',
    totalAmount: 'totalAmount',
    totalAmountPen: 'totalAmountPen',
    qualityScore: 'qualityScore',
    notes: 'notes',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuotationScalarFieldEnum = (typeof QuotationScalarFieldEnum)[keyof typeof QuotationScalarFieldEnum]


  export const QuotationItemScalarFieldEnum: {
    id: 'id',
    quotationId: 'quotationId',
    baselineItemId: 'baselineItemId',
    materialId: 'materialId',
    sourceRow: 'sourceRow',
    itemCode: 'itemCode',
    description: 'description',
    unit: 'unit',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    totalPrice: 'totalPrice',
    currency: 'currency',
    normalizedPrice: 'normalizedPrice',
    matchScore: 'matchScore',
    extraAttributes: 'extraAttributes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuotationItemScalarFieldEnum = (typeof QuotationItemScalarFieldEnum)[keyof typeof QuotationItemScalarFieldEnum]


  export const QuotationAttachmentScalarFieldEnum: {
    id: 'id',
    quotationId: 'quotationId',
    type: 'type',
    originalName: 'originalName',
    storagePath: 'storagePath',
    mimeType: 'mimeType',
    sizeBytes: 'sizeBytes',
    checksum: 'checksum',
    parsed: 'parsed',
    parsedAt: 'parsedAt',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuotationAttachmentScalarFieldEnum = (typeof QuotationAttachmentScalarFieldEnum)[keyof typeof QuotationAttachmentScalarFieldEnum]


  export const PurchaseOrderLogScalarFieldEnum: {
    id: 'id',
    processId: 'processId',
    quotationId: 'quotationId',
    supplierId: 'supplierId',
    supplierName: 'supplierName',
    orderNumber: 'orderNumber',
    sequence: 'sequence',
    issueDate: 'issueDate',
    currency: 'currency',
    subtotal: 'subtotal',
    discount: 'discount',
    netSubtotal: 'netSubtotal',
    igv: 'igv',
    total: 'total',
    totalsJson: 'totalsJson',
    itemsJson: 'itemsJson',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseOrderLogScalarFieldEnum = (typeof PurchaseOrderLogScalarFieldEnum)[keyof typeof PurchaseOrderLogScalarFieldEnum]


  export const PurchaseOrderLineScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    baselineId: 'baselineId',
    description: 'description',
    unit: 'unit',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    totalPrice: 'totalPrice',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseOrderLineScalarFieldEnum = (typeof PurchaseOrderLineScalarFieldEnum)[keyof typeof PurchaseOrderLineScalarFieldEnum]


  export const PurchaseDeliveryLogScalarFieldEnum: {
    id: 'id',
    processId: 'processId',
    orderId: 'orderId',
    proveedorId: 'proveedorId',
    supplierName: 'supplierName',
    guideNumber: 'guideNumber',
    date: 'date',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseDeliveryLogScalarFieldEnum = (typeof PurchaseDeliveryLogScalarFieldEnum)[keyof typeof PurchaseDeliveryLogScalarFieldEnum]


  export const PurchaseDeliveryItemScalarFieldEnum: {
    id: 'id',
    deliveryId: 'deliveryId',
    orderLineId: 'orderLineId',
    baselineId: 'baselineId',
    description: 'description',
    unit: 'unit',
    quantity: 'quantity',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseDeliveryItemScalarFieldEnum = (typeof PurchaseDeliveryItemScalarFieldEnum)[keyof typeof PurchaseDeliveryItemScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'AssetStatus'
   */
  export type EnumAssetStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssetStatus'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'MoveType'
   */
  export type EnumMoveTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MoveType'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'DocType'
   */
  export type EnumDocTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocType'>
    


  /**
   * Reference to a field of type 'ExpenseKind'
   */
  export type EnumExpenseKindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExpenseKind'>
    


  /**
   * Reference to a field of type 'IncomeStatus'
   */
  export type EnumIncomeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncomeStatus'>
    


  /**
   * Reference to a field of type 'ExpenseType'
   */
  export type EnumExpenseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExpenseType'>
    


  /**
   * Reference to a field of type 'VariableType'
   */
  export type EnumVariableTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VariableType'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'DocumentType'
   */
  export type EnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType'>
    


  /**
   * Reference to a field of type 'BankType'
   */
  export type EnumBankTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BankType'>
    


  /**
   * Reference to a field of type 'PensionSystem'
   */
  export type EnumPensionSystemFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PensionSystem'>
    


  /**
   * Reference to a field of type 'EmployeeArea'
   */
  export type EnumEmployeeAreaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmployeeArea'>
    


  /**
   * Reference to a field of type 'AttendanceStatus'
   */
  export type EnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus'>
    


  /**
   * Reference to a field of type 'PayrollPeriodStatus'
   */
  export type EnumPayrollPeriodStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayrollPeriodStatus'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'PayrollAdjustmentType'
   */
  export type EnumPayrollAdjustmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayrollAdjustmentType'>
    


  /**
   * Reference to a field of type 'PartnerLoanStatus'
   */
  export type EnumPartnerLoanStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PartnerLoanStatus'>
    


  /**
   * Reference to a field of type 'FoodMealType'
   */
  export type EnumFoodMealTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FoodMealType'>
    


  /**
   * Reference to a field of type 'FoodCostLineType'
   */
  export type EnumFoodCostLineTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FoodCostLineType'>
    


  /**
   * Reference to a field of type 'FoodCostPeriod'
   */
  export type EnumFoodCostPeriodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FoodCostPeriod'>
    


  /**
   * Reference to a field of type 'FoodCostPoolType'
   */
  export type EnumFoodCostPoolTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FoodCostPoolType'>
    


  /**
   * Reference to a field of type 'PoolAllocationMethod'
   */
  export type EnumPoolAllocationMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PoolAllocationMethod'>
    


  /**
   * Reference to a field of type 'QuotationProcessStatus'
   */
  export type EnumQuotationProcessStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuotationProcessStatus'>
    


  /**
   * Reference to a field of type 'QuotationStatus'
   */
  export type EnumQuotationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuotationStatus'>
    


  /**
   * Reference to a field of type 'QuotationAttachmentType'
   */
  export type EnumQuotationAttachmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuotationAttachmentType'>
    
  /**
   * Deep Input Types
   */


  export type ObraWhereInput = {
    AND?: ObraWhereInput | ObraWhereInput[]
    OR?: ObraWhereInput[]
    NOT?: ObraWhereInput | ObraWhereInput[]
    id?: IntFilter<"Obra"> | number
    name?: StringFilter<"Obra"> | string
    code?: StringNullableFilter<"Obra"> | string | null
    frentes?: FrenteListRelationFilter
    moves?: MoveListRelationFilter
    incomes?: IncomeListRelationFilter
    expenses?: ExpenseListRelationFilter
    employees?: EmployeeListRelationFilter
    payrollPeriods?: PayrollPeriodListRelationFilter
    dailyCashRenditions?: DailyCashRenditionListRelationFilter
  }

  export type ObraOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    frentes?: FrenteOrderByRelationAggregateInput
    moves?: MoveOrderByRelationAggregateInput
    incomes?: IncomeOrderByRelationAggregateInput
    expenses?: ExpenseOrderByRelationAggregateInput
    employees?: EmployeeOrderByRelationAggregateInput
    payrollPeriods?: PayrollPeriodOrderByRelationAggregateInput
    dailyCashRenditions?: DailyCashRenditionOrderByRelationAggregateInput
  }

  export type ObraWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    code?: string
    AND?: ObraWhereInput | ObraWhereInput[]
    OR?: ObraWhereInput[]
    NOT?: ObraWhereInput | ObraWhereInput[]
    frentes?: FrenteListRelationFilter
    moves?: MoveListRelationFilter
    incomes?: IncomeListRelationFilter
    expenses?: ExpenseListRelationFilter
    employees?: EmployeeListRelationFilter
    payrollPeriods?: PayrollPeriodListRelationFilter
    dailyCashRenditions?: DailyCashRenditionListRelationFilter
  }, "id" | "name" | "code">

  export type ObraOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    _count?: ObraCountOrderByAggregateInput
    _avg?: ObraAvgOrderByAggregateInput
    _max?: ObraMaxOrderByAggregateInput
    _min?: ObraMinOrderByAggregateInput
    _sum?: ObraSumOrderByAggregateInput
  }

  export type ObraScalarWhereWithAggregatesInput = {
    AND?: ObraScalarWhereWithAggregatesInput | ObraScalarWhereWithAggregatesInput[]
    OR?: ObraScalarWhereWithAggregatesInput[]
    NOT?: ObraScalarWhereWithAggregatesInput | ObraScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Obra"> | number
    name?: StringWithAggregatesFilter<"Obra"> | string
    code?: StringNullableWithAggregatesFilter<"Obra"> | string | null
  }

  export type MaterialWhereInput = {
    AND?: MaterialWhereInput | MaterialWhereInput[]
    OR?: MaterialWhereInput[]
    NOT?: MaterialWhereInput | MaterialWhereInput[]
    id?: IntFilter<"Material"> | number
    code?: StringNullableFilter<"Material"> | string | null
    name?: StringFilter<"Material"> | string
    unit?: StringNullableFilter<"Material"> | string | null
    groupId?: IntNullableFilter<"Material"> | number | null
    minStock?: DecimalFilter<"Material"> | Decimal | DecimalJsLike | number | string
    reorderQuantity?: DecimalFilter<"Material"> | Decimal | DecimalJsLike | number | string
    allowNegative?: BoolFilter<"Material"> | boolean
    isCompanyAsset?: BoolFilter<"Material"> | boolean
    assetStatus?: EnumAssetStatusFilter<"Material"> | $Enums.AssetStatus
    assetResponsible?: StringNullableFilter<"Material"> | string | null
    group?: XOR<MaterialGroupNullableScalarRelationFilter, MaterialGroupWhereInput> | null
    moves?: MoveListRelationFilter
    expenses?: ExpenseListRelationFilter
    baseQuotes?: QuotationBaselineItemListRelationFilter
    quoteItems?: QuotationItemListRelationFilter
  }

  export type MaterialOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrderInput | SortOrder
    name?: SortOrder
    unit?: SortOrderInput | SortOrder
    groupId?: SortOrderInput | SortOrder
    minStock?: SortOrder
    reorderQuantity?: SortOrder
    allowNegative?: SortOrder
    isCompanyAsset?: SortOrder
    assetStatus?: SortOrder
    assetResponsible?: SortOrderInput | SortOrder
    group?: MaterialGroupOrderByWithRelationInput
    moves?: MoveOrderByRelationAggregateInput
    expenses?: ExpenseOrderByRelationAggregateInput
    baseQuotes?: QuotationBaselineItemOrderByRelationAggregateInput
    quoteItems?: QuotationItemOrderByRelationAggregateInput
  }

  export type MaterialWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: MaterialWhereInput | MaterialWhereInput[]
    OR?: MaterialWhereInput[]
    NOT?: MaterialWhereInput | MaterialWhereInput[]
    name?: StringFilter<"Material"> | string
    unit?: StringNullableFilter<"Material"> | string | null
    groupId?: IntNullableFilter<"Material"> | number | null
    minStock?: DecimalFilter<"Material"> | Decimal | DecimalJsLike | number | string
    reorderQuantity?: DecimalFilter<"Material"> | Decimal | DecimalJsLike | number | string
    allowNegative?: BoolFilter<"Material"> | boolean
    isCompanyAsset?: BoolFilter<"Material"> | boolean
    assetStatus?: EnumAssetStatusFilter<"Material"> | $Enums.AssetStatus
    assetResponsible?: StringNullableFilter<"Material"> | string | null
    group?: XOR<MaterialGroupNullableScalarRelationFilter, MaterialGroupWhereInput> | null
    moves?: MoveListRelationFilter
    expenses?: ExpenseListRelationFilter
    baseQuotes?: QuotationBaselineItemListRelationFilter
    quoteItems?: QuotationItemListRelationFilter
  }, "id" | "code">

  export type MaterialOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrderInput | SortOrder
    name?: SortOrder
    unit?: SortOrderInput | SortOrder
    groupId?: SortOrderInput | SortOrder
    minStock?: SortOrder
    reorderQuantity?: SortOrder
    allowNegative?: SortOrder
    isCompanyAsset?: SortOrder
    assetStatus?: SortOrder
    assetResponsible?: SortOrderInput | SortOrder
    _count?: MaterialCountOrderByAggregateInput
    _avg?: MaterialAvgOrderByAggregateInput
    _max?: MaterialMaxOrderByAggregateInput
    _min?: MaterialMinOrderByAggregateInput
    _sum?: MaterialSumOrderByAggregateInput
  }

  export type MaterialScalarWhereWithAggregatesInput = {
    AND?: MaterialScalarWhereWithAggregatesInput | MaterialScalarWhereWithAggregatesInput[]
    OR?: MaterialScalarWhereWithAggregatesInput[]
    NOT?: MaterialScalarWhereWithAggregatesInput | MaterialScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Material"> | number
    code?: StringNullableWithAggregatesFilter<"Material"> | string | null
    name?: StringWithAggregatesFilter<"Material"> | string
    unit?: StringNullableWithAggregatesFilter<"Material"> | string | null
    groupId?: IntNullableWithAggregatesFilter<"Material"> | number | null
    minStock?: DecimalWithAggregatesFilter<"Material"> | Decimal | DecimalJsLike | number | string
    reorderQuantity?: DecimalWithAggregatesFilter<"Material"> | Decimal | DecimalJsLike | number | string
    allowNegative?: BoolWithAggregatesFilter<"Material"> | boolean
    isCompanyAsset?: BoolWithAggregatesFilter<"Material"> | boolean
    assetStatus?: EnumAssetStatusWithAggregatesFilter<"Material"> | $Enums.AssetStatus
    assetResponsible?: StringNullableWithAggregatesFilter<"Material"> | string | null
  }

  export type ProveedorWhereInput = {
    AND?: ProveedorWhereInput | ProveedorWhereInput[]
    OR?: ProveedorWhereInput[]
    NOT?: ProveedorWhereInput | ProveedorWhereInput[]
    id?: IntFilter<"Proveedor"> | number
    name?: StringFilter<"Proveedor"> | string
    ruc?: StringNullableFilter<"Proveedor"> | string | null
    phone?: StringNullableFilter<"Proveedor"> | string | null
    moves?: MoveListRelationFilter
    expenses?: ExpenseListRelationFilter
    quotations?: QuotationListRelationFilter
    deliveries?: PurchaseDeliveryLogListRelationFilter
  }

  export type ProveedorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    ruc?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    moves?: MoveOrderByRelationAggregateInput
    expenses?: ExpenseOrderByRelationAggregateInput
    quotations?: QuotationOrderByRelationAggregateInput
    deliveries?: PurchaseDeliveryLogOrderByRelationAggregateInput
  }

  export type ProveedorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    ruc?: string
    AND?: ProveedorWhereInput | ProveedorWhereInput[]
    OR?: ProveedorWhereInput[]
    NOT?: ProveedorWhereInput | ProveedorWhereInput[]
    name?: StringFilter<"Proveedor"> | string
    phone?: StringNullableFilter<"Proveedor"> | string | null
    moves?: MoveListRelationFilter
    expenses?: ExpenseListRelationFilter
    quotations?: QuotationListRelationFilter
    deliveries?: PurchaseDeliveryLogListRelationFilter
  }, "id" | "ruc">

  export type ProveedorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    ruc?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    _count?: ProveedorCountOrderByAggregateInput
    _avg?: ProveedorAvgOrderByAggregateInput
    _max?: ProveedorMaxOrderByAggregateInput
    _min?: ProveedorMinOrderByAggregateInput
    _sum?: ProveedorSumOrderByAggregateInput
  }

  export type ProveedorScalarWhereWithAggregatesInput = {
    AND?: ProveedorScalarWhereWithAggregatesInput | ProveedorScalarWhereWithAggregatesInput[]
    OR?: ProveedorScalarWhereWithAggregatesInput[]
    NOT?: ProveedorScalarWhereWithAggregatesInput | ProveedorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Proveedor"> | number
    name?: StringWithAggregatesFilter<"Proveedor"> | string
    ruc?: StringNullableWithAggregatesFilter<"Proveedor"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Proveedor"> | string | null
  }

  export type FrenteWhereInput = {
    AND?: FrenteWhereInput | FrenteWhereInput[]
    OR?: FrenteWhereInput[]
    NOT?: FrenteWhereInput | FrenteWhereInput[]
    id?: IntFilter<"Frente"> | number
    name?: StringFilter<"Frente"> | string
    obraId?: IntFilter<"Frente"> | number
    obra?: XOR<ObraScalarRelationFilter, ObraWhereInput>
    moves?: MoveListRelationFilter
    incomes?: IncomeListRelationFilter
    expenses?: ExpenseListRelationFilter
  }

  export type FrenteOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    obraId?: SortOrder
    obra?: ObraOrderByWithRelationInput
    moves?: MoveOrderByRelationAggregateInput
    incomes?: IncomeOrderByRelationAggregateInput
    expenses?: ExpenseOrderByRelationAggregateInput
  }

  export type FrenteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FrenteWhereInput | FrenteWhereInput[]
    OR?: FrenteWhereInput[]
    NOT?: FrenteWhereInput | FrenteWhereInput[]
    name?: StringFilter<"Frente"> | string
    obraId?: IntFilter<"Frente"> | number
    obra?: XOR<ObraScalarRelationFilter, ObraWhereInput>
    moves?: MoveListRelationFilter
    incomes?: IncomeListRelationFilter
    expenses?: ExpenseListRelationFilter
  }, "id">

  export type FrenteOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    obraId?: SortOrder
    _count?: FrenteCountOrderByAggregateInput
    _avg?: FrenteAvgOrderByAggregateInput
    _max?: FrenteMaxOrderByAggregateInput
    _min?: FrenteMinOrderByAggregateInput
    _sum?: FrenteSumOrderByAggregateInput
  }

  export type FrenteScalarWhereWithAggregatesInput = {
    AND?: FrenteScalarWhereWithAggregatesInput | FrenteScalarWhereWithAggregatesInput[]
    OR?: FrenteScalarWhereWithAggregatesInput[]
    NOT?: FrenteScalarWhereWithAggregatesInput | FrenteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Frente"> | number
    name?: StringWithAggregatesFilter<"Frente"> | string
    obraId?: IntWithAggregatesFilter<"Frente"> | number
  }

  export type MaterialGroupWhereInput = {
    AND?: MaterialGroupWhereInput | MaterialGroupWhereInput[]
    OR?: MaterialGroupWhereInput[]
    NOT?: MaterialGroupWhereInput | MaterialGroupWhereInput[]
    id?: IntFilter<"MaterialGroup"> | number
    name?: StringFilter<"MaterialGroup"> | string
    parentId?: IntNullableFilter<"MaterialGroup"> | number | null
    color?: StringNullableFilter<"MaterialGroup"> | string | null
    createdAt?: DateTimeFilter<"MaterialGroup"> | Date | string
    updatedAt?: DateTimeFilter<"MaterialGroup"> | Date | string
    parent?: XOR<MaterialGroupNullableScalarRelationFilter, MaterialGroupWhereInput> | null
    children?: MaterialGroupListRelationFilter
    materials?: MaterialListRelationFilter
  }

  export type MaterialGroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parent?: MaterialGroupOrderByWithRelationInput
    children?: MaterialGroupOrderByRelationAggregateInput
    materials?: MaterialOrderByRelationAggregateInput
  }

  export type MaterialGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: MaterialGroupWhereInput | MaterialGroupWhereInput[]
    OR?: MaterialGroupWhereInput[]
    NOT?: MaterialGroupWhereInput | MaterialGroupWhereInput[]
    parentId?: IntNullableFilter<"MaterialGroup"> | number | null
    color?: StringNullableFilter<"MaterialGroup"> | string | null
    createdAt?: DateTimeFilter<"MaterialGroup"> | Date | string
    updatedAt?: DateTimeFilter<"MaterialGroup"> | Date | string
    parent?: XOR<MaterialGroupNullableScalarRelationFilter, MaterialGroupWhereInput> | null
    children?: MaterialGroupListRelationFilter
    materials?: MaterialListRelationFilter
  }, "id" | "name">

  export type MaterialGroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MaterialGroupCountOrderByAggregateInput
    _avg?: MaterialGroupAvgOrderByAggregateInput
    _max?: MaterialGroupMaxOrderByAggregateInput
    _min?: MaterialGroupMinOrderByAggregateInput
    _sum?: MaterialGroupSumOrderByAggregateInput
  }

  export type MaterialGroupScalarWhereWithAggregatesInput = {
    AND?: MaterialGroupScalarWhereWithAggregatesInput | MaterialGroupScalarWhereWithAggregatesInput[]
    OR?: MaterialGroupScalarWhereWithAggregatesInput[]
    NOT?: MaterialGroupScalarWhereWithAggregatesInput | MaterialGroupScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MaterialGroup"> | number
    name?: StringWithAggregatesFilter<"MaterialGroup"> | string
    parentId?: IntNullableWithAggregatesFilter<"MaterialGroup"> | number | null
    color?: StringNullableWithAggregatesFilter<"MaterialGroup"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MaterialGroup"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MaterialGroup"> | Date | string
  }

  export type MoveWhereInput = {
    AND?: MoveWhereInput | MoveWhereInput[]
    OR?: MoveWhereInput[]
    NOT?: MoveWhereInput | MoveWhereInput[]
    id?: IntFilter<"Move"> | number
    obraId?: IntFilter<"Move"> | number
    frenteId?: IntNullableFilter<"Move"> | number | null
    materialId?: IntFilter<"Move"> | number
    proveedorId?: IntNullableFilter<"Move"> | number | null
    type?: EnumMoveTypeFilter<"Move"> | $Enums.MoveType
    quantity?: FloatFilter<"Move"> | number
    unitCost?: FloatNullableFilter<"Move"> | number | null
    totalCost?: FloatNullableFilter<"Move"> | number | null
    date?: DateTimeFilter<"Move"> | Date | string
    note?: StringNullableFilter<"Move"> | string | null
    docType?: EnumDocTypeNullableFilter<"Move"> | $Enums.DocType | null
    docSerie?: StringNullableFilter<"Move"> | string | null
    docNumero?: StringNullableFilter<"Move"> | string | null
    igvRate?: DecimalNullableFilter<"Move"> | Decimal | DecimalJsLike | number | string | null
    isTaxable?: BoolNullableFilter<"Move"> | boolean | null
    responsible?: StringNullableFilter<"Move"> | string | null
    assetStatus?: EnumAssetStatusNullableFilter<"Move"> | $Enums.AssetStatus | null
    obra?: XOR<ObraScalarRelationFilter, ObraWhereInput>
    frente?: XOR<FrenteNullableScalarRelationFilter, FrenteWhereInput> | null
    material?: XOR<MaterialScalarRelationFilter, MaterialWhereInput>
    proveedor?: XOR<ProveedorNullableScalarRelationFilter, ProveedorWhereInput> | null
    expense?: XOR<ExpenseNullableScalarRelationFilter, ExpenseWhereInput> | null
  }

  export type MoveOrderByWithRelationInput = {
    id?: SortOrder
    obraId?: SortOrder
    frenteId?: SortOrderInput | SortOrder
    materialId?: SortOrder
    proveedorId?: SortOrderInput | SortOrder
    type?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrderInput | SortOrder
    totalCost?: SortOrderInput | SortOrder
    date?: SortOrder
    note?: SortOrderInput | SortOrder
    docType?: SortOrderInput | SortOrder
    docSerie?: SortOrderInput | SortOrder
    docNumero?: SortOrderInput | SortOrder
    igvRate?: SortOrderInput | SortOrder
    isTaxable?: SortOrderInput | SortOrder
    responsible?: SortOrderInput | SortOrder
    assetStatus?: SortOrderInput | SortOrder
    obra?: ObraOrderByWithRelationInput
    frente?: FrenteOrderByWithRelationInput
    material?: MaterialOrderByWithRelationInput
    proveedor?: ProveedorOrderByWithRelationInput
    expense?: ExpenseOrderByWithRelationInput
  }

  export type MoveWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MoveWhereInput | MoveWhereInput[]
    OR?: MoveWhereInput[]
    NOT?: MoveWhereInput | MoveWhereInput[]
    obraId?: IntFilter<"Move"> | number
    frenteId?: IntNullableFilter<"Move"> | number | null
    materialId?: IntFilter<"Move"> | number
    proveedorId?: IntNullableFilter<"Move"> | number | null
    type?: EnumMoveTypeFilter<"Move"> | $Enums.MoveType
    quantity?: FloatFilter<"Move"> | number
    unitCost?: FloatNullableFilter<"Move"> | number | null
    totalCost?: FloatNullableFilter<"Move"> | number | null
    date?: DateTimeFilter<"Move"> | Date | string
    note?: StringNullableFilter<"Move"> | string | null
    docType?: EnumDocTypeNullableFilter<"Move"> | $Enums.DocType | null
    docSerie?: StringNullableFilter<"Move"> | string | null
    docNumero?: StringNullableFilter<"Move"> | string | null
    igvRate?: DecimalNullableFilter<"Move"> | Decimal | DecimalJsLike | number | string | null
    isTaxable?: BoolNullableFilter<"Move"> | boolean | null
    responsible?: StringNullableFilter<"Move"> | string | null
    assetStatus?: EnumAssetStatusNullableFilter<"Move"> | $Enums.AssetStatus | null
    obra?: XOR<ObraScalarRelationFilter, ObraWhereInput>
    frente?: XOR<FrenteNullableScalarRelationFilter, FrenteWhereInput> | null
    material?: XOR<MaterialScalarRelationFilter, MaterialWhereInput>
    proveedor?: XOR<ProveedorNullableScalarRelationFilter, ProveedorWhereInput> | null
    expense?: XOR<ExpenseNullableScalarRelationFilter, ExpenseWhereInput> | null
  }, "id">

  export type MoveOrderByWithAggregationInput = {
    id?: SortOrder
    obraId?: SortOrder
    frenteId?: SortOrderInput | SortOrder
    materialId?: SortOrder
    proveedorId?: SortOrderInput | SortOrder
    type?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrderInput | SortOrder
    totalCost?: SortOrderInput | SortOrder
    date?: SortOrder
    note?: SortOrderInput | SortOrder
    docType?: SortOrderInput | SortOrder
    docSerie?: SortOrderInput | SortOrder
    docNumero?: SortOrderInput | SortOrder
    igvRate?: SortOrderInput | SortOrder
    isTaxable?: SortOrderInput | SortOrder
    responsible?: SortOrderInput | SortOrder
    assetStatus?: SortOrderInput | SortOrder
    _count?: MoveCountOrderByAggregateInput
    _avg?: MoveAvgOrderByAggregateInput
    _max?: MoveMaxOrderByAggregateInput
    _min?: MoveMinOrderByAggregateInput
    _sum?: MoveSumOrderByAggregateInput
  }

  export type MoveScalarWhereWithAggregatesInput = {
    AND?: MoveScalarWhereWithAggregatesInput | MoveScalarWhereWithAggregatesInput[]
    OR?: MoveScalarWhereWithAggregatesInput[]
    NOT?: MoveScalarWhereWithAggregatesInput | MoveScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Move"> | number
    obraId?: IntWithAggregatesFilter<"Move"> | number
    frenteId?: IntNullableWithAggregatesFilter<"Move"> | number | null
    materialId?: IntWithAggregatesFilter<"Move"> | number
    proveedorId?: IntNullableWithAggregatesFilter<"Move"> | number | null
    type?: EnumMoveTypeWithAggregatesFilter<"Move"> | $Enums.MoveType
    quantity?: FloatWithAggregatesFilter<"Move"> | number
    unitCost?: FloatNullableWithAggregatesFilter<"Move"> | number | null
    totalCost?: FloatNullableWithAggregatesFilter<"Move"> | number | null
    date?: DateTimeWithAggregatesFilter<"Move"> | Date | string
    note?: StringNullableWithAggregatesFilter<"Move"> | string | null
    docType?: EnumDocTypeNullableWithAggregatesFilter<"Move"> | $Enums.DocType | null
    docSerie?: StringNullableWithAggregatesFilter<"Move"> | string | null
    docNumero?: StringNullableWithAggregatesFilter<"Move"> | string | null
    igvRate?: DecimalNullableWithAggregatesFilter<"Move"> | Decimal | DecimalJsLike | number | string | null
    isTaxable?: BoolNullableWithAggregatesFilter<"Move"> | boolean | null
    responsible?: StringNullableWithAggregatesFilter<"Move"> | string | null
    assetStatus?: EnumAssetStatusNullableWithAggregatesFilter<"Move"> | $Enums.AssetStatus | null
  }

  export type ExpenseCategoryWhereInput = {
    AND?: ExpenseCategoryWhereInput | ExpenseCategoryWhereInput[]
    OR?: ExpenseCategoryWhereInput[]
    NOT?: ExpenseCategoryWhereInput | ExpenseCategoryWhereInput[]
    id?: IntFilter<"ExpenseCategory"> | number
    name?: StringFilter<"ExpenseCategory"> | string
    createdAt?: DateTimeFilter<"ExpenseCategory"> | Date | string
    kind?: EnumExpenseKindFilter<"ExpenseCategory"> | $Enums.ExpenseKind
    expenses?: ExpenseListRelationFilter
  }

  export type ExpenseCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    kind?: SortOrder
    expenses?: ExpenseOrderByRelationAggregateInput
  }

  export type ExpenseCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: ExpenseCategoryWhereInput | ExpenseCategoryWhereInput[]
    OR?: ExpenseCategoryWhereInput[]
    NOT?: ExpenseCategoryWhereInput | ExpenseCategoryWhereInput[]
    createdAt?: DateTimeFilter<"ExpenseCategory"> | Date | string
    kind?: EnumExpenseKindFilter<"ExpenseCategory"> | $Enums.ExpenseKind
    expenses?: ExpenseListRelationFilter
  }, "id" | "name">

  export type ExpenseCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    kind?: SortOrder
    _count?: ExpenseCategoryCountOrderByAggregateInput
    _avg?: ExpenseCategoryAvgOrderByAggregateInput
    _max?: ExpenseCategoryMaxOrderByAggregateInput
    _min?: ExpenseCategoryMinOrderByAggregateInput
    _sum?: ExpenseCategorySumOrderByAggregateInput
  }

  export type ExpenseCategoryScalarWhereWithAggregatesInput = {
    AND?: ExpenseCategoryScalarWhereWithAggregatesInput | ExpenseCategoryScalarWhereWithAggregatesInput[]
    OR?: ExpenseCategoryScalarWhereWithAggregatesInput[]
    NOT?: ExpenseCategoryScalarWhereWithAggregatesInput | ExpenseCategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ExpenseCategory"> | number
    name?: StringWithAggregatesFilter<"ExpenseCategory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ExpenseCategory"> | Date | string
    kind?: EnumExpenseKindWithAggregatesFilter<"ExpenseCategory"> | $Enums.ExpenseKind
  }

  export type IncomeWhereInput = {
    AND?: IncomeWhereInput | IncomeWhereInput[]
    OR?: IncomeWhereInput[]
    NOT?: IncomeWhereInput | IncomeWhereInput[]
    id?: IntFilter<"Income"> | number
    obraId?: IntFilter<"Income"> | number
    frenteId?: IntNullableFilter<"Income"> | number | null
    date?: DateTimeFilter<"Income"> | Date | string
    description?: StringNullableFilter<"Income"> | string | null
    docType?: EnumDocTypeFilter<"Income"> | $Enums.DocType
    docSerie?: StringNullableFilter<"Income"> | string | null
    docNumero?: StringNullableFilter<"Income"> | string | null
    status?: EnumIncomeStatusFilter<"Income"> | $Enums.IncomeStatus
    igvRate?: DecimalFilter<"Income"> | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFilter<"Income"> | boolean
    base?: DecimalFilter<"Income"> | Decimal | DecimalJsLike | number | string
    igv?: DecimalFilter<"Income"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Income"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Income"> | Date | string
    updatedAt?: DateTimeFilter<"Income"> | Date | string
    obra?: XOR<ObraScalarRelationFilter, ObraWhereInput>
    frente?: XOR<FrenteNullableScalarRelationFilter, FrenteWhereInput> | null
  }

  export type IncomeOrderByWithRelationInput = {
    id?: SortOrder
    obraId?: SortOrder
    frenteId?: SortOrderInput | SortOrder
    date?: SortOrder
    description?: SortOrderInput | SortOrder
    docType?: SortOrder
    docSerie?: SortOrderInput | SortOrder
    docNumero?: SortOrderInput | SortOrder
    status?: SortOrder
    igvRate?: SortOrder
    isTaxable?: SortOrder
    base?: SortOrder
    igv?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    obra?: ObraOrderByWithRelationInput
    frente?: FrenteOrderByWithRelationInput
  }

  export type IncomeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: IncomeWhereInput | IncomeWhereInput[]
    OR?: IncomeWhereInput[]
    NOT?: IncomeWhereInput | IncomeWhereInput[]
    obraId?: IntFilter<"Income"> | number
    frenteId?: IntNullableFilter<"Income"> | number | null
    date?: DateTimeFilter<"Income"> | Date | string
    description?: StringNullableFilter<"Income"> | string | null
    docType?: EnumDocTypeFilter<"Income"> | $Enums.DocType
    docSerie?: StringNullableFilter<"Income"> | string | null
    docNumero?: StringNullableFilter<"Income"> | string | null
    status?: EnumIncomeStatusFilter<"Income"> | $Enums.IncomeStatus
    igvRate?: DecimalFilter<"Income"> | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFilter<"Income"> | boolean
    base?: DecimalFilter<"Income"> | Decimal | DecimalJsLike | number | string
    igv?: DecimalFilter<"Income"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Income"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Income"> | Date | string
    updatedAt?: DateTimeFilter<"Income"> | Date | string
    obra?: XOR<ObraScalarRelationFilter, ObraWhereInput>
    frente?: XOR<FrenteNullableScalarRelationFilter, FrenteWhereInput> | null
  }, "id">

  export type IncomeOrderByWithAggregationInput = {
    id?: SortOrder
    obraId?: SortOrder
    frenteId?: SortOrderInput | SortOrder
    date?: SortOrder
    description?: SortOrderInput | SortOrder
    docType?: SortOrder
    docSerie?: SortOrderInput | SortOrder
    docNumero?: SortOrderInput | SortOrder
    status?: SortOrder
    igvRate?: SortOrder
    isTaxable?: SortOrder
    base?: SortOrder
    igv?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IncomeCountOrderByAggregateInput
    _avg?: IncomeAvgOrderByAggregateInput
    _max?: IncomeMaxOrderByAggregateInput
    _min?: IncomeMinOrderByAggregateInput
    _sum?: IncomeSumOrderByAggregateInput
  }

  export type IncomeScalarWhereWithAggregatesInput = {
    AND?: IncomeScalarWhereWithAggregatesInput | IncomeScalarWhereWithAggregatesInput[]
    OR?: IncomeScalarWhereWithAggregatesInput[]
    NOT?: IncomeScalarWhereWithAggregatesInput | IncomeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Income"> | number
    obraId?: IntWithAggregatesFilter<"Income"> | number
    frenteId?: IntNullableWithAggregatesFilter<"Income"> | number | null
    date?: DateTimeWithAggregatesFilter<"Income"> | Date | string
    description?: StringNullableWithAggregatesFilter<"Income"> | string | null
    docType?: EnumDocTypeWithAggregatesFilter<"Income"> | $Enums.DocType
    docSerie?: StringNullableWithAggregatesFilter<"Income"> | string | null
    docNumero?: StringNullableWithAggregatesFilter<"Income"> | string | null
    status?: EnumIncomeStatusWithAggregatesFilter<"Income"> | $Enums.IncomeStatus
    igvRate?: DecimalWithAggregatesFilter<"Income"> | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolWithAggregatesFilter<"Income"> | boolean
    base?: DecimalWithAggregatesFilter<"Income"> | Decimal | DecimalJsLike | number | string
    igv?: DecimalWithAggregatesFilter<"Income"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"Income"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"Income"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Income"> | Date | string
  }

  export type ExpenseWhereInput = {
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    id?: IntFilter<"Expense"> | number
    obraId?: IntFilter<"Expense"> | number
    frenteId?: IntNullableFilter<"Expense"> | number | null
    proveedorId?: IntNullableFilter<"Expense"> | number | null
    materialId?: IntNullableFilter<"Expense"> | number | null
    categoryId?: IntNullableFilter<"Expense"> | number | null
    moveId?: IntNullableFilter<"Expense"> | number | null
    docType?: EnumDocTypeFilter<"Expense"> | $Enums.DocType
    docSerie?: StringNullableFilter<"Expense"> | string | null
    docNumero?: StringNullableFilter<"Expense"> | string | null
    date?: DateTimeFilter<"Expense"> | Date | string
    description?: StringNullableFilter<"Expense"> | string | null
    spentBy?: StringNullableFilter<"Expense"> | string | null
    type?: EnumExpenseTypeFilter<"Expense"> | $Enums.ExpenseType
    variableType?: EnumVariableTypeFilter<"Expense"> | $Enums.VariableType
    quantity?: DecimalNullableFilter<"Expense"> | Decimal | DecimalJsLike | number | string | null
    unitCost?: DecimalNullableFilter<"Expense"> | Decimal | DecimalJsLike | number | string | null
    igvRate?: DecimalFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFilter<"Expense"> | boolean
    base?: DecimalFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    igv?: DecimalFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFilter<"Expense"> | $Enums.PaymentMethod
    paidAt?: DateTimeNullableFilter<"Expense"> | Date | string | null
    status?: StringFilter<"Expense"> | string
    reminderIntervalDays?: IntNullableFilter<"Expense"> | number | null
    reminderNextDate?: DateTimeNullableFilter<"Expense"> | Date | string | null
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
    obra?: XOR<ObraScalarRelationFilter, ObraWhereInput>
    frente?: XOR<FrenteNullableScalarRelationFilter, FrenteWhereInput> | null
    proveedor?: XOR<ProveedorNullableScalarRelationFilter, ProveedorWhereInput> | null
    material?: XOR<MaterialNullableScalarRelationFilter, MaterialWhereInput> | null
    category?: XOR<ExpenseCategoryNullableScalarRelationFilter, ExpenseCategoryWhereInput> | null
    move?: XOR<MoveNullableScalarRelationFilter, MoveWhereInput> | null
  }

  export type ExpenseOrderByWithRelationInput = {
    id?: SortOrder
    obraId?: SortOrder
    frenteId?: SortOrderInput | SortOrder
    proveedorId?: SortOrderInput | SortOrder
    materialId?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    moveId?: SortOrderInput | SortOrder
    docType?: SortOrder
    docSerie?: SortOrderInput | SortOrder
    docNumero?: SortOrderInput | SortOrder
    date?: SortOrder
    description?: SortOrderInput | SortOrder
    spentBy?: SortOrderInput | SortOrder
    type?: SortOrder
    variableType?: SortOrder
    quantity?: SortOrderInput | SortOrder
    unitCost?: SortOrderInput | SortOrder
    igvRate?: SortOrder
    isTaxable?: SortOrder
    base?: SortOrder
    igv?: SortOrder
    total?: SortOrder
    paymentMethod?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    status?: SortOrder
    reminderIntervalDays?: SortOrderInput | SortOrder
    reminderNextDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    obra?: ObraOrderByWithRelationInput
    frente?: FrenteOrderByWithRelationInput
    proveedor?: ProveedorOrderByWithRelationInput
    material?: MaterialOrderByWithRelationInput
    category?: ExpenseCategoryOrderByWithRelationInput
    move?: MoveOrderByWithRelationInput
  }

  export type ExpenseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    moveId?: number
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    obraId?: IntFilter<"Expense"> | number
    frenteId?: IntNullableFilter<"Expense"> | number | null
    proveedorId?: IntNullableFilter<"Expense"> | number | null
    materialId?: IntNullableFilter<"Expense"> | number | null
    categoryId?: IntNullableFilter<"Expense"> | number | null
    docType?: EnumDocTypeFilter<"Expense"> | $Enums.DocType
    docSerie?: StringNullableFilter<"Expense"> | string | null
    docNumero?: StringNullableFilter<"Expense"> | string | null
    date?: DateTimeFilter<"Expense"> | Date | string
    description?: StringNullableFilter<"Expense"> | string | null
    spentBy?: StringNullableFilter<"Expense"> | string | null
    type?: EnumExpenseTypeFilter<"Expense"> | $Enums.ExpenseType
    variableType?: EnumVariableTypeFilter<"Expense"> | $Enums.VariableType
    quantity?: DecimalNullableFilter<"Expense"> | Decimal | DecimalJsLike | number | string | null
    unitCost?: DecimalNullableFilter<"Expense"> | Decimal | DecimalJsLike | number | string | null
    igvRate?: DecimalFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFilter<"Expense"> | boolean
    base?: DecimalFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    igv?: DecimalFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFilter<"Expense"> | $Enums.PaymentMethod
    paidAt?: DateTimeNullableFilter<"Expense"> | Date | string | null
    status?: StringFilter<"Expense"> | string
    reminderIntervalDays?: IntNullableFilter<"Expense"> | number | null
    reminderNextDate?: DateTimeNullableFilter<"Expense"> | Date | string | null
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
    obra?: XOR<ObraScalarRelationFilter, ObraWhereInput>
    frente?: XOR<FrenteNullableScalarRelationFilter, FrenteWhereInput> | null
    proveedor?: XOR<ProveedorNullableScalarRelationFilter, ProveedorWhereInput> | null
    material?: XOR<MaterialNullableScalarRelationFilter, MaterialWhereInput> | null
    category?: XOR<ExpenseCategoryNullableScalarRelationFilter, ExpenseCategoryWhereInput> | null
    move?: XOR<MoveNullableScalarRelationFilter, MoveWhereInput> | null
  }, "id" | "moveId">

  export type ExpenseOrderByWithAggregationInput = {
    id?: SortOrder
    obraId?: SortOrder
    frenteId?: SortOrderInput | SortOrder
    proveedorId?: SortOrderInput | SortOrder
    materialId?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    moveId?: SortOrderInput | SortOrder
    docType?: SortOrder
    docSerie?: SortOrderInput | SortOrder
    docNumero?: SortOrderInput | SortOrder
    date?: SortOrder
    description?: SortOrderInput | SortOrder
    spentBy?: SortOrderInput | SortOrder
    type?: SortOrder
    variableType?: SortOrder
    quantity?: SortOrderInput | SortOrder
    unitCost?: SortOrderInput | SortOrder
    igvRate?: SortOrder
    isTaxable?: SortOrder
    base?: SortOrder
    igv?: SortOrder
    total?: SortOrder
    paymentMethod?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    status?: SortOrder
    reminderIntervalDays?: SortOrderInput | SortOrder
    reminderNextDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExpenseCountOrderByAggregateInput
    _avg?: ExpenseAvgOrderByAggregateInput
    _max?: ExpenseMaxOrderByAggregateInput
    _min?: ExpenseMinOrderByAggregateInput
    _sum?: ExpenseSumOrderByAggregateInput
  }

  export type ExpenseScalarWhereWithAggregatesInput = {
    AND?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    OR?: ExpenseScalarWhereWithAggregatesInput[]
    NOT?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Expense"> | number
    obraId?: IntWithAggregatesFilter<"Expense"> | number
    frenteId?: IntNullableWithAggregatesFilter<"Expense"> | number | null
    proveedorId?: IntNullableWithAggregatesFilter<"Expense"> | number | null
    materialId?: IntNullableWithAggregatesFilter<"Expense"> | number | null
    categoryId?: IntNullableWithAggregatesFilter<"Expense"> | number | null
    moveId?: IntNullableWithAggregatesFilter<"Expense"> | number | null
    docType?: EnumDocTypeWithAggregatesFilter<"Expense"> | $Enums.DocType
    docSerie?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    docNumero?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    date?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    description?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    spentBy?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    type?: EnumExpenseTypeWithAggregatesFilter<"Expense"> | $Enums.ExpenseType
    variableType?: EnumVariableTypeWithAggregatesFilter<"Expense"> | $Enums.VariableType
    quantity?: DecimalNullableWithAggregatesFilter<"Expense"> | Decimal | DecimalJsLike | number | string | null
    unitCost?: DecimalNullableWithAggregatesFilter<"Expense"> | Decimal | DecimalJsLike | number | string | null
    igvRate?: DecimalWithAggregatesFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolWithAggregatesFilter<"Expense"> | boolean
    base?: DecimalWithAggregatesFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    igv?: DecimalWithAggregatesFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"Expense"> | $Enums.PaymentMethod
    paidAt?: DateTimeNullableWithAggregatesFilter<"Expense"> | Date | string | null
    status?: StringWithAggregatesFilter<"Expense"> | string
    reminderIntervalDays?: IntNullableWithAggregatesFilter<"Expense"> | number | null
    reminderNextDate?: DateTimeNullableWithAggregatesFilter<"Expense"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
  }

  export type DailyCashRenditionWhereInput = {
    AND?: DailyCashRenditionWhereInput | DailyCashRenditionWhereInput[]
    OR?: DailyCashRenditionWhereInput[]
    NOT?: DailyCashRenditionWhereInput | DailyCashRenditionWhereInput[]
    id?: IntFilter<"DailyCashRendition"> | number
    date?: DateTimeFilter<"DailyCashRendition"> | Date | string
    obraId?: IntNullableFilter<"DailyCashRendition"> | number | null
    openingBalance?: DecimalFilter<"DailyCashRendition"> | Decimal | DecimalJsLike | number | string
    received?: DecimalFilter<"DailyCashRendition"> | Decimal | DecimalJsLike | number | string
    spent?: DecimalFilter<"DailyCashRendition"> | Decimal | DecimalJsLike | number | string
    personalContribution?: DecimalFilter<"DailyCashRendition"> | Decimal | DecimalJsLike | number | string
    balance?: DecimalFilter<"DailyCashRendition"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"DailyCashRendition"> | string | null
    createdAt?: DateTimeFilter<"DailyCashRendition"> | Date | string
    updatedAt?: DateTimeFilter<"DailyCashRendition"> | Date | string
    obra?: XOR<ObraNullableScalarRelationFilter, ObraWhereInput> | null
    expenses?: DailyCashExpenseListRelationFilter
  }

  export type DailyCashRenditionOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    obraId?: SortOrderInput | SortOrder
    openingBalance?: SortOrder
    received?: SortOrder
    spent?: SortOrder
    personalContribution?: SortOrder
    balance?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    obra?: ObraOrderByWithRelationInput
    expenses?: DailyCashExpenseOrderByRelationAggregateInput
  }

  export type DailyCashRenditionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DailyCashRenditionWhereInput | DailyCashRenditionWhereInput[]
    OR?: DailyCashRenditionWhereInput[]
    NOT?: DailyCashRenditionWhereInput | DailyCashRenditionWhereInput[]
    date?: DateTimeFilter<"DailyCashRendition"> | Date | string
    obraId?: IntNullableFilter<"DailyCashRendition"> | number | null
    openingBalance?: DecimalFilter<"DailyCashRendition"> | Decimal | DecimalJsLike | number | string
    received?: DecimalFilter<"DailyCashRendition"> | Decimal | DecimalJsLike | number | string
    spent?: DecimalFilter<"DailyCashRendition"> | Decimal | DecimalJsLike | number | string
    personalContribution?: DecimalFilter<"DailyCashRendition"> | Decimal | DecimalJsLike | number | string
    balance?: DecimalFilter<"DailyCashRendition"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"DailyCashRendition"> | string | null
    createdAt?: DateTimeFilter<"DailyCashRendition"> | Date | string
    updatedAt?: DateTimeFilter<"DailyCashRendition"> | Date | string
    obra?: XOR<ObraNullableScalarRelationFilter, ObraWhereInput> | null
    expenses?: DailyCashExpenseListRelationFilter
  }, "id">

  export type DailyCashRenditionOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    obraId?: SortOrderInput | SortOrder
    openingBalance?: SortOrder
    received?: SortOrder
    spent?: SortOrder
    personalContribution?: SortOrder
    balance?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DailyCashRenditionCountOrderByAggregateInput
    _avg?: DailyCashRenditionAvgOrderByAggregateInput
    _max?: DailyCashRenditionMaxOrderByAggregateInput
    _min?: DailyCashRenditionMinOrderByAggregateInput
    _sum?: DailyCashRenditionSumOrderByAggregateInput
  }

  export type DailyCashRenditionScalarWhereWithAggregatesInput = {
    AND?: DailyCashRenditionScalarWhereWithAggregatesInput | DailyCashRenditionScalarWhereWithAggregatesInput[]
    OR?: DailyCashRenditionScalarWhereWithAggregatesInput[]
    NOT?: DailyCashRenditionScalarWhereWithAggregatesInput | DailyCashRenditionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DailyCashRendition"> | number
    date?: DateTimeWithAggregatesFilter<"DailyCashRendition"> | Date | string
    obraId?: IntNullableWithAggregatesFilter<"DailyCashRendition"> | number | null
    openingBalance?: DecimalWithAggregatesFilter<"DailyCashRendition"> | Decimal | DecimalJsLike | number | string
    received?: DecimalWithAggregatesFilter<"DailyCashRendition"> | Decimal | DecimalJsLike | number | string
    spent?: DecimalWithAggregatesFilter<"DailyCashRendition"> | Decimal | DecimalJsLike | number | string
    personalContribution?: DecimalWithAggregatesFilter<"DailyCashRendition"> | Decimal | DecimalJsLike | number | string
    balance?: DecimalWithAggregatesFilter<"DailyCashRendition"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableWithAggregatesFilter<"DailyCashRendition"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DailyCashRendition"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DailyCashRendition"> | Date | string
  }

  export type DailyCashExpenseWhereInput = {
    AND?: DailyCashExpenseWhereInput | DailyCashExpenseWhereInput[]
    OR?: DailyCashExpenseWhereInput[]
    NOT?: DailyCashExpenseWhereInput | DailyCashExpenseWhereInput[]
    id?: IntFilter<"DailyCashExpense"> | number
    renditionId?: IntFilter<"DailyCashExpense"> | number
    description?: StringFilter<"DailyCashExpense"> | string
    amount?: DecimalFilter<"DailyCashExpense"> | Decimal | DecimalJsLike | number | string
    personalAmount?: DecimalFilter<"DailyCashExpense"> | Decimal | DecimalJsLike | number | string
    paidWithPersonal?: BoolFilter<"DailyCashExpense"> | boolean
    createdAt?: DateTimeFilter<"DailyCashExpense"> | Date | string
    rendition?: XOR<DailyCashRenditionScalarRelationFilter, DailyCashRenditionWhereInput>
  }

  export type DailyCashExpenseOrderByWithRelationInput = {
    id?: SortOrder
    renditionId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    personalAmount?: SortOrder
    paidWithPersonal?: SortOrder
    createdAt?: SortOrder
    rendition?: DailyCashRenditionOrderByWithRelationInput
  }

  export type DailyCashExpenseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DailyCashExpenseWhereInput | DailyCashExpenseWhereInput[]
    OR?: DailyCashExpenseWhereInput[]
    NOT?: DailyCashExpenseWhereInput | DailyCashExpenseWhereInput[]
    renditionId?: IntFilter<"DailyCashExpense"> | number
    description?: StringFilter<"DailyCashExpense"> | string
    amount?: DecimalFilter<"DailyCashExpense"> | Decimal | DecimalJsLike | number | string
    personalAmount?: DecimalFilter<"DailyCashExpense"> | Decimal | DecimalJsLike | number | string
    paidWithPersonal?: BoolFilter<"DailyCashExpense"> | boolean
    createdAt?: DateTimeFilter<"DailyCashExpense"> | Date | string
    rendition?: XOR<DailyCashRenditionScalarRelationFilter, DailyCashRenditionWhereInput>
  }, "id">

  export type DailyCashExpenseOrderByWithAggregationInput = {
    id?: SortOrder
    renditionId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    personalAmount?: SortOrder
    paidWithPersonal?: SortOrder
    createdAt?: SortOrder
    _count?: DailyCashExpenseCountOrderByAggregateInput
    _avg?: DailyCashExpenseAvgOrderByAggregateInput
    _max?: DailyCashExpenseMaxOrderByAggregateInput
    _min?: DailyCashExpenseMinOrderByAggregateInput
    _sum?: DailyCashExpenseSumOrderByAggregateInput
  }

  export type DailyCashExpenseScalarWhereWithAggregatesInput = {
    AND?: DailyCashExpenseScalarWhereWithAggregatesInput | DailyCashExpenseScalarWhereWithAggregatesInput[]
    OR?: DailyCashExpenseScalarWhereWithAggregatesInput[]
    NOT?: DailyCashExpenseScalarWhereWithAggregatesInput | DailyCashExpenseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DailyCashExpense"> | number
    renditionId?: IntWithAggregatesFilter<"DailyCashExpense"> | number
    description?: StringWithAggregatesFilter<"DailyCashExpense"> | string
    amount?: DecimalWithAggregatesFilter<"DailyCashExpense"> | Decimal | DecimalJsLike | number | string
    personalAmount?: DecimalWithAggregatesFilter<"DailyCashExpense"> | Decimal | DecimalJsLike | number | string
    paidWithPersonal?: BoolWithAggregatesFilter<"DailyCashExpense"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"DailyCashExpense"> | Date | string
  }

  export type AdminSettingWhereInput = {
    AND?: AdminSettingWhereInput | AdminSettingWhereInput[]
    OR?: AdminSettingWhereInput[]
    NOT?: AdminSettingWhereInput | AdminSettingWhereInput[]
    id?: IntFilter<"AdminSetting"> | number
    deletePasswordHash?: StringFilter<"AdminSetting"> | string
    createdAt?: DateTimeFilter<"AdminSetting"> | Date | string
    updatedAt?: DateTimeFilter<"AdminSetting"> | Date | string
  }

  export type AdminSettingOrderByWithRelationInput = {
    id?: SortOrder
    deletePasswordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AdminSettingWhereInput | AdminSettingWhereInput[]
    OR?: AdminSettingWhereInput[]
    NOT?: AdminSettingWhereInput | AdminSettingWhereInput[]
    deletePasswordHash?: StringFilter<"AdminSetting"> | string
    createdAt?: DateTimeFilter<"AdminSetting"> | Date | string
    updatedAt?: DateTimeFilter<"AdminSetting"> | Date | string
  }, "id">

  export type AdminSettingOrderByWithAggregationInput = {
    id?: SortOrder
    deletePasswordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminSettingCountOrderByAggregateInput
    _avg?: AdminSettingAvgOrderByAggregateInput
    _max?: AdminSettingMaxOrderByAggregateInput
    _min?: AdminSettingMinOrderByAggregateInput
    _sum?: AdminSettingSumOrderByAggregateInput
  }

  export type AdminSettingScalarWhereWithAggregatesInput = {
    AND?: AdminSettingScalarWhereWithAggregatesInput | AdminSettingScalarWhereWithAggregatesInput[]
    OR?: AdminSettingScalarWhereWithAggregatesInput[]
    NOT?: AdminSettingScalarWhereWithAggregatesInput | AdminSettingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AdminSetting"> | number
    deletePasswordHash?: StringWithAggregatesFilter<"AdminSetting"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AdminSetting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdminSetting"> | Date | string
  }

  export type EmployeeWhereInput = {
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    id?: IntFilter<"Employee"> | number
    code?: StringNullableFilter<"Employee"> | string | null
    firstName?: StringFilter<"Employee"> | string
    lastName?: StringFilter<"Employee"> | string
    documentType?: EnumDocumentTypeNullableFilter<"Employee"> | $Enums.DocumentType | null
    documentNumber?: StringNullableFilter<"Employee"> | string | null
    position?: StringNullableFilter<"Employee"> | string | null
    phone?: StringNullableFilter<"Employee"> | string | null
    email?: StringNullableFilter<"Employee"> | string | null
    bankType?: EnumBankTypeFilter<"Employee"> | $Enums.BankType
    accountNumber?: StringNullableFilter<"Employee"> | string | null
    cci?: StringNullableFilter<"Employee"> | string | null
    startDate?: DateTimeNullableFilter<"Employee"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Employee"> | Date | string | null
    baseSalary?: DecimalFilter<"Employee"> | Decimal | DecimalJsLike | number | string
    dailyHours?: DecimalFilter<"Employee"> | Decimal | DecimalJsLike | number | string
    pensionSystem?: EnumPensionSystemFilter<"Employee"> | $Enums.PensionSystem
    pensionRate?: DecimalFilter<"Employee"> | Decimal | DecimalJsLike | number | string
    healthRate?: DecimalFilter<"Employee"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"Employee"> | boolean
    area?: EnumEmployeeAreaFilter<"Employee"> | $Enums.EmployeeArea
    obraId?: IntNullableFilter<"Employee"> | number | null
    notes?: StringNullableFilter<"Employee"> | string | null
    absenceSundayPenalty?: BoolFilter<"Employee"> | boolean
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    obra?: XOR<ObraNullableScalarRelationFilter, ObraWhereInput> | null
    attendances?: AttendanceRecordListRelationFilter
    payrollEntries?: PayrollEntryListRelationFilter
    accumulationPayment?: XOR<EmployeeAccumulationPaymentNullableScalarRelationFilter, EmployeeAccumulationPaymentWhereInput> | null
  }

  export type EmployeeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    documentType?: SortOrderInput | SortOrder
    documentNumber?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    bankType?: SortOrder
    accountNumber?: SortOrderInput | SortOrder
    cci?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    baseSalary?: SortOrder
    dailyHours?: SortOrder
    pensionSystem?: SortOrder
    pensionRate?: SortOrder
    healthRate?: SortOrder
    isActive?: SortOrder
    area?: SortOrder
    obraId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    absenceSundayPenalty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    obra?: ObraOrderByWithRelationInput
    attendances?: AttendanceRecordOrderByRelationAggregateInput
    payrollEntries?: PayrollEntryOrderByRelationAggregateInput
    accumulationPayment?: EmployeeAccumulationPaymentOrderByWithRelationInput
  }

  export type EmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    documentNumber?: string
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    firstName?: StringFilter<"Employee"> | string
    lastName?: StringFilter<"Employee"> | string
    documentType?: EnumDocumentTypeNullableFilter<"Employee"> | $Enums.DocumentType | null
    position?: StringNullableFilter<"Employee"> | string | null
    phone?: StringNullableFilter<"Employee"> | string | null
    email?: StringNullableFilter<"Employee"> | string | null
    bankType?: EnumBankTypeFilter<"Employee"> | $Enums.BankType
    accountNumber?: StringNullableFilter<"Employee"> | string | null
    cci?: StringNullableFilter<"Employee"> | string | null
    startDate?: DateTimeNullableFilter<"Employee"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Employee"> | Date | string | null
    baseSalary?: DecimalFilter<"Employee"> | Decimal | DecimalJsLike | number | string
    dailyHours?: DecimalFilter<"Employee"> | Decimal | DecimalJsLike | number | string
    pensionSystem?: EnumPensionSystemFilter<"Employee"> | $Enums.PensionSystem
    pensionRate?: DecimalFilter<"Employee"> | Decimal | DecimalJsLike | number | string
    healthRate?: DecimalFilter<"Employee"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"Employee"> | boolean
    area?: EnumEmployeeAreaFilter<"Employee"> | $Enums.EmployeeArea
    obraId?: IntNullableFilter<"Employee"> | number | null
    notes?: StringNullableFilter<"Employee"> | string | null
    absenceSundayPenalty?: BoolFilter<"Employee"> | boolean
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    obra?: XOR<ObraNullableScalarRelationFilter, ObraWhereInput> | null
    attendances?: AttendanceRecordListRelationFilter
    payrollEntries?: PayrollEntryListRelationFilter
    accumulationPayment?: XOR<EmployeeAccumulationPaymentNullableScalarRelationFilter, EmployeeAccumulationPaymentWhereInput> | null
  }, "id" | "code" | "documentNumber">

  export type EmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    documentType?: SortOrderInput | SortOrder
    documentNumber?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    bankType?: SortOrder
    accountNumber?: SortOrderInput | SortOrder
    cci?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    baseSalary?: SortOrder
    dailyHours?: SortOrder
    pensionSystem?: SortOrder
    pensionRate?: SortOrder
    healthRate?: SortOrder
    isActive?: SortOrder
    area?: SortOrder
    obraId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    absenceSundayPenalty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _avg?: EmployeeAvgOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
    _sum?: EmployeeSumOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    OR?: EmployeeScalarWhereWithAggregatesInput[]
    NOT?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Employee"> | number
    code?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    firstName?: StringWithAggregatesFilter<"Employee"> | string
    lastName?: StringWithAggregatesFilter<"Employee"> | string
    documentType?: EnumDocumentTypeNullableWithAggregatesFilter<"Employee"> | $Enums.DocumentType | null
    documentNumber?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    position?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    email?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    bankType?: EnumBankTypeWithAggregatesFilter<"Employee"> | $Enums.BankType
    accountNumber?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    cci?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    startDate?: DateTimeNullableWithAggregatesFilter<"Employee"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Employee"> | Date | string | null
    baseSalary?: DecimalWithAggregatesFilter<"Employee"> | Decimal | DecimalJsLike | number | string
    dailyHours?: DecimalWithAggregatesFilter<"Employee"> | Decimal | DecimalJsLike | number | string
    pensionSystem?: EnumPensionSystemWithAggregatesFilter<"Employee"> | $Enums.PensionSystem
    pensionRate?: DecimalWithAggregatesFilter<"Employee"> | Decimal | DecimalJsLike | number | string
    healthRate?: DecimalWithAggregatesFilter<"Employee"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolWithAggregatesFilter<"Employee"> | boolean
    area?: EnumEmployeeAreaWithAggregatesFilter<"Employee"> | $Enums.EmployeeArea
    obraId?: IntNullableWithAggregatesFilter<"Employee"> | number | null
    notes?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    absenceSundayPenalty?: BoolWithAggregatesFilter<"Employee"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
  }

  export type EmployeeAccumulationPaymentWhereInput = {
    AND?: EmployeeAccumulationPaymentWhereInput | EmployeeAccumulationPaymentWhereInput[]
    OR?: EmployeeAccumulationPaymentWhereInput[]
    NOT?: EmployeeAccumulationPaymentWhereInput | EmployeeAccumulationPaymentWhereInput[]
    employeeId?: IntFilter<"EmployeeAccumulationPayment"> | number
    paid?: BoolFilter<"EmployeeAccumulationPayment"> | boolean
    paidAt?: DateTimeNullableFilter<"EmployeeAccumulationPayment"> | Date | string | null
    createdAt?: DateTimeFilter<"EmployeeAccumulationPayment"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeAccumulationPayment"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type EmployeeAccumulationPaymentOrderByWithRelationInput = {
    employeeId?: SortOrder
    paid?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type EmployeeAccumulationPaymentWhereUniqueInput = Prisma.AtLeast<{
    employeeId?: number
    AND?: EmployeeAccumulationPaymentWhereInput | EmployeeAccumulationPaymentWhereInput[]
    OR?: EmployeeAccumulationPaymentWhereInput[]
    NOT?: EmployeeAccumulationPaymentWhereInput | EmployeeAccumulationPaymentWhereInput[]
    paid?: BoolFilter<"EmployeeAccumulationPayment"> | boolean
    paidAt?: DateTimeNullableFilter<"EmployeeAccumulationPayment"> | Date | string | null
    createdAt?: DateTimeFilter<"EmployeeAccumulationPayment"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeAccumulationPayment"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "employeeId">

  export type EmployeeAccumulationPaymentOrderByWithAggregationInput = {
    employeeId?: SortOrder
    paid?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmployeeAccumulationPaymentCountOrderByAggregateInput
    _avg?: EmployeeAccumulationPaymentAvgOrderByAggregateInput
    _max?: EmployeeAccumulationPaymentMaxOrderByAggregateInput
    _min?: EmployeeAccumulationPaymentMinOrderByAggregateInput
    _sum?: EmployeeAccumulationPaymentSumOrderByAggregateInput
  }

  export type EmployeeAccumulationPaymentScalarWhereWithAggregatesInput = {
    AND?: EmployeeAccumulationPaymentScalarWhereWithAggregatesInput | EmployeeAccumulationPaymentScalarWhereWithAggregatesInput[]
    OR?: EmployeeAccumulationPaymentScalarWhereWithAggregatesInput[]
    NOT?: EmployeeAccumulationPaymentScalarWhereWithAggregatesInput | EmployeeAccumulationPaymentScalarWhereWithAggregatesInput[]
    employeeId?: IntWithAggregatesFilter<"EmployeeAccumulationPayment"> | number
    paid?: BoolWithAggregatesFilter<"EmployeeAccumulationPayment"> | boolean
    paidAt?: DateTimeNullableWithAggregatesFilter<"EmployeeAccumulationPayment"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmployeeAccumulationPayment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmployeeAccumulationPayment"> | Date | string
  }

  export type AttendanceRecordWhereInput = {
    AND?: AttendanceRecordWhereInput | AttendanceRecordWhereInput[]
    OR?: AttendanceRecordWhereInput[]
    NOT?: AttendanceRecordWhereInput | AttendanceRecordWhereInput[]
    id?: IntFilter<"AttendanceRecord"> | number
    employeeId?: IntFilter<"AttendanceRecord"> | number
    date?: DateTimeFilter<"AttendanceRecord"> | Date | string
    status?: EnumAttendanceStatusFilter<"AttendanceRecord"> | $Enums.AttendanceStatus
    minutesLate?: IntNullableFilter<"AttendanceRecord"> | number | null
    permissionHours?: DecimalNullableFilter<"AttendanceRecord"> | Decimal | DecimalJsLike | number | string | null
    extraHours?: DecimalNullableFilter<"AttendanceRecord"> | Decimal | DecimalJsLike | number | string | null
    permissionPaid?: BoolNullableFilter<"AttendanceRecord"> | boolean | null
    holidayWorked?: BoolFilter<"AttendanceRecord"> | boolean
    holidayCount?: IntFilter<"AttendanceRecord"> | number
    notes?: StringNullableFilter<"AttendanceRecord"> | string | null
    createdAt?: DateTimeFilter<"AttendanceRecord"> | Date | string
    updatedAt?: DateTimeFilter<"AttendanceRecord"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type AttendanceRecordOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    minutesLate?: SortOrderInput | SortOrder
    permissionHours?: SortOrderInput | SortOrder
    extraHours?: SortOrderInput | SortOrder
    permissionPaid?: SortOrderInput | SortOrder
    holidayWorked?: SortOrder
    holidayCount?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type AttendanceRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    employeeId_date?: AttendanceRecordEmployeeIdDateCompoundUniqueInput
    AND?: AttendanceRecordWhereInput | AttendanceRecordWhereInput[]
    OR?: AttendanceRecordWhereInput[]
    NOT?: AttendanceRecordWhereInput | AttendanceRecordWhereInput[]
    employeeId?: IntFilter<"AttendanceRecord"> | number
    date?: DateTimeFilter<"AttendanceRecord"> | Date | string
    status?: EnumAttendanceStatusFilter<"AttendanceRecord"> | $Enums.AttendanceStatus
    minutesLate?: IntNullableFilter<"AttendanceRecord"> | number | null
    permissionHours?: DecimalNullableFilter<"AttendanceRecord"> | Decimal | DecimalJsLike | number | string | null
    extraHours?: DecimalNullableFilter<"AttendanceRecord"> | Decimal | DecimalJsLike | number | string | null
    permissionPaid?: BoolNullableFilter<"AttendanceRecord"> | boolean | null
    holidayWorked?: BoolFilter<"AttendanceRecord"> | boolean
    holidayCount?: IntFilter<"AttendanceRecord"> | number
    notes?: StringNullableFilter<"AttendanceRecord"> | string | null
    createdAt?: DateTimeFilter<"AttendanceRecord"> | Date | string
    updatedAt?: DateTimeFilter<"AttendanceRecord"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "id" | "employeeId_date">

  export type AttendanceRecordOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    minutesLate?: SortOrderInput | SortOrder
    permissionHours?: SortOrderInput | SortOrder
    extraHours?: SortOrderInput | SortOrder
    permissionPaid?: SortOrderInput | SortOrder
    holidayWorked?: SortOrder
    holidayCount?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AttendanceRecordCountOrderByAggregateInput
    _avg?: AttendanceRecordAvgOrderByAggregateInput
    _max?: AttendanceRecordMaxOrderByAggregateInput
    _min?: AttendanceRecordMinOrderByAggregateInput
    _sum?: AttendanceRecordSumOrderByAggregateInput
  }

  export type AttendanceRecordScalarWhereWithAggregatesInput = {
    AND?: AttendanceRecordScalarWhereWithAggregatesInput | AttendanceRecordScalarWhereWithAggregatesInput[]
    OR?: AttendanceRecordScalarWhereWithAggregatesInput[]
    NOT?: AttendanceRecordScalarWhereWithAggregatesInput | AttendanceRecordScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AttendanceRecord"> | number
    employeeId?: IntWithAggregatesFilter<"AttendanceRecord"> | number
    date?: DateTimeWithAggregatesFilter<"AttendanceRecord"> | Date | string
    status?: EnumAttendanceStatusWithAggregatesFilter<"AttendanceRecord"> | $Enums.AttendanceStatus
    minutesLate?: IntNullableWithAggregatesFilter<"AttendanceRecord"> | number | null
    permissionHours?: DecimalNullableWithAggregatesFilter<"AttendanceRecord"> | Decimal | DecimalJsLike | number | string | null
    extraHours?: DecimalNullableWithAggregatesFilter<"AttendanceRecord"> | Decimal | DecimalJsLike | number | string | null
    permissionPaid?: BoolNullableWithAggregatesFilter<"AttendanceRecord"> | boolean | null
    holidayWorked?: BoolWithAggregatesFilter<"AttendanceRecord"> | boolean
    holidayCount?: IntWithAggregatesFilter<"AttendanceRecord"> | number
    notes?: StringNullableWithAggregatesFilter<"AttendanceRecord"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AttendanceRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AttendanceRecord"> | Date | string
  }

  export type PayrollPeriodWhereInput = {
    AND?: PayrollPeriodWhereInput | PayrollPeriodWhereInput[]
    OR?: PayrollPeriodWhereInput[]
    NOT?: PayrollPeriodWhereInput | PayrollPeriodWhereInput[]
    id?: IntFilter<"PayrollPeriod"> | number
    obraId?: IntNullableFilter<"PayrollPeriod"> | number | null
    month?: IntFilter<"PayrollPeriod"> | number
    year?: IntFilter<"PayrollPeriod"> | number
    startDate?: DateTimeFilter<"PayrollPeriod"> | Date | string
    endDate?: DateTimeFilter<"PayrollPeriod"> | Date | string
    workingDays?: IntFilter<"PayrollPeriod"> | number
    status?: EnumPayrollPeriodStatusFilter<"PayrollPeriod"> | $Enums.PayrollPeriodStatus
    notes?: StringNullableFilter<"PayrollPeriod"> | string | null
    createdAt?: DateTimeFilter<"PayrollPeriod"> | Date | string
    updatedAt?: DateTimeFilter<"PayrollPeriod"> | Date | string
    obra?: XOR<ObraNullableScalarRelationFilter, ObraWhereInput> | null
    entries?: PayrollEntryListRelationFilter
  }

  export type PayrollPeriodOrderByWithRelationInput = {
    id?: SortOrder
    obraId?: SortOrderInput | SortOrder
    month?: SortOrder
    year?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    workingDays?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    obra?: ObraOrderByWithRelationInput
    entries?: PayrollEntryOrderByRelationAggregateInput
  }

  export type PayrollPeriodWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    year_month_obraId?: PayrollPeriodYearMonthObraIdCompoundUniqueInput
    AND?: PayrollPeriodWhereInput | PayrollPeriodWhereInput[]
    OR?: PayrollPeriodWhereInput[]
    NOT?: PayrollPeriodWhereInput | PayrollPeriodWhereInput[]
    obraId?: IntNullableFilter<"PayrollPeriod"> | number | null
    month?: IntFilter<"PayrollPeriod"> | number
    year?: IntFilter<"PayrollPeriod"> | number
    startDate?: DateTimeFilter<"PayrollPeriod"> | Date | string
    endDate?: DateTimeFilter<"PayrollPeriod"> | Date | string
    workingDays?: IntFilter<"PayrollPeriod"> | number
    status?: EnumPayrollPeriodStatusFilter<"PayrollPeriod"> | $Enums.PayrollPeriodStatus
    notes?: StringNullableFilter<"PayrollPeriod"> | string | null
    createdAt?: DateTimeFilter<"PayrollPeriod"> | Date | string
    updatedAt?: DateTimeFilter<"PayrollPeriod"> | Date | string
    obra?: XOR<ObraNullableScalarRelationFilter, ObraWhereInput> | null
    entries?: PayrollEntryListRelationFilter
  }, "id" | "year_month_obraId">

  export type PayrollPeriodOrderByWithAggregationInput = {
    id?: SortOrder
    obraId?: SortOrderInput | SortOrder
    month?: SortOrder
    year?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    workingDays?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PayrollPeriodCountOrderByAggregateInput
    _avg?: PayrollPeriodAvgOrderByAggregateInput
    _max?: PayrollPeriodMaxOrderByAggregateInput
    _min?: PayrollPeriodMinOrderByAggregateInput
    _sum?: PayrollPeriodSumOrderByAggregateInput
  }

  export type PayrollPeriodScalarWhereWithAggregatesInput = {
    AND?: PayrollPeriodScalarWhereWithAggregatesInput | PayrollPeriodScalarWhereWithAggregatesInput[]
    OR?: PayrollPeriodScalarWhereWithAggregatesInput[]
    NOT?: PayrollPeriodScalarWhereWithAggregatesInput | PayrollPeriodScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PayrollPeriod"> | number
    obraId?: IntNullableWithAggregatesFilter<"PayrollPeriod"> | number | null
    month?: IntWithAggregatesFilter<"PayrollPeriod"> | number
    year?: IntWithAggregatesFilter<"PayrollPeriod"> | number
    startDate?: DateTimeWithAggregatesFilter<"PayrollPeriod"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"PayrollPeriod"> | Date | string
    workingDays?: IntWithAggregatesFilter<"PayrollPeriod"> | number
    status?: EnumPayrollPeriodStatusWithAggregatesFilter<"PayrollPeriod"> | $Enums.PayrollPeriodStatus
    notes?: StringNullableWithAggregatesFilter<"PayrollPeriod"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PayrollPeriod"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PayrollPeriod"> | Date | string
  }

  export type PayrollEntryWhereInput = {
    AND?: PayrollEntryWhereInput | PayrollEntryWhereInput[]
    OR?: PayrollEntryWhereInput[]
    NOT?: PayrollEntryWhereInput | PayrollEntryWhereInput[]
    id?: IntFilter<"PayrollEntry"> | number
    periodId?: IntFilter<"PayrollEntry"> | number
    employeeId?: IntFilter<"PayrollEntry"> | number
    baseSalary?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    dailyRate?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    hourlyRate?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    workedDays?: IntFilter<"PayrollEntry"> | number
    absenceDays?: IntFilter<"PayrollEntry"> | number
    tardinessMinutes?: IntFilter<"PayrollEntry"> | number
    permissionHours?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    overtimeHours?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    bonusesTotal?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    deductionsTotal?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    pensionAmount?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    healthAmount?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    grossEarnings?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    netPay?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    permissionDays?: IntFilter<"PayrollEntry"> | number
    holidayDays?: IntFilter<"PayrollEntry"> | number
    holidayBonus?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    details?: JsonNullableFilter<"PayrollEntry">
    createdAt?: DateTimeFilter<"PayrollEntry"> | Date | string
    updatedAt?: DateTimeFilter<"PayrollEntry"> | Date | string
    period?: XOR<PayrollPeriodScalarRelationFilter, PayrollPeriodWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    adjustments?: PayrollAdjustmentListRelationFilter
  }

  export type PayrollEntryOrderByWithRelationInput = {
    id?: SortOrder
    periodId?: SortOrder
    employeeId?: SortOrder
    baseSalary?: SortOrder
    dailyRate?: SortOrder
    hourlyRate?: SortOrder
    workedDays?: SortOrder
    absenceDays?: SortOrder
    tardinessMinutes?: SortOrder
    permissionHours?: SortOrder
    overtimeHours?: SortOrder
    bonusesTotal?: SortOrder
    deductionsTotal?: SortOrder
    pensionAmount?: SortOrder
    healthAmount?: SortOrder
    grossEarnings?: SortOrder
    netPay?: SortOrder
    permissionDays?: SortOrder
    holidayDays?: SortOrder
    holidayBonus?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    period?: PayrollPeriodOrderByWithRelationInput
    employee?: EmployeeOrderByWithRelationInput
    adjustments?: PayrollAdjustmentOrderByRelationAggregateInput
  }

  export type PayrollEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    periodId_employeeId?: PayrollEntryPeriodIdEmployeeIdCompoundUniqueInput
    AND?: PayrollEntryWhereInput | PayrollEntryWhereInput[]
    OR?: PayrollEntryWhereInput[]
    NOT?: PayrollEntryWhereInput | PayrollEntryWhereInput[]
    periodId?: IntFilter<"PayrollEntry"> | number
    employeeId?: IntFilter<"PayrollEntry"> | number
    baseSalary?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    dailyRate?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    hourlyRate?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    workedDays?: IntFilter<"PayrollEntry"> | number
    absenceDays?: IntFilter<"PayrollEntry"> | number
    tardinessMinutes?: IntFilter<"PayrollEntry"> | number
    permissionHours?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    overtimeHours?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    bonusesTotal?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    deductionsTotal?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    pensionAmount?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    healthAmount?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    grossEarnings?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    netPay?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    permissionDays?: IntFilter<"PayrollEntry"> | number
    holidayDays?: IntFilter<"PayrollEntry"> | number
    holidayBonus?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    details?: JsonNullableFilter<"PayrollEntry">
    createdAt?: DateTimeFilter<"PayrollEntry"> | Date | string
    updatedAt?: DateTimeFilter<"PayrollEntry"> | Date | string
    period?: XOR<PayrollPeriodScalarRelationFilter, PayrollPeriodWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    adjustments?: PayrollAdjustmentListRelationFilter
  }, "id" | "periodId_employeeId">

  export type PayrollEntryOrderByWithAggregationInput = {
    id?: SortOrder
    periodId?: SortOrder
    employeeId?: SortOrder
    baseSalary?: SortOrder
    dailyRate?: SortOrder
    hourlyRate?: SortOrder
    workedDays?: SortOrder
    absenceDays?: SortOrder
    tardinessMinutes?: SortOrder
    permissionHours?: SortOrder
    overtimeHours?: SortOrder
    bonusesTotal?: SortOrder
    deductionsTotal?: SortOrder
    pensionAmount?: SortOrder
    healthAmount?: SortOrder
    grossEarnings?: SortOrder
    netPay?: SortOrder
    permissionDays?: SortOrder
    holidayDays?: SortOrder
    holidayBonus?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PayrollEntryCountOrderByAggregateInput
    _avg?: PayrollEntryAvgOrderByAggregateInput
    _max?: PayrollEntryMaxOrderByAggregateInput
    _min?: PayrollEntryMinOrderByAggregateInput
    _sum?: PayrollEntrySumOrderByAggregateInput
  }

  export type PayrollEntryScalarWhereWithAggregatesInput = {
    AND?: PayrollEntryScalarWhereWithAggregatesInput | PayrollEntryScalarWhereWithAggregatesInput[]
    OR?: PayrollEntryScalarWhereWithAggregatesInput[]
    NOT?: PayrollEntryScalarWhereWithAggregatesInput | PayrollEntryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PayrollEntry"> | number
    periodId?: IntWithAggregatesFilter<"PayrollEntry"> | number
    employeeId?: IntWithAggregatesFilter<"PayrollEntry"> | number
    baseSalary?: DecimalWithAggregatesFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    dailyRate?: DecimalWithAggregatesFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    hourlyRate?: DecimalWithAggregatesFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    workedDays?: IntWithAggregatesFilter<"PayrollEntry"> | number
    absenceDays?: IntWithAggregatesFilter<"PayrollEntry"> | number
    tardinessMinutes?: IntWithAggregatesFilter<"PayrollEntry"> | number
    permissionHours?: DecimalWithAggregatesFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    overtimeHours?: DecimalWithAggregatesFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    bonusesTotal?: DecimalWithAggregatesFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    deductionsTotal?: DecimalWithAggregatesFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    pensionAmount?: DecimalWithAggregatesFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    healthAmount?: DecimalWithAggregatesFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    grossEarnings?: DecimalWithAggregatesFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    netPay?: DecimalWithAggregatesFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    permissionDays?: IntWithAggregatesFilter<"PayrollEntry"> | number
    holidayDays?: IntWithAggregatesFilter<"PayrollEntry"> | number
    holidayBonus?: DecimalWithAggregatesFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    details?: JsonNullableWithAggregatesFilter<"PayrollEntry">
    createdAt?: DateTimeWithAggregatesFilter<"PayrollEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PayrollEntry"> | Date | string
  }

  export type PayrollAdjustmentWhereInput = {
    AND?: PayrollAdjustmentWhereInput | PayrollAdjustmentWhereInput[]
    OR?: PayrollAdjustmentWhereInput[]
    NOT?: PayrollAdjustmentWhereInput | PayrollAdjustmentWhereInput[]
    id?: IntFilter<"PayrollAdjustment"> | number
    entryId?: IntFilter<"PayrollAdjustment"> | number
    type?: EnumPayrollAdjustmentTypeFilter<"PayrollAdjustment"> | $Enums.PayrollAdjustmentType
    concept?: StringFilter<"PayrollAdjustment"> | string
    amount?: DecimalFilter<"PayrollAdjustment"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"PayrollAdjustment"> | Date | string
    updatedAt?: DateTimeFilter<"PayrollAdjustment"> | Date | string
    entry?: XOR<PayrollEntryScalarRelationFilter, PayrollEntryWhereInput>
  }

  export type PayrollAdjustmentOrderByWithRelationInput = {
    id?: SortOrder
    entryId?: SortOrder
    type?: SortOrder
    concept?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    entry?: PayrollEntryOrderByWithRelationInput
  }

  export type PayrollAdjustmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PayrollAdjustmentWhereInput | PayrollAdjustmentWhereInput[]
    OR?: PayrollAdjustmentWhereInput[]
    NOT?: PayrollAdjustmentWhereInput | PayrollAdjustmentWhereInput[]
    entryId?: IntFilter<"PayrollAdjustment"> | number
    type?: EnumPayrollAdjustmentTypeFilter<"PayrollAdjustment"> | $Enums.PayrollAdjustmentType
    concept?: StringFilter<"PayrollAdjustment"> | string
    amount?: DecimalFilter<"PayrollAdjustment"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"PayrollAdjustment"> | Date | string
    updatedAt?: DateTimeFilter<"PayrollAdjustment"> | Date | string
    entry?: XOR<PayrollEntryScalarRelationFilter, PayrollEntryWhereInput>
  }, "id">

  export type PayrollAdjustmentOrderByWithAggregationInput = {
    id?: SortOrder
    entryId?: SortOrder
    type?: SortOrder
    concept?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PayrollAdjustmentCountOrderByAggregateInput
    _avg?: PayrollAdjustmentAvgOrderByAggregateInput
    _max?: PayrollAdjustmentMaxOrderByAggregateInput
    _min?: PayrollAdjustmentMinOrderByAggregateInput
    _sum?: PayrollAdjustmentSumOrderByAggregateInput
  }

  export type PayrollAdjustmentScalarWhereWithAggregatesInput = {
    AND?: PayrollAdjustmentScalarWhereWithAggregatesInput | PayrollAdjustmentScalarWhereWithAggregatesInput[]
    OR?: PayrollAdjustmentScalarWhereWithAggregatesInput[]
    NOT?: PayrollAdjustmentScalarWhereWithAggregatesInput | PayrollAdjustmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PayrollAdjustment"> | number
    entryId?: IntWithAggregatesFilter<"PayrollAdjustment"> | number
    type?: EnumPayrollAdjustmentTypeWithAggregatesFilter<"PayrollAdjustment"> | $Enums.PayrollAdjustmentType
    concept?: StringWithAggregatesFilter<"PayrollAdjustment"> | string
    amount?: DecimalWithAggregatesFilter<"PayrollAdjustment"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"PayrollAdjustment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PayrollAdjustment"> | Date | string
  }

  export type PartnerWhereInput = {
    AND?: PartnerWhereInput | PartnerWhereInput[]
    OR?: PartnerWhereInput[]
    NOT?: PartnerWhereInput | PartnerWhereInput[]
    id?: IntFilter<"Partner"> | number
    name?: StringFilter<"Partner"> | string
    createdAt?: DateTimeFilter<"Partner"> | Date | string
    updatedAt?: DateTimeFilter<"Partner"> | Date | string
    loansGiven?: PartnerLoanListRelationFilter
    loansReceived?: PartnerLoanListRelationFilter
  }

  export type PartnerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    loansGiven?: PartnerLoanOrderByRelationAggregateInput
    loansReceived?: PartnerLoanOrderByRelationAggregateInput
  }

  export type PartnerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: PartnerWhereInput | PartnerWhereInput[]
    OR?: PartnerWhereInput[]
    NOT?: PartnerWhereInput | PartnerWhereInput[]
    createdAt?: DateTimeFilter<"Partner"> | Date | string
    updatedAt?: DateTimeFilter<"Partner"> | Date | string
    loansGiven?: PartnerLoanListRelationFilter
    loansReceived?: PartnerLoanListRelationFilter
  }, "id" | "name">

  export type PartnerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PartnerCountOrderByAggregateInput
    _avg?: PartnerAvgOrderByAggregateInput
    _max?: PartnerMaxOrderByAggregateInput
    _min?: PartnerMinOrderByAggregateInput
    _sum?: PartnerSumOrderByAggregateInput
  }

  export type PartnerScalarWhereWithAggregatesInput = {
    AND?: PartnerScalarWhereWithAggregatesInput | PartnerScalarWhereWithAggregatesInput[]
    OR?: PartnerScalarWhereWithAggregatesInput[]
    NOT?: PartnerScalarWhereWithAggregatesInput | PartnerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Partner"> | number
    name?: StringWithAggregatesFilter<"Partner"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Partner"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Partner"> | Date | string
  }

  export type PartnerLoanWhereInput = {
    AND?: PartnerLoanWhereInput | PartnerLoanWhereInput[]
    OR?: PartnerLoanWhereInput[]
    NOT?: PartnerLoanWhereInput | PartnerLoanWhereInput[]
    id?: IntFilter<"PartnerLoan"> | number
    date?: DateTimeFilter<"PartnerLoan"> | Date | string
    giverId?: IntFilter<"PartnerLoan"> | number
    receiverId?: IntFilter<"PartnerLoan"> | number
    amount?: DecimalFilter<"PartnerLoan"> | Decimal | DecimalJsLike | number | string
    note?: StringNullableFilter<"PartnerLoan"> | string | null
    status?: EnumPartnerLoanStatusFilter<"PartnerLoan"> | $Enums.PartnerLoanStatus
    financeRefs?: JsonNullableFilter<"PartnerLoan">
    closeDate?: DateTimeNullableFilter<"PartnerLoan"> | Date | string | null
    createdAt?: DateTimeFilter<"PartnerLoan"> | Date | string
    updatedAt?: DateTimeFilter<"PartnerLoan"> | Date | string
    giver?: XOR<PartnerScalarRelationFilter, PartnerWhereInput>
    receiver?: XOR<PartnerScalarRelationFilter, PartnerWhereInput>
  }

  export type PartnerLoanOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    giverId?: SortOrder
    receiverId?: SortOrder
    amount?: SortOrder
    note?: SortOrderInput | SortOrder
    status?: SortOrder
    financeRefs?: SortOrderInput | SortOrder
    closeDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    giver?: PartnerOrderByWithRelationInput
    receiver?: PartnerOrderByWithRelationInput
  }

  export type PartnerLoanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PartnerLoanWhereInput | PartnerLoanWhereInput[]
    OR?: PartnerLoanWhereInput[]
    NOT?: PartnerLoanWhereInput | PartnerLoanWhereInput[]
    date?: DateTimeFilter<"PartnerLoan"> | Date | string
    giverId?: IntFilter<"PartnerLoan"> | number
    receiverId?: IntFilter<"PartnerLoan"> | number
    amount?: DecimalFilter<"PartnerLoan"> | Decimal | DecimalJsLike | number | string
    note?: StringNullableFilter<"PartnerLoan"> | string | null
    status?: EnumPartnerLoanStatusFilter<"PartnerLoan"> | $Enums.PartnerLoanStatus
    financeRefs?: JsonNullableFilter<"PartnerLoan">
    closeDate?: DateTimeNullableFilter<"PartnerLoan"> | Date | string | null
    createdAt?: DateTimeFilter<"PartnerLoan"> | Date | string
    updatedAt?: DateTimeFilter<"PartnerLoan"> | Date | string
    giver?: XOR<PartnerScalarRelationFilter, PartnerWhereInput>
    receiver?: XOR<PartnerScalarRelationFilter, PartnerWhereInput>
  }, "id">

  export type PartnerLoanOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    giverId?: SortOrder
    receiverId?: SortOrder
    amount?: SortOrder
    note?: SortOrderInput | SortOrder
    status?: SortOrder
    financeRefs?: SortOrderInput | SortOrder
    closeDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PartnerLoanCountOrderByAggregateInput
    _avg?: PartnerLoanAvgOrderByAggregateInput
    _max?: PartnerLoanMaxOrderByAggregateInput
    _min?: PartnerLoanMinOrderByAggregateInput
    _sum?: PartnerLoanSumOrderByAggregateInput
  }

  export type PartnerLoanScalarWhereWithAggregatesInput = {
    AND?: PartnerLoanScalarWhereWithAggregatesInput | PartnerLoanScalarWhereWithAggregatesInput[]
    OR?: PartnerLoanScalarWhereWithAggregatesInput[]
    NOT?: PartnerLoanScalarWhereWithAggregatesInput | PartnerLoanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PartnerLoan"> | number
    date?: DateTimeWithAggregatesFilter<"PartnerLoan"> | Date | string
    giverId?: IntWithAggregatesFilter<"PartnerLoan"> | number
    receiverId?: IntWithAggregatesFilter<"PartnerLoan"> | number
    amount?: DecimalWithAggregatesFilter<"PartnerLoan"> | Decimal | DecimalJsLike | number | string
    note?: StringNullableWithAggregatesFilter<"PartnerLoan"> | string | null
    status?: EnumPartnerLoanStatusWithAggregatesFilter<"PartnerLoan"> | $Enums.PartnerLoanStatus
    financeRefs?: JsonNullableWithAggregatesFilter<"PartnerLoan">
    closeDate?: DateTimeNullableWithAggregatesFilter<"PartnerLoan"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PartnerLoan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PartnerLoan"> | Date | string
  }

  export type FoodIngredientWhereInput = {
    AND?: FoodIngredientWhereInput | FoodIngredientWhereInput[]
    OR?: FoodIngredientWhereInput[]
    NOT?: FoodIngredientWhereInput | FoodIngredientWhereInput[]
    id?: IntFilter<"FoodIngredient"> | number
    name?: StringFilter<"FoodIngredient"> | string
    category?: StringNullableFilter<"FoodIngredient"> | string | null
    unit?: StringNullableFilter<"FoodIngredient"> | string | null
    defaultWastePct?: DecimalFilter<"FoodIngredient"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"FoodIngredient"> | string | null
    createdAt?: DateTimeFilter<"FoodIngredient"> | Date | string
    updatedAt?: DateTimeFilter<"FoodIngredient"> | Date | string
    costs?: FoodIngredientCostListRelationFilter
    items?: FoodRecipeItemListRelationFilter
  }

  export type FoodIngredientOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    defaultWastePct?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    costs?: FoodIngredientCostOrderByRelationAggregateInput
    items?: FoodRecipeItemOrderByRelationAggregateInput
  }

  export type FoodIngredientWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: FoodIngredientWhereInput | FoodIngredientWhereInput[]
    OR?: FoodIngredientWhereInput[]
    NOT?: FoodIngredientWhereInput | FoodIngredientWhereInput[]
    category?: StringNullableFilter<"FoodIngredient"> | string | null
    unit?: StringNullableFilter<"FoodIngredient"> | string | null
    defaultWastePct?: DecimalFilter<"FoodIngredient"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"FoodIngredient"> | string | null
    createdAt?: DateTimeFilter<"FoodIngredient"> | Date | string
    updatedAt?: DateTimeFilter<"FoodIngredient"> | Date | string
    costs?: FoodIngredientCostListRelationFilter
    items?: FoodRecipeItemListRelationFilter
  }, "id" | "name">

  export type FoodIngredientOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    defaultWastePct?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FoodIngredientCountOrderByAggregateInput
    _avg?: FoodIngredientAvgOrderByAggregateInput
    _max?: FoodIngredientMaxOrderByAggregateInput
    _min?: FoodIngredientMinOrderByAggregateInput
    _sum?: FoodIngredientSumOrderByAggregateInput
  }

  export type FoodIngredientScalarWhereWithAggregatesInput = {
    AND?: FoodIngredientScalarWhereWithAggregatesInput | FoodIngredientScalarWhereWithAggregatesInput[]
    OR?: FoodIngredientScalarWhereWithAggregatesInput[]
    NOT?: FoodIngredientScalarWhereWithAggregatesInput | FoodIngredientScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FoodIngredient"> | number
    name?: StringWithAggregatesFilter<"FoodIngredient"> | string
    category?: StringNullableWithAggregatesFilter<"FoodIngredient"> | string | null
    unit?: StringNullableWithAggregatesFilter<"FoodIngredient"> | string | null
    defaultWastePct?: DecimalWithAggregatesFilter<"FoodIngredient"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableWithAggregatesFilter<"FoodIngredient"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FoodIngredient"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FoodIngredient"> | Date | string
  }

  export type FoodIngredientCostWhereInput = {
    AND?: FoodIngredientCostWhereInput | FoodIngredientCostWhereInput[]
    OR?: FoodIngredientCostWhereInput[]
    NOT?: FoodIngredientCostWhereInput | FoodIngredientCostWhereInput[]
    id?: IntFilter<"FoodIngredientCost"> | number
    ingredientId?: IntFilter<"FoodIngredientCost"> | number
    unitCost?: DecimalFilter<"FoodIngredientCost"> | Decimal | DecimalJsLike | number | string
    effectiveDate?: DateTimeNullableFilter<"FoodIngredientCost"> | Date | string | null
    source?: StringNullableFilter<"FoodIngredientCost"> | string | null
    createdAt?: DateTimeFilter<"FoodIngredientCost"> | Date | string
    ingredient?: XOR<FoodIngredientScalarRelationFilter, FoodIngredientWhereInput>
  }

  export type FoodIngredientCostOrderByWithRelationInput = {
    id?: SortOrder
    ingredientId?: SortOrder
    unitCost?: SortOrder
    effectiveDate?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    ingredient?: FoodIngredientOrderByWithRelationInput
  }

  export type FoodIngredientCostWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FoodIngredientCostWhereInput | FoodIngredientCostWhereInput[]
    OR?: FoodIngredientCostWhereInput[]
    NOT?: FoodIngredientCostWhereInput | FoodIngredientCostWhereInput[]
    ingredientId?: IntFilter<"FoodIngredientCost"> | number
    unitCost?: DecimalFilter<"FoodIngredientCost"> | Decimal | DecimalJsLike | number | string
    effectiveDate?: DateTimeNullableFilter<"FoodIngredientCost"> | Date | string | null
    source?: StringNullableFilter<"FoodIngredientCost"> | string | null
    createdAt?: DateTimeFilter<"FoodIngredientCost"> | Date | string
    ingredient?: XOR<FoodIngredientScalarRelationFilter, FoodIngredientWhereInput>
  }, "id">

  export type FoodIngredientCostOrderByWithAggregationInput = {
    id?: SortOrder
    ingredientId?: SortOrder
    unitCost?: SortOrder
    effectiveDate?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: FoodIngredientCostCountOrderByAggregateInput
    _avg?: FoodIngredientCostAvgOrderByAggregateInput
    _max?: FoodIngredientCostMaxOrderByAggregateInput
    _min?: FoodIngredientCostMinOrderByAggregateInput
    _sum?: FoodIngredientCostSumOrderByAggregateInput
  }

  export type FoodIngredientCostScalarWhereWithAggregatesInput = {
    AND?: FoodIngredientCostScalarWhereWithAggregatesInput | FoodIngredientCostScalarWhereWithAggregatesInput[]
    OR?: FoodIngredientCostScalarWhereWithAggregatesInput[]
    NOT?: FoodIngredientCostScalarWhereWithAggregatesInput | FoodIngredientCostScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FoodIngredientCost"> | number
    ingredientId?: IntWithAggregatesFilter<"FoodIngredientCost"> | number
    unitCost?: DecimalWithAggregatesFilter<"FoodIngredientCost"> | Decimal | DecimalJsLike | number | string
    effectiveDate?: DateTimeNullableWithAggregatesFilter<"FoodIngredientCost"> | Date | string | null
    source?: StringNullableWithAggregatesFilter<"FoodIngredientCost"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FoodIngredientCost"> | Date | string
  }

  export type FoodRecipeWhereInput = {
    AND?: FoodRecipeWhereInput | FoodRecipeWhereInput[]
    OR?: FoodRecipeWhereInput[]
    NOT?: FoodRecipeWhereInput | FoodRecipeWhereInput[]
    id?: IntFilter<"FoodRecipe"> | number
    name?: StringFilter<"FoodRecipe"> | string
    code?: StringNullableFilter<"FoodRecipe"> | string | null
    mealType?: EnumFoodMealTypeFilter<"FoodRecipe"> | $Enums.FoodMealType
    yield?: DecimalFilter<"FoodRecipe"> | Decimal | DecimalJsLike | number | string
    yieldUnit?: StringNullableFilter<"FoodRecipe"> | string | null
    isActive?: BoolFilter<"FoodRecipe"> | boolean
    notes?: StringNullableFilter<"FoodRecipe"> | string | null
    createdAt?: DateTimeFilter<"FoodRecipe"> | Date | string
    updatedAt?: DateTimeFilter<"FoodRecipe"> | Date | string
    prepMinutes?: DecimalNullableFilter<"FoodRecipe"> | Decimal | DecimalJsLike | number | string | null
    dailyBlocks?: IntNullableFilter<"FoodRecipe"> | number | null
    items?: FoodRecipeItemListRelationFilter
    childItems?: FoodRecipeItemListRelationFilter
    extraCosts?: FoodRecipeCostListRelationFilter
    mealPlanEntries?: FoodMealPlanEntryListRelationFilter
  }

  export type FoodRecipeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    mealType?: SortOrder
    yield?: SortOrder
    yieldUnit?: SortOrderInput | SortOrder
    isActive?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    prepMinutes?: SortOrderInput | SortOrder
    dailyBlocks?: SortOrderInput | SortOrder
    items?: FoodRecipeItemOrderByRelationAggregateInput
    childItems?: FoodRecipeItemOrderByRelationAggregateInput
    extraCosts?: FoodRecipeCostOrderByRelationAggregateInput
    mealPlanEntries?: FoodMealPlanEntryOrderByRelationAggregateInput
  }

  export type FoodRecipeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FoodRecipeWhereInput | FoodRecipeWhereInput[]
    OR?: FoodRecipeWhereInput[]
    NOT?: FoodRecipeWhereInput | FoodRecipeWhereInput[]
    name?: StringFilter<"FoodRecipe"> | string
    code?: StringNullableFilter<"FoodRecipe"> | string | null
    mealType?: EnumFoodMealTypeFilter<"FoodRecipe"> | $Enums.FoodMealType
    yield?: DecimalFilter<"FoodRecipe"> | Decimal | DecimalJsLike | number | string
    yieldUnit?: StringNullableFilter<"FoodRecipe"> | string | null
    isActive?: BoolFilter<"FoodRecipe"> | boolean
    notes?: StringNullableFilter<"FoodRecipe"> | string | null
    createdAt?: DateTimeFilter<"FoodRecipe"> | Date | string
    updatedAt?: DateTimeFilter<"FoodRecipe"> | Date | string
    prepMinutes?: DecimalNullableFilter<"FoodRecipe"> | Decimal | DecimalJsLike | number | string | null
    dailyBlocks?: IntNullableFilter<"FoodRecipe"> | number | null
    items?: FoodRecipeItemListRelationFilter
    childItems?: FoodRecipeItemListRelationFilter
    extraCosts?: FoodRecipeCostListRelationFilter
    mealPlanEntries?: FoodMealPlanEntryListRelationFilter
  }, "id">

  export type FoodRecipeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    mealType?: SortOrder
    yield?: SortOrder
    yieldUnit?: SortOrderInput | SortOrder
    isActive?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    prepMinutes?: SortOrderInput | SortOrder
    dailyBlocks?: SortOrderInput | SortOrder
    _count?: FoodRecipeCountOrderByAggregateInput
    _avg?: FoodRecipeAvgOrderByAggregateInput
    _max?: FoodRecipeMaxOrderByAggregateInput
    _min?: FoodRecipeMinOrderByAggregateInput
    _sum?: FoodRecipeSumOrderByAggregateInput
  }

  export type FoodRecipeScalarWhereWithAggregatesInput = {
    AND?: FoodRecipeScalarWhereWithAggregatesInput | FoodRecipeScalarWhereWithAggregatesInput[]
    OR?: FoodRecipeScalarWhereWithAggregatesInput[]
    NOT?: FoodRecipeScalarWhereWithAggregatesInput | FoodRecipeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FoodRecipe"> | number
    name?: StringWithAggregatesFilter<"FoodRecipe"> | string
    code?: StringNullableWithAggregatesFilter<"FoodRecipe"> | string | null
    mealType?: EnumFoodMealTypeWithAggregatesFilter<"FoodRecipe"> | $Enums.FoodMealType
    yield?: DecimalWithAggregatesFilter<"FoodRecipe"> | Decimal | DecimalJsLike | number | string
    yieldUnit?: StringNullableWithAggregatesFilter<"FoodRecipe"> | string | null
    isActive?: BoolWithAggregatesFilter<"FoodRecipe"> | boolean
    notes?: StringNullableWithAggregatesFilter<"FoodRecipe"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FoodRecipe"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FoodRecipe"> | Date | string
    prepMinutes?: DecimalNullableWithAggregatesFilter<"FoodRecipe"> | Decimal | DecimalJsLike | number | string | null
    dailyBlocks?: IntNullableWithAggregatesFilter<"FoodRecipe"> | number | null
  }

  export type FoodRecipeItemWhereInput = {
    AND?: FoodRecipeItemWhereInput | FoodRecipeItemWhereInput[]
    OR?: FoodRecipeItemWhereInput[]
    NOT?: FoodRecipeItemWhereInput | FoodRecipeItemWhereInput[]
    id?: IntFilter<"FoodRecipeItem"> | number
    recipeId?: IntFilter<"FoodRecipeItem"> | number
    ingredientId?: IntNullableFilter<"FoodRecipeItem"> | number | null
    childRecipeId?: IntNullableFilter<"FoodRecipeItem"> | number | null
    quantity?: DecimalFilter<"FoodRecipeItem"> | Decimal | DecimalJsLike | number | string
    unit?: StringNullableFilter<"FoodRecipeItem"> | string | null
    wastePct?: DecimalNullableFilter<"FoodRecipeItem"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"FoodRecipeItem"> | string | null
    createdAt?: DateTimeFilter<"FoodRecipeItem"> | Date | string
    recipe?: XOR<FoodRecipeScalarRelationFilter, FoodRecipeWhereInput>
    ingredient?: XOR<FoodIngredientNullableScalarRelationFilter, FoodIngredientWhereInput> | null
    childRecipe?: XOR<FoodRecipeNullableScalarRelationFilter, FoodRecipeWhereInput> | null
  }

  export type FoodRecipeItemOrderByWithRelationInput = {
    id?: SortOrder
    recipeId?: SortOrder
    ingredientId?: SortOrderInput | SortOrder
    childRecipeId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    unit?: SortOrderInput | SortOrder
    wastePct?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    recipe?: FoodRecipeOrderByWithRelationInput
    ingredient?: FoodIngredientOrderByWithRelationInput
    childRecipe?: FoodRecipeOrderByWithRelationInput
  }

  export type FoodRecipeItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FoodRecipeItemWhereInput | FoodRecipeItemWhereInput[]
    OR?: FoodRecipeItemWhereInput[]
    NOT?: FoodRecipeItemWhereInput | FoodRecipeItemWhereInput[]
    recipeId?: IntFilter<"FoodRecipeItem"> | number
    ingredientId?: IntNullableFilter<"FoodRecipeItem"> | number | null
    childRecipeId?: IntNullableFilter<"FoodRecipeItem"> | number | null
    quantity?: DecimalFilter<"FoodRecipeItem"> | Decimal | DecimalJsLike | number | string
    unit?: StringNullableFilter<"FoodRecipeItem"> | string | null
    wastePct?: DecimalNullableFilter<"FoodRecipeItem"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"FoodRecipeItem"> | string | null
    createdAt?: DateTimeFilter<"FoodRecipeItem"> | Date | string
    recipe?: XOR<FoodRecipeScalarRelationFilter, FoodRecipeWhereInput>
    ingredient?: XOR<FoodIngredientNullableScalarRelationFilter, FoodIngredientWhereInput> | null
    childRecipe?: XOR<FoodRecipeNullableScalarRelationFilter, FoodRecipeWhereInput> | null
  }, "id">

  export type FoodRecipeItemOrderByWithAggregationInput = {
    id?: SortOrder
    recipeId?: SortOrder
    ingredientId?: SortOrderInput | SortOrder
    childRecipeId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    unit?: SortOrderInput | SortOrder
    wastePct?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: FoodRecipeItemCountOrderByAggregateInput
    _avg?: FoodRecipeItemAvgOrderByAggregateInput
    _max?: FoodRecipeItemMaxOrderByAggregateInput
    _min?: FoodRecipeItemMinOrderByAggregateInput
    _sum?: FoodRecipeItemSumOrderByAggregateInput
  }

  export type FoodRecipeItemScalarWhereWithAggregatesInput = {
    AND?: FoodRecipeItemScalarWhereWithAggregatesInput | FoodRecipeItemScalarWhereWithAggregatesInput[]
    OR?: FoodRecipeItemScalarWhereWithAggregatesInput[]
    NOT?: FoodRecipeItemScalarWhereWithAggregatesInput | FoodRecipeItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FoodRecipeItem"> | number
    recipeId?: IntWithAggregatesFilter<"FoodRecipeItem"> | number
    ingredientId?: IntNullableWithAggregatesFilter<"FoodRecipeItem"> | number | null
    childRecipeId?: IntNullableWithAggregatesFilter<"FoodRecipeItem"> | number | null
    quantity?: DecimalWithAggregatesFilter<"FoodRecipeItem"> | Decimal | DecimalJsLike | number | string
    unit?: StringNullableWithAggregatesFilter<"FoodRecipeItem"> | string | null
    wastePct?: DecimalNullableWithAggregatesFilter<"FoodRecipeItem"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableWithAggregatesFilter<"FoodRecipeItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FoodRecipeItem"> | Date | string
  }

  export type FoodRecipeCostWhereInput = {
    AND?: FoodRecipeCostWhereInput | FoodRecipeCostWhereInput[]
    OR?: FoodRecipeCostWhereInput[]
    NOT?: FoodRecipeCostWhereInput | FoodRecipeCostWhereInput[]
    id?: IntFilter<"FoodRecipeCost"> | number
    recipeId?: IntFilter<"FoodRecipeCost"> | number
    label?: StringFilter<"FoodRecipeCost"> | string
    amount?: DecimalFilter<"FoodRecipeCost"> | Decimal | DecimalJsLike | number | string
    costType?: EnumFoodCostLineTypeFilter<"FoodRecipeCost"> | $Enums.FoodCostLineType
    period?: EnumFoodCostPeriodFilter<"FoodRecipeCost"> | $Enums.FoodCostPeriod
    periodRations?: DecimalNullableFilter<"FoodRecipeCost"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"FoodRecipeCost"> | string | null
    createdAt?: DateTimeFilter<"FoodRecipeCost"> | Date | string
    recipe?: XOR<FoodRecipeScalarRelationFilter, FoodRecipeWhereInput>
  }

  export type FoodRecipeCostOrderByWithRelationInput = {
    id?: SortOrder
    recipeId?: SortOrder
    label?: SortOrder
    amount?: SortOrder
    costType?: SortOrder
    period?: SortOrder
    periodRations?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    recipe?: FoodRecipeOrderByWithRelationInput
  }

  export type FoodRecipeCostWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FoodRecipeCostWhereInput | FoodRecipeCostWhereInput[]
    OR?: FoodRecipeCostWhereInput[]
    NOT?: FoodRecipeCostWhereInput | FoodRecipeCostWhereInput[]
    recipeId?: IntFilter<"FoodRecipeCost"> | number
    label?: StringFilter<"FoodRecipeCost"> | string
    amount?: DecimalFilter<"FoodRecipeCost"> | Decimal | DecimalJsLike | number | string
    costType?: EnumFoodCostLineTypeFilter<"FoodRecipeCost"> | $Enums.FoodCostLineType
    period?: EnumFoodCostPeriodFilter<"FoodRecipeCost"> | $Enums.FoodCostPeriod
    periodRations?: DecimalNullableFilter<"FoodRecipeCost"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"FoodRecipeCost"> | string | null
    createdAt?: DateTimeFilter<"FoodRecipeCost"> | Date | string
    recipe?: XOR<FoodRecipeScalarRelationFilter, FoodRecipeWhereInput>
  }, "id">

  export type FoodRecipeCostOrderByWithAggregationInput = {
    id?: SortOrder
    recipeId?: SortOrder
    label?: SortOrder
    amount?: SortOrder
    costType?: SortOrder
    period?: SortOrder
    periodRations?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: FoodRecipeCostCountOrderByAggregateInput
    _avg?: FoodRecipeCostAvgOrderByAggregateInput
    _max?: FoodRecipeCostMaxOrderByAggregateInput
    _min?: FoodRecipeCostMinOrderByAggregateInput
    _sum?: FoodRecipeCostSumOrderByAggregateInput
  }

  export type FoodRecipeCostScalarWhereWithAggregatesInput = {
    AND?: FoodRecipeCostScalarWhereWithAggregatesInput | FoodRecipeCostScalarWhereWithAggregatesInput[]
    OR?: FoodRecipeCostScalarWhereWithAggregatesInput[]
    NOT?: FoodRecipeCostScalarWhereWithAggregatesInput | FoodRecipeCostScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FoodRecipeCost"> | number
    recipeId?: IntWithAggregatesFilter<"FoodRecipeCost"> | number
    label?: StringWithAggregatesFilter<"FoodRecipeCost"> | string
    amount?: DecimalWithAggregatesFilter<"FoodRecipeCost"> | Decimal | DecimalJsLike | number | string
    costType?: EnumFoodCostLineTypeWithAggregatesFilter<"FoodRecipeCost"> | $Enums.FoodCostLineType
    period?: EnumFoodCostPeriodWithAggregatesFilter<"FoodRecipeCost"> | $Enums.FoodCostPeriod
    periodRations?: DecimalNullableWithAggregatesFilter<"FoodRecipeCost"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableWithAggregatesFilter<"FoodRecipeCost"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FoodRecipeCost"> | Date | string
  }

  export type FoodCostPoolWhereInput = {
    AND?: FoodCostPoolWhereInput | FoodCostPoolWhereInput[]
    OR?: FoodCostPoolWhereInput[]
    NOT?: FoodCostPoolWhereInput | FoodCostPoolWhereInput[]
    id?: IntFilter<"FoodCostPool"> | number
    name?: StringFilter<"FoodCostPool"> | string
    type?: EnumFoodCostPoolTypeFilter<"FoodCostPool"> | $Enums.FoodCostPoolType
    amount?: DecimalFilter<"FoodCostPool"> | Decimal | DecimalJsLike | number | string
    period?: EnumFoodCostPeriodFilter<"FoodCostPool"> | $Enums.FoodCostPeriod
    periodRations?: DecimalNullableFilter<"FoodCostPool"> | Decimal | DecimalJsLike | number | string | null
    appliesTo?: EnumFoodMealTypeNullableFilter<"FoodCostPool"> | $Enums.FoodMealType | null
    notes?: StringNullableFilter<"FoodCostPool"> | string | null
    allocationMethod?: EnumPoolAllocationMethodFilter<"FoodCostPool"> | $Enums.PoolAllocationMethod
    dailyBlocks?: IntNullableFilter<"FoodCostPool"> | number | null
    timeMinutes?: DecimalNullableFilter<"FoodCostPool"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"FoodCostPool"> | Date | string
    updatedAt?: DateTimeFilter<"FoodCostPool"> | Date | string
  }

  export type FoodCostPoolOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    period?: SortOrder
    periodRations?: SortOrderInput | SortOrder
    appliesTo?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    allocationMethod?: SortOrder
    dailyBlocks?: SortOrderInput | SortOrder
    timeMinutes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoodCostPoolWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FoodCostPoolWhereInput | FoodCostPoolWhereInput[]
    OR?: FoodCostPoolWhereInput[]
    NOT?: FoodCostPoolWhereInput | FoodCostPoolWhereInput[]
    name?: StringFilter<"FoodCostPool"> | string
    type?: EnumFoodCostPoolTypeFilter<"FoodCostPool"> | $Enums.FoodCostPoolType
    amount?: DecimalFilter<"FoodCostPool"> | Decimal | DecimalJsLike | number | string
    period?: EnumFoodCostPeriodFilter<"FoodCostPool"> | $Enums.FoodCostPeriod
    periodRations?: DecimalNullableFilter<"FoodCostPool"> | Decimal | DecimalJsLike | number | string | null
    appliesTo?: EnumFoodMealTypeNullableFilter<"FoodCostPool"> | $Enums.FoodMealType | null
    notes?: StringNullableFilter<"FoodCostPool"> | string | null
    allocationMethod?: EnumPoolAllocationMethodFilter<"FoodCostPool"> | $Enums.PoolAllocationMethod
    dailyBlocks?: IntNullableFilter<"FoodCostPool"> | number | null
    timeMinutes?: DecimalNullableFilter<"FoodCostPool"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"FoodCostPool"> | Date | string
    updatedAt?: DateTimeFilter<"FoodCostPool"> | Date | string
  }, "id">

  export type FoodCostPoolOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    period?: SortOrder
    periodRations?: SortOrderInput | SortOrder
    appliesTo?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    allocationMethod?: SortOrder
    dailyBlocks?: SortOrderInput | SortOrder
    timeMinutes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FoodCostPoolCountOrderByAggregateInput
    _avg?: FoodCostPoolAvgOrderByAggregateInput
    _max?: FoodCostPoolMaxOrderByAggregateInput
    _min?: FoodCostPoolMinOrderByAggregateInput
    _sum?: FoodCostPoolSumOrderByAggregateInput
  }

  export type FoodCostPoolScalarWhereWithAggregatesInput = {
    AND?: FoodCostPoolScalarWhereWithAggregatesInput | FoodCostPoolScalarWhereWithAggregatesInput[]
    OR?: FoodCostPoolScalarWhereWithAggregatesInput[]
    NOT?: FoodCostPoolScalarWhereWithAggregatesInput | FoodCostPoolScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FoodCostPool"> | number
    name?: StringWithAggregatesFilter<"FoodCostPool"> | string
    type?: EnumFoodCostPoolTypeWithAggregatesFilter<"FoodCostPool"> | $Enums.FoodCostPoolType
    amount?: DecimalWithAggregatesFilter<"FoodCostPool"> | Decimal | DecimalJsLike | number | string
    period?: EnumFoodCostPeriodWithAggregatesFilter<"FoodCostPool"> | $Enums.FoodCostPeriod
    periodRations?: DecimalNullableWithAggregatesFilter<"FoodCostPool"> | Decimal | DecimalJsLike | number | string | null
    appliesTo?: EnumFoodMealTypeNullableWithAggregatesFilter<"FoodCostPool"> | $Enums.FoodMealType | null
    notes?: StringNullableWithAggregatesFilter<"FoodCostPool"> | string | null
    allocationMethod?: EnumPoolAllocationMethodWithAggregatesFilter<"FoodCostPool"> | $Enums.PoolAllocationMethod
    dailyBlocks?: IntNullableWithAggregatesFilter<"FoodCostPool"> | number | null
    timeMinutes?: DecimalNullableWithAggregatesFilter<"FoodCostPool"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FoodCostPool"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FoodCostPool"> | Date | string
  }

  export type FoodMealPlanWhereInput = {
    AND?: FoodMealPlanWhereInput | FoodMealPlanWhereInput[]
    OR?: FoodMealPlanWhereInput[]
    NOT?: FoodMealPlanWhereInput | FoodMealPlanWhereInput[]
    id?: IntFilter<"FoodMealPlan"> | number
    name?: StringFilter<"FoodMealPlan"> | string
    weekStart?: DateTimeNullableFilter<"FoodMealPlan"> | Date | string | null
    notes?: StringNullableFilter<"FoodMealPlan"> | string | null
    createdAt?: DateTimeFilter<"FoodMealPlan"> | Date | string
    updatedAt?: DateTimeFilter<"FoodMealPlan"> | Date | string
    entries?: FoodMealPlanEntryListRelationFilter
  }

  export type FoodMealPlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    weekStart?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    entries?: FoodMealPlanEntryOrderByRelationAggregateInput
  }

  export type FoodMealPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FoodMealPlanWhereInput | FoodMealPlanWhereInput[]
    OR?: FoodMealPlanWhereInput[]
    NOT?: FoodMealPlanWhereInput | FoodMealPlanWhereInput[]
    name?: StringFilter<"FoodMealPlan"> | string
    weekStart?: DateTimeNullableFilter<"FoodMealPlan"> | Date | string | null
    notes?: StringNullableFilter<"FoodMealPlan"> | string | null
    createdAt?: DateTimeFilter<"FoodMealPlan"> | Date | string
    updatedAt?: DateTimeFilter<"FoodMealPlan"> | Date | string
    entries?: FoodMealPlanEntryListRelationFilter
  }, "id">

  export type FoodMealPlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    weekStart?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FoodMealPlanCountOrderByAggregateInput
    _avg?: FoodMealPlanAvgOrderByAggregateInput
    _max?: FoodMealPlanMaxOrderByAggregateInput
    _min?: FoodMealPlanMinOrderByAggregateInput
    _sum?: FoodMealPlanSumOrderByAggregateInput
  }

  export type FoodMealPlanScalarWhereWithAggregatesInput = {
    AND?: FoodMealPlanScalarWhereWithAggregatesInput | FoodMealPlanScalarWhereWithAggregatesInput[]
    OR?: FoodMealPlanScalarWhereWithAggregatesInput[]
    NOT?: FoodMealPlanScalarWhereWithAggregatesInput | FoodMealPlanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FoodMealPlan"> | number
    name?: StringWithAggregatesFilter<"FoodMealPlan"> | string
    weekStart?: DateTimeNullableWithAggregatesFilter<"FoodMealPlan"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"FoodMealPlan"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FoodMealPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FoodMealPlan"> | Date | string
  }

  export type FoodMealPlanEntryWhereInput = {
    AND?: FoodMealPlanEntryWhereInput | FoodMealPlanEntryWhereInput[]
    OR?: FoodMealPlanEntryWhereInput[]
    NOT?: FoodMealPlanEntryWhereInput | FoodMealPlanEntryWhereInput[]
    id?: IntFilter<"FoodMealPlanEntry"> | number
    planId?: IntFilter<"FoodMealPlanEntry"> | number
    dayIndex?: IntFilter<"FoodMealPlanEntry"> | number
    mealType?: EnumFoodMealTypeFilter<"FoodMealPlanEntry"> | $Enums.FoodMealType
    recipeId?: IntFilter<"FoodMealPlanEntry"> | number
    servings?: DecimalFilter<"FoodMealPlanEntry"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"FoodMealPlanEntry"> | string | null
    createdAt?: DateTimeFilter<"FoodMealPlanEntry"> | Date | string
    updatedAt?: DateTimeFilter<"FoodMealPlanEntry"> | Date | string
    plan?: XOR<FoodMealPlanScalarRelationFilter, FoodMealPlanWhereInput>
    recipe?: XOR<FoodRecipeScalarRelationFilter, FoodRecipeWhereInput>
  }

  export type FoodMealPlanEntryOrderByWithRelationInput = {
    id?: SortOrder
    planId?: SortOrder
    dayIndex?: SortOrder
    mealType?: SortOrder
    recipeId?: SortOrder
    servings?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plan?: FoodMealPlanOrderByWithRelationInput
    recipe?: FoodRecipeOrderByWithRelationInput
  }

  export type FoodMealPlanEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FoodMealPlanEntryWhereInput | FoodMealPlanEntryWhereInput[]
    OR?: FoodMealPlanEntryWhereInput[]
    NOT?: FoodMealPlanEntryWhereInput | FoodMealPlanEntryWhereInput[]
    planId?: IntFilter<"FoodMealPlanEntry"> | number
    dayIndex?: IntFilter<"FoodMealPlanEntry"> | number
    mealType?: EnumFoodMealTypeFilter<"FoodMealPlanEntry"> | $Enums.FoodMealType
    recipeId?: IntFilter<"FoodMealPlanEntry"> | number
    servings?: DecimalFilter<"FoodMealPlanEntry"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"FoodMealPlanEntry"> | string | null
    createdAt?: DateTimeFilter<"FoodMealPlanEntry"> | Date | string
    updatedAt?: DateTimeFilter<"FoodMealPlanEntry"> | Date | string
    plan?: XOR<FoodMealPlanScalarRelationFilter, FoodMealPlanWhereInput>
    recipe?: XOR<FoodRecipeScalarRelationFilter, FoodRecipeWhereInput>
  }, "id">

  export type FoodMealPlanEntryOrderByWithAggregationInput = {
    id?: SortOrder
    planId?: SortOrder
    dayIndex?: SortOrder
    mealType?: SortOrder
    recipeId?: SortOrder
    servings?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FoodMealPlanEntryCountOrderByAggregateInput
    _avg?: FoodMealPlanEntryAvgOrderByAggregateInput
    _max?: FoodMealPlanEntryMaxOrderByAggregateInput
    _min?: FoodMealPlanEntryMinOrderByAggregateInput
    _sum?: FoodMealPlanEntrySumOrderByAggregateInput
  }

  export type FoodMealPlanEntryScalarWhereWithAggregatesInput = {
    AND?: FoodMealPlanEntryScalarWhereWithAggregatesInput | FoodMealPlanEntryScalarWhereWithAggregatesInput[]
    OR?: FoodMealPlanEntryScalarWhereWithAggregatesInput[]
    NOT?: FoodMealPlanEntryScalarWhereWithAggregatesInput | FoodMealPlanEntryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FoodMealPlanEntry"> | number
    planId?: IntWithAggregatesFilter<"FoodMealPlanEntry"> | number
    dayIndex?: IntWithAggregatesFilter<"FoodMealPlanEntry"> | number
    mealType?: EnumFoodMealTypeWithAggregatesFilter<"FoodMealPlanEntry"> | $Enums.FoodMealType
    recipeId?: IntWithAggregatesFilter<"FoodMealPlanEntry"> | number
    servings?: DecimalWithAggregatesFilter<"FoodMealPlanEntry"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableWithAggregatesFilter<"FoodMealPlanEntry"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FoodMealPlanEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FoodMealPlanEntry"> | Date | string
  }

  export type QuotationProcessWhereInput = {
    AND?: QuotationProcessWhereInput | QuotationProcessWhereInput[]
    OR?: QuotationProcessWhereInput[]
    NOT?: QuotationProcessWhereInput | QuotationProcessWhereInput[]
    id?: IntFilter<"QuotationProcess"> | number
    name?: StringFilter<"QuotationProcess"> | string
    code?: StringNullableFilter<"QuotationProcess"> | string | null
    status?: EnumQuotationProcessStatusFilter<"QuotationProcess"> | $Enums.QuotationProcessStatus
    baseCurrency?: StringFilter<"QuotationProcess"> | string
    targetCurrency?: StringNullableFilter<"QuotationProcess"> | string | null
    exchangeRate?: DecimalNullableFilter<"QuotationProcess"> | Decimal | DecimalJsLike | number | string | null
    targetMarginPct?: DecimalNullableFilter<"QuotationProcess"> | Decimal | DecimalJsLike | number | string | null
    baselineFileId?: IntNullableFilter<"QuotationProcess"> | number | null
    notes?: StringNullableFilter<"QuotationProcess"> | string | null
    createdAt?: DateTimeFilter<"QuotationProcess"> | Date | string
    updatedAt?: DateTimeFilter<"QuotationProcess"> | Date | string
    baselineFile?: XOR<QuotationAttachmentNullableScalarRelationFilter, QuotationAttachmentWhereInput> | null
    baselines?: QuotationBaselineItemListRelationFilter
    quotations?: QuotationListRelationFilter
    purchaseOrders?: PurchaseOrderLogListRelationFilter
    deliveryLogs?: PurchaseDeliveryLogListRelationFilter
  }

  export type QuotationProcessOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    status?: SortOrder
    baseCurrency?: SortOrder
    targetCurrency?: SortOrderInput | SortOrder
    exchangeRate?: SortOrderInput | SortOrder
    targetMarginPct?: SortOrderInput | SortOrder
    baselineFileId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    baselineFile?: QuotationAttachmentOrderByWithRelationInput
    baselines?: QuotationBaselineItemOrderByRelationAggregateInput
    quotations?: QuotationOrderByRelationAggregateInput
    purchaseOrders?: PurchaseOrderLogOrderByRelationAggregateInput
    deliveryLogs?: PurchaseDeliveryLogOrderByRelationAggregateInput
  }

  export type QuotationProcessWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    baselineFileId?: number
    AND?: QuotationProcessWhereInput | QuotationProcessWhereInput[]
    OR?: QuotationProcessWhereInput[]
    NOT?: QuotationProcessWhereInput | QuotationProcessWhereInput[]
    name?: StringFilter<"QuotationProcess"> | string
    status?: EnumQuotationProcessStatusFilter<"QuotationProcess"> | $Enums.QuotationProcessStatus
    baseCurrency?: StringFilter<"QuotationProcess"> | string
    targetCurrency?: StringNullableFilter<"QuotationProcess"> | string | null
    exchangeRate?: DecimalNullableFilter<"QuotationProcess"> | Decimal | DecimalJsLike | number | string | null
    targetMarginPct?: DecimalNullableFilter<"QuotationProcess"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"QuotationProcess"> | string | null
    createdAt?: DateTimeFilter<"QuotationProcess"> | Date | string
    updatedAt?: DateTimeFilter<"QuotationProcess"> | Date | string
    baselineFile?: XOR<QuotationAttachmentNullableScalarRelationFilter, QuotationAttachmentWhereInput> | null
    baselines?: QuotationBaselineItemListRelationFilter
    quotations?: QuotationListRelationFilter
    purchaseOrders?: PurchaseOrderLogListRelationFilter
    deliveryLogs?: PurchaseDeliveryLogListRelationFilter
  }, "id" | "code" | "baselineFileId">

  export type QuotationProcessOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    status?: SortOrder
    baseCurrency?: SortOrder
    targetCurrency?: SortOrderInput | SortOrder
    exchangeRate?: SortOrderInput | SortOrder
    targetMarginPct?: SortOrderInput | SortOrder
    baselineFileId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuotationProcessCountOrderByAggregateInput
    _avg?: QuotationProcessAvgOrderByAggregateInput
    _max?: QuotationProcessMaxOrderByAggregateInput
    _min?: QuotationProcessMinOrderByAggregateInput
    _sum?: QuotationProcessSumOrderByAggregateInput
  }

  export type QuotationProcessScalarWhereWithAggregatesInput = {
    AND?: QuotationProcessScalarWhereWithAggregatesInput | QuotationProcessScalarWhereWithAggregatesInput[]
    OR?: QuotationProcessScalarWhereWithAggregatesInput[]
    NOT?: QuotationProcessScalarWhereWithAggregatesInput | QuotationProcessScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QuotationProcess"> | number
    name?: StringWithAggregatesFilter<"QuotationProcess"> | string
    code?: StringNullableWithAggregatesFilter<"QuotationProcess"> | string | null
    status?: EnumQuotationProcessStatusWithAggregatesFilter<"QuotationProcess"> | $Enums.QuotationProcessStatus
    baseCurrency?: StringWithAggregatesFilter<"QuotationProcess"> | string
    targetCurrency?: StringNullableWithAggregatesFilter<"QuotationProcess"> | string | null
    exchangeRate?: DecimalNullableWithAggregatesFilter<"QuotationProcess"> | Decimal | DecimalJsLike | number | string | null
    targetMarginPct?: DecimalNullableWithAggregatesFilter<"QuotationProcess"> | Decimal | DecimalJsLike | number | string | null
    baselineFileId?: IntNullableWithAggregatesFilter<"QuotationProcess"> | number | null
    notes?: StringNullableWithAggregatesFilter<"QuotationProcess"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"QuotationProcess"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QuotationProcess"> | Date | string
  }

  export type QuotationBaselineItemWhereInput = {
    AND?: QuotationBaselineItemWhereInput | QuotationBaselineItemWhereInput[]
    OR?: QuotationBaselineItemWhereInput[]
    NOT?: QuotationBaselineItemWhereInput | QuotationBaselineItemWhereInput[]
    id?: IntFilter<"QuotationBaselineItem"> | number
    processId?: IntFilter<"QuotationBaselineItem"> | number
    materialId?: IntNullableFilter<"QuotationBaselineItem"> | number | null
    sheetName?: StringNullableFilter<"QuotationBaselineItem"> | string | null
    sectionPath?: StringNullableFilter<"QuotationBaselineItem"> | string | null
    itemCode?: StringNullableFilter<"QuotationBaselineItem"> | string | null
    description?: StringFilter<"QuotationBaselineItem"> | string
    unit?: StringNullableFilter<"QuotationBaselineItem"> | string | null
    quantity?: DecimalNullableFilter<"QuotationBaselineItem"> | Decimal | DecimalJsLike | number | string | null
    unitPrice?: DecimalNullableFilter<"QuotationBaselineItem"> | Decimal | DecimalJsLike | number | string | null
    totalPrice?: DecimalNullableFilter<"QuotationBaselineItem"> | Decimal | DecimalJsLike | number | string | null
    metadata?: JsonNullableFilter<"QuotationBaselineItem">
    createdAt?: DateTimeFilter<"QuotationBaselineItem"> | Date | string
    updatedAt?: DateTimeFilter<"QuotationBaselineItem"> | Date | string
    process?: XOR<QuotationProcessScalarRelationFilter, QuotationProcessWhereInput>
    material?: XOR<MaterialNullableScalarRelationFilter, MaterialWhereInput> | null
    quoteItems?: QuotationItemListRelationFilter
    orderLines?: PurchaseOrderLineListRelationFilter
    deliveryItems?: PurchaseDeliveryItemListRelationFilter
  }

  export type QuotationBaselineItemOrderByWithRelationInput = {
    id?: SortOrder
    processId?: SortOrder
    materialId?: SortOrderInput | SortOrder
    sheetName?: SortOrderInput | SortOrder
    sectionPath?: SortOrderInput | SortOrder
    itemCode?: SortOrderInput | SortOrder
    description?: SortOrder
    unit?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    unitPrice?: SortOrderInput | SortOrder
    totalPrice?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    process?: QuotationProcessOrderByWithRelationInput
    material?: MaterialOrderByWithRelationInput
    quoteItems?: QuotationItemOrderByRelationAggregateInput
    orderLines?: PurchaseOrderLineOrderByRelationAggregateInput
    deliveryItems?: PurchaseDeliveryItemOrderByRelationAggregateInput
  }

  export type QuotationBaselineItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QuotationBaselineItemWhereInput | QuotationBaselineItemWhereInput[]
    OR?: QuotationBaselineItemWhereInput[]
    NOT?: QuotationBaselineItemWhereInput | QuotationBaselineItemWhereInput[]
    processId?: IntFilter<"QuotationBaselineItem"> | number
    materialId?: IntNullableFilter<"QuotationBaselineItem"> | number | null
    sheetName?: StringNullableFilter<"QuotationBaselineItem"> | string | null
    sectionPath?: StringNullableFilter<"QuotationBaselineItem"> | string | null
    itemCode?: StringNullableFilter<"QuotationBaselineItem"> | string | null
    description?: StringFilter<"QuotationBaselineItem"> | string
    unit?: StringNullableFilter<"QuotationBaselineItem"> | string | null
    quantity?: DecimalNullableFilter<"QuotationBaselineItem"> | Decimal | DecimalJsLike | number | string | null
    unitPrice?: DecimalNullableFilter<"QuotationBaselineItem"> | Decimal | DecimalJsLike | number | string | null
    totalPrice?: DecimalNullableFilter<"QuotationBaselineItem"> | Decimal | DecimalJsLike | number | string | null
    metadata?: JsonNullableFilter<"QuotationBaselineItem">
    createdAt?: DateTimeFilter<"QuotationBaselineItem"> | Date | string
    updatedAt?: DateTimeFilter<"QuotationBaselineItem"> | Date | string
    process?: XOR<QuotationProcessScalarRelationFilter, QuotationProcessWhereInput>
    material?: XOR<MaterialNullableScalarRelationFilter, MaterialWhereInput> | null
    quoteItems?: QuotationItemListRelationFilter
    orderLines?: PurchaseOrderLineListRelationFilter
    deliveryItems?: PurchaseDeliveryItemListRelationFilter
  }, "id">

  export type QuotationBaselineItemOrderByWithAggregationInput = {
    id?: SortOrder
    processId?: SortOrder
    materialId?: SortOrderInput | SortOrder
    sheetName?: SortOrderInput | SortOrder
    sectionPath?: SortOrderInput | SortOrder
    itemCode?: SortOrderInput | SortOrder
    description?: SortOrder
    unit?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    unitPrice?: SortOrderInput | SortOrder
    totalPrice?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuotationBaselineItemCountOrderByAggregateInput
    _avg?: QuotationBaselineItemAvgOrderByAggregateInput
    _max?: QuotationBaselineItemMaxOrderByAggregateInput
    _min?: QuotationBaselineItemMinOrderByAggregateInput
    _sum?: QuotationBaselineItemSumOrderByAggregateInput
  }

  export type QuotationBaselineItemScalarWhereWithAggregatesInput = {
    AND?: QuotationBaselineItemScalarWhereWithAggregatesInput | QuotationBaselineItemScalarWhereWithAggregatesInput[]
    OR?: QuotationBaselineItemScalarWhereWithAggregatesInput[]
    NOT?: QuotationBaselineItemScalarWhereWithAggregatesInput | QuotationBaselineItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QuotationBaselineItem"> | number
    processId?: IntWithAggregatesFilter<"QuotationBaselineItem"> | number
    materialId?: IntNullableWithAggregatesFilter<"QuotationBaselineItem"> | number | null
    sheetName?: StringNullableWithAggregatesFilter<"QuotationBaselineItem"> | string | null
    sectionPath?: StringNullableWithAggregatesFilter<"QuotationBaselineItem"> | string | null
    itemCode?: StringNullableWithAggregatesFilter<"QuotationBaselineItem"> | string | null
    description?: StringWithAggregatesFilter<"QuotationBaselineItem"> | string
    unit?: StringNullableWithAggregatesFilter<"QuotationBaselineItem"> | string | null
    quantity?: DecimalNullableWithAggregatesFilter<"QuotationBaselineItem"> | Decimal | DecimalJsLike | number | string | null
    unitPrice?: DecimalNullableWithAggregatesFilter<"QuotationBaselineItem"> | Decimal | DecimalJsLike | number | string | null
    totalPrice?: DecimalNullableWithAggregatesFilter<"QuotationBaselineItem"> | Decimal | DecimalJsLike | number | string | null
    metadata?: JsonNullableWithAggregatesFilter<"QuotationBaselineItem">
    createdAt?: DateTimeWithAggregatesFilter<"QuotationBaselineItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QuotationBaselineItem"> | Date | string
  }

  export type QuotationWhereInput = {
    AND?: QuotationWhereInput | QuotationWhereInput[]
    OR?: QuotationWhereInput[]
    NOT?: QuotationWhereInput | QuotationWhereInput[]
    id?: IntFilter<"Quotation"> | number
    processId?: IntFilter<"Quotation"> | number
    proveedorId?: IntNullableFilter<"Quotation"> | number | null
    supplierName?: StringNullableFilter<"Quotation"> | string | null
    currency?: StringFilter<"Quotation"> | string
    exchangeRate?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    submittedAt?: DateTimeNullableFilter<"Quotation"> | Date | string | null
    status?: EnumQuotationStatusFilter<"Quotation"> | $Enums.QuotationStatus
    totalAmount?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    totalAmountPen?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    qualityScore?: IntNullableFilter<"Quotation"> | number | null
    notes?: StringNullableFilter<"Quotation"> | string | null
    metadata?: JsonNullableFilter<"Quotation">
    createdAt?: DateTimeFilter<"Quotation"> | Date | string
    updatedAt?: DateTimeFilter<"Quotation"> | Date | string
    process?: XOR<QuotationProcessScalarRelationFilter, QuotationProcessWhereInput>
    proveedor?: XOR<ProveedorNullableScalarRelationFilter, ProveedorWhereInput> | null
    items?: QuotationItemListRelationFilter
    attachments?: QuotationAttachmentListRelationFilter
    purchaseOrders?: PurchaseOrderLogListRelationFilter
  }

  export type QuotationOrderByWithRelationInput = {
    id?: SortOrder
    processId?: SortOrder
    proveedorId?: SortOrderInput | SortOrder
    supplierName?: SortOrderInput | SortOrder
    currency?: SortOrder
    exchangeRate?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    totalAmount?: SortOrderInput | SortOrder
    totalAmountPen?: SortOrderInput | SortOrder
    qualityScore?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    process?: QuotationProcessOrderByWithRelationInput
    proveedor?: ProveedorOrderByWithRelationInput
    items?: QuotationItemOrderByRelationAggregateInput
    attachments?: QuotationAttachmentOrderByRelationAggregateInput
    purchaseOrders?: PurchaseOrderLogOrderByRelationAggregateInput
  }

  export type QuotationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QuotationWhereInput | QuotationWhereInput[]
    OR?: QuotationWhereInput[]
    NOT?: QuotationWhereInput | QuotationWhereInput[]
    processId?: IntFilter<"Quotation"> | number
    proveedorId?: IntNullableFilter<"Quotation"> | number | null
    supplierName?: StringNullableFilter<"Quotation"> | string | null
    currency?: StringFilter<"Quotation"> | string
    exchangeRate?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    submittedAt?: DateTimeNullableFilter<"Quotation"> | Date | string | null
    status?: EnumQuotationStatusFilter<"Quotation"> | $Enums.QuotationStatus
    totalAmount?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    totalAmountPen?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    qualityScore?: IntNullableFilter<"Quotation"> | number | null
    notes?: StringNullableFilter<"Quotation"> | string | null
    metadata?: JsonNullableFilter<"Quotation">
    createdAt?: DateTimeFilter<"Quotation"> | Date | string
    updatedAt?: DateTimeFilter<"Quotation"> | Date | string
    process?: XOR<QuotationProcessScalarRelationFilter, QuotationProcessWhereInput>
    proveedor?: XOR<ProveedorNullableScalarRelationFilter, ProveedorWhereInput> | null
    items?: QuotationItemListRelationFilter
    attachments?: QuotationAttachmentListRelationFilter
    purchaseOrders?: PurchaseOrderLogListRelationFilter
  }, "id">

  export type QuotationOrderByWithAggregationInput = {
    id?: SortOrder
    processId?: SortOrder
    proveedorId?: SortOrderInput | SortOrder
    supplierName?: SortOrderInput | SortOrder
    currency?: SortOrder
    exchangeRate?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    totalAmount?: SortOrderInput | SortOrder
    totalAmountPen?: SortOrderInput | SortOrder
    qualityScore?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuotationCountOrderByAggregateInput
    _avg?: QuotationAvgOrderByAggregateInput
    _max?: QuotationMaxOrderByAggregateInput
    _min?: QuotationMinOrderByAggregateInput
    _sum?: QuotationSumOrderByAggregateInput
  }

  export type QuotationScalarWhereWithAggregatesInput = {
    AND?: QuotationScalarWhereWithAggregatesInput | QuotationScalarWhereWithAggregatesInput[]
    OR?: QuotationScalarWhereWithAggregatesInput[]
    NOT?: QuotationScalarWhereWithAggregatesInput | QuotationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Quotation"> | number
    processId?: IntWithAggregatesFilter<"Quotation"> | number
    proveedorId?: IntNullableWithAggregatesFilter<"Quotation"> | number | null
    supplierName?: StringNullableWithAggregatesFilter<"Quotation"> | string | null
    currency?: StringWithAggregatesFilter<"Quotation"> | string
    exchangeRate?: DecimalNullableWithAggregatesFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    submittedAt?: DateTimeNullableWithAggregatesFilter<"Quotation"> | Date | string | null
    status?: EnumQuotationStatusWithAggregatesFilter<"Quotation"> | $Enums.QuotationStatus
    totalAmount?: DecimalNullableWithAggregatesFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    totalAmountPen?: DecimalNullableWithAggregatesFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    qualityScore?: IntNullableWithAggregatesFilter<"Quotation"> | number | null
    notes?: StringNullableWithAggregatesFilter<"Quotation"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Quotation">
    createdAt?: DateTimeWithAggregatesFilter<"Quotation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Quotation"> | Date | string
  }

  export type QuotationItemWhereInput = {
    AND?: QuotationItemWhereInput | QuotationItemWhereInput[]
    OR?: QuotationItemWhereInput[]
    NOT?: QuotationItemWhereInput | QuotationItemWhereInput[]
    id?: IntFilter<"QuotationItem"> | number
    quotationId?: IntFilter<"QuotationItem"> | number
    baselineItemId?: IntNullableFilter<"QuotationItem"> | number | null
    materialId?: IntNullableFilter<"QuotationItem"> | number | null
    sourceRow?: IntNullableFilter<"QuotationItem"> | number | null
    itemCode?: StringNullableFilter<"QuotationItem"> | string | null
    description?: StringFilter<"QuotationItem"> | string
    unit?: StringNullableFilter<"QuotationItem"> | string | null
    quantity?: DecimalNullableFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string | null
    unitPrice?: DecimalNullableFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string | null
    totalPrice?: DecimalNullableFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter<"QuotationItem"> | string | null
    normalizedPrice?: DecimalNullableFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string | null
    matchScore?: FloatNullableFilter<"QuotationItem"> | number | null
    extraAttributes?: JsonNullableFilter<"QuotationItem">
    createdAt?: DateTimeFilter<"QuotationItem"> | Date | string
    updatedAt?: DateTimeFilter<"QuotationItem"> | Date | string
    quotation?: XOR<QuotationScalarRelationFilter, QuotationWhereInput>
    baselineItem?: XOR<QuotationBaselineItemNullableScalarRelationFilter, QuotationBaselineItemWhereInput> | null
    material?: XOR<MaterialNullableScalarRelationFilter, MaterialWhereInput> | null
  }

  export type QuotationItemOrderByWithRelationInput = {
    id?: SortOrder
    quotationId?: SortOrder
    baselineItemId?: SortOrderInput | SortOrder
    materialId?: SortOrderInput | SortOrder
    sourceRow?: SortOrderInput | SortOrder
    itemCode?: SortOrderInput | SortOrder
    description?: SortOrder
    unit?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    unitPrice?: SortOrderInput | SortOrder
    totalPrice?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    normalizedPrice?: SortOrderInput | SortOrder
    matchScore?: SortOrderInput | SortOrder
    extraAttributes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quotation?: QuotationOrderByWithRelationInput
    baselineItem?: QuotationBaselineItemOrderByWithRelationInput
    material?: MaterialOrderByWithRelationInput
  }

  export type QuotationItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QuotationItemWhereInput | QuotationItemWhereInput[]
    OR?: QuotationItemWhereInput[]
    NOT?: QuotationItemWhereInput | QuotationItemWhereInput[]
    quotationId?: IntFilter<"QuotationItem"> | number
    baselineItemId?: IntNullableFilter<"QuotationItem"> | number | null
    materialId?: IntNullableFilter<"QuotationItem"> | number | null
    sourceRow?: IntNullableFilter<"QuotationItem"> | number | null
    itemCode?: StringNullableFilter<"QuotationItem"> | string | null
    description?: StringFilter<"QuotationItem"> | string
    unit?: StringNullableFilter<"QuotationItem"> | string | null
    quantity?: DecimalNullableFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string | null
    unitPrice?: DecimalNullableFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string | null
    totalPrice?: DecimalNullableFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter<"QuotationItem"> | string | null
    normalizedPrice?: DecimalNullableFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string | null
    matchScore?: FloatNullableFilter<"QuotationItem"> | number | null
    extraAttributes?: JsonNullableFilter<"QuotationItem">
    createdAt?: DateTimeFilter<"QuotationItem"> | Date | string
    updatedAt?: DateTimeFilter<"QuotationItem"> | Date | string
    quotation?: XOR<QuotationScalarRelationFilter, QuotationWhereInput>
    baselineItem?: XOR<QuotationBaselineItemNullableScalarRelationFilter, QuotationBaselineItemWhereInput> | null
    material?: XOR<MaterialNullableScalarRelationFilter, MaterialWhereInput> | null
  }, "id">

  export type QuotationItemOrderByWithAggregationInput = {
    id?: SortOrder
    quotationId?: SortOrder
    baselineItemId?: SortOrderInput | SortOrder
    materialId?: SortOrderInput | SortOrder
    sourceRow?: SortOrderInput | SortOrder
    itemCode?: SortOrderInput | SortOrder
    description?: SortOrder
    unit?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    unitPrice?: SortOrderInput | SortOrder
    totalPrice?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    normalizedPrice?: SortOrderInput | SortOrder
    matchScore?: SortOrderInput | SortOrder
    extraAttributes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuotationItemCountOrderByAggregateInput
    _avg?: QuotationItemAvgOrderByAggregateInput
    _max?: QuotationItemMaxOrderByAggregateInput
    _min?: QuotationItemMinOrderByAggregateInput
    _sum?: QuotationItemSumOrderByAggregateInput
  }

  export type QuotationItemScalarWhereWithAggregatesInput = {
    AND?: QuotationItemScalarWhereWithAggregatesInput | QuotationItemScalarWhereWithAggregatesInput[]
    OR?: QuotationItemScalarWhereWithAggregatesInput[]
    NOT?: QuotationItemScalarWhereWithAggregatesInput | QuotationItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QuotationItem"> | number
    quotationId?: IntWithAggregatesFilter<"QuotationItem"> | number
    baselineItemId?: IntNullableWithAggregatesFilter<"QuotationItem"> | number | null
    materialId?: IntNullableWithAggregatesFilter<"QuotationItem"> | number | null
    sourceRow?: IntNullableWithAggregatesFilter<"QuotationItem"> | number | null
    itemCode?: StringNullableWithAggregatesFilter<"QuotationItem"> | string | null
    description?: StringWithAggregatesFilter<"QuotationItem"> | string
    unit?: StringNullableWithAggregatesFilter<"QuotationItem"> | string | null
    quantity?: DecimalNullableWithAggregatesFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string | null
    unitPrice?: DecimalNullableWithAggregatesFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string | null
    totalPrice?: DecimalNullableWithAggregatesFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableWithAggregatesFilter<"QuotationItem"> | string | null
    normalizedPrice?: DecimalNullableWithAggregatesFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string | null
    matchScore?: FloatNullableWithAggregatesFilter<"QuotationItem"> | number | null
    extraAttributes?: JsonNullableWithAggregatesFilter<"QuotationItem">
    createdAt?: DateTimeWithAggregatesFilter<"QuotationItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QuotationItem"> | Date | string
  }

  export type QuotationAttachmentWhereInput = {
    AND?: QuotationAttachmentWhereInput | QuotationAttachmentWhereInput[]
    OR?: QuotationAttachmentWhereInput[]
    NOT?: QuotationAttachmentWhereInput | QuotationAttachmentWhereInput[]
    id?: IntFilter<"QuotationAttachment"> | number
    quotationId?: IntNullableFilter<"QuotationAttachment"> | number | null
    type?: EnumQuotationAttachmentTypeFilter<"QuotationAttachment"> | $Enums.QuotationAttachmentType
    originalName?: StringFilter<"QuotationAttachment"> | string
    storagePath?: StringFilter<"QuotationAttachment"> | string
    mimeType?: StringNullableFilter<"QuotationAttachment"> | string | null
    sizeBytes?: IntNullableFilter<"QuotationAttachment"> | number | null
    checksum?: StringNullableFilter<"QuotationAttachment"> | string | null
    parsed?: BoolFilter<"QuotationAttachment"> | boolean
    parsedAt?: DateTimeNullableFilter<"QuotationAttachment"> | Date | string | null
    metadata?: JsonNullableFilter<"QuotationAttachment">
    createdAt?: DateTimeFilter<"QuotationAttachment"> | Date | string
    updatedAt?: DateTimeFilter<"QuotationAttachment"> | Date | string
    quotation?: XOR<QuotationNullableScalarRelationFilter, QuotationWhereInput> | null
    process?: XOR<QuotationProcessNullableScalarRelationFilter, QuotationProcessWhereInput> | null
  }

  export type QuotationAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    quotationId?: SortOrderInput | SortOrder
    type?: SortOrder
    originalName?: SortOrder
    storagePath?: SortOrder
    mimeType?: SortOrderInput | SortOrder
    sizeBytes?: SortOrderInput | SortOrder
    checksum?: SortOrderInput | SortOrder
    parsed?: SortOrder
    parsedAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quotation?: QuotationOrderByWithRelationInput
    process?: QuotationProcessOrderByWithRelationInput
  }

  export type QuotationAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QuotationAttachmentWhereInput | QuotationAttachmentWhereInput[]
    OR?: QuotationAttachmentWhereInput[]
    NOT?: QuotationAttachmentWhereInput | QuotationAttachmentWhereInput[]
    quotationId?: IntNullableFilter<"QuotationAttachment"> | number | null
    type?: EnumQuotationAttachmentTypeFilter<"QuotationAttachment"> | $Enums.QuotationAttachmentType
    originalName?: StringFilter<"QuotationAttachment"> | string
    storagePath?: StringFilter<"QuotationAttachment"> | string
    mimeType?: StringNullableFilter<"QuotationAttachment"> | string | null
    sizeBytes?: IntNullableFilter<"QuotationAttachment"> | number | null
    checksum?: StringNullableFilter<"QuotationAttachment"> | string | null
    parsed?: BoolFilter<"QuotationAttachment"> | boolean
    parsedAt?: DateTimeNullableFilter<"QuotationAttachment"> | Date | string | null
    metadata?: JsonNullableFilter<"QuotationAttachment">
    createdAt?: DateTimeFilter<"QuotationAttachment"> | Date | string
    updatedAt?: DateTimeFilter<"QuotationAttachment"> | Date | string
    quotation?: XOR<QuotationNullableScalarRelationFilter, QuotationWhereInput> | null
    process?: XOR<QuotationProcessNullableScalarRelationFilter, QuotationProcessWhereInput> | null
  }, "id">

  export type QuotationAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    quotationId?: SortOrderInput | SortOrder
    type?: SortOrder
    originalName?: SortOrder
    storagePath?: SortOrder
    mimeType?: SortOrderInput | SortOrder
    sizeBytes?: SortOrderInput | SortOrder
    checksum?: SortOrderInput | SortOrder
    parsed?: SortOrder
    parsedAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuotationAttachmentCountOrderByAggregateInput
    _avg?: QuotationAttachmentAvgOrderByAggregateInput
    _max?: QuotationAttachmentMaxOrderByAggregateInput
    _min?: QuotationAttachmentMinOrderByAggregateInput
    _sum?: QuotationAttachmentSumOrderByAggregateInput
  }

  export type QuotationAttachmentScalarWhereWithAggregatesInput = {
    AND?: QuotationAttachmentScalarWhereWithAggregatesInput | QuotationAttachmentScalarWhereWithAggregatesInput[]
    OR?: QuotationAttachmentScalarWhereWithAggregatesInput[]
    NOT?: QuotationAttachmentScalarWhereWithAggregatesInput | QuotationAttachmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QuotationAttachment"> | number
    quotationId?: IntNullableWithAggregatesFilter<"QuotationAttachment"> | number | null
    type?: EnumQuotationAttachmentTypeWithAggregatesFilter<"QuotationAttachment"> | $Enums.QuotationAttachmentType
    originalName?: StringWithAggregatesFilter<"QuotationAttachment"> | string
    storagePath?: StringWithAggregatesFilter<"QuotationAttachment"> | string
    mimeType?: StringNullableWithAggregatesFilter<"QuotationAttachment"> | string | null
    sizeBytes?: IntNullableWithAggregatesFilter<"QuotationAttachment"> | number | null
    checksum?: StringNullableWithAggregatesFilter<"QuotationAttachment"> | string | null
    parsed?: BoolWithAggregatesFilter<"QuotationAttachment"> | boolean
    parsedAt?: DateTimeNullableWithAggregatesFilter<"QuotationAttachment"> | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter<"QuotationAttachment">
    createdAt?: DateTimeWithAggregatesFilter<"QuotationAttachment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QuotationAttachment"> | Date | string
  }

  export type PurchaseOrderLogWhereInput = {
    AND?: PurchaseOrderLogWhereInput | PurchaseOrderLogWhereInput[]
    OR?: PurchaseOrderLogWhereInput[]
    NOT?: PurchaseOrderLogWhereInput | PurchaseOrderLogWhereInput[]
    id?: IntFilter<"PurchaseOrderLog"> | number
    processId?: IntFilter<"PurchaseOrderLog"> | number
    quotationId?: IntNullableFilter<"PurchaseOrderLog"> | number | null
    supplierId?: IntNullableFilter<"PurchaseOrderLog"> | number | null
    supplierName?: StringFilter<"PurchaseOrderLog"> | string
    orderNumber?: StringFilter<"PurchaseOrderLog"> | string
    sequence?: IntFilter<"PurchaseOrderLog"> | number
    issueDate?: DateTimeFilter<"PurchaseOrderLog"> | Date | string
    currency?: StringFilter<"PurchaseOrderLog"> | string
    subtotal?: DecimalNullableFilter<"PurchaseOrderLog"> | Decimal | DecimalJsLike | number | string | null
    discount?: DecimalNullableFilter<"PurchaseOrderLog"> | Decimal | DecimalJsLike | number | string | null
    netSubtotal?: DecimalNullableFilter<"PurchaseOrderLog"> | Decimal | DecimalJsLike | number | string | null
    igv?: DecimalNullableFilter<"PurchaseOrderLog"> | Decimal | DecimalJsLike | number | string | null
    total?: DecimalNullableFilter<"PurchaseOrderLog"> | Decimal | DecimalJsLike | number | string | null
    totalsJson?: JsonNullableFilter<"PurchaseOrderLog">
    itemsJson?: JsonNullableFilter<"PurchaseOrderLog">
    createdAt?: DateTimeFilter<"PurchaseOrderLog"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrderLog"> | Date | string
    process?: XOR<QuotationProcessScalarRelationFilter, QuotationProcessWhereInput>
    quotation?: XOR<QuotationNullableScalarRelationFilter, QuotationWhereInput> | null
    lines?: PurchaseOrderLineListRelationFilter
    deliveries?: PurchaseDeliveryLogListRelationFilter
  }

  export type PurchaseOrderLogOrderByWithRelationInput = {
    id?: SortOrder
    processId?: SortOrder
    quotationId?: SortOrderInput | SortOrder
    supplierId?: SortOrderInput | SortOrder
    supplierName?: SortOrder
    orderNumber?: SortOrder
    sequence?: SortOrder
    issueDate?: SortOrder
    currency?: SortOrder
    subtotal?: SortOrderInput | SortOrder
    discount?: SortOrderInput | SortOrder
    netSubtotal?: SortOrderInput | SortOrder
    igv?: SortOrderInput | SortOrder
    total?: SortOrderInput | SortOrder
    totalsJson?: SortOrderInput | SortOrder
    itemsJson?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    process?: QuotationProcessOrderByWithRelationInput
    quotation?: QuotationOrderByWithRelationInput
    lines?: PurchaseOrderLineOrderByRelationAggregateInput
    deliveries?: PurchaseDeliveryLogOrderByRelationAggregateInput
  }

  export type PurchaseOrderLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PurchaseOrderLogWhereInput | PurchaseOrderLogWhereInput[]
    OR?: PurchaseOrderLogWhereInput[]
    NOT?: PurchaseOrderLogWhereInput | PurchaseOrderLogWhereInput[]
    processId?: IntFilter<"PurchaseOrderLog"> | number
    quotationId?: IntNullableFilter<"PurchaseOrderLog"> | number | null
    supplierId?: IntNullableFilter<"PurchaseOrderLog"> | number | null
    supplierName?: StringFilter<"PurchaseOrderLog"> | string
    orderNumber?: StringFilter<"PurchaseOrderLog"> | string
    sequence?: IntFilter<"PurchaseOrderLog"> | number
    issueDate?: DateTimeFilter<"PurchaseOrderLog"> | Date | string
    currency?: StringFilter<"PurchaseOrderLog"> | string
    subtotal?: DecimalNullableFilter<"PurchaseOrderLog"> | Decimal | DecimalJsLike | number | string | null
    discount?: DecimalNullableFilter<"PurchaseOrderLog"> | Decimal | DecimalJsLike | number | string | null
    netSubtotal?: DecimalNullableFilter<"PurchaseOrderLog"> | Decimal | DecimalJsLike | number | string | null
    igv?: DecimalNullableFilter<"PurchaseOrderLog"> | Decimal | DecimalJsLike | number | string | null
    total?: DecimalNullableFilter<"PurchaseOrderLog"> | Decimal | DecimalJsLike | number | string | null
    totalsJson?: JsonNullableFilter<"PurchaseOrderLog">
    itemsJson?: JsonNullableFilter<"PurchaseOrderLog">
    createdAt?: DateTimeFilter<"PurchaseOrderLog"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrderLog"> | Date | string
    process?: XOR<QuotationProcessScalarRelationFilter, QuotationProcessWhereInput>
    quotation?: XOR<QuotationNullableScalarRelationFilter, QuotationWhereInput> | null
    lines?: PurchaseOrderLineListRelationFilter
    deliveries?: PurchaseDeliveryLogListRelationFilter
  }, "id">

  export type PurchaseOrderLogOrderByWithAggregationInput = {
    id?: SortOrder
    processId?: SortOrder
    quotationId?: SortOrderInput | SortOrder
    supplierId?: SortOrderInput | SortOrder
    supplierName?: SortOrder
    orderNumber?: SortOrder
    sequence?: SortOrder
    issueDate?: SortOrder
    currency?: SortOrder
    subtotal?: SortOrderInput | SortOrder
    discount?: SortOrderInput | SortOrder
    netSubtotal?: SortOrderInput | SortOrder
    igv?: SortOrderInput | SortOrder
    total?: SortOrderInput | SortOrder
    totalsJson?: SortOrderInput | SortOrder
    itemsJson?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseOrderLogCountOrderByAggregateInput
    _avg?: PurchaseOrderLogAvgOrderByAggregateInput
    _max?: PurchaseOrderLogMaxOrderByAggregateInput
    _min?: PurchaseOrderLogMinOrderByAggregateInput
    _sum?: PurchaseOrderLogSumOrderByAggregateInput
  }

  export type PurchaseOrderLogScalarWhereWithAggregatesInput = {
    AND?: PurchaseOrderLogScalarWhereWithAggregatesInput | PurchaseOrderLogScalarWhereWithAggregatesInput[]
    OR?: PurchaseOrderLogScalarWhereWithAggregatesInput[]
    NOT?: PurchaseOrderLogScalarWhereWithAggregatesInput | PurchaseOrderLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PurchaseOrderLog"> | number
    processId?: IntWithAggregatesFilter<"PurchaseOrderLog"> | number
    quotationId?: IntNullableWithAggregatesFilter<"PurchaseOrderLog"> | number | null
    supplierId?: IntNullableWithAggregatesFilter<"PurchaseOrderLog"> | number | null
    supplierName?: StringWithAggregatesFilter<"PurchaseOrderLog"> | string
    orderNumber?: StringWithAggregatesFilter<"PurchaseOrderLog"> | string
    sequence?: IntWithAggregatesFilter<"PurchaseOrderLog"> | number
    issueDate?: DateTimeWithAggregatesFilter<"PurchaseOrderLog"> | Date | string
    currency?: StringWithAggregatesFilter<"PurchaseOrderLog"> | string
    subtotal?: DecimalNullableWithAggregatesFilter<"PurchaseOrderLog"> | Decimal | DecimalJsLike | number | string | null
    discount?: DecimalNullableWithAggregatesFilter<"PurchaseOrderLog"> | Decimal | DecimalJsLike | number | string | null
    netSubtotal?: DecimalNullableWithAggregatesFilter<"PurchaseOrderLog"> | Decimal | DecimalJsLike | number | string | null
    igv?: DecimalNullableWithAggregatesFilter<"PurchaseOrderLog"> | Decimal | DecimalJsLike | number | string | null
    total?: DecimalNullableWithAggregatesFilter<"PurchaseOrderLog"> | Decimal | DecimalJsLike | number | string | null
    totalsJson?: JsonNullableWithAggregatesFilter<"PurchaseOrderLog">
    itemsJson?: JsonNullableWithAggregatesFilter<"PurchaseOrderLog">
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseOrderLog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseOrderLog"> | Date | string
  }

  export type PurchaseOrderLineWhereInput = {
    AND?: PurchaseOrderLineWhereInput | PurchaseOrderLineWhereInput[]
    OR?: PurchaseOrderLineWhereInput[]
    NOT?: PurchaseOrderLineWhereInput | PurchaseOrderLineWhereInput[]
    id?: IntFilter<"PurchaseOrderLine"> | number
    orderId?: IntFilter<"PurchaseOrderLine"> | number
    baselineId?: IntNullableFilter<"PurchaseOrderLine"> | number | null
    description?: StringFilter<"PurchaseOrderLine"> | string
    unit?: StringNullableFilter<"PurchaseOrderLine"> | string | null
    quantity?: DecimalNullableFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string | null
    unitPrice?: DecimalNullableFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string | null
    totalPrice?: DecimalNullableFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string | null
    metadata?: JsonNullableFilter<"PurchaseOrderLine">
    createdAt?: DateTimeFilter<"PurchaseOrderLine"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrderLine"> | Date | string
    order?: XOR<PurchaseOrderLogScalarRelationFilter, PurchaseOrderLogWhereInput>
    baseline?: XOR<QuotationBaselineItemNullableScalarRelationFilter, QuotationBaselineItemWhereInput> | null
    deliveries?: PurchaseDeliveryItemListRelationFilter
  }

  export type PurchaseOrderLineOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    baselineId?: SortOrderInput | SortOrder
    description?: SortOrder
    unit?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    unitPrice?: SortOrderInput | SortOrder
    totalPrice?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: PurchaseOrderLogOrderByWithRelationInput
    baseline?: QuotationBaselineItemOrderByWithRelationInput
    deliveries?: PurchaseDeliveryItemOrderByRelationAggregateInput
  }

  export type PurchaseOrderLineWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PurchaseOrderLineWhereInput | PurchaseOrderLineWhereInput[]
    OR?: PurchaseOrderLineWhereInput[]
    NOT?: PurchaseOrderLineWhereInput | PurchaseOrderLineWhereInput[]
    orderId?: IntFilter<"PurchaseOrderLine"> | number
    baselineId?: IntNullableFilter<"PurchaseOrderLine"> | number | null
    description?: StringFilter<"PurchaseOrderLine"> | string
    unit?: StringNullableFilter<"PurchaseOrderLine"> | string | null
    quantity?: DecimalNullableFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string | null
    unitPrice?: DecimalNullableFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string | null
    totalPrice?: DecimalNullableFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string | null
    metadata?: JsonNullableFilter<"PurchaseOrderLine">
    createdAt?: DateTimeFilter<"PurchaseOrderLine"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrderLine"> | Date | string
    order?: XOR<PurchaseOrderLogScalarRelationFilter, PurchaseOrderLogWhereInput>
    baseline?: XOR<QuotationBaselineItemNullableScalarRelationFilter, QuotationBaselineItemWhereInput> | null
    deliveries?: PurchaseDeliveryItemListRelationFilter
  }, "id">

  export type PurchaseOrderLineOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    baselineId?: SortOrderInput | SortOrder
    description?: SortOrder
    unit?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    unitPrice?: SortOrderInput | SortOrder
    totalPrice?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseOrderLineCountOrderByAggregateInput
    _avg?: PurchaseOrderLineAvgOrderByAggregateInput
    _max?: PurchaseOrderLineMaxOrderByAggregateInput
    _min?: PurchaseOrderLineMinOrderByAggregateInput
    _sum?: PurchaseOrderLineSumOrderByAggregateInput
  }

  export type PurchaseOrderLineScalarWhereWithAggregatesInput = {
    AND?: PurchaseOrderLineScalarWhereWithAggregatesInput | PurchaseOrderLineScalarWhereWithAggregatesInput[]
    OR?: PurchaseOrderLineScalarWhereWithAggregatesInput[]
    NOT?: PurchaseOrderLineScalarWhereWithAggregatesInput | PurchaseOrderLineScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PurchaseOrderLine"> | number
    orderId?: IntWithAggregatesFilter<"PurchaseOrderLine"> | number
    baselineId?: IntNullableWithAggregatesFilter<"PurchaseOrderLine"> | number | null
    description?: StringWithAggregatesFilter<"PurchaseOrderLine"> | string
    unit?: StringNullableWithAggregatesFilter<"PurchaseOrderLine"> | string | null
    quantity?: DecimalNullableWithAggregatesFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string | null
    unitPrice?: DecimalNullableWithAggregatesFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string | null
    totalPrice?: DecimalNullableWithAggregatesFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string | null
    metadata?: JsonNullableWithAggregatesFilter<"PurchaseOrderLine">
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseOrderLine"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseOrderLine"> | Date | string
  }

  export type PurchaseDeliveryLogWhereInput = {
    AND?: PurchaseDeliveryLogWhereInput | PurchaseDeliveryLogWhereInput[]
    OR?: PurchaseDeliveryLogWhereInput[]
    NOT?: PurchaseDeliveryLogWhereInput | PurchaseDeliveryLogWhereInput[]
    id?: IntFilter<"PurchaseDeliveryLog"> | number
    processId?: IntFilter<"PurchaseDeliveryLog"> | number
    orderId?: IntNullableFilter<"PurchaseDeliveryLog"> | number | null
    proveedorId?: IntNullableFilter<"PurchaseDeliveryLog"> | number | null
    supplierName?: StringNullableFilter<"PurchaseDeliveryLog"> | string | null
    guideNumber?: StringNullableFilter<"PurchaseDeliveryLog"> | string | null
    date?: DateTimeFilter<"PurchaseDeliveryLog"> | Date | string
    notes?: StringNullableFilter<"PurchaseDeliveryLog"> | string | null
    createdAt?: DateTimeFilter<"PurchaseDeliveryLog"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseDeliveryLog"> | Date | string
    process?: XOR<QuotationProcessScalarRelationFilter, QuotationProcessWhereInput>
    order?: XOR<PurchaseOrderLogNullableScalarRelationFilter, PurchaseOrderLogWhereInput> | null
    proveedor?: XOR<ProveedorNullableScalarRelationFilter, ProveedorWhereInput> | null
    items?: PurchaseDeliveryItemListRelationFilter
  }

  export type PurchaseDeliveryLogOrderByWithRelationInput = {
    id?: SortOrder
    processId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    proveedorId?: SortOrderInput | SortOrder
    supplierName?: SortOrderInput | SortOrder
    guideNumber?: SortOrderInput | SortOrder
    date?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    process?: QuotationProcessOrderByWithRelationInput
    order?: PurchaseOrderLogOrderByWithRelationInput
    proveedor?: ProveedorOrderByWithRelationInput
    items?: PurchaseDeliveryItemOrderByRelationAggregateInput
  }

  export type PurchaseDeliveryLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PurchaseDeliveryLogWhereInput | PurchaseDeliveryLogWhereInput[]
    OR?: PurchaseDeliveryLogWhereInput[]
    NOT?: PurchaseDeliveryLogWhereInput | PurchaseDeliveryLogWhereInput[]
    processId?: IntFilter<"PurchaseDeliveryLog"> | number
    orderId?: IntNullableFilter<"PurchaseDeliveryLog"> | number | null
    proveedorId?: IntNullableFilter<"PurchaseDeliveryLog"> | number | null
    supplierName?: StringNullableFilter<"PurchaseDeliveryLog"> | string | null
    guideNumber?: StringNullableFilter<"PurchaseDeliveryLog"> | string | null
    date?: DateTimeFilter<"PurchaseDeliveryLog"> | Date | string
    notes?: StringNullableFilter<"PurchaseDeliveryLog"> | string | null
    createdAt?: DateTimeFilter<"PurchaseDeliveryLog"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseDeliveryLog"> | Date | string
    process?: XOR<QuotationProcessScalarRelationFilter, QuotationProcessWhereInput>
    order?: XOR<PurchaseOrderLogNullableScalarRelationFilter, PurchaseOrderLogWhereInput> | null
    proveedor?: XOR<ProveedorNullableScalarRelationFilter, ProveedorWhereInput> | null
    items?: PurchaseDeliveryItemListRelationFilter
  }, "id">

  export type PurchaseDeliveryLogOrderByWithAggregationInput = {
    id?: SortOrder
    processId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    proveedorId?: SortOrderInput | SortOrder
    supplierName?: SortOrderInput | SortOrder
    guideNumber?: SortOrderInput | SortOrder
    date?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseDeliveryLogCountOrderByAggregateInput
    _avg?: PurchaseDeliveryLogAvgOrderByAggregateInput
    _max?: PurchaseDeliveryLogMaxOrderByAggregateInput
    _min?: PurchaseDeliveryLogMinOrderByAggregateInput
    _sum?: PurchaseDeliveryLogSumOrderByAggregateInput
  }

  export type PurchaseDeliveryLogScalarWhereWithAggregatesInput = {
    AND?: PurchaseDeliveryLogScalarWhereWithAggregatesInput | PurchaseDeliveryLogScalarWhereWithAggregatesInput[]
    OR?: PurchaseDeliveryLogScalarWhereWithAggregatesInput[]
    NOT?: PurchaseDeliveryLogScalarWhereWithAggregatesInput | PurchaseDeliveryLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PurchaseDeliveryLog"> | number
    processId?: IntWithAggregatesFilter<"PurchaseDeliveryLog"> | number
    orderId?: IntNullableWithAggregatesFilter<"PurchaseDeliveryLog"> | number | null
    proveedorId?: IntNullableWithAggregatesFilter<"PurchaseDeliveryLog"> | number | null
    supplierName?: StringNullableWithAggregatesFilter<"PurchaseDeliveryLog"> | string | null
    guideNumber?: StringNullableWithAggregatesFilter<"PurchaseDeliveryLog"> | string | null
    date?: DateTimeWithAggregatesFilter<"PurchaseDeliveryLog"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"PurchaseDeliveryLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseDeliveryLog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseDeliveryLog"> | Date | string
  }

  export type PurchaseDeliveryItemWhereInput = {
    AND?: PurchaseDeliveryItemWhereInput | PurchaseDeliveryItemWhereInput[]
    OR?: PurchaseDeliveryItemWhereInput[]
    NOT?: PurchaseDeliveryItemWhereInput | PurchaseDeliveryItemWhereInput[]
    id?: IntFilter<"PurchaseDeliveryItem"> | number
    deliveryId?: IntFilter<"PurchaseDeliveryItem"> | number
    orderLineId?: IntNullableFilter<"PurchaseDeliveryItem"> | number | null
    baselineId?: IntNullableFilter<"PurchaseDeliveryItem"> | number | null
    description?: StringFilter<"PurchaseDeliveryItem"> | string
    unit?: StringNullableFilter<"PurchaseDeliveryItem"> | string | null
    quantity?: DecimalNullableFilter<"PurchaseDeliveryItem"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"PurchaseDeliveryItem"> | string | null
    createdAt?: DateTimeFilter<"PurchaseDeliveryItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseDeliveryItem"> | Date | string
    delivery?: XOR<PurchaseDeliveryLogScalarRelationFilter, PurchaseDeliveryLogWhereInput>
    orderLine?: XOR<PurchaseOrderLineNullableScalarRelationFilter, PurchaseOrderLineWhereInput> | null
    baseline?: XOR<QuotationBaselineItemNullableScalarRelationFilter, QuotationBaselineItemWhereInput> | null
  }

  export type PurchaseDeliveryItemOrderByWithRelationInput = {
    id?: SortOrder
    deliveryId?: SortOrder
    orderLineId?: SortOrderInput | SortOrder
    baselineId?: SortOrderInput | SortOrder
    description?: SortOrder
    unit?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    delivery?: PurchaseDeliveryLogOrderByWithRelationInput
    orderLine?: PurchaseOrderLineOrderByWithRelationInput
    baseline?: QuotationBaselineItemOrderByWithRelationInput
  }

  export type PurchaseDeliveryItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PurchaseDeliveryItemWhereInput | PurchaseDeliveryItemWhereInput[]
    OR?: PurchaseDeliveryItemWhereInput[]
    NOT?: PurchaseDeliveryItemWhereInput | PurchaseDeliveryItemWhereInput[]
    deliveryId?: IntFilter<"PurchaseDeliveryItem"> | number
    orderLineId?: IntNullableFilter<"PurchaseDeliveryItem"> | number | null
    baselineId?: IntNullableFilter<"PurchaseDeliveryItem"> | number | null
    description?: StringFilter<"PurchaseDeliveryItem"> | string
    unit?: StringNullableFilter<"PurchaseDeliveryItem"> | string | null
    quantity?: DecimalNullableFilter<"PurchaseDeliveryItem"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"PurchaseDeliveryItem"> | string | null
    createdAt?: DateTimeFilter<"PurchaseDeliveryItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseDeliveryItem"> | Date | string
    delivery?: XOR<PurchaseDeliveryLogScalarRelationFilter, PurchaseDeliveryLogWhereInput>
    orderLine?: XOR<PurchaseOrderLineNullableScalarRelationFilter, PurchaseOrderLineWhereInput> | null
    baseline?: XOR<QuotationBaselineItemNullableScalarRelationFilter, QuotationBaselineItemWhereInput> | null
  }, "id">

  export type PurchaseDeliveryItemOrderByWithAggregationInput = {
    id?: SortOrder
    deliveryId?: SortOrder
    orderLineId?: SortOrderInput | SortOrder
    baselineId?: SortOrderInput | SortOrder
    description?: SortOrder
    unit?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseDeliveryItemCountOrderByAggregateInput
    _avg?: PurchaseDeliveryItemAvgOrderByAggregateInput
    _max?: PurchaseDeliveryItemMaxOrderByAggregateInput
    _min?: PurchaseDeliveryItemMinOrderByAggregateInput
    _sum?: PurchaseDeliveryItemSumOrderByAggregateInput
  }

  export type PurchaseDeliveryItemScalarWhereWithAggregatesInput = {
    AND?: PurchaseDeliveryItemScalarWhereWithAggregatesInput | PurchaseDeliveryItemScalarWhereWithAggregatesInput[]
    OR?: PurchaseDeliveryItemScalarWhereWithAggregatesInput[]
    NOT?: PurchaseDeliveryItemScalarWhereWithAggregatesInput | PurchaseDeliveryItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PurchaseDeliveryItem"> | number
    deliveryId?: IntWithAggregatesFilter<"PurchaseDeliveryItem"> | number
    orderLineId?: IntNullableWithAggregatesFilter<"PurchaseDeliveryItem"> | number | null
    baselineId?: IntNullableWithAggregatesFilter<"PurchaseDeliveryItem"> | number | null
    description?: StringWithAggregatesFilter<"PurchaseDeliveryItem"> | string
    unit?: StringNullableWithAggregatesFilter<"PurchaseDeliveryItem"> | string | null
    quantity?: DecimalNullableWithAggregatesFilter<"PurchaseDeliveryItem"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableWithAggregatesFilter<"PurchaseDeliveryItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseDeliveryItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseDeliveryItem"> | Date | string
  }

  export type ObraCreateInput = {
    name: string
    code?: string | null
    frentes?: FrenteCreateNestedManyWithoutObraInput
    moves?: MoveCreateNestedManyWithoutObraInput
    incomes?: IncomeCreateNestedManyWithoutObraInput
    expenses?: ExpenseCreateNestedManyWithoutObraInput
    employees?: EmployeeCreateNestedManyWithoutObraInput
    payrollPeriods?: PayrollPeriodCreateNestedManyWithoutObraInput
    dailyCashRenditions?: DailyCashRenditionCreateNestedManyWithoutObraInput
  }

  export type ObraUncheckedCreateInput = {
    id?: number
    name: string
    code?: string | null
    frentes?: FrenteUncheckedCreateNestedManyWithoutObraInput
    moves?: MoveUncheckedCreateNestedManyWithoutObraInput
    incomes?: IncomeUncheckedCreateNestedManyWithoutObraInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutObraInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutObraInput
    payrollPeriods?: PayrollPeriodUncheckedCreateNestedManyWithoutObraInput
    dailyCashRenditions?: DailyCashRenditionUncheckedCreateNestedManyWithoutObraInput
  }

  export type ObraUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    frentes?: FrenteUpdateManyWithoutObraNestedInput
    moves?: MoveUpdateManyWithoutObraNestedInput
    incomes?: IncomeUpdateManyWithoutObraNestedInput
    expenses?: ExpenseUpdateManyWithoutObraNestedInput
    employees?: EmployeeUpdateManyWithoutObraNestedInput
    payrollPeriods?: PayrollPeriodUpdateManyWithoutObraNestedInput
    dailyCashRenditions?: DailyCashRenditionUpdateManyWithoutObraNestedInput
  }

  export type ObraUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    frentes?: FrenteUncheckedUpdateManyWithoutObraNestedInput
    moves?: MoveUncheckedUpdateManyWithoutObraNestedInput
    incomes?: IncomeUncheckedUpdateManyWithoutObraNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutObraNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutObraNestedInput
    payrollPeriods?: PayrollPeriodUncheckedUpdateManyWithoutObraNestedInput
    dailyCashRenditions?: DailyCashRenditionUncheckedUpdateManyWithoutObraNestedInput
  }

  export type ObraCreateManyInput = {
    id?: number
    name: string
    code?: string | null
  }

  export type ObraUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ObraUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaterialCreateInput = {
    code?: string | null
    name: string
    unit?: string | null
    minStock?: Decimal | DecimalJsLike | number | string
    reorderQuantity?: Decimal | DecimalJsLike | number | string
    allowNegative?: boolean
    isCompanyAsset?: boolean
    assetStatus?: $Enums.AssetStatus
    assetResponsible?: string | null
    group?: MaterialGroupCreateNestedOneWithoutMaterialsInput
    moves?: MoveCreateNestedManyWithoutMaterialInput
    expenses?: ExpenseCreateNestedManyWithoutMaterialInput
    baseQuotes?: QuotationBaselineItemCreateNestedManyWithoutMaterialInput
    quoteItems?: QuotationItemCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUncheckedCreateInput = {
    id?: number
    code?: string | null
    name: string
    unit?: string | null
    groupId?: number | null
    minStock?: Decimal | DecimalJsLike | number | string
    reorderQuantity?: Decimal | DecimalJsLike | number | string
    allowNegative?: boolean
    isCompanyAsset?: boolean
    assetStatus?: $Enums.AssetStatus
    assetResponsible?: string | null
    moves?: MoveUncheckedCreateNestedManyWithoutMaterialInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutMaterialInput
    baseQuotes?: QuotationBaselineItemUncheckedCreateNestedManyWithoutMaterialInput
    quoteItems?: QuotationItemUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUpdateInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowNegative?: BoolFieldUpdateOperationsInput | boolean
    isCompanyAsset?: BoolFieldUpdateOperationsInput | boolean
    assetStatus?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    assetResponsible?: NullableStringFieldUpdateOperationsInput | string | null
    group?: MaterialGroupUpdateOneWithoutMaterialsNestedInput
    moves?: MoveUpdateManyWithoutMaterialNestedInput
    expenses?: ExpenseUpdateManyWithoutMaterialNestedInput
    baseQuotes?: QuotationBaselineItemUpdateManyWithoutMaterialNestedInput
    quoteItems?: QuotationItemUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: NullableIntFieldUpdateOperationsInput | number | null
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowNegative?: BoolFieldUpdateOperationsInput | boolean
    isCompanyAsset?: BoolFieldUpdateOperationsInput | boolean
    assetStatus?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    assetResponsible?: NullableStringFieldUpdateOperationsInput | string | null
    moves?: MoveUncheckedUpdateManyWithoutMaterialNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutMaterialNestedInput
    baseQuotes?: QuotationBaselineItemUncheckedUpdateManyWithoutMaterialNestedInput
    quoteItems?: QuotationItemUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialCreateManyInput = {
    id?: number
    code?: string | null
    name: string
    unit?: string | null
    groupId?: number | null
    minStock?: Decimal | DecimalJsLike | number | string
    reorderQuantity?: Decimal | DecimalJsLike | number | string
    allowNegative?: boolean
    isCompanyAsset?: boolean
    assetStatus?: $Enums.AssetStatus
    assetResponsible?: string | null
  }

  export type MaterialUpdateManyMutationInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowNegative?: BoolFieldUpdateOperationsInput | boolean
    isCompanyAsset?: BoolFieldUpdateOperationsInput | boolean
    assetStatus?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    assetResponsible?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaterialUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: NullableIntFieldUpdateOperationsInput | number | null
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowNegative?: BoolFieldUpdateOperationsInput | boolean
    isCompanyAsset?: BoolFieldUpdateOperationsInput | boolean
    assetStatus?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    assetResponsible?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProveedorCreateInput = {
    name: string
    ruc?: string | null
    phone?: string | null
    moves?: MoveCreateNestedManyWithoutProveedorInput
    expenses?: ExpenseCreateNestedManyWithoutProveedorInput
    quotations?: QuotationCreateNestedManyWithoutProveedorInput
    deliveries?: PurchaseDeliveryLogCreateNestedManyWithoutProveedorInput
  }

  export type ProveedorUncheckedCreateInput = {
    id?: number
    name: string
    ruc?: string | null
    phone?: string | null
    moves?: MoveUncheckedCreateNestedManyWithoutProveedorInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutProveedorInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutProveedorInput
    deliveries?: PurchaseDeliveryLogUncheckedCreateNestedManyWithoutProveedorInput
  }

  export type ProveedorUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    moves?: MoveUpdateManyWithoutProveedorNestedInput
    expenses?: ExpenseUpdateManyWithoutProveedorNestedInput
    quotations?: QuotationUpdateManyWithoutProveedorNestedInput
    deliveries?: PurchaseDeliveryLogUpdateManyWithoutProveedorNestedInput
  }

  export type ProveedorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    moves?: MoveUncheckedUpdateManyWithoutProveedorNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutProveedorNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutProveedorNestedInput
    deliveries?: PurchaseDeliveryLogUncheckedUpdateManyWithoutProveedorNestedInput
  }

  export type ProveedorCreateManyInput = {
    id?: number
    name: string
    ruc?: string | null
    phone?: string | null
  }

  export type ProveedorUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProveedorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FrenteCreateInput = {
    name: string
    obra: ObraCreateNestedOneWithoutFrentesInput
    moves?: MoveCreateNestedManyWithoutFrenteInput
    incomes?: IncomeCreateNestedManyWithoutFrenteInput
    expenses?: ExpenseCreateNestedManyWithoutFrenteInput
  }

  export type FrenteUncheckedCreateInput = {
    id?: number
    name: string
    obraId: number
    moves?: MoveUncheckedCreateNestedManyWithoutFrenteInput
    incomes?: IncomeUncheckedCreateNestedManyWithoutFrenteInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutFrenteInput
  }

  export type FrenteUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    obra?: ObraUpdateOneRequiredWithoutFrentesNestedInput
    moves?: MoveUpdateManyWithoutFrenteNestedInput
    incomes?: IncomeUpdateManyWithoutFrenteNestedInput
    expenses?: ExpenseUpdateManyWithoutFrenteNestedInput
  }

  export type FrenteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    obraId?: IntFieldUpdateOperationsInput | number
    moves?: MoveUncheckedUpdateManyWithoutFrenteNestedInput
    incomes?: IncomeUncheckedUpdateManyWithoutFrenteNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutFrenteNestedInput
  }

  export type FrenteCreateManyInput = {
    id?: number
    name: string
    obraId: number
  }

  export type FrenteUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type FrenteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    obraId?: IntFieldUpdateOperationsInput | number
  }

  export type MaterialGroupCreateInput = {
    name: string
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: MaterialGroupCreateNestedOneWithoutChildrenInput
    children?: MaterialGroupCreateNestedManyWithoutParentInput
    materials?: MaterialCreateNestedManyWithoutGroupInput
  }

  export type MaterialGroupUncheckedCreateInput = {
    id?: number
    name: string
    parentId?: number | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: MaterialGroupUncheckedCreateNestedManyWithoutParentInput
    materials?: MaterialUncheckedCreateNestedManyWithoutGroupInput
  }

  export type MaterialGroupUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: MaterialGroupUpdateOneWithoutChildrenNestedInput
    children?: MaterialGroupUpdateManyWithoutParentNestedInput
    materials?: MaterialUpdateManyWithoutGroupNestedInput
  }

  export type MaterialGroupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: MaterialGroupUncheckedUpdateManyWithoutParentNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type MaterialGroupCreateManyInput = {
    id?: number
    name: string
    parentId?: number | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialGroupUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialGroupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoveCreateInput = {
    type: $Enums.MoveType
    quantity: number
    unitCost?: number | null
    totalCost?: number | null
    date?: Date | string
    note?: string | null
    docType?: $Enums.DocType | null
    docSerie?: string | null
    docNumero?: string | null
    igvRate?: Decimal | DecimalJsLike | number | string | null
    isTaxable?: boolean | null
    responsible?: string | null
    assetStatus?: $Enums.AssetStatus | null
    obra: ObraCreateNestedOneWithoutMovesInput
    frente?: FrenteCreateNestedOneWithoutMovesInput
    material: MaterialCreateNestedOneWithoutMovesInput
    proveedor?: ProveedorCreateNestedOneWithoutMovesInput
    expense?: ExpenseCreateNestedOneWithoutMoveInput
  }

  export type MoveUncheckedCreateInput = {
    id?: number
    obraId: number
    frenteId?: number | null
    materialId: number
    proveedorId?: number | null
    type: $Enums.MoveType
    quantity: number
    unitCost?: number | null
    totalCost?: number | null
    date?: Date | string
    note?: string | null
    docType?: $Enums.DocType | null
    docSerie?: string | null
    docNumero?: string | null
    igvRate?: Decimal | DecimalJsLike | number | string | null
    isTaxable?: boolean | null
    responsible?: string | null
    assetStatus?: $Enums.AssetStatus | null
    expense?: ExpenseUncheckedCreateNestedOneWithoutMoveInput
  }

  export type MoveUpdateInput = {
    type?: EnumMoveTypeFieldUpdateOperationsInput | $Enums.MoveType
    quantity?: FloatFieldUpdateOperationsInput | number
    unitCost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableEnumDocTypeFieldUpdateOperationsInput | $Enums.DocType | null
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    igvRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isTaxable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    responsible?: NullableStringFieldUpdateOperationsInput | string | null
    assetStatus?: NullableEnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus | null
    obra?: ObraUpdateOneRequiredWithoutMovesNestedInput
    frente?: FrenteUpdateOneWithoutMovesNestedInput
    material?: MaterialUpdateOneRequiredWithoutMovesNestedInput
    proveedor?: ProveedorUpdateOneWithoutMovesNestedInput
    expense?: ExpenseUpdateOneWithoutMoveNestedInput
  }

  export type MoveUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    obraId?: IntFieldUpdateOperationsInput | number
    frenteId?: NullableIntFieldUpdateOperationsInput | number | null
    materialId?: IntFieldUpdateOperationsInput | number
    proveedorId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumMoveTypeFieldUpdateOperationsInput | $Enums.MoveType
    quantity?: FloatFieldUpdateOperationsInput | number
    unitCost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableEnumDocTypeFieldUpdateOperationsInput | $Enums.DocType | null
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    igvRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isTaxable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    responsible?: NullableStringFieldUpdateOperationsInput | string | null
    assetStatus?: NullableEnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus | null
    expense?: ExpenseUncheckedUpdateOneWithoutMoveNestedInput
  }

  export type MoveCreateManyInput = {
    id?: number
    obraId: number
    frenteId?: number | null
    materialId: number
    proveedorId?: number | null
    type: $Enums.MoveType
    quantity: number
    unitCost?: number | null
    totalCost?: number | null
    date?: Date | string
    note?: string | null
    docType?: $Enums.DocType | null
    docSerie?: string | null
    docNumero?: string | null
    igvRate?: Decimal | DecimalJsLike | number | string | null
    isTaxable?: boolean | null
    responsible?: string | null
    assetStatus?: $Enums.AssetStatus | null
  }

  export type MoveUpdateManyMutationInput = {
    type?: EnumMoveTypeFieldUpdateOperationsInput | $Enums.MoveType
    quantity?: FloatFieldUpdateOperationsInput | number
    unitCost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableEnumDocTypeFieldUpdateOperationsInput | $Enums.DocType | null
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    igvRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isTaxable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    responsible?: NullableStringFieldUpdateOperationsInput | string | null
    assetStatus?: NullableEnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus | null
  }

  export type MoveUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    obraId?: IntFieldUpdateOperationsInput | number
    frenteId?: NullableIntFieldUpdateOperationsInput | number | null
    materialId?: IntFieldUpdateOperationsInput | number
    proveedorId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumMoveTypeFieldUpdateOperationsInput | $Enums.MoveType
    quantity?: FloatFieldUpdateOperationsInput | number
    unitCost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableEnumDocTypeFieldUpdateOperationsInput | $Enums.DocType | null
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    igvRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isTaxable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    responsible?: NullableStringFieldUpdateOperationsInput | string | null
    assetStatus?: NullableEnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus | null
  }

  export type ExpenseCategoryCreateInput = {
    name: string
    createdAt?: Date | string
    kind?: $Enums.ExpenseKind
    expenses?: ExpenseCreateNestedManyWithoutCategoryInput
  }

  export type ExpenseCategoryUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    kind?: $Enums.ExpenseKind
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ExpenseCategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kind?: EnumExpenseKindFieldUpdateOperationsInput | $Enums.ExpenseKind
    expenses?: ExpenseUpdateManyWithoutCategoryNestedInput
  }

  export type ExpenseCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kind?: EnumExpenseKindFieldUpdateOperationsInput | $Enums.ExpenseKind
    expenses?: ExpenseUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ExpenseCategoryCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    kind?: $Enums.ExpenseKind
  }

  export type ExpenseCategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kind?: EnumExpenseKindFieldUpdateOperationsInput | $Enums.ExpenseKind
  }

  export type ExpenseCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kind?: EnumExpenseKindFieldUpdateOperationsInput | $Enums.ExpenseKind
  }

  export type IncomeCreateInput = {
    date?: Date | string
    description?: string | null
    docType?: $Enums.DocType
    docSerie?: string | null
    docNumero?: string | null
    status?: $Enums.IncomeStatus
    igvRate?: Decimal | DecimalJsLike | number | string
    isTaxable?: boolean
    base: Decimal | DecimalJsLike | number | string
    igv: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    obra: ObraCreateNestedOneWithoutIncomesInput
    frente?: FrenteCreateNestedOneWithoutIncomesInput
  }

  export type IncomeUncheckedCreateInput = {
    id?: number
    obraId: number
    frenteId?: number | null
    date?: Date | string
    description?: string | null
    docType?: $Enums.DocType
    docSerie?: string | null
    docNumero?: string | null
    status?: $Enums.IncomeStatus
    igvRate?: Decimal | DecimalJsLike | number | string
    isTaxable?: boolean
    base: Decimal | DecimalJsLike | number | string
    igv: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncomeUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: EnumDocTypeFieldUpdateOperationsInput | $Enums.DocType
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumIncomeStatusFieldUpdateOperationsInput | $Enums.IncomeStatus
    igvRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    base?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    igv?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    obra?: ObraUpdateOneRequiredWithoutIncomesNestedInput
    frente?: FrenteUpdateOneWithoutIncomesNestedInput
  }

  export type IncomeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    obraId?: IntFieldUpdateOperationsInput | number
    frenteId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: EnumDocTypeFieldUpdateOperationsInput | $Enums.DocType
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumIncomeStatusFieldUpdateOperationsInput | $Enums.IncomeStatus
    igvRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    base?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    igv?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncomeCreateManyInput = {
    id?: number
    obraId: number
    frenteId?: number | null
    date?: Date | string
    description?: string | null
    docType?: $Enums.DocType
    docSerie?: string | null
    docNumero?: string | null
    status?: $Enums.IncomeStatus
    igvRate?: Decimal | DecimalJsLike | number | string
    isTaxable?: boolean
    base: Decimal | DecimalJsLike | number | string
    igv: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncomeUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: EnumDocTypeFieldUpdateOperationsInput | $Enums.DocType
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumIncomeStatusFieldUpdateOperationsInput | $Enums.IncomeStatus
    igvRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    base?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    igv?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncomeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    obraId?: IntFieldUpdateOperationsInput | number
    frenteId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: EnumDocTypeFieldUpdateOperationsInput | $Enums.DocType
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumIncomeStatusFieldUpdateOperationsInput | $Enums.IncomeStatus
    igvRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    base?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    igv?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCreateInput = {
    docType?: $Enums.DocType
    docSerie?: string | null
    docNumero?: string | null
    date?: Date | string
    description?: string | null
    spentBy?: string | null
    type?: $Enums.ExpenseType
    variableType?: $Enums.VariableType
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
    igvRate?: Decimal | DecimalJsLike | number | string
    isTaxable?: boolean
    base: Decimal | DecimalJsLike | number | string
    igv: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paymentMethod?: $Enums.PaymentMethod
    paidAt?: Date | string | null
    status?: string
    reminderIntervalDays?: number | null
    reminderNextDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    obra: ObraCreateNestedOneWithoutExpensesInput
    frente?: FrenteCreateNestedOneWithoutExpensesInput
    proveedor?: ProveedorCreateNestedOneWithoutExpensesInput
    material?: MaterialCreateNestedOneWithoutExpensesInput
    category?: ExpenseCategoryCreateNestedOneWithoutExpensesInput
    move?: MoveCreateNestedOneWithoutExpenseInput
  }

  export type ExpenseUncheckedCreateInput = {
    id?: number
    obraId: number
    frenteId?: number | null
    proveedorId?: number | null
    materialId?: number | null
    categoryId?: number | null
    moveId?: number | null
    docType?: $Enums.DocType
    docSerie?: string | null
    docNumero?: string | null
    date?: Date | string
    description?: string | null
    spentBy?: string | null
    type?: $Enums.ExpenseType
    variableType?: $Enums.VariableType
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
    igvRate?: Decimal | DecimalJsLike | number | string
    isTaxable?: boolean
    base: Decimal | DecimalJsLike | number | string
    igv: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paymentMethod?: $Enums.PaymentMethod
    paidAt?: Date | string | null
    status?: string
    reminderIntervalDays?: number | null
    reminderNextDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseUpdateInput = {
    docType?: EnumDocTypeFieldUpdateOperationsInput | $Enums.DocType
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    spentBy?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExpenseTypeFieldUpdateOperationsInput | $Enums.ExpenseType
    variableType?: EnumVariableTypeFieldUpdateOperationsInput | $Enums.VariableType
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    igvRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    base?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    igv?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    reminderIntervalDays?: NullableIntFieldUpdateOperationsInput | number | null
    reminderNextDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    obra?: ObraUpdateOneRequiredWithoutExpensesNestedInput
    frente?: FrenteUpdateOneWithoutExpensesNestedInput
    proveedor?: ProveedorUpdateOneWithoutExpensesNestedInput
    material?: MaterialUpdateOneWithoutExpensesNestedInput
    category?: ExpenseCategoryUpdateOneWithoutExpensesNestedInput
    move?: MoveUpdateOneWithoutExpenseNestedInput
  }

  export type ExpenseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    obraId?: IntFieldUpdateOperationsInput | number
    frenteId?: NullableIntFieldUpdateOperationsInput | number | null
    proveedorId?: NullableIntFieldUpdateOperationsInput | number | null
    materialId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    moveId?: NullableIntFieldUpdateOperationsInput | number | null
    docType?: EnumDocTypeFieldUpdateOperationsInput | $Enums.DocType
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    spentBy?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExpenseTypeFieldUpdateOperationsInput | $Enums.ExpenseType
    variableType?: EnumVariableTypeFieldUpdateOperationsInput | $Enums.VariableType
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    igvRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    base?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    igv?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    reminderIntervalDays?: NullableIntFieldUpdateOperationsInput | number | null
    reminderNextDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCreateManyInput = {
    id?: number
    obraId: number
    frenteId?: number | null
    proveedorId?: number | null
    materialId?: number | null
    categoryId?: number | null
    moveId?: number | null
    docType?: $Enums.DocType
    docSerie?: string | null
    docNumero?: string | null
    date?: Date | string
    description?: string | null
    spentBy?: string | null
    type?: $Enums.ExpenseType
    variableType?: $Enums.VariableType
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
    igvRate?: Decimal | DecimalJsLike | number | string
    isTaxable?: boolean
    base: Decimal | DecimalJsLike | number | string
    igv: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paymentMethod?: $Enums.PaymentMethod
    paidAt?: Date | string | null
    status?: string
    reminderIntervalDays?: number | null
    reminderNextDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseUpdateManyMutationInput = {
    docType?: EnumDocTypeFieldUpdateOperationsInput | $Enums.DocType
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    spentBy?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExpenseTypeFieldUpdateOperationsInput | $Enums.ExpenseType
    variableType?: EnumVariableTypeFieldUpdateOperationsInput | $Enums.VariableType
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    igvRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    base?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    igv?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    reminderIntervalDays?: NullableIntFieldUpdateOperationsInput | number | null
    reminderNextDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    obraId?: IntFieldUpdateOperationsInput | number
    frenteId?: NullableIntFieldUpdateOperationsInput | number | null
    proveedorId?: NullableIntFieldUpdateOperationsInput | number | null
    materialId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    moveId?: NullableIntFieldUpdateOperationsInput | number | null
    docType?: EnumDocTypeFieldUpdateOperationsInput | $Enums.DocType
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    spentBy?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExpenseTypeFieldUpdateOperationsInput | $Enums.ExpenseType
    variableType?: EnumVariableTypeFieldUpdateOperationsInput | $Enums.VariableType
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    igvRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    base?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    igv?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    reminderIntervalDays?: NullableIntFieldUpdateOperationsInput | number | null
    reminderNextDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyCashRenditionCreateInput = {
    date?: Date | string
    openingBalance?: Decimal | DecimalJsLike | number | string
    received?: Decimal | DecimalJsLike | number | string
    spent?: Decimal | DecimalJsLike | number | string
    personalContribution?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    obra?: ObraCreateNestedOneWithoutDailyCashRenditionsInput
    expenses?: DailyCashExpenseCreateNestedManyWithoutRenditionInput
  }

  export type DailyCashRenditionUncheckedCreateInput = {
    id?: number
    date?: Date | string
    obraId?: number | null
    openingBalance?: Decimal | DecimalJsLike | number | string
    received?: Decimal | DecimalJsLike | number | string
    spent?: Decimal | DecimalJsLike | number | string
    personalContribution?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    expenses?: DailyCashExpenseUncheckedCreateNestedManyWithoutRenditionInput
  }

  export type DailyCashRenditionUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    received?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    spent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personalContribution?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    obra?: ObraUpdateOneWithoutDailyCashRenditionsNestedInput
    expenses?: DailyCashExpenseUpdateManyWithoutRenditionNestedInput
  }

  export type DailyCashRenditionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    obraId?: NullableIntFieldUpdateOperationsInput | number | null
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    received?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    spent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personalContribution?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expenses?: DailyCashExpenseUncheckedUpdateManyWithoutRenditionNestedInput
  }

  export type DailyCashRenditionCreateManyInput = {
    id?: number
    date?: Date | string
    obraId?: number | null
    openingBalance?: Decimal | DecimalJsLike | number | string
    received?: Decimal | DecimalJsLike | number | string
    spent?: Decimal | DecimalJsLike | number | string
    personalContribution?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyCashRenditionUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    received?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    spent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personalContribution?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyCashRenditionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    obraId?: NullableIntFieldUpdateOperationsInput | number | null
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    received?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    spent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personalContribution?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyCashExpenseCreateInput = {
    description: string
    amount: Decimal | DecimalJsLike | number | string
    personalAmount?: Decimal | DecimalJsLike | number | string
    paidWithPersonal?: boolean
    createdAt?: Date | string
    rendition: DailyCashRenditionCreateNestedOneWithoutExpensesInput
  }

  export type DailyCashExpenseUncheckedCreateInput = {
    id?: number
    renditionId: number
    description: string
    amount: Decimal | DecimalJsLike | number | string
    personalAmount?: Decimal | DecimalJsLike | number | string
    paidWithPersonal?: boolean
    createdAt?: Date | string
  }

  export type DailyCashExpenseUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidWithPersonal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rendition?: DailyCashRenditionUpdateOneRequiredWithoutExpensesNestedInput
  }

  export type DailyCashExpenseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    renditionId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidWithPersonal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyCashExpenseCreateManyInput = {
    id?: number
    renditionId: number
    description: string
    amount: Decimal | DecimalJsLike | number | string
    personalAmount?: Decimal | DecimalJsLike | number | string
    paidWithPersonal?: boolean
    createdAt?: Date | string
  }

  export type DailyCashExpenseUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidWithPersonal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyCashExpenseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    renditionId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidWithPersonal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminSettingCreateInput = {
    id: number
    deletePasswordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminSettingUncheckedCreateInput = {
    id: number
    deletePasswordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminSettingUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    deletePasswordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminSettingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    deletePasswordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminSettingCreateManyInput = {
    id: number
    deletePasswordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminSettingUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    deletePasswordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminSettingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    deletePasswordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateInput = {
    code?: string | null
    firstName: string
    lastName: string
    documentType?: $Enums.DocumentType | null
    documentNumber?: string | null
    position?: string | null
    phone?: string | null
    email?: string | null
    bankType?: $Enums.BankType
    accountNumber?: string | null
    cci?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    baseSalary?: Decimal | DecimalJsLike | number | string
    dailyHours?: Decimal | DecimalJsLike | number | string
    pensionSystem?: $Enums.PensionSystem
    pensionRate?: Decimal | DecimalJsLike | number | string
    healthRate?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    area?: $Enums.EmployeeArea
    notes?: string | null
    absenceSundayPenalty?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    obra?: ObraCreateNestedOneWithoutEmployeesInput
    attendances?: AttendanceRecordCreateNestedManyWithoutEmployeeInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutEmployeeInput
    accumulationPayment?: EmployeeAccumulationPaymentCreateNestedOneWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateInput = {
    id?: number
    code?: string | null
    firstName: string
    lastName: string
    documentType?: $Enums.DocumentType | null
    documentNumber?: string | null
    position?: string | null
    phone?: string | null
    email?: string | null
    bankType?: $Enums.BankType
    accountNumber?: string | null
    cci?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    baseSalary?: Decimal | DecimalJsLike | number | string
    dailyHours?: Decimal | DecimalJsLike | number | string
    pensionSystem?: $Enums.PensionSystem
    pensionRate?: Decimal | DecimalJsLike | number | string
    healthRate?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    area?: $Enums.EmployeeArea
    obraId?: number | null
    notes?: string | null
    absenceSundayPenalty?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    attendances?: AttendanceRecordUncheckedCreateNestedManyWithoutEmployeeInput
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutEmployeeInput
    accumulationPayment?: EmployeeAccumulationPaymentUncheckedCreateNestedOneWithoutEmployeeInput
  }

  export type EmployeeUpdateInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    documentType?: NullableEnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    bankType?: EnumBankTypeFieldUpdateOperationsInput | $Enums.BankType
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cci?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dailyHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pensionSystem?: EnumPensionSystemFieldUpdateOperationsInput | $Enums.PensionSystem
    pensionRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    healthRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    area?: EnumEmployeeAreaFieldUpdateOperationsInput | $Enums.EmployeeArea
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    absenceSundayPenalty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    obra?: ObraUpdateOneWithoutEmployeesNestedInput
    attendances?: AttendanceRecordUpdateManyWithoutEmployeeNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutEmployeeNestedInput
    accumulationPayment?: EmployeeAccumulationPaymentUpdateOneWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    documentType?: NullableEnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    bankType?: EnumBankTypeFieldUpdateOperationsInput | $Enums.BankType
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cci?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dailyHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pensionSystem?: EnumPensionSystemFieldUpdateOperationsInput | $Enums.PensionSystem
    pensionRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    healthRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    area?: EnumEmployeeAreaFieldUpdateOperationsInput | $Enums.EmployeeArea
    obraId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    absenceSundayPenalty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: AttendanceRecordUncheckedUpdateManyWithoutEmployeeNestedInput
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    accumulationPayment?: EmployeeAccumulationPaymentUncheckedUpdateOneWithoutEmployeeNestedInput
  }

  export type EmployeeCreateManyInput = {
    id?: number
    code?: string | null
    firstName: string
    lastName: string
    documentType?: $Enums.DocumentType | null
    documentNumber?: string | null
    position?: string | null
    phone?: string | null
    email?: string | null
    bankType?: $Enums.BankType
    accountNumber?: string | null
    cci?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    baseSalary?: Decimal | DecimalJsLike | number | string
    dailyHours?: Decimal | DecimalJsLike | number | string
    pensionSystem?: $Enums.PensionSystem
    pensionRate?: Decimal | DecimalJsLike | number | string
    healthRate?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    area?: $Enums.EmployeeArea
    obraId?: number | null
    notes?: string | null
    absenceSundayPenalty?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeUpdateManyMutationInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    documentType?: NullableEnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    bankType?: EnumBankTypeFieldUpdateOperationsInput | $Enums.BankType
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cci?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dailyHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pensionSystem?: EnumPensionSystemFieldUpdateOperationsInput | $Enums.PensionSystem
    pensionRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    healthRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    area?: EnumEmployeeAreaFieldUpdateOperationsInput | $Enums.EmployeeArea
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    absenceSundayPenalty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    documentType?: NullableEnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    bankType?: EnumBankTypeFieldUpdateOperationsInput | $Enums.BankType
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cci?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dailyHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pensionSystem?: EnumPensionSystemFieldUpdateOperationsInput | $Enums.PensionSystem
    pensionRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    healthRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    area?: EnumEmployeeAreaFieldUpdateOperationsInput | $Enums.EmployeeArea
    obraId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    absenceSundayPenalty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeAccumulationPaymentCreateInput = {
    paid?: boolean
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutAccumulationPaymentInput
  }

  export type EmployeeAccumulationPaymentUncheckedCreateInput = {
    employeeId: number
    paid?: boolean
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeAccumulationPaymentUpdateInput = {
    paid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutAccumulationPaymentNestedInput
  }

  export type EmployeeAccumulationPaymentUncheckedUpdateInput = {
    employeeId?: IntFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeAccumulationPaymentCreateManyInput = {
    employeeId: number
    paid?: boolean
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeAccumulationPaymentUpdateManyMutationInput = {
    paid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeAccumulationPaymentUncheckedUpdateManyInput = {
    employeeId?: IntFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceRecordCreateInput = {
    date: Date | string
    status?: $Enums.AttendanceStatus
    minutesLate?: number | null
    permissionHours?: Decimal | DecimalJsLike | number | string | null
    extraHours?: Decimal | DecimalJsLike | number | string | null
    permissionPaid?: boolean | null
    holidayWorked?: boolean
    holidayCount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutAttendancesInput
  }

  export type AttendanceRecordUncheckedCreateInput = {
    id?: number
    employeeId: number
    date: Date | string
    status?: $Enums.AttendanceStatus
    minutesLate?: number | null
    permissionHours?: Decimal | DecimalJsLike | number | string | null
    extraHours?: Decimal | DecimalJsLike | number | string | null
    permissionPaid?: boolean | null
    holidayWorked?: boolean
    holidayCount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceRecordUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    minutesLate?: NullableIntFieldUpdateOperationsInput | number | null
    permissionHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    extraHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    permissionPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    holidayWorked?: BoolFieldUpdateOperationsInput | boolean
    holidayCount?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutAttendancesNestedInput
  }

  export type AttendanceRecordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    minutesLate?: NullableIntFieldUpdateOperationsInput | number | null
    permissionHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    extraHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    permissionPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    holidayWorked?: BoolFieldUpdateOperationsInput | boolean
    holidayCount?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceRecordCreateManyInput = {
    id?: number
    employeeId: number
    date: Date | string
    status?: $Enums.AttendanceStatus
    minutesLate?: number | null
    permissionHours?: Decimal | DecimalJsLike | number | string | null
    extraHours?: Decimal | DecimalJsLike | number | string | null
    permissionPaid?: boolean | null
    holidayWorked?: boolean
    holidayCount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceRecordUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    minutesLate?: NullableIntFieldUpdateOperationsInput | number | null
    permissionHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    extraHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    permissionPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    holidayWorked?: BoolFieldUpdateOperationsInput | boolean
    holidayCount?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceRecordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    minutesLate?: NullableIntFieldUpdateOperationsInput | number | null
    permissionHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    extraHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    permissionPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    holidayWorked?: BoolFieldUpdateOperationsInput | boolean
    holidayCount?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollPeriodCreateInput = {
    month: number
    year: number
    startDate: Date | string
    endDate: Date | string
    workingDays: number
    status?: $Enums.PayrollPeriodStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    obra?: ObraCreateNestedOneWithoutPayrollPeriodsInput
    entries?: PayrollEntryCreateNestedManyWithoutPeriodInput
  }

  export type PayrollPeriodUncheckedCreateInput = {
    id?: number
    obraId?: number | null
    month: number
    year: number
    startDate: Date | string
    endDate: Date | string
    workingDays: number
    status?: $Enums.PayrollPeriodStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    entries?: PayrollEntryUncheckedCreateNestedManyWithoutPeriodInput
  }

  export type PayrollPeriodUpdateInput = {
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    workingDays?: IntFieldUpdateOperationsInput | number
    status?: EnumPayrollPeriodStatusFieldUpdateOperationsInput | $Enums.PayrollPeriodStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    obra?: ObraUpdateOneWithoutPayrollPeriodsNestedInput
    entries?: PayrollEntryUpdateManyWithoutPeriodNestedInput
  }

  export type PayrollPeriodUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    obraId?: NullableIntFieldUpdateOperationsInput | number | null
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    workingDays?: IntFieldUpdateOperationsInput | number
    status?: EnumPayrollPeriodStatusFieldUpdateOperationsInput | $Enums.PayrollPeriodStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entries?: PayrollEntryUncheckedUpdateManyWithoutPeriodNestedInput
  }

  export type PayrollPeriodCreateManyInput = {
    id?: number
    obraId?: number | null
    month: number
    year: number
    startDate: Date | string
    endDate: Date | string
    workingDays: number
    status?: $Enums.PayrollPeriodStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollPeriodUpdateManyMutationInput = {
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    workingDays?: IntFieldUpdateOperationsInput | number
    status?: EnumPayrollPeriodStatusFieldUpdateOperationsInput | $Enums.PayrollPeriodStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollPeriodUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    obraId?: NullableIntFieldUpdateOperationsInput | number | null
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    workingDays?: IntFieldUpdateOperationsInput | number
    status?: EnumPayrollPeriodStatusFieldUpdateOperationsInput | $Enums.PayrollPeriodStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollEntryCreateInput = {
    baseSalary: Decimal | DecimalJsLike | number | string
    dailyRate: Decimal | DecimalJsLike | number | string
    hourlyRate: Decimal | DecimalJsLike | number | string
    workedDays?: number
    absenceDays?: number
    tardinessMinutes?: number
    permissionHours?: Decimal | DecimalJsLike | number | string
    overtimeHours?: Decimal | DecimalJsLike | number | string
    bonusesTotal?: Decimal | DecimalJsLike | number | string
    deductionsTotal?: Decimal | DecimalJsLike | number | string
    pensionAmount?: Decimal | DecimalJsLike | number | string
    healthAmount?: Decimal | DecimalJsLike | number | string
    grossEarnings?: Decimal | DecimalJsLike | number | string
    netPay?: Decimal | DecimalJsLike | number | string
    permissionDays?: number
    holidayDays?: number
    holidayBonus?: Decimal | DecimalJsLike | number | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    period: PayrollPeriodCreateNestedOneWithoutEntriesInput
    employee: EmployeeCreateNestedOneWithoutPayrollEntriesInput
    adjustments?: PayrollAdjustmentCreateNestedManyWithoutEntryInput
  }

  export type PayrollEntryUncheckedCreateInput = {
    id?: number
    periodId: number
    employeeId: number
    baseSalary: Decimal | DecimalJsLike | number | string
    dailyRate: Decimal | DecimalJsLike | number | string
    hourlyRate: Decimal | DecimalJsLike | number | string
    workedDays?: number
    absenceDays?: number
    tardinessMinutes?: number
    permissionHours?: Decimal | DecimalJsLike | number | string
    overtimeHours?: Decimal | DecimalJsLike | number | string
    bonusesTotal?: Decimal | DecimalJsLike | number | string
    deductionsTotal?: Decimal | DecimalJsLike | number | string
    pensionAmount?: Decimal | DecimalJsLike | number | string
    healthAmount?: Decimal | DecimalJsLike | number | string
    grossEarnings?: Decimal | DecimalJsLike | number | string
    netPay?: Decimal | DecimalJsLike | number | string
    permissionDays?: number
    holidayDays?: number
    holidayBonus?: Decimal | DecimalJsLike | number | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    adjustments?: PayrollAdjustmentUncheckedCreateNestedManyWithoutEntryInput
  }

  export type PayrollEntryUpdateInput = {
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dailyRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hourlyRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    workedDays?: IntFieldUpdateOperationsInput | number
    absenceDays?: IntFieldUpdateOperationsInput | number
    tardinessMinutes?: IntFieldUpdateOperationsInput | number
    permissionHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusesTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductionsTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pensionAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    healthAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossEarnings?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    permissionDays?: IntFieldUpdateOperationsInput | number
    holidayDays?: IntFieldUpdateOperationsInput | number
    holidayBonus?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    period?: PayrollPeriodUpdateOneRequiredWithoutEntriesNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutPayrollEntriesNestedInput
    adjustments?: PayrollAdjustmentUpdateManyWithoutEntryNestedInput
  }

  export type PayrollEntryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    periodId?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dailyRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hourlyRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    workedDays?: IntFieldUpdateOperationsInput | number
    absenceDays?: IntFieldUpdateOperationsInput | number
    tardinessMinutes?: IntFieldUpdateOperationsInput | number
    permissionHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusesTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductionsTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pensionAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    healthAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossEarnings?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    permissionDays?: IntFieldUpdateOperationsInput | number
    holidayDays?: IntFieldUpdateOperationsInput | number
    holidayBonus?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adjustments?: PayrollAdjustmentUncheckedUpdateManyWithoutEntryNestedInput
  }

  export type PayrollEntryCreateManyInput = {
    id?: number
    periodId: number
    employeeId: number
    baseSalary: Decimal | DecimalJsLike | number | string
    dailyRate: Decimal | DecimalJsLike | number | string
    hourlyRate: Decimal | DecimalJsLike | number | string
    workedDays?: number
    absenceDays?: number
    tardinessMinutes?: number
    permissionHours?: Decimal | DecimalJsLike | number | string
    overtimeHours?: Decimal | DecimalJsLike | number | string
    bonusesTotal?: Decimal | DecimalJsLike | number | string
    deductionsTotal?: Decimal | DecimalJsLike | number | string
    pensionAmount?: Decimal | DecimalJsLike | number | string
    healthAmount?: Decimal | DecimalJsLike | number | string
    grossEarnings?: Decimal | DecimalJsLike | number | string
    netPay?: Decimal | DecimalJsLike | number | string
    permissionDays?: number
    holidayDays?: number
    holidayBonus?: Decimal | DecimalJsLike | number | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollEntryUpdateManyMutationInput = {
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dailyRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hourlyRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    workedDays?: IntFieldUpdateOperationsInput | number
    absenceDays?: IntFieldUpdateOperationsInput | number
    tardinessMinutes?: IntFieldUpdateOperationsInput | number
    permissionHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusesTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductionsTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pensionAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    healthAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossEarnings?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    permissionDays?: IntFieldUpdateOperationsInput | number
    holidayDays?: IntFieldUpdateOperationsInput | number
    holidayBonus?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollEntryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    periodId?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dailyRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hourlyRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    workedDays?: IntFieldUpdateOperationsInput | number
    absenceDays?: IntFieldUpdateOperationsInput | number
    tardinessMinutes?: IntFieldUpdateOperationsInput | number
    permissionHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusesTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductionsTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pensionAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    healthAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossEarnings?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    permissionDays?: IntFieldUpdateOperationsInput | number
    holidayDays?: IntFieldUpdateOperationsInput | number
    holidayBonus?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollAdjustmentCreateInput = {
    type: $Enums.PayrollAdjustmentType
    concept: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    entry: PayrollEntryCreateNestedOneWithoutAdjustmentsInput
  }

  export type PayrollAdjustmentUncheckedCreateInput = {
    id?: number
    entryId: number
    type: $Enums.PayrollAdjustmentType
    concept: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollAdjustmentUpdateInput = {
    type?: EnumPayrollAdjustmentTypeFieldUpdateOperationsInput | $Enums.PayrollAdjustmentType
    concept?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entry?: PayrollEntryUpdateOneRequiredWithoutAdjustmentsNestedInput
  }

  export type PayrollAdjustmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    entryId?: IntFieldUpdateOperationsInput | number
    type?: EnumPayrollAdjustmentTypeFieldUpdateOperationsInput | $Enums.PayrollAdjustmentType
    concept?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollAdjustmentCreateManyInput = {
    id?: number
    entryId: number
    type: $Enums.PayrollAdjustmentType
    concept: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollAdjustmentUpdateManyMutationInput = {
    type?: EnumPayrollAdjustmentTypeFieldUpdateOperationsInput | $Enums.PayrollAdjustmentType
    concept?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollAdjustmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    entryId?: IntFieldUpdateOperationsInput | number
    type?: EnumPayrollAdjustmentTypeFieldUpdateOperationsInput | $Enums.PayrollAdjustmentType
    concept?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    loansGiven?: PartnerLoanCreateNestedManyWithoutGiverInput
    loansReceived?: PartnerLoanCreateNestedManyWithoutReceiverInput
  }

  export type PartnerUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    loansGiven?: PartnerLoanUncheckedCreateNestedManyWithoutGiverInput
    loansReceived?: PartnerLoanUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type PartnerUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loansGiven?: PartnerLoanUpdateManyWithoutGiverNestedInput
    loansReceived?: PartnerLoanUpdateManyWithoutReceiverNestedInput
  }

  export type PartnerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loansGiven?: PartnerLoanUncheckedUpdateManyWithoutGiverNestedInput
    loansReceived?: PartnerLoanUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type PartnerCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PartnerUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerLoanCreateInput = {
    date: Date | string
    amount: Decimal | DecimalJsLike | number | string
    note?: string | null
    status?: $Enums.PartnerLoanStatus
    financeRefs?: NullableJsonNullValueInput | InputJsonValue
    closeDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    giver: PartnerCreateNestedOneWithoutLoansGivenInput
    receiver: PartnerCreateNestedOneWithoutLoansReceivedInput
  }

  export type PartnerLoanUncheckedCreateInput = {
    id?: number
    date: Date | string
    giverId: number
    receiverId: number
    amount: Decimal | DecimalJsLike | number | string
    note?: string | null
    status?: $Enums.PartnerLoanStatus
    financeRefs?: NullableJsonNullValueInput | InputJsonValue
    closeDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PartnerLoanUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPartnerLoanStatusFieldUpdateOperationsInput | $Enums.PartnerLoanStatus
    financeRefs?: NullableJsonNullValueInput | InputJsonValue
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    giver?: PartnerUpdateOneRequiredWithoutLoansGivenNestedInput
    receiver?: PartnerUpdateOneRequiredWithoutLoansReceivedNestedInput
  }

  export type PartnerLoanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    giverId?: IntFieldUpdateOperationsInput | number
    receiverId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPartnerLoanStatusFieldUpdateOperationsInput | $Enums.PartnerLoanStatus
    financeRefs?: NullableJsonNullValueInput | InputJsonValue
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerLoanCreateManyInput = {
    id?: number
    date: Date | string
    giverId: number
    receiverId: number
    amount: Decimal | DecimalJsLike | number | string
    note?: string | null
    status?: $Enums.PartnerLoanStatus
    financeRefs?: NullableJsonNullValueInput | InputJsonValue
    closeDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PartnerLoanUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPartnerLoanStatusFieldUpdateOperationsInput | $Enums.PartnerLoanStatus
    financeRefs?: NullableJsonNullValueInput | InputJsonValue
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerLoanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    giverId?: IntFieldUpdateOperationsInput | number
    receiverId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPartnerLoanStatusFieldUpdateOperationsInput | $Enums.PartnerLoanStatus
    financeRefs?: NullableJsonNullValueInput | InputJsonValue
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodIngredientCreateInput = {
    name: string
    category?: string | null
    unit?: string | null
    defaultWastePct?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    costs?: FoodIngredientCostCreateNestedManyWithoutIngredientInput
    items?: FoodRecipeItemCreateNestedManyWithoutIngredientInput
  }

  export type FoodIngredientUncheckedCreateInput = {
    id?: number
    name: string
    category?: string | null
    unit?: string | null
    defaultWastePct?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    costs?: FoodIngredientCostUncheckedCreateNestedManyWithoutIngredientInput
    items?: FoodRecipeItemUncheckedCreateNestedManyWithoutIngredientInput
  }

  export type FoodIngredientUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWastePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    costs?: FoodIngredientCostUpdateManyWithoutIngredientNestedInput
    items?: FoodRecipeItemUpdateManyWithoutIngredientNestedInput
  }

  export type FoodIngredientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWastePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    costs?: FoodIngredientCostUncheckedUpdateManyWithoutIngredientNestedInput
    items?: FoodRecipeItemUncheckedUpdateManyWithoutIngredientNestedInput
  }

  export type FoodIngredientCreateManyInput = {
    id?: number
    name: string
    category?: string | null
    unit?: string | null
    defaultWastePct?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoodIngredientUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWastePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodIngredientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWastePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodIngredientCostCreateInput = {
    unitCost: Decimal | DecimalJsLike | number | string
    effectiveDate?: Date | string | null
    source?: string | null
    createdAt?: Date | string
    ingredient: FoodIngredientCreateNestedOneWithoutCostsInput
  }

  export type FoodIngredientCostUncheckedCreateInput = {
    id?: number
    ingredientId: number
    unitCost: Decimal | DecimalJsLike | number | string
    effectiveDate?: Date | string | null
    source?: string | null
    createdAt?: Date | string
  }

  export type FoodIngredientCostUpdateInput = {
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ingredient?: FoodIngredientUpdateOneRequiredWithoutCostsNestedInput
  }

  export type FoodIngredientCostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ingredientId?: IntFieldUpdateOperationsInput | number
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodIngredientCostCreateManyInput = {
    id?: number
    ingredientId: number
    unitCost: Decimal | DecimalJsLike | number | string
    effectiveDate?: Date | string | null
    source?: string | null
    createdAt?: Date | string
  }

  export type FoodIngredientCostUpdateManyMutationInput = {
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodIngredientCostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ingredientId?: IntFieldUpdateOperationsInput | number
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodRecipeCreateInput = {
    name: string
    code?: string | null
    mealType?: $Enums.FoodMealType
    yield?: Decimal | DecimalJsLike | number | string
    yieldUnit?: string | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prepMinutes?: Decimal | DecimalJsLike | number | string | null
    dailyBlocks?: number | null
    items?: FoodRecipeItemCreateNestedManyWithoutRecipeInput
    childItems?: FoodRecipeItemCreateNestedManyWithoutChildRecipeInput
    extraCosts?: FoodRecipeCostCreateNestedManyWithoutRecipeInput
    mealPlanEntries?: FoodMealPlanEntryCreateNestedManyWithoutRecipeInput
  }

  export type FoodRecipeUncheckedCreateInput = {
    id?: number
    name: string
    code?: string | null
    mealType?: $Enums.FoodMealType
    yield?: Decimal | DecimalJsLike | number | string
    yieldUnit?: string | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prepMinutes?: Decimal | DecimalJsLike | number | string | null
    dailyBlocks?: number | null
    items?: FoodRecipeItemUncheckedCreateNestedManyWithoutRecipeInput
    childItems?: FoodRecipeItemUncheckedCreateNestedManyWithoutChildRecipeInput
    extraCosts?: FoodRecipeCostUncheckedCreateNestedManyWithoutRecipeInput
    mealPlanEntries?: FoodMealPlanEntryUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type FoodRecipeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    mealType?: EnumFoodMealTypeFieldUpdateOperationsInput | $Enums.FoodMealType
    yield?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    yieldUnit?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepMinutes?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dailyBlocks?: NullableIntFieldUpdateOperationsInput | number | null
    items?: FoodRecipeItemUpdateManyWithoutRecipeNestedInput
    childItems?: FoodRecipeItemUpdateManyWithoutChildRecipeNestedInput
    extraCosts?: FoodRecipeCostUpdateManyWithoutRecipeNestedInput
    mealPlanEntries?: FoodMealPlanEntryUpdateManyWithoutRecipeNestedInput
  }

  export type FoodRecipeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    mealType?: EnumFoodMealTypeFieldUpdateOperationsInput | $Enums.FoodMealType
    yield?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    yieldUnit?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepMinutes?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dailyBlocks?: NullableIntFieldUpdateOperationsInput | number | null
    items?: FoodRecipeItemUncheckedUpdateManyWithoutRecipeNestedInput
    childItems?: FoodRecipeItemUncheckedUpdateManyWithoutChildRecipeNestedInput
    extraCosts?: FoodRecipeCostUncheckedUpdateManyWithoutRecipeNestedInput
    mealPlanEntries?: FoodMealPlanEntryUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type FoodRecipeCreateManyInput = {
    id?: number
    name: string
    code?: string | null
    mealType?: $Enums.FoodMealType
    yield?: Decimal | DecimalJsLike | number | string
    yieldUnit?: string | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prepMinutes?: Decimal | DecimalJsLike | number | string | null
    dailyBlocks?: number | null
  }

  export type FoodRecipeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    mealType?: EnumFoodMealTypeFieldUpdateOperationsInput | $Enums.FoodMealType
    yield?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    yieldUnit?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepMinutes?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dailyBlocks?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FoodRecipeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    mealType?: EnumFoodMealTypeFieldUpdateOperationsInput | $Enums.FoodMealType
    yield?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    yieldUnit?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepMinutes?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dailyBlocks?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FoodRecipeItemCreateInput = {
    quantity?: Decimal | DecimalJsLike | number | string
    unit?: string | null
    wastePct?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    recipe: FoodRecipeCreateNestedOneWithoutItemsInput
    ingredient?: FoodIngredientCreateNestedOneWithoutItemsInput
    childRecipe?: FoodRecipeCreateNestedOneWithoutChildItemsInput
  }

  export type FoodRecipeItemUncheckedCreateInput = {
    id?: number
    recipeId: number
    ingredientId?: number | null
    childRecipeId?: number | null
    quantity?: Decimal | DecimalJsLike | number | string
    unit?: string | null
    wastePct?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type FoodRecipeItemUpdateInput = {
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    wastePct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipe?: FoodRecipeUpdateOneRequiredWithoutItemsNestedInput
    ingredient?: FoodIngredientUpdateOneWithoutItemsNestedInput
    childRecipe?: FoodRecipeUpdateOneWithoutChildItemsNestedInput
  }

  export type FoodRecipeItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    recipeId?: IntFieldUpdateOperationsInput | number
    ingredientId?: NullableIntFieldUpdateOperationsInput | number | null
    childRecipeId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    wastePct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodRecipeItemCreateManyInput = {
    id?: number
    recipeId: number
    ingredientId?: number | null
    childRecipeId?: number | null
    quantity?: Decimal | DecimalJsLike | number | string
    unit?: string | null
    wastePct?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type FoodRecipeItemUpdateManyMutationInput = {
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    wastePct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodRecipeItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    recipeId?: IntFieldUpdateOperationsInput | number
    ingredientId?: NullableIntFieldUpdateOperationsInput | number | null
    childRecipeId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    wastePct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodRecipeCostCreateInput = {
    label: string
    amount?: Decimal | DecimalJsLike | number | string
    costType?: $Enums.FoodCostLineType
    period?: $Enums.FoodCostPeriod
    periodRations?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    recipe: FoodRecipeCreateNestedOneWithoutExtraCostsInput
  }

  export type FoodRecipeCostUncheckedCreateInput = {
    id?: number
    recipeId: number
    label: string
    amount?: Decimal | DecimalJsLike | number | string
    costType?: $Enums.FoodCostLineType
    period?: $Enums.FoodCostPeriod
    periodRations?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type FoodRecipeCostUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costType?: EnumFoodCostLineTypeFieldUpdateOperationsInput | $Enums.FoodCostLineType
    period?: EnumFoodCostPeriodFieldUpdateOperationsInput | $Enums.FoodCostPeriod
    periodRations?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipe?: FoodRecipeUpdateOneRequiredWithoutExtraCostsNestedInput
  }

  export type FoodRecipeCostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    recipeId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costType?: EnumFoodCostLineTypeFieldUpdateOperationsInput | $Enums.FoodCostLineType
    period?: EnumFoodCostPeriodFieldUpdateOperationsInput | $Enums.FoodCostPeriod
    periodRations?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodRecipeCostCreateManyInput = {
    id?: number
    recipeId: number
    label: string
    amount?: Decimal | DecimalJsLike | number | string
    costType?: $Enums.FoodCostLineType
    period?: $Enums.FoodCostPeriod
    periodRations?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type FoodRecipeCostUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costType?: EnumFoodCostLineTypeFieldUpdateOperationsInput | $Enums.FoodCostLineType
    period?: EnumFoodCostPeriodFieldUpdateOperationsInput | $Enums.FoodCostPeriod
    periodRations?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodRecipeCostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    recipeId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costType?: EnumFoodCostLineTypeFieldUpdateOperationsInput | $Enums.FoodCostLineType
    period?: EnumFoodCostPeriodFieldUpdateOperationsInput | $Enums.FoodCostPeriod
    periodRations?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodCostPoolCreateInput = {
    name: string
    type?: $Enums.FoodCostPoolType
    amount?: Decimal | DecimalJsLike | number | string
    period?: $Enums.FoodCostPeriod
    periodRations?: Decimal | DecimalJsLike | number | string | null
    appliesTo?: $Enums.FoodMealType | null
    notes?: string | null
    allocationMethod?: $Enums.PoolAllocationMethod
    dailyBlocks?: number | null
    timeMinutes?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoodCostPoolUncheckedCreateInput = {
    id?: number
    name: string
    type?: $Enums.FoodCostPoolType
    amount?: Decimal | DecimalJsLike | number | string
    period?: $Enums.FoodCostPeriod
    periodRations?: Decimal | DecimalJsLike | number | string | null
    appliesTo?: $Enums.FoodMealType | null
    notes?: string | null
    allocationMethod?: $Enums.PoolAllocationMethod
    dailyBlocks?: number | null
    timeMinutes?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoodCostPoolUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFoodCostPoolTypeFieldUpdateOperationsInput | $Enums.FoodCostPoolType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    period?: EnumFoodCostPeriodFieldUpdateOperationsInput | $Enums.FoodCostPeriod
    periodRations?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    appliesTo?: NullableEnumFoodMealTypeFieldUpdateOperationsInput | $Enums.FoodMealType | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    allocationMethod?: EnumPoolAllocationMethodFieldUpdateOperationsInput | $Enums.PoolAllocationMethod
    dailyBlocks?: NullableIntFieldUpdateOperationsInput | number | null
    timeMinutes?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodCostPoolUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFoodCostPoolTypeFieldUpdateOperationsInput | $Enums.FoodCostPoolType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    period?: EnumFoodCostPeriodFieldUpdateOperationsInput | $Enums.FoodCostPeriod
    periodRations?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    appliesTo?: NullableEnumFoodMealTypeFieldUpdateOperationsInput | $Enums.FoodMealType | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    allocationMethod?: EnumPoolAllocationMethodFieldUpdateOperationsInput | $Enums.PoolAllocationMethod
    dailyBlocks?: NullableIntFieldUpdateOperationsInput | number | null
    timeMinutes?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodCostPoolCreateManyInput = {
    id?: number
    name: string
    type?: $Enums.FoodCostPoolType
    amount?: Decimal | DecimalJsLike | number | string
    period?: $Enums.FoodCostPeriod
    periodRations?: Decimal | DecimalJsLike | number | string | null
    appliesTo?: $Enums.FoodMealType | null
    notes?: string | null
    allocationMethod?: $Enums.PoolAllocationMethod
    dailyBlocks?: number | null
    timeMinutes?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoodCostPoolUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFoodCostPoolTypeFieldUpdateOperationsInput | $Enums.FoodCostPoolType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    period?: EnumFoodCostPeriodFieldUpdateOperationsInput | $Enums.FoodCostPeriod
    periodRations?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    appliesTo?: NullableEnumFoodMealTypeFieldUpdateOperationsInput | $Enums.FoodMealType | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    allocationMethod?: EnumPoolAllocationMethodFieldUpdateOperationsInput | $Enums.PoolAllocationMethod
    dailyBlocks?: NullableIntFieldUpdateOperationsInput | number | null
    timeMinutes?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodCostPoolUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFoodCostPoolTypeFieldUpdateOperationsInput | $Enums.FoodCostPoolType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    period?: EnumFoodCostPeriodFieldUpdateOperationsInput | $Enums.FoodCostPeriod
    periodRations?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    appliesTo?: NullableEnumFoodMealTypeFieldUpdateOperationsInput | $Enums.FoodMealType | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    allocationMethod?: EnumPoolAllocationMethodFieldUpdateOperationsInput | $Enums.PoolAllocationMethod
    dailyBlocks?: NullableIntFieldUpdateOperationsInput | number | null
    timeMinutes?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodMealPlanCreateInput = {
    name: string
    weekStart?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    entries?: FoodMealPlanEntryCreateNestedManyWithoutPlanInput
  }

  export type FoodMealPlanUncheckedCreateInput = {
    id?: number
    name: string
    weekStart?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    entries?: FoodMealPlanEntryUncheckedCreateNestedManyWithoutPlanInput
  }

  export type FoodMealPlanUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    weekStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entries?: FoodMealPlanEntryUpdateManyWithoutPlanNestedInput
  }

  export type FoodMealPlanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    weekStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entries?: FoodMealPlanEntryUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type FoodMealPlanCreateManyInput = {
    id?: number
    name: string
    weekStart?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoodMealPlanUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    weekStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodMealPlanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    weekStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodMealPlanEntryCreateInput = {
    dayIndex: number
    mealType: $Enums.FoodMealType
    servings?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: FoodMealPlanCreateNestedOneWithoutEntriesInput
    recipe: FoodRecipeCreateNestedOneWithoutMealPlanEntriesInput
  }

  export type FoodMealPlanEntryUncheckedCreateInput = {
    id?: number
    planId: number
    dayIndex: number
    mealType: $Enums.FoodMealType
    recipeId: number
    servings?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoodMealPlanEntryUpdateInput = {
    dayIndex?: IntFieldUpdateOperationsInput | number
    mealType?: EnumFoodMealTypeFieldUpdateOperationsInput | $Enums.FoodMealType
    servings?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: FoodMealPlanUpdateOneRequiredWithoutEntriesNestedInput
    recipe?: FoodRecipeUpdateOneRequiredWithoutMealPlanEntriesNestedInput
  }

  export type FoodMealPlanEntryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    planId?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    mealType?: EnumFoodMealTypeFieldUpdateOperationsInput | $Enums.FoodMealType
    recipeId?: IntFieldUpdateOperationsInput | number
    servings?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodMealPlanEntryCreateManyInput = {
    id?: number
    planId: number
    dayIndex: number
    mealType: $Enums.FoodMealType
    recipeId: number
    servings?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoodMealPlanEntryUpdateManyMutationInput = {
    dayIndex?: IntFieldUpdateOperationsInput | number
    mealType?: EnumFoodMealTypeFieldUpdateOperationsInput | $Enums.FoodMealType
    servings?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodMealPlanEntryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    planId?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    mealType?: EnumFoodMealTypeFieldUpdateOperationsInput | $Enums.FoodMealType
    recipeId?: IntFieldUpdateOperationsInput | number
    servings?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotationProcessCreateInput = {
    name: string
    code?: string | null
    status?: $Enums.QuotationProcessStatus
    baseCurrency?: string
    targetCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    targetMarginPct?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    baselineFile?: QuotationAttachmentCreateNestedOneWithoutProcessInput
    baselines?: QuotationBaselineItemCreateNestedManyWithoutProcessInput
    quotations?: QuotationCreateNestedManyWithoutProcessInput
    purchaseOrders?: PurchaseOrderLogCreateNestedManyWithoutProcessInput
    deliveryLogs?: PurchaseDeliveryLogCreateNestedManyWithoutProcessInput
  }

  export type QuotationProcessUncheckedCreateInput = {
    id?: number
    name: string
    code?: string | null
    status?: $Enums.QuotationProcessStatus
    baseCurrency?: string
    targetCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    targetMarginPct?: Decimal | DecimalJsLike | number | string | null
    baselineFileId?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    baselines?: QuotationBaselineItemUncheckedCreateNestedManyWithoutProcessInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutProcessInput
    purchaseOrders?: PurchaseOrderLogUncheckedCreateNestedManyWithoutProcessInput
    deliveryLogs?: PurchaseDeliveryLogUncheckedCreateNestedManyWithoutProcessInput
  }

  export type QuotationProcessUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuotationProcessStatusFieldUpdateOperationsInput | $Enums.QuotationProcessStatus
    baseCurrency?: StringFieldUpdateOperationsInput | string
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    targetMarginPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baselineFile?: QuotationAttachmentUpdateOneWithoutProcessNestedInput
    baselines?: QuotationBaselineItemUpdateManyWithoutProcessNestedInput
    quotations?: QuotationUpdateManyWithoutProcessNestedInput
    purchaseOrders?: PurchaseOrderLogUpdateManyWithoutProcessNestedInput
    deliveryLogs?: PurchaseDeliveryLogUpdateManyWithoutProcessNestedInput
  }

  export type QuotationProcessUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuotationProcessStatusFieldUpdateOperationsInput | $Enums.QuotationProcessStatus
    baseCurrency?: StringFieldUpdateOperationsInput | string
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    targetMarginPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baselineFileId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baselines?: QuotationBaselineItemUncheckedUpdateManyWithoutProcessNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutProcessNestedInput
    purchaseOrders?: PurchaseOrderLogUncheckedUpdateManyWithoutProcessNestedInput
    deliveryLogs?: PurchaseDeliveryLogUncheckedUpdateManyWithoutProcessNestedInput
  }

  export type QuotationProcessCreateManyInput = {
    id?: number
    name: string
    code?: string | null
    status?: $Enums.QuotationProcessStatus
    baseCurrency?: string
    targetCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    targetMarginPct?: Decimal | DecimalJsLike | number | string | null
    baselineFileId?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuotationProcessUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuotationProcessStatusFieldUpdateOperationsInput | $Enums.QuotationProcessStatus
    baseCurrency?: StringFieldUpdateOperationsInput | string
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    targetMarginPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotationProcessUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuotationProcessStatusFieldUpdateOperationsInput | $Enums.QuotationProcessStatus
    baseCurrency?: StringFieldUpdateOperationsInput | string
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    targetMarginPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baselineFileId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotationBaselineItemCreateInput = {
    sheetName?: string | null
    sectionPath?: string | null
    itemCode?: string | null
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    process: QuotationProcessCreateNestedOneWithoutBaselinesInput
    material?: MaterialCreateNestedOneWithoutBaseQuotesInput
    quoteItems?: QuotationItemCreateNestedManyWithoutBaselineItemInput
    orderLines?: PurchaseOrderLineCreateNestedManyWithoutBaselineInput
    deliveryItems?: PurchaseDeliveryItemCreateNestedManyWithoutBaselineInput
  }

  export type QuotationBaselineItemUncheckedCreateInput = {
    id?: number
    processId: number
    materialId?: number | null
    sheetName?: string | null
    sectionPath?: string | null
    itemCode?: string | null
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    quoteItems?: QuotationItemUncheckedCreateNestedManyWithoutBaselineItemInput
    orderLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutBaselineInput
    deliveryItems?: PurchaseDeliveryItemUncheckedCreateNestedManyWithoutBaselineInput
  }

  export type QuotationBaselineItemUpdateInput = {
    sheetName?: NullableStringFieldUpdateOperationsInput | string | null
    sectionPath?: NullableStringFieldUpdateOperationsInput | string | null
    itemCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    process?: QuotationProcessUpdateOneRequiredWithoutBaselinesNestedInput
    material?: MaterialUpdateOneWithoutBaseQuotesNestedInput
    quoteItems?: QuotationItemUpdateManyWithoutBaselineItemNestedInput
    orderLines?: PurchaseOrderLineUpdateManyWithoutBaselineNestedInput
    deliveryItems?: PurchaseDeliveryItemUpdateManyWithoutBaselineNestedInput
  }

  export type QuotationBaselineItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    processId?: IntFieldUpdateOperationsInput | number
    materialId?: NullableIntFieldUpdateOperationsInput | number | null
    sheetName?: NullableStringFieldUpdateOperationsInput | string | null
    sectionPath?: NullableStringFieldUpdateOperationsInput | string | null
    itemCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quoteItems?: QuotationItemUncheckedUpdateManyWithoutBaselineItemNestedInput
    orderLines?: PurchaseOrderLineUncheckedUpdateManyWithoutBaselineNestedInput
    deliveryItems?: PurchaseDeliveryItemUncheckedUpdateManyWithoutBaselineNestedInput
  }

  export type QuotationBaselineItemCreateManyInput = {
    id?: number
    processId: number
    materialId?: number | null
    sheetName?: string | null
    sectionPath?: string | null
    itemCode?: string | null
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuotationBaselineItemUpdateManyMutationInput = {
    sheetName?: NullableStringFieldUpdateOperationsInput | string | null
    sectionPath?: NullableStringFieldUpdateOperationsInput | string | null
    itemCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotationBaselineItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    processId?: IntFieldUpdateOperationsInput | number
    materialId?: NullableIntFieldUpdateOperationsInput | number | null
    sheetName?: NullableStringFieldUpdateOperationsInput | string | null
    sectionPath?: NullableStringFieldUpdateOperationsInput | string | null
    itemCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotationCreateInput = {
    supplierName?: string | null
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    submittedAt?: Date | string | null
    status?: $Enums.QuotationStatus
    totalAmount?: Decimal | DecimalJsLike | number | string | null
    totalAmountPen?: Decimal | DecimalJsLike | number | string | null
    qualityScore?: number | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    process: QuotationProcessCreateNestedOneWithoutQuotationsInput
    proveedor?: ProveedorCreateNestedOneWithoutQuotationsInput
    items?: QuotationItemCreateNestedManyWithoutQuotationInput
    attachments?: QuotationAttachmentCreateNestedManyWithoutQuotationInput
    purchaseOrders?: PurchaseOrderLogCreateNestedManyWithoutQuotationInput
  }

  export type QuotationUncheckedCreateInput = {
    id?: number
    processId: number
    proveedorId?: number | null
    supplierName?: string | null
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    submittedAt?: Date | string | null
    status?: $Enums.QuotationStatus
    totalAmount?: Decimal | DecimalJsLike | number | string | null
    totalAmountPen?: Decimal | DecimalJsLike | number | string | null
    qualityScore?: number | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: QuotationItemUncheckedCreateNestedManyWithoutQuotationInput
    attachments?: QuotationAttachmentUncheckedCreateNestedManyWithoutQuotationInput
    purchaseOrders?: PurchaseOrderLogUncheckedCreateNestedManyWithoutQuotationInput
  }

  export type QuotationUpdateInput = {
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    totalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAmountPen?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    process?: QuotationProcessUpdateOneRequiredWithoutQuotationsNestedInput
    proveedor?: ProveedorUpdateOneWithoutQuotationsNestedInput
    items?: QuotationItemUpdateManyWithoutQuotationNestedInput
    attachments?: QuotationAttachmentUpdateManyWithoutQuotationNestedInput
    purchaseOrders?: PurchaseOrderLogUpdateManyWithoutQuotationNestedInput
  }

  export type QuotationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    processId?: IntFieldUpdateOperationsInput | number
    proveedorId?: NullableIntFieldUpdateOperationsInput | number | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    totalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAmountPen?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: QuotationItemUncheckedUpdateManyWithoutQuotationNestedInput
    attachments?: QuotationAttachmentUncheckedUpdateManyWithoutQuotationNestedInput
    purchaseOrders?: PurchaseOrderLogUncheckedUpdateManyWithoutQuotationNestedInput
  }

  export type QuotationCreateManyInput = {
    id?: number
    processId: number
    proveedorId?: number | null
    supplierName?: string | null
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    submittedAt?: Date | string | null
    status?: $Enums.QuotationStatus
    totalAmount?: Decimal | DecimalJsLike | number | string | null
    totalAmountPen?: Decimal | DecimalJsLike | number | string | null
    qualityScore?: number | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuotationUpdateManyMutationInput = {
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    totalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAmountPen?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    processId?: IntFieldUpdateOperationsInput | number
    proveedorId?: NullableIntFieldUpdateOperationsInput | number | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    totalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAmountPen?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotationItemCreateInput = {
    sourceRow?: number | null
    itemCode?: string | null
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    normalizedPrice?: Decimal | DecimalJsLike | number | string | null
    matchScore?: number | null
    extraAttributes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    quotation: QuotationCreateNestedOneWithoutItemsInput
    baselineItem?: QuotationBaselineItemCreateNestedOneWithoutQuoteItemsInput
    material?: MaterialCreateNestedOneWithoutQuoteItemsInput
  }

  export type QuotationItemUncheckedCreateInput = {
    id?: number
    quotationId: number
    baselineItemId?: number | null
    materialId?: number | null
    sourceRow?: number | null
    itemCode?: string | null
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    normalizedPrice?: Decimal | DecimalJsLike | number | string | null
    matchScore?: number | null
    extraAttributes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuotationItemUpdateInput = {
    sourceRow?: NullableIntFieldUpdateOperationsInput | number | null
    itemCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    normalizedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matchScore?: NullableFloatFieldUpdateOperationsInput | number | null
    extraAttributes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotation?: QuotationUpdateOneRequiredWithoutItemsNestedInput
    baselineItem?: QuotationBaselineItemUpdateOneWithoutQuoteItemsNestedInput
    material?: MaterialUpdateOneWithoutQuoteItemsNestedInput
  }

  export type QuotationItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    quotationId?: IntFieldUpdateOperationsInput | number
    baselineItemId?: NullableIntFieldUpdateOperationsInput | number | null
    materialId?: NullableIntFieldUpdateOperationsInput | number | null
    sourceRow?: NullableIntFieldUpdateOperationsInput | number | null
    itemCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    normalizedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matchScore?: NullableFloatFieldUpdateOperationsInput | number | null
    extraAttributes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotationItemCreateManyInput = {
    id?: number
    quotationId: number
    baselineItemId?: number | null
    materialId?: number | null
    sourceRow?: number | null
    itemCode?: string | null
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    normalizedPrice?: Decimal | DecimalJsLike | number | string | null
    matchScore?: number | null
    extraAttributes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuotationItemUpdateManyMutationInput = {
    sourceRow?: NullableIntFieldUpdateOperationsInput | number | null
    itemCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    normalizedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matchScore?: NullableFloatFieldUpdateOperationsInput | number | null
    extraAttributes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotationItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    quotationId?: IntFieldUpdateOperationsInput | number
    baselineItemId?: NullableIntFieldUpdateOperationsInput | number | null
    materialId?: NullableIntFieldUpdateOperationsInput | number | null
    sourceRow?: NullableIntFieldUpdateOperationsInput | number | null
    itemCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    normalizedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matchScore?: NullableFloatFieldUpdateOperationsInput | number | null
    extraAttributes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotationAttachmentCreateInput = {
    type?: $Enums.QuotationAttachmentType
    originalName: string
    storagePath: string
    mimeType?: string | null
    sizeBytes?: number | null
    checksum?: string | null
    parsed?: boolean
    parsedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    quotation?: QuotationCreateNestedOneWithoutAttachmentsInput
    process?: QuotationProcessCreateNestedOneWithoutBaselineFileInput
  }

  export type QuotationAttachmentUncheckedCreateInput = {
    id?: number
    quotationId?: number | null
    type?: $Enums.QuotationAttachmentType
    originalName: string
    storagePath: string
    mimeType?: string | null
    sizeBytes?: number | null
    checksum?: string | null
    parsed?: boolean
    parsedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    process?: QuotationProcessUncheckedCreateNestedOneWithoutBaselineFileInput
  }

  export type QuotationAttachmentUpdateInput = {
    type?: EnumQuotationAttachmentTypeFieldUpdateOperationsInput | $Enums.QuotationAttachmentType
    originalName?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    parsed?: BoolFieldUpdateOperationsInput | boolean
    parsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotation?: QuotationUpdateOneWithoutAttachmentsNestedInput
    process?: QuotationProcessUpdateOneWithoutBaselineFileNestedInput
  }

  export type QuotationAttachmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    quotationId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumQuotationAttachmentTypeFieldUpdateOperationsInput | $Enums.QuotationAttachmentType
    originalName?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    parsed?: BoolFieldUpdateOperationsInput | boolean
    parsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    process?: QuotationProcessUncheckedUpdateOneWithoutBaselineFileNestedInput
  }

  export type QuotationAttachmentCreateManyInput = {
    id?: number
    quotationId?: number | null
    type?: $Enums.QuotationAttachmentType
    originalName: string
    storagePath: string
    mimeType?: string | null
    sizeBytes?: number | null
    checksum?: string | null
    parsed?: boolean
    parsedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuotationAttachmentUpdateManyMutationInput = {
    type?: EnumQuotationAttachmentTypeFieldUpdateOperationsInput | $Enums.QuotationAttachmentType
    originalName?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    parsed?: BoolFieldUpdateOperationsInput | boolean
    parsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotationAttachmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    quotationId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumQuotationAttachmentTypeFieldUpdateOperationsInput | $Enums.QuotationAttachmentType
    originalName?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    parsed?: BoolFieldUpdateOperationsInput | boolean
    parsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderLogCreateInput = {
    supplierId?: number | null
    supplierName: string
    orderNumber: string
    sequence?: number
    issueDate?: Date | string
    currency?: string
    subtotal?: Decimal | DecimalJsLike | number | string | null
    discount?: Decimal | DecimalJsLike | number | string | null
    netSubtotal?: Decimal | DecimalJsLike | number | string | null
    igv?: Decimal | DecimalJsLike | number | string | null
    total?: Decimal | DecimalJsLike | number | string | null
    totalsJson?: NullableJsonNullValueInput | InputJsonValue
    itemsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    process: QuotationProcessCreateNestedOneWithoutPurchaseOrdersInput
    quotation?: QuotationCreateNestedOneWithoutPurchaseOrdersInput
    lines?: PurchaseOrderLineCreateNestedManyWithoutOrderInput
    deliveries?: PurchaseDeliveryLogCreateNestedManyWithoutOrderInput
  }

  export type PurchaseOrderLogUncheckedCreateInput = {
    id?: number
    processId: number
    quotationId?: number | null
    supplierId?: number | null
    supplierName: string
    orderNumber: string
    sequence?: number
    issueDate?: Date | string
    currency?: string
    subtotal?: Decimal | DecimalJsLike | number | string | null
    discount?: Decimal | DecimalJsLike | number | string | null
    netSubtotal?: Decimal | DecimalJsLike | number | string | null
    igv?: Decimal | DecimalJsLike | number | string | null
    total?: Decimal | DecimalJsLike | number | string | null
    totalsJson?: NullableJsonNullValueInput | InputJsonValue
    itemsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutOrderInput
    deliveries?: PurchaseDeliveryLogUncheckedCreateNestedManyWithoutOrderInput
  }

  export type PurchaseOrderLogUpdateInput = {
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    supplierName?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netSubtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    igv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalsJson?: NullableJsonNullValueInput | InputJsonValue
    itemsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    process?: QuotationProcessUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    quotation?: QuotationUpdateOneWithoutPurchaseOrdersNestedInput
    lines?: PurchaseOrderLineUpdateManyWithoutOrderNestedInput
    deliveries?: PurchaseDeliveryLogUpdateManyWithoutOrderNestedInput
  }

  export type PurchaseOrderLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    processId?: IntFieldUpdateOperationsInput | number
    quotationId?: NullableIntFieldUpdateOperationsInput | number | null
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    supplierName?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netSubtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    igv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalsJson?: NullableJsonNullValueInput | InputJsonValue
    itemsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: PurchaseOrderLineUncheckedUpdateManyWithoutOrderNestedInput
    deliveries?: PurchaseDeliveryLogUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type PurchaseOrderLogCreateManyInput = {
    id?: number
    processId: number
    quotationId?: number | null
    supplierId?: number | null
    supplierName: string
    orderNumber: string
    sequence?: number
    issueDate?: Date | string
    currency?: string
    subtotal?: Decimal | DecimalJsLike | number | string | null
    discount?: Decimal | DecimalJsLike | number | string | null
    netSubtotal?: Decimal | DecimalJsLike | number | string | null
    igv?: Decimal | DecimalJsLike | number | string | null
    total?: Decimal | DecimalJsLike | number | string | null
    totalsJson?: NullableJsonNullValueInput | InputJsonValue
    itemsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderLogUpdateManyMutationInput = {
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    supplierName?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netSubtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    igv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalsJson?: NullableJsonNullValueInput | InputJsonValue
    itemsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    processId?: IntFieldUpdateOperationsInput | number
    quotationId?: NullableIntFieldUpdateOperationsInput | number | null
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    supplierName?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netSubtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    igv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalsJson?: NullableJsonNullValueInput | InputJsonValue
    itemsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderLineCreateInput = {
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    order: PurchaseOrderLogCreateNestedOneWithoutLinesInput
    baseline?: QuotationBaselineItemCreateNestedOneWithoutOrderLinesInput
    deliveries?: PurchaseDeliveryItemCreateNestedManyWithoutOrderLineInput
  }

  export type PurchaseOrderLineUncheckedCreateInput = {
    id?: number
    orderId: number
    baselineId?: number | null
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: PurchaseDeliveryItemUncheckedCreateNestedManyWithoutOrderLineInput
  }

  export type PurchaseOrderLineUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: PurchaseOrderLogUpdateOneRequiredWithoutLinesNestedInput
    baseline?: QuotationBaselineItemUpdateOneWithoutOrderLinesNestedInput
    deliveries?: PurchaseDeliveryItemUpdateManyWithoutOrderLineNestedInput
  }

  export type PurchaseOrderLineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    baselineId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: PurchaseDeliveryItemUncheckedUpdateManyWithoutOrderLineNestedInput
  }

  export type PurchaseOrderLineCreateManyInput = {
    id?: number
    orderId: number
    baselineId?: number | null
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderLineUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderLineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    baselineId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseDeliveryLogCreateInput = {
    supplierName?: string | null
    guideNumber?: string | null
    date?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    process: QuotationProcessCreateNestedOneWithoutDeliveryLogsInput
    order?: PurchaseOrderLogCreateNestedOneWithoutDeliveriesInput
    proveedor?: ProveedorCreateNestedOneWithoutDeliveriesInput
    items?: PurchaseDeliveryItemCreateNestedManyWithoutDeliveryInput
  }

  export type PurchaseDeliveryLogUncheckedCreateInput = {
    id?: number
    processId: number
    orderId?: number | null
    proveedorId?: number | null
    supplierName?: string | null
    guideNumber?: string | null
    date?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseDeliveryItemUncheckedCreateNestedManyWithoutDeliveryInput
  }

  export type PurchaseDeliveryLogUpdateInput = {
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    guideNumber?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    process?: QuotationProcessUpdateOneRequiredWithoutDeliveryLogsNestedInput
    order?: PurchaseOrderLogUpdateOneWithoutDeliveriesNestedInput
    proveedor?: ProveedorUpdateOneWithoutDeliveriesNestedInput
    items?: PurchaseDeliveryItemUpdateManyWithoutDeliveryNestedInput
  }

  export type PurchaseDeliveryLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    processId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    proveedorId?: NullableIntFieldUpdateOperationsInput | number | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    guideNumber?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseDeliveryItemUncheckedUpdateManyWithoutDeliveryNestedInput
  }

  export type PurchaseDeliveryLogCreateManyInput = {
    id?: number
    processId: number
    orderId?: number | null
    proveedorId?: number | null
    supplierName?: string | null
    guideNumber?: string | null
    date?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseDeliveryLogUpdateManyMutationInput = {
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    guideNumber?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseDeliveryLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    processId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    proveedorId?: NullableIntFieldUpdateOperationsInput | number | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    guideNumber?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseDeliveryItemCreateInput = {
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    delivery: PurchaseDeliveryLogCreateNestedOneWithoutItemsInput
    orderLine?: PurchaseOrderLineCreateNestedOneWithoutDeliveriesInput
    baseline?: QuotationBaselineItemCreateNestedOneWithoutDeliveryItemsInput
  }

  export type PurchaseDeliveryItemUncheckedCreateInput = {
    id?: number
    deliveryId: number
    orderLineId?: number | null
    baselineId?: number | null
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseDeliveryItemUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    delivery?: PurchaseDeliveryLogUpdateOneRequiredWithoutItemsNestedInput
    orderLine?: PurchaseOrderLineUpdateOneWithoutDeliveriesNestedInput
    baseline?: QuotationBaselineItemUpdateOneWithoutDeliveryItemsNestedInput
  }

  export type PurchaseDeliveryItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    deliveryId?: IntFieldUpdateOperationsInput | number
    orderLineId?: NullableIntFieldUpdateOperationsInput | number | null
    baselineId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseDeliveryItemCreateManyInput = {
    id?: number
    deliveryId: number
    orderLineId?: number | null
    baselineId?: number | null
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseDeliveryItemUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseDeliveryItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    deliveryId?: IntFieldUpdateOperationsInput | number
    orderLineId?: NullableIntFieldUpdateOperationsInput | number | null
    baselineId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type FrenteListRelationFilter = {
    every?: FrenteWhereInput
    some?: FrenteWhereInput
    none?: FrenteWhereInput
  }

  export type MoveListRelationFilter = {
    every?: MoveWhereInput
    some?: MoveWhereInput
    none?: MoveWhereInput
  }

  export type IncomeListRelationFilter = {
    every?: IncomeWhereInput
    some?: IncomeWhereInput
    none?: IncomeWhereInput
  }

  export type ExpenseListRelationFilter = {
    every?: ExpenseWhereInput
    some?: ExpenseWhereInput
    none?: ExpenseWhereInput
  }

  export type EmployeeListRelationFilter = {
    every?: EmployeeWhereInput
    some?: EmployeeWhereInput
    none?: EmployeeWhereInput
  }

  export type PayrollPeriodListRelationFilter = {
    every?: PayrollPeriodWhereInput
    some?: PayrollPeriodWhereInput
    none?: PayrollPeriodWhereInput
  }

  export type DailyCashRenditionListRelationFilter = {
    every?: DailyCashRenditionWhereInput
    some?: DailyCashRenditionWhereInput
    none?: DailyCashRenditionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type FrenteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MoveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IncomeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpenseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PayrollPeriodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DailyCashRenditionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ObraCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
  }

  export type ObraAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ObraMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
  }

  export type ObraMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
  }

  export type ObraSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumAssetStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetStatus | EnumAssetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssetStatus[]
    notIn?: $Enums.AssetStatus[]
    not?: NestedEnumAssetStatusFilter<$PrismaModel> | $Enums.AssetStatus
  }

  export type MaterialGroupNullableScalarRelationFilter = {
    is?: MaterialGroupWhereInput | null
    isNot?: MaterialGroupWhereInput | null
  }

  export type QuotationBaselineItemListRelationFilter = {
    every?: QuotationBaselineItemWhereInput
    some?: QuotationBaselineItemWhereInput
    none?: QuotationBaselineItemWhereInput
  }

  export type QuotationItemListRelationFilter = {
    every?: QuotationItemWhereInput
    some?: QuotationItemWhereInput
    none?: QuotationItemWhereInput
  }

  export type QuotationBaselineItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuotationItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaterialCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    groupId?: SortOrder
    minStock?: SortOrder
    reorderQuantity?: SortOrder
    allowNegative?: SortOrder
    isCompanyAsset?: SortOrder
    assetStatus?: SortOrder
    assetResponsible?: SortOrder
  }

  export type MaterialAvgOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    minStock?: SortOrder
    reorderQuantity?: SortOrder
  }

  export type MaterialMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    groupId?: SortOrder
    minStock?: SortOrder
    reorderQuantity?: SortOrder
    allowNegative?: SortOrder
    isCompanyAsset?: SortOrder
    assetStatus?: SortOrder
    assetResponsible?: SortOrder
  }

  export type MaterialMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    groupId?: SortOrder
    minStock?: SortOrder
    reorderQuantity?: SortOrder
    allowNegative?: SortOrder
    isCompanyAsset?: SortOrder
    assetStatus?: SortOrder
    assetResponsible?: SortOrder
  }

  export type MaterialSumOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    minStock?: SortOrder
    reorderQuantity?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumAssetStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetStatus | EnumAssetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssetStatus[]
    notIn?: $Enums.AssetStatus[]
    not?: NestedEnumAssetStatusWithAggregatesFilter<$PrismaModel> | $Enums.AssetStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssetStatusFilter<$PrismaModel>
    _max?: NestedEnumAssetStatusFilter<$PrismaModel>
  }

  export type QuotationListRelationFilter = {
    every?: QuotationWhereInput
    some?: QuotationWhereInput
    none?: QuotationWhereInput
  }

  export type PurchaseDeliveryLogListRelationFilter = {
    every?: PurchaseDeliveryLogWhereInput
    some?: PurchaseDeliveryLogWhereInput
    none?: PurchaseDeliveryLogWhereInput
  }

  export type QuotationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseDeliveryLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProveedorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ruc?: SortOrder
    phone?: SortOrder
  }

  export type ProveedorAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProveedorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ruc?: SortOrder
    phone?: SortOrder
  }

  export type ProveedorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ruc?: SortOrder
    phone?: SortOrder
  }

  export type ProveedorSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ObraScalarRelationFilter = {
    is?: ObraWhereInput
    isNot?: ObraWhereInput
  }

  export type FrenteCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    obraId?: SortOrder
  }

  export type FrenteAvgOrderByAggregateInput = {
    id?: SortOrder
    obraId?: SortOrder
  }

  export type FrenteMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    obraId?: SortOrder
  }

  export type FrenteMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    obraId?: SortOrder
  }

  export type FrenteSumOrderByAggregateInput = {
    id?: SortOrder
    obraId?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type MaterialGroupListRelationFilter = {
    every?: MaterialGroupWhereInput
    some?: MaterialGroupWhereInput
    none?: MaterialGroupWhereInput
  }

  export type MaterialListRelationFilter = {
    every?: MaterialWhereInput
    some?: MaterialWhereInput
    none?: MaterialWhereInput
  }

  export type MaterialGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaterialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaterialGroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterialGroupAvgOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
  }

  export type MaterialGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterialGroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterialGroupSumOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumMoveTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MoveType | EnumMoveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MoveType[]
    notIn?: $Enums.MoveType[]
    not?: NestedEnumMoveTypeFilter<$PrismaModel> | $Enums.MoveType
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumDocTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DocType | EnumDocTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DocType[] | null
    notIn?: $Enums.DocType[] | null
    not?: NestedEnumDocTypeNullableFilter<$PrismaModel> | $Enums.DocType | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type EnumAssetStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetStatus | EnumAssetStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.AssetStatus[] | null
    notIn?: $Enums.AssetStatus[] | null
    not?: NestedEnumAssetStatusNullableFilter<$PrismaModel> | $Enums.AssetStatus | null
  }

  export type FrenteNullableScalarRelationFilter = {
    is?: FrenteWhereInput | null
    isNot?: FrenteWhereInput | null
  }

  export type MaterialScalarRelationFilter = {
    is?: MaterialWhereInput
    isNot?: MaterialWhereInput
  }

  export type ProveedorNullableScalarRelationFilter = {
    is?: ProveedorWhereInput | null
    isNot?: ProveedorWhereInput | null
  }

  export type ExpenseNullableScalarRelationFilter = {
    is?: ExpenseWhereInput | null
    isNot?: ExpenseWhereInput | null
  }

  export type MoveCountOrderByAggregateInput = {
    id?: SortOrder
    obraId?: SortOrder
    frenteId?: SortOrder
    materialId?: SortOrder
    proveedorId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
    date?: SortOrder
    note?: SortOrder
    docType?: SortOrder
    docSerie?: SortOrder
    docNumero?: SortOrder
    igvRate?: SortOrder
    isTaxable?: SortOrder
    responsible?: SortOrder
    assetStatus?: SortOrder
  }

  export type MoveAvgOrderByAggregateInput = {
    id?: SortOrder
    obraId?: SortOrder
    frenteId?: SortOrder
    materialId?: SortOrder
    proveedorId?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
    igvRate?: SortOrder
  }

  export type MoveMaxOrderByAggregateInput = {
    id?: SortOrder
    obraId?: SortOrder
    frenteId?: SortOrder
    materialId?: SortOrder
    proveedorId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
    date?: SortOrder
    note?: SortOrder
    docType?: SortOrder
    docSerie?: SortOrder
    docNumero?: SortOrder
    igvRate?: SortOrder
    isTaxable?: SortOrder
    responsible?: SortOrder
    assetStatus?: SortOrder
  }

  export type MoveMinOrderByAggregateInput = {
    id?: SortOrder
    obraId?: SortOrder
    frenteId?: SortOrder
    materialId?: SortOrder
    proveedorId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
    date?: SortOrder
    note?: SortOrder
    docType?: SortOrder
    docSerie?: SortOrder
    docNumero?: SortOrder
    igvRate?: SortOrder
    isTaxable?: SortOrder
    responsible?: SortOrder
    assetStatus?: SortOrder
  }

  export type MoveSumOrderByAggregateInput = {
    id?: SortOrder
    obraId?: SortOrder
    frenteId?: SortOrder
    materialId?: SortOrder
    proveedorId?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
    igvRate?: SortOrder
  }

  export type EnumMoveTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MoveType | EnumMoveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MoveType[]
    notIn?: $Enums.MoveType[]
    not?: NestedEnumMoveTypeWithAggregatesFilter<$PrismaModel> | $Enums.MoveType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMoveTypeFilter<$PrismaModel>
    _max?: NestedEnumMoveTypeFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumDocTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocType | EnumDocTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DocType[] | null
    notIn?: $Enums.DocType[] | null
    not?: NestedEnumDocTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.DocType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDocTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumDocTypeNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type EnumAssetStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetStatus | EnumAssetStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.AssetStatus[] | null
    notIn?: $Enums.AssetStatus[] | null
    not?: NestedEnumAssetStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.AssetStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAssetStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumAssetStatusNullableFilter<$PrismaModel>
  }

  export type EnumExpenseKindFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseKind | EnumExpenseKindFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseKind[]
    notIn?: $Enums.ExpenseKind[]
    not?: NestedEnumExpenseKindFilter<$PrismaModel> | $Enums.ExpenseKind
  }

  export type ExpenseCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    kind?: SortOrder
  }

  export type ExpenseCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ExpenseCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    kind?: SortOrder
  }

  export type ExpenseCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    kind?: SortOrder
  }

  export type ExpenseCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumExpenseKindWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseKind | EnumExpenseKindFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseKind[]
    notIn?: $Enums.ExpenseKind[]
    not?: NestedEnumExpenseKindWithAggregatesFilter<$PrismaModel> | $Enums.ExpenseKind
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExpenseKindFilter<$PrismaModel>
    _max?: NestedEnumExpenseKindFilter<$PrismaModel>
  }

  export type EnumDocTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocType | EnumDocTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocType[]
    notIn?: $Enums.DocType[]
    not?: NestedEnumDocTypeFilter<$PrismaModel> | $Enums.DocType
  }

  export type EnumIncomeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.IncomeStatus | EnumIncomeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IncomeStatus[]
    notIn?: $Enums.IncomeStatus[]
    not?: NestedEnumIncomeStatusFilter<$PrismaModel> | $Enums.IncomeStatus
  }

  export type IncomeCountOrderByAggregateInput = {
    id?: SortOrder
    obraId?: SortOrder
    frenteId?: SortOrder
    date?: SortOrder
    description?: SortOrder
    docType?: SortOrder
    docSerie?: SortOrder
    docNumero?: SortOrder
    status?: SortOrder
    igvRate?: SortOrder
    isTaxable?: SortOrder
    base?: SortOrder
    igv?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IncomeAvgOrderByAggregateInput = {
    id?: SortOrder
    obraId?: SortOrder
    frenteId?: SortOrder
    igvRate?: SortOrder
    base?: SortOrder
    igv?: SortOrder
    total?: SortOrder
  }

  export type IncomeMaxOrderByAggregateInput = {
    id?: SortOrder
    obraId?: SortOrder
    frenteId?: SortOrder
    date?: SortOrder
    description?: SortOrder
    docType?: SortOrder
    docSerie?: SortOrder
    docNumero?: SortOrder
    status?: SortOrder
    igvRate?: SortOrder
    isTaxable?: SortOrder
    base?: SortOrder
    igv?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IncomeMinOrderByAggregateInput = {
    id?: SortOrder
    obraId?: SortOrder
    frenteId?: SortOrder
    date?: SortOrder
    description?: SortOrder
    docType?: SortOrder
    docSerie?: SortOrder
    docNumero?: SortOrder
    status?: SortOrder
    igvRate?: SortOrder
    isTaxable?: SortOrder
    base?: SortOrder
    igv?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IncomeSumOrderByAggregateInput = {
    id?: SortOrder
    obraId?: SortOrder
    frenteId?: SortOrder
    igvRate?: SortOrder
    base?: SortOrder
    igv?: SortOrder
    total?: SortOrder
  }

  export type EnumDocTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocType | EnumDocTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocType[]
    notIn?: $Enums.DocType[]
    not?: NestedEnumDocTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocTypeFilter<$PrismaModel>
    _max?: NestedEnumDocTypeFilter<$PrismaModel>
  }

  export type EnumIncomeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncomeStatus | EnumIncomeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IncomeStatus[]
    notIn?: $Enums.IncomeStatus[]
    not?: NestedEnumIncomeStatusWithAggregatesFilter<$PrismaModel> | $Enums.IncomeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncomeStatusFilter<$PrismaModel>
    _max?: NestedEnumIncomeStatusFilter<$PrismaModel>
  }

  export type EnumExpenseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseType | EnumExpenseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseType[]
    notIn?: $Enums.ExpenseType[]
    not?: NestedEnumExpenseTypeFilter<$PrismaModel> | $Enums.ExpenseType
  }

  export type EnumVariableTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VariableType | EnumVariableTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VariableType[]
    notIn?: $Enums.VariableType[]
    not?: NestedEnumVariableTypeFilter<$PrismaModel> | $Enums.VariableType
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type MaterialNullableScalarRelationFilter = {
    is?: MaterialWhereInput | null
    isNot?: MaterialWhereInput | null
  }

  export type ExpenseCategoryNullableScalarRelationFilter = {
    is?: ExpenseCategoryWhereInput | null
    isNot?: ExpenseCategoryWhereInput | null
  }

  export type MoveNullableScalarRelationFilter = {
    is?: MoveWhereInput | null
    isNot?: MoveWhereInput | null
  }

  export type ExpenseCountOrderByAggregateInput = {
    id?: SortOrder
    obraId?: SortOrder
    frenteId?: SortOrder
    proveedorId?: SortOrder
    materialId?: SortOrder
    categoryId?: SortOrder
    moveId?: SortOrder
    docType?: SortOrder
    docSerie?: SortOrder
    docNumero?: SortOrder
    date?: SortOrder
    description?: SortOrder
    spentBy?: SortOrder
    type?: SortOrder
    variableType?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrder
    igvRate?: SortOrder
    isTaxable?: SortOrder
    base?: SortOrder
    igv?: SortOrder
    total?: SortOrder
    paymentMethod?: SortOrder
    paidAt?: SortOrder
    status?: SortOrder
    reminderIntervalDays?: SortOrder
    reminderNextDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseAvgOrderByAggregateInput = {
    id?: SortOrder
    obraId?: SortOrder
    frenteId?: SortOrder
    proveedorId?: SortOrder
    materialId?: SortOrder
    categoryId?: SortOrder
    moveId?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrder
    igvRate?: SortOrder
    base?: SortOrder
    igv?: SortOrder
    total?: SortOrder
    reminderIntervalDays?: SortOrder
  }

  export type ExpenseMaxOrderByAggregateInput = {
    id?: SortOrder
    obraId?: SortOrder
    frenteId?: SortOrder
    proveedorId?: SortOrder
    materialId?: SortOrder
    categoryId?: SortOrder
    moveId?: SortOrder
    docType?: SortOrder
    docSerie?: SortOrder
    docNumero?: SortOrder
    date?: SortOrder
    description?: SortOrder
    spentBy?: SortOrder
    type?: SortOrder
    variableType?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrder
    igvRate?: SortOrder
    isTaxable?: SortOrder
    base?: SortOrder
    igv?: SortOrder
    total?: SortOrder
    paymentMethod?: SortOrder
    paidAt?: SortOrder
    status?: SortOrder
    reminderIntervalDays?: SortOrder
    reminderNextDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseMinOrderByAggregateInput = {
    id?: SortOrder
    obraId?: SortOrder
    frenteId?: SortOrder
    proveedorId?: SortOrder
    materialId?: SortOrder
    categoryId?: SortOrder
    moveId?: SortOrder
    docType?: SortOrder
    docSerie?: SortOrder
    docNumero?: SortOrder
    date?: SortOrder
    description?: SortOrder
    spentBy?: SortOrder
    type?: SortOrder
    variableType?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrder
    igvRate?: SortOrder
    isTaxable?: SortOrder
    base?: SortOrder
    igv?: SortOrder
    total?: SortOrder
    paymentMethod?: SortOrder
    paidAt?: SortOrder
    status?: SortOrder
    reminderIntervalDays?: SortOrder
    reminderNextDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseSumOrderByAggregateInput = {
    id?: SortOrder
    obraId?: SortOrder
    frenteId?: SortOrder
    proveedorId?: SortOrder
    materialId?: SortOrder
    categoryId?: SortOrder
    moveId?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrder
    igvRate?: SortOrder
    base?: SortOrder
    igv?: SortOrder
    total?: SortOrder
    reminderIntervalDays?: SortOrder
  }

  export type EnumExpenseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseType | EnumExpenseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseType[]
    notIn?: $Enums.ExpenseType[]
    not?: NestedEnumExpenseTypeWithAggregatesFilter<$PrismaModel> | $Enums.ExpenseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExpenseTypeFilter<$PrismaModel>
    _max?: NestedEnumExpenseTypeFilter<$PrismaModel>
  }

  export type EnumVariableTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VariableType | EnumVariableTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VariableType[]
    notIn?: $Enums.VariableType[]
    not?: NestedEnumVariableTypeWithAggregatesFilter<$PrismaModel> | $Enums.VariableType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVariableTypeFilter<$PrismaModel>
    _max?: NestedEnumVariableTypeFilter<$PrismaModel>
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ObraNullableScalarRelationFilter = {
    is?: ObraWhereInput | null
    isNot?: ObraWhereInput | null
  }

  export type DailyCashExpenseListRelationFilter = {
    every?: DailyCashExpenseWhereInput
    some?: DailyCashExpenseWhereInput
    none?: DailyCashExpenseWhereInput
  }

  export type DailyCashExpenseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DailyCashRenditionCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    obraId?: SortOrder
    openingBalance?: SortOrder
    received?: SortOrder
    spent?: SortOrder
    personalContribution?: SortOrder
    balance?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyCashRenditionAvgOrderByAggregateInput = {
    id?: SortOrder
    obraId?: SortOrder
    openingBalance?: SortOrder
    received?: SortOrder
    spent?: SortOrder
    personalContribution?: SortOrder
    balance?: SortOrder
  }

  export type DailyCashRenditionMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    obraId?: SortOrder
    openingBalance?: SortOrder
    received?: SortOrder
    spent?: SortOrder
    personalContribution?: SortOrder
    balance?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyCashRenditionMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    obraId?: SortOrder
    openingBalance?: SortOrder
    received?: SortOrder
    spent?: SortOrder
    personalContribution?: SortOrder
    balance?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyCashRenditionSumOrderByAggregateInput = {
    id?: SortOrder
    obraId?: SortOrder
    openingBalance?: SortOrder
    received?: SortOrder
    spent?: SortOrder
    personalContribution?: SortOrder
    balance?: SortOrder
  }

  export type DailyCashRenditionScalarRelationFilter = {
    is?: DailyCashRenditionWhereInput
    isNot?: DailyCashRenditionWhereInput
  }

  export type DailyCashExpenseCountOrderByAggregateInput = {
    id?: SortOrder
    renditionId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    personalAmount?: SortOrder
    paidWithPersonal?: SortOrder
    createdAt?: SortOrder
  }

  export type DailyCashExpenseAvgOrderByAggregateInput = {
    id?: SortOrder
    renditionId?: SortOrder
    amount?: SortOrder
    personalAmount?: SortOrder
  }

  export type DailyCashExpenseMaxOrderByAggregateInput = {
    id?: SortOrder
    renditionId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    personalAmount?: SortOrder
    paidWithPersonal?: SortOrder
    createdAt?: SortOrder
  }

  export type DailyCashExpenseMinOrderByAggregateInput = {
    id?: SortOrder
    renditionId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    personalAmount?: SortOrder
    paidWithPersonal?: SortOrder
    createdAt?: SortOrder
  }

  export type DailyCashExpenseSumOrderByAggregateInput = {
    id?: SortOrder
    renditionId?: SortOrder
    amount?: SortOrder
    personalAmount?: SortOrder
  }

  export type AdminSettingCountOrderByAggregateInput = {
    id?: SortOrder
    deletePasswordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminSettingAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AdminSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    deletePasswordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminSettingMinOrderByAggregateInput = {
    id?: SortOrder
    deletePasswordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminSettingSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumDocumentTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DocumentType[] | null
    notIn?: $Enums.DocumentType[] | null
    not?: NestedEnumDocumentTypeNullableFilter<$PrismaModel> | $Enums.DocumentType | null
  }

  export type EnumBankTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BankType | EnumBankTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BankType[]
    notIn?: $Enums.BankType[]
    not?: NestedEnumBankTypeFilter<$PrismaModel> | $Enums.BankType
  }

  export type EnumPensionSystemFilter<$PrismaModel = never> = {
    equals?: $Enums.PensionSystem | EnumPensionSystemFieldRefInput<$PrismaModel>
    in?: $Enums.PensionSystem[]
    notIn?: $Enums.PensionSystem[]
    not?: NestedEnumPensionSystemFilter<$PrismaModel> | $Enums.PensionSystem
  }

  export type EnumEmployeeAreaFilter<$PrismaModel = never> = {
    equals?: $Enums.EmployeeArea | EnumEmployeeAreaFieldRefInput<$PrismaModel>
    in?: $Enums.EmployeeArea[]
    notIn?: $Enums.EmployeeArea[]
    not?: NestedEnumEmployeeAreaFilter<$PrismaModel> | $Enums.EmployeeArea
  }

  export type AttendanceRecordListRelationFilter = {
    every?: AttendanceRecordWhereInput
    some?: AttendanceRecordWhereInput
    none?: AttendanceRecordWhereInput
  }

  export type PayrollEntryListRelationFilter = {
    every?: PayrollEntryWhereInput
    some?: PayrollEntryWhereInput
    none?: PayrollEntryWhereInput
  }

  export type EmployeeAccumulationPaymentNullableScalarRelationFilter = {
    is?: EmployeeAccumulationPaymentWhereInput | null
    isNot?: EmployeeAccumulationPaymentWhereInput | null
  }

  export type AttendanceRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PayrollEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    documentType?: SortOrder
    documentNumber?: SortOrder
    position?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    bankType?: SortOrder
    accountNumber?: SortOrder
    cci?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    baseSalary?: SortOrder
    dailyHours?: SortOrder
    pensionSystem?: SortOrder
    pensionRate?: SortOrder
    healthRate?: SortOrder
    isActive?: SortOrder
    area?: SortOrder
    obraId?: SortOrder
    notes?: SortOrder
    absenceSundayPenalty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeAvgOrderByAggregateInput = {
    id?: SortOrder
    baseSalary?: SortOrder
    dailyHours?: SortOrder
    pensionRate?: SortOrder
    healthRate?: SortOrder
    obraId?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    documentType?: SortOrder
    documentNumber?: SortOrder
    position?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    bankType?: SortOrder
    accountNumber?: SortOrder
    cci?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    baseSalary?: SortOrder
    dailyHours?: SortOrder
    pensionSystem?: SortOrder
    pensionRate?: SortOrder
    healthRate?: SortOrder
    isActive?: SortOrder
    area?: SortOrder
    obraId?: SortOrder
    notes?: SortOrder
    absenceSundayPenalty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    documentType?: SortOrder
    documentNumber?: SortOrder
    position?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    bankType?: SortOrder
    accountNumber?: SortOrder
    cci?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    baseSalary?: SortOrder
    dailyHours?: SortOrder
    pensionSystem?: SortOrder
    pensionRate?: SortOrder
    healthRate?: SortOrder
    isActive?: SortOrder
    area?: SortOrder
    obraId?: SortOrder
    notes?: SortOrder
    absenceSundayPenalty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeSumOrderByAggregateInput = {
    id?: SortOrder
    baseSalary?: SortOrder
    dailyHours?: SortOrder
    pensionRate?: SortOrder
    healthRate?: SortOrder
    obraId?: SortOrder
  }

  export type EnumDocumentTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DocumentType[] | null
    notIn?: $Enums.DocumentType[] | null
    not?: NestedEnumDocumentTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeNullableFilter<$PrismaModel>
  }

  export type EnumBankTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BankType | EnumBankTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BankType[]
    notIn?: $Enums.BankType[]
    not?: NestedEnumBankTypeWithAggregatesFilter<$PrismaModel> | $Enums.BankType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBankTypeFilter<$PrismaModel>
    _max?: NestedEnumBankTypeFilter<$PrismaModel>
  }

  export type EnumPensionSystemWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PensionSystem | EnumPensionSystemFieldRefInput<$PrismaModel>
    in?: $Enums.PensionSystem[]
    notIn?: $Enums.PensionSystem[]
    not?: NestedEnumPensionSystemWithAggregatesFilter<$PrismaModel> | $Enums.PensionSystem
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPensionSystemFilter<$PrismaModel>
    _max?: NestedEnumPensionSystemFilter<$PrismaModel>
  }

  export type EnumEmployeeAreaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmployeeArea | EnumEmployeeAreaFieldRefInput<$PrismaModel>
    in?: $Enums.EmployeeArea[]
    notIn?: $Enums.EmployeeArea[]
    not?: NestedEnumEmployeeAreaWithAggregatesFilter<$PrismaModel> | $Enums.EmployeeArea
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmployeeAreaFilter<$PrismaModel>
    _max?: NestedEnumEmployeeAreaFilter<$PrismaModel>
  }

  export type EmployeeScalarRelationFilter = {
    is?: EmployeeWhereInput
    isNot?: EmployeeWhereInput
  }

  export type EmployeeAccumulationPaymentCountOrderByAggregateInput = {
    employeeId?: SortOrder
    paid?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeAccumulationPaymentAvgOrderByAggregateInput = {
    employeeId?: SortOrder
  }

  export type EmployeeAccumulationPaymentMaxOrderByAggregateInput = {
    employeeId?: SortOrder
    paid?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeAccumulationPaymentMinOrderByAggregateInput = {
    employeeId?: SortOrder
    paid?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeAccumulationPaymentSumOrderByAggregateInput = {
    employeeId?: SortOrder
  }

  export type EnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[]
    notIn?: $Enums.AttendanceStatus[]
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type AttendanceRecordEmployeeIdDateCompoundUniqueInput = {
    employeeId: number
    date: Date | string
  }

  export type AttendanceRecordCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    minutesLate?: SortOrder
    permissionHours?: SortOrder
    extraHours?: SortOrder
    permissionPaid?: SortOrder
    holidayWorked?: SortOrder
    holidayCount?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceRecordAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    minutesLate?: SortOrder
    permissionHours?: SortOrder
    extraHours?: SortOrder
    holidayCount?: SortOrder
  }

  export type AttendanceRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    minutesLate?: SortOrder
    permissionHours?: SortOrder
    extraHours?: SortOrder
    permissionPaid?: SortOrder
    holidayWorked?: SortOrder
    holidayCount?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceRecordMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    minutesLate?: SortOrder
    permissionHours?: SortOrder
    extraHours?: SortOrder
    permissionPaid?: SortOrder
    holidayWorked?: SortOrder
    holidayCount?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceRecordSumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    minutesLate?: SortOrder
    permissionHours?: SortOrder
    extraHours?: SortOrder
    holidayCount?: SortOrder
  }

  export type EnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[]
    notIn?: $Enums.AttendanceStatus[]
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type EnumPayrollPeriodStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PayrollPeriodStatus | EnumPayrollPeriodStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayrollPeriodStatus[]
    notIn?: $Enums.PayrollPeriodStatus[]
    not?: NestedEnumPayrollPeriodStatusFilter<$PrismaModel> | $Enums.PayrollPeriodStatus
  }

  export type PayrollPeriodYearMonthObraIdCompoundUniqueInput = {
    year: number
    month: number
    obraId: number
  }

  export type PayrollPeriodCountOrderByAggregateInput = {
    id?: SortOrder
    obraId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    workingDays?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollPeriodAvgOrderByAggregateInput = {
    id?: SortOrder
    obraId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    workingDays?: SortOrder
  }

  export type PayrollPeriodMaxOrderByAggregateInput = {
    id?: SortOrder
    obraId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    workingDays?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollPeriodMinOrderByAggregateInput = {
    id?: SortOrder
    obraId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    workingDays?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollPeriodSumOrderByAggregateInput = {
    id?: SortOrder
    obraId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    workingDays?: SortOrder
  }

  export type EnumPayrollPeriodStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayrollPeriodStatus | EnumPayrollPeriodStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayrollPeriodStatus[]
    notIn?: $Enums.PayrollPeriodStatus[]
    not?: NestedEnumPayrollPeriodStatusWithAggregatesFilter<$PrismaModel> | $Enums.PayrollPeriodStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayrollPeriodStatusFilter<$PrismaModel>
    _max?: NestedEnumPayrollPeriodStatusFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type PayrollPeriodScalarRelationFilter = {
    is?: PayrollPeriodWhereInput
    isNot?: PayrollPeriodWhereInput
  }

  export type PayrollAdjustmentListRelationFilter = {
    every?: PayrollAdjustmentWhereInput
    some?: PayrollAdjustmentWhereInput
    none?: PayrollAdjustmentWhereInput
  }

  export type PayrollAdjustmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PayrollEntryPeriodIdEmployeeIdCompoundUniqueInput = {
    periodId: number
    employeeId: number
  }

  export type PayrollEntryCountOrderByAggregateInput = {
    id?: SortOrder
    periodId?: SortOrder
    employeeId?: SortOrder
    baseSalary?: SortOrder
    dailyRate?: SortOrder
    hourlyRate?: SortOrder
    workedDays?: SortOrder
    absenceDays?: SortOrder
    tardinessMinutes?: SortOrder
    permissionHours?: SortOrder
    overtimeHours?: SortOrder
    bonusesTotal?: SortOrder
    deductionsTotal?: SortOrder
    pensionAmount?: SortOrder
    healthAmount?: SortOrder
    grossEarnings?: SortOrder
    netPay?: SortOrder
    permissionDays?: SortOrder
    holidayDays?: SortOrder
    holidayBonus?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollEntryAvgOrderByAggregateInput = {
    id?: SortOrder
    periodId?: SortOrder
    employeeId?: SortOrder
    baseSalary?: SortOrder
    dailyRate?: SortOrder
    hourlyRate?: SortOrder
    workedDays?: SortOrder
    absenceDays?: SortOrder
    tardinessMinutes?: SortOrder
    permissionHours?: SortOrder
    overtimeHours?: SortOrder
    bonusesTotal?: SortOrder
    deductionsTotal?: SortOrder
    pensionAmount?: SortOrder
    healthAmount?: SortOrder
    grossEarnings?: SortOrder
    netPay?: SortOrder
    permissionDays?: SortOrder
    holidayDays?: SortOrder
    holidayBonus?: SortOrder
  }

  export type PayrollEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    periodId?: SortOrder
    employeeId?: SortOrder
    baseSalary?: SortOrder
    dailyRate?: SortOrder
    hourlyRate?: SortOrder
    workedDays?: SortOrder
    absenceDays?: SortOrder
    tardinessMinutes?: SortOrder
    permissionHours?: SortOrder
    overtimeHours?: SortOrder
    bonusesTotal?: SortOrder
    deductionsTotal?: SortOrder
    pensionAmount?: SortOrder
    healthAmount?: SortOrder
    grossEarnings?: SortOrder
    netPay?: SortOrder
    permissionDays?: SortOrder
    holidayDays?: SortOrder
    holidayBonus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollEntryMinOrderByAggregateInput = {
    id?: SortOrder
    periodId?: SortOrder
    employeeId?: SortOrder
    baseSalary?: SortOrder
    dailyRate?: SortOrder
    hourlyRate?: SortOrder
    workedDays?: SortOrder
    absenceDays?: SortOrder
    tardinessMinutes?: SortOrder
    permissionHours?: SortOrder
    overtimeHours?: SortOrder
    bonusesTotal?: SortOrder
    deductionsTotal?: SortOrder
    pensionAmount?: SortOrder
    healthAmount?: SortOrder
    grossEarnings?: SortOrder
    netPay?: SortOrder
    permissionDays?: SortOrder
    holidayDays?: SortOrder
    holidayBonus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollEntrySumOrderByAggregateInput = {
    id?: SortOrder
    periodId?: SortOrder
    employeeId?: SortOrder
    baseSalary?: SortOrder
    dailyRate?: SortOrder
    hourlyRate?: SortOrder
    workedDays?: SortOrder
    absenceDays?: SortOrder
    tardinessMinutes?: SortOrder
    permissionHours?: SortOrder
    overtimeHours?: SortOrder
    bonusesTotal?: SortOrder
    deductionsTotal?: SortOrder
    pensionAmount?: SortOrder
    healthAmount?: SortOrder
    grossEarnings?: SortOrder
    netPay?: SortOrder
    permissionDays?: SortOrder
    holidayDays?: SortOrder
    holidayBonus?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumPayrollAdjustmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PayrollAdjustmentType | EnumPayrollAdjustmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PayrollAdjustmentType[]
    notIn?: $Enums.PayrollAdjustmentType[]
    not?: NestedEnumPayrollAdjustmentTypeFilter<$PrismaModel> | $Enums.PayrollAdjustmentType
  }

  export type PayrollEntryScalarRelationFilter = {
    is?: PayrollEntryWhereInput
    isNot?: PayrollEntryWhereInput
  }

  export type PayrollAdjustmentCountOrderByAggregateInput = {
    id?: SortOrder
    entryId?: SortOrder
    type?: SortOrder
    concept?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollAdjustmentAvgOrderByAggregateInput = {
    id?: SortOrder
    entryId?: SortOrder
    amount?: SortOrder
  }

  export type PayrollAdjustmentMaxOrderByAggregateInput = {
    id?: SortOrder
    entryId?: SortOrder
    type?: SortOrder
    concept?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollAdjustmentMinOrderByAggregateInput = {
    id?: SortOrder
    entryId?: SortOrder
    type?: SortOrder
    concept?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollAdjustmentSumOrderByAggregateInput = {
    id?: SortOrder
    entryId?: SortOrder
    amount?: SortOrder
  }

  export type EnumPayrollAdjustmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayrollAdjustmentType | EnumPayrollAdjustmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PayrollAdjustmentType[]
    notIn?: $Enums.PayrollAdjustmentType[]
    not?: NestedEnumPayrollAdjustmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.PayrollAdjustmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayrollAdjustmentTypeFilter<$PrismaModel>
    _max?: NestedEnumPayrollAdjustmentTypeFilter<$PrismaModel>
  }

  export type PartnerLoanListRelationFilter = {
    every?: PartnerLoanWhereInput
    some?: PartnerLoanWhereInput
    none?: PartnerLoanWhereInput
  }

  export type PartnerLoanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PartnerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PartnerAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PartnerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PartnerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PartnerSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumPartnerLoanStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PartnerLoanStatus | EnumPartnerLoanStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PartnerLoanStatus[]
    notIn?: $Enums.PartnerLoanStatus[]
    not?: NestedEnumPartnerLoanStatusFilter<$PrismaModel> | $Enums.PartnerLoanStatus
  }

  export type PartnerScalarRelationFilter = {
    is?: PartnerWhereInput
    isNot?: PartnerWhereInput
  }

  export type PartnerLoanCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    giverId?: SortOrder
    receiverId?: SortOrder
    amount?: SortOrder
    note?: SortOrder
    status?: SortOrder
    financeRefs?: SortOrder
    closeDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PartnerLoanAvgOrderByAggregateInput = {
    id?: SortOrder
    giverId?: SortOrder
    receiverId?: SortOrder
    amount?: SortOrder
  }

  export type PartnerLoanMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    giverId?: SortOrder
    receiverId?: SortOrder
    amount?: SortOrder
    note?: SortOrder
    status?: SortOrder
    closeDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PartnerLoanMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    giverId?: SortOrder
    receiverId?: SortOrder
    amount?: SortOrder
    note?: SortOrder
    status?: SortOrder
    closeDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PartnerLoanSumOrderByAggregateInput = {
    id?: SortOrder
    giverId?: SortOrder
    receiverId?: SortOrder
    amount?: SortOrder
  }

  export type EnumPartnerLoanStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PartnerLoanStatus | EnumPartnerLoanStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PartnerLoanStatus[]
    notIn?: $Enums.PartnerLoanStatus[]
    not?: NestedEnumPartnerLoanStatusWithAggregatesFilter<$PrismaModel> | $Enums.PartnerLoanStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPartnerLoanStatusFilter<$PrismaModel>
    _max?: NestedEnumPartnerLoanStatusFilter<$PrismaModel>
  }

  export type FoodIngredientCostListRelationFilter = {
    every?: FoodIngredientCostWhereInput
    some?: FoodIngredientCostWhereInput
    none?: FoodIngredientCostWhereInput
  }

  export type FoodRecipeItemListRelationFilter = {
    every?: FoodRecipeItemWhereInput
    some?: FoodRecipeItemWhereInput
    none?: FoodRecipeItemWhereInput
  }

  export type FoodIngredientCostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FoodRecipeItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FoodIngredientCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    unit?: SortOrder
    defaultWastePct?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoodIngredientAvgOrderByAggregateInput = {
    id?: SortOrder
    defaultWastePct?: SortOrder
  }

  export type FoodIngredientMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    unit?: SortOrder
    defaultWastePct?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoodIngredientMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    unit?: SortOrder
    defaultWastePct?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoodIngredientSumOrderByAggregateInput = {
    id?: SortOrder
    defaultWastePct?: SortOrder
  }

  export type FoodIngredientScalarRelationFilter = {
    is?: FoodIngredientWhereInput
    isNot?: FoodIngredientWhereInput
  }

  export type FoodIngredientCostCountOrderByAggregateInput = {
    id?: SortOrder
    ingredientId?: SortOrder
    unitCost?: SortOrder
    effectiveDate?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
  }

  export type FoodIngredientCostAvgOrderByAggregateInput = {
    id?: SortOrder
    ingredientId?: SortOrder
    unitCost?: SortOrder
  }

  export type FoodIngredientCostMaxOrderByAggregateInput = {
    id?: SortOrder
    ingredientId?: SortOrder
    unitCost?: SortOrder
    effectiveDate?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
  }

  export type FoodIngredientCostMinOrderByAggregateInput = {
    id?: SortOrder
    ingredientId?: SortOrder
    unitCost?: SortOrder
    effectiveDate?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
  }

  export type FoodIngredientCostSumOrderByAggregateInput = {
    id?: SortOrder
    ingredientId?: SortOrder
    unitCost?: SortOrder
  }

  export type EnumFoodMealTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FoodMealType | EnumFoodMealTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FoodMealType[]
    notIn?: $Enums.FoodMealType[]
    not?: NestedEnumFoodMealTypeFilter<$PrismaModel> | $Enums.FoodMealType
  }

  export type FoodRecipeCostListRelationFilter = {
    every?: FoodRecipeCostWhereInput
    some?: FoodRecipeCostWhereInput
    none?: FoodRecipeCostWhereInput
  }

  export type FoodMealPlanEntryListRelationFilter = {
    every?: FoodMealPlanEntryWhereInput
    some?: FoodMealPlanEntryWhereInput
    none?: FoodMealPlanEntryWhereInput
  }

  export type FoodRecipeCostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FoodMealPlanEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FoodRecipeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    mealType?: SortOrder
    yield?: SortOrder
    yieldUnit?: SortOrder
    isActive?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    prepMinutes?: SortOrder
    dailyBlocks?: SortOrder
  }

  export type FoodRecipeAvgOrderByAggregateInput = {
    id?: SortOrder
    yield?: SortOrder
    prepMinutes?: SortOrder
    dailyBlocks?: SortOrder
  }

  export type FoodRecipeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    mealType?: SortOrder
    yield?: SortOrder
    yieldUnit?: SortOrder
    isActive?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    prepMinutes?: SortOrder
    dailyBlocks?: SortOrder
  }

  export type FoodRecipeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    mealType?: SortOrder
    yield?: SortOrder
    yieldUnit?: SortOrder
    isActive?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    prepMinutes?: SortOrder
    dailyBlocks?: SortOrder
  }

  export type FoodRecipeSumOrderByAggregateInput = {
    id?: SortOrder
    yield?: SortOrder
    prepMinutes?: SortOrder
    dailyBlocks?: SortOrder
  }

  export type EnumFoodMealTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FoodMealType | EnumFoodMealTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FoodMealType[]
    notIn?: $Enums.FoodMealType[]
    not?: NestedEnumFoodMealTypeWithAggregatesFilter<$PrismaModel> | $Enums.FoodMealType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFoodMealTypeFilter<$PrismaModel>
    _max?: NestedEnumFoodMealTypeFilter<$PrismaModel>
  }

  export type FoodRecipeScalarRelationFilter = {
    is?: FoodRecipeWhereInput
    isNot?: FoodRecipeWhereInput
  }

  export type FoodIngredientNullableScalarRelationFilter = {
    is?: FoodIngredientWhereInput | null
    isNot?: FoodIngredientWhereInput | null
  }

  export type FoodRecipeNullableScalarRelationFilter = {
    is?: FoodRecipeWhereInput | null
    isNot?: FoodRecipeWhereInput | null
  }

  export type FoodRecipeItemCountOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    ingredientId?: SortOrder
    childRecipeId?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    wastePct?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type FoodRecipeItemAvgOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    ingredientId?: SortOrder
    childRecipeId?: SortOrder
    quantity?: SortOrder
    wastePct?: SortOrder
  }

  export type FoodRecipeItemMaxOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    ingredientId?: SortOrder
    childRecipeId?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    wastePct?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type FoodRecipeItemMinOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    ingredientId?: SortOrder
    childRecipeId?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    wastePct?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type FoodRecipeItemSumOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    ingredientId?: SortOrder
    childRecipeId?: SortOrder
    quantity?: SortOrder
    wastePct?: SortOrder
  }

  export type EnumFoodCostLineTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FoodCostLineType | EnumFoodCostLineTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FoodCostLineType[]
    notIn?: $Enums.FoodCostLineType[]
    not?: NestedEnumFoodCostLineTypeFilter<$PrismaModel> | $Enums.FoodCostLineType
  }

  export type EnumFoodCostPeriodFilter<$PrismaModel = never> = {
    equals?: $Enums.FoodCostPeriod | EnumFoodCostPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.FoodCostPeriod[]
    notIn?: $Enums.FoodCostPeriod[]
    not?: NestedEnumFoodCostPeriodFilter<$PrismaModel> | $Enums.FoodCostPeriod
  }

  export type FoodRecipeCostCountOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    label?: SortOrder
    amount?: SortOrder
    costType?: SortOrder
    period?: SortOrder
    periodRations?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type FoodRecipeCostAvgOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    amount?: SortOrder
    periodRations?: SortOrder
  }

  export type FoodRecipeCostMaxOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    label?: SortOrder
    amount?: SortOrder
    costType?: SortOrder
    period?: SortOrder
    periodRations?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type FoodRecipeCostMinOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    label?: SortOrder
    amount?: SortOrder
    costType?: SortOrder
    period?: SortOrder
    periodRations?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type FoodRecipeCostSumOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    amount?: SortOrder
    periodRations?: SortOrder
  }

  export type EnumFoodCostLineTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FoodCostLineType | EnumFoodCostLineTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FoodCostLineType[]
    notIn?: $Enums.FoodCostLineType[]
    not?: NestedEnumFoodCostLineTypeWithAggregatesFilter<$PrismaModel> | $Enums.FoodCostLineType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFoodCostLineTypeFilter<$PrismaModel>
    _max?: NestedEnumFoodCostLineTypeFilter<$PrismaModel>
  }

  export type EnumFoodCostPeriodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FoodCostPeriod | EnumFoodCostPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.FoodCostPeriod[]
    notIn?: $Enums.FoodCostPeriod[]
    not?: NestedEnumFoodCostPeriodWithAggregatesFilter<$PrismaModel> | $Enums.FoodCostPeriod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFoodCostPeriodFilter<$PrismaModel>
    _max?: NestedEnumFoodCostPeriodFilter<$PrismaModel>
  }

  export type EnumFoodCostPoolTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FoodCostPoolType | EnumFoodCostPoolTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FoodCostPoolType[]
    notIn?: $Enums.FoodCostPoolType[]
    not?: NestedEnumFoodCostPoolTypeFilter<$PrismaModel> | $Enums.FoodCostPoolType
  }

  export type EnumFoodMealTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.FoodMealType | EnumFoodMealTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.FoodMealType[] | null
    notIn?: $Enums.FoodMealType[] | null
    not?: NestedEnumFoodMealTypeNullableFilter<$PrismaModel> | $Enums.FoodMealType | null
  }

  export type EnumPoolAllocationMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PoolAllocationMethod | EnumPoolAllocationMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PoolAllocationMethod[]
    notIn?: $Enums.PoolAllocationMethod[]
    not?: NestedEnumPoolAllocationMethodFilter<$PrismaModel> | $Enums.PoolAllocationMethod
  }

  export type FoodCostPoolCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    period?: SortOrder
    periodRations?: SortOrder
    appliesTo?: SortOrder
    notes?: SortOrder
    allocationMethod?: SortOrder
    dailyBlocks?: SortOrder
    timeMinutes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoodCostPoolAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    periodRations?: SortOrder
    dailyBlocks?: SortOrder
    timeMinutes?: SortOrder
  }

  export type FoodCostPoolMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    period?: SortOrder
    periodRations?: SortOrder
    appliesTo?: SortOrder
    notes?: SortOrder
    allocationMethod?: SortOrder
    dailyBlocks?: SortOrder
    timeMinutes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoodCostPoolMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    period?: SortOrder
    periodRations?: SortOrder
    appliesTo?: SortOrder
    notes?: SortOrder
    allocationMethod?: SortOrder
    dailyBlocks?: SortOrder
    timeMinutes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoodCostPoolSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    periodRations?: SortOrder
    dailyBlocks?: SortOrder
    timeMinutes?: SortOrder
  }

  export type EnumFoodCostPoolTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FoodCostPoolType | EnumFoodCostPoolTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FoodCostPoolType[]
    notIn?: $Enums.FoodCostPoolType[]
    not?: NestedEnumFoodCostPoolTypeWithAggregatesFilter<$PrismaModel> | $Enums.FoodCostPoolType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFoodCostPoolTypeFilter<$PrismaModel>
    _max?: NestedEnumFoodCostPoolTypeFilter<$PrismaModel>
  }

  export type EnumFoodMealTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FoodMealType | EnumFoodMealTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.FoodMealType[] | null
    notIn?: $Enums.FoodMealType[] | null
    not?: NestedEnumFoodMealTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.FoodMealType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumFoodMealTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumFoodMealTypeNullableFilter<$PrismaModel>
  }

  export type EnumPoolAllocationMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PoolAllocationMethod | EnumPoolAllocationMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PoolAllocationMethod[]
    notIn?: $Enums.PoolAllocationMethod[]
    not?: NestedEnumPoolAllocationMethodWithAggregatesFilter<$PrismaModel> | $Enums.PoolAllocationMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPoolAllocationMethodFilter<$PrismaModel>
    _max?: NestedEnumPoolAllocationMethodFilter<$PrismaModel>
  }

  export type FoodMealPlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    weekStart?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoodMealPlanAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FoodMealPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    weekStart?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoodMealPlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    weekStart?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoodMealPlanSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FoodMealPlanScalarRelationFilter = {
    is?: FoodMealPlanWhereInput
    isNot?: FoodMealPlanWhereInput
  }

  export type FoodMealPlanEntryCountOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    dayIndex?: SortOrder
    mealType?: SortOrder
    recipeId?: SortOrder
    servings?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoodMealPlanEntryAvgOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    dayIndex?: SortOrder
    recipeId?: SortOrder
    servings?: SortOrder
  }

  export type FoodMealPlanEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    dayIndex?: SortOrder
    mealType?: SortOrder
    recipeId?: SortOrder
    servings?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoodMealPlanEntryMinOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    dayIndex?: SortOrder
    mealType?: SortOrder
    recipeId?: SortOrder
    servings?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoodMealPlanEntrySumOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    dayIndex?: SortOrder
    recipeId?: SortOrder
    servings?: SortOrder
  }

  export type EnumQuotationProcessStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotationProcessStatus | EnumQuotationProcessStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuotationProcessStatus[]
    notIn?: $Enums.QuotationProcessStatus[]
    not?: NestedEnumQuotationProcessStatusFilter<$PrismaModel> | $Enums.QuotationProcessStatus
  }

  export type QuotationAttachmentNullableScalarRelationFilter = {
    is?: QuotationAttachmentWhereInput | null
    isNot?: QuotationAttachmentWhereInput | null
  }

  export type PurchaseOrderLogListRelationFilter = {
    every?: PurchaseOrderLogWhereInput
    some?: PurchaseOrderLogWhereInput
    none?: PurchaseOrderLogWhereInput
  }

  export type PurchaseOrderLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuotationProcessCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    status?: SortOrder
    baseCurrency?: SortOrder
    targetCurrency?: SortOrder
    exchangeRate?: SortOrder
    targetMarginPct?: SortOrder
    baselineFileId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuotationProcessAvgOrderByAggregateInput = {
    id?: SortOrder
    exchangeRate?: SortOrder
    targetMarginPct?: SortOrder
    baselineFileId?: SortOrder
  }

  export type QuotationProcessMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    status?: SortOrder
    baseCurrency?: SortOrder
    targetCurrency?: SortOrder
    exchangeRate?: SortOrder
    targetMarginPct?: SortOrder
    baselineFileId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuotationProcessMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    status?: SortOrder
    baseCurrency?: SortOrder
    targetCurrency?: SortOrder
    exchangeRate?: SortOrder
    targetMarginPct?: SortOrder
    baselineFileId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuotationProcessSumOrderByAggregateInput = {
    id?: SortOrder
    exchangeRate?: SortOrder
    targetMarginPct?: SortOrder
    baselineFileId?: SortOrder
  }

  export type EnumQuotationProcessStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotationProcessStatus | EnumQuotationProcessStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuotationProcessStatus[]
    notIn?: $Enums.QuotationProcessStatus[]
    not?: NestedEnumQuotationProcessStatusWithAggregatesFilter<$PrismaModel> | $Enums.QuotationProcessStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuotationProcessStatusFilter<$PrismaModel>
    _max?: NestedEnumQuotationProcessStatusFilter<$PrismaModel>
  }

  export type QuotationProcessScalarRelationFilter = {
    is?: QuotationProcessWhereInput
    isNot?: QuotationProcessWhereInput
  }

  export type PurchaseOrderLineListRelationFilter = {
    every?: PurchaseOrderLineWhereInput
    some?: PurchaseOrderLineWhereInput
    none?: PurchaseOrderLineWhereInput
  }

  export type PurchaseDeliveryItemListRelationFilter = {
    every?: PurchaseDeliveryItemWhereInput
    some?: PurchaseDeliveryItemWhereInput
    none?: PurchaseDeliveryItemWhereInput
  }

  export type PurchaseOrderLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseDeliveryItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuotationBaselineItemCountOrderByAggregateInput = {
    id?: SortOrder
    processId?: SortOrder
    materialId?: SortOrder
    sheetName?: SortOrder
    sectionPath?: SortOrder
    itemCode?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuotationBaselineItemAvgOrderByAggregateInput = {
    id?: SortOrder
    processId?: SortOrder
    materialId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type QuotationBaselineItemMaxOrderByAggregateInput = {
    id?: SortOrder
    processId?: SortOrder
    materialId?: SortOrder
    sheetName?: SortOrder
    sectionPath?: SortOrder
    itemCode?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuotationBaselineItemMinOrderByAggregateInput = {
    id?: SortOrder
    processId?: SortOrder
    materialId?: SortOrder
    sheetName?: SortOrder
    sectionPath?: SortOrder
    itemCode?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuotationBaselineItemSumOrderByAggregateInput = {
    id?: SortOrder
    processId?: SortOrder
    materialId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type EnumQuotationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotationStatus | EnumQuotationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuotationStatus[]
    notIn?: $Enums.QuotationStatus[]
    not?: NestedEnumQuotationStatusFilter<$PrismaModel> | $Enums.QuotationStatus
  }

  export type QuotationAttachmentListRelationFilter = {
    every?: QuotationAttachmentWhereInput
    some?: QuotationAttachmentWhereInput
    none?: QuotationAttachmentWhereInput
  }

  export type QuotationAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuotationCountOrderByAggregateInput = {
    id?: SortOrder
    processId?: SortOrder
    proveedorId?: SortOrder
    supplierName?: SortOrder
    currency?: SortOrder
    exchangeRate?: SortOrder
    submittedAt?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    totalAmountPen?: SortOrder
    qualityScore?: SortOrder
    notes?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuotationAvgOrderByAggregateInput = {
    id?: SortOrder
    processId?: SortOrder
    proveedorId?: SortOrder
    exchangeRate?: SortOrder
    totalAmount?: SortOrder
    totalAmountPen?: SortOrder
    qualityScore?: SortOrder
  }

  export type QuotationMaxOrderByAggregateInput = {
    id?: SortOrder
    processId?: SortOrder
    proveedorId?: SortOrder
    supplierName?: SortOrder
    currency?: SortOrder
    exchangeRate?: SortOrder
    submittedAt?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    totalAmountPen?: SortOrder
    qualityScore?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuotationMinOrderByAggregateInput = {
    id?: SortOrder
    processId?: SortOrder
    proveedorId?: SortOrder
    supplierName?: SortOrder
    currency?: SortOrder
    exchangeRate?: SortOrder
    submittedAt?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    totalAmountPen?: SortOrder
    qualityScore?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuotationSumOrderByAggregateInput = {
    id?: SortOrder
    processId?: SortOrder
    proveedorId?: SortOrder
    exchangeRate?: SortOrder
    totalAmount?: SortOrder
    totalAmountPen?: SortOrder
    qualityScore?: SortOrder
  }

  export type EnumQuotationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotationStatus | EnumQuotationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuotationStatus[]
    notIn?: $Enums.QuotationStatus[]
    not?: NestedEnumQuotationStatusWithAggregatesFilter<$PrismaModel> | $Enums.QuotationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuotationStatusFilter<$PrismaModel>
    _max?: NestedEnumQuotationStatusFilter<$PrismaModel>
  }

  export type QuotationScalarRelationFilter = {
    is?: QuotationWhereInput
    isNot?: QuotationWhereInput
  }

  export type QuotationBaselineItemNullableScalarRelationFilter = {
    is?: QuotationBaselineItemWhereInput | null
    isNot?: QuotationBaselineItemWhereInput | null
  }

  export type QuotationItemCountOrderByAggregateInput = {
    id?: SortOrder
    quotationId?: SortOrder
    baselineItemId?: SortOrder
    materialId?: SortOrder
    sourceRow?: SortOrder
    itemCode?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    currency?: SortOrder
    normalizedPrice?: SortOrder
    matchScore?: SortOrder
    extraAttributes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuotationItemAvgOrderByAggregateInput = {
    id?: SortOrder
    quotationId?: SortOrder
    baselineItemId?: SortOrder
    materialId?: SortOrder
    sourceRow?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    normalizedPrice?: SortOrder
    matchScore?: SortOrder
  }

  export type QuotationItemMaxOrderByAggregateInput = {
    id?: SortOrder
    quotationId?: SortOrder
    baselineItemId?: SortOrder
    materialId?: SortOrder
    sourceRow?: SortOrder
    itemCode?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    currency?: SortOrder
    normalizedPrice?: SortOrder
    matchScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuotationItemMinOrderByAggregateInput = {
    id?: SortOrder
    quotationId?: SortOrder
    baselineItemId?: SortOrder
    materialId?: SortOrder
    sourceRow?: SortOrder
    itemCode?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    currency?: SortOrder
    normalizedPrice?: SortOrder
    matchScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuotationItemSumOrderByAggregateInput = {
    id?: SortOrder
    quotationId?: SortOrder
    baselineItemId?: SortOrder
    materialId?: SortOrder
    sourceRow?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    normalizedPrice?: SortOrder
    matchScore?: SortOrder
  }

  export type EnumQuotationAttachmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotationAttachmentType | EnumQuotationAttachmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuotationAttachmentType[]
    notIn?: $Enums.QuotationAttachmentType[]
    not?: NestedEnumQuotationAttachmentTypeFilter<$PrismaModel> | $Enums.QuotationAttachmentType
  }

  export type QuotationNullableScalarRelationFilter = {
    is?: QuotationWhereInput | null
    isNot?: QuotationWhereInput | null
  }

  export type QuotationProcessNullableScalarRelationFilter = {
    is?: QuotationProcessWhereInput | null
    isNot?: QuotationProcessWhereInput | null
  }

  export type QuotationAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    quotationId?: SortOrder
    type?: SortOrder
    originalName?: SortOrder
    storagePath?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    checksum?: SortOrder
    parsed?: SortOrder
    parsedAt?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuotationAttachmentAvgOrderByAggregateInput = {
    id?: SortOrder
    quotationId?: SortOrder
    sizeBytes?: SortOrder
  }

  export type QuotationAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    quotationId?: SortOrder
    type?: SortOrder
    originalName?: SortOrder
    storagePath?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    checksum?: SortOrder
    parsed?: SortOrder
    parsedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuotationAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    quotationId?: SortOrder
    type?: SortOrder
    originalName?: SortOrder
    storagePath?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    checksum?: SortOrder
    parsed?: SortOrder
    parsedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuotationAttachmentSumOrderByAggregateInput = {
    id?: SortOrder
    quotationId?: SortOrder
    sizeBytes?: SortOrder
  }

  export type EnumQuotationAttachmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotationAttachmentType | EnumQuotationAttachmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuotationAttachmentType[]
    notIn?: $Enums.QuotationAttachmentType[]
    not?: NestedEnumQuotationAttachmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.QuotationAttachmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuotationAttachmentTypeFilter<$PrismaModel>
    _max?: NestedEnumQuotationAttachmentTypeFilter<$PrismaModel>
  }

  export type PurchaseOrderLogCountOrderByAggregateInput = {
    id?: SortOrder
    processId?: SortOrder
    quotationId?: SortOrder
    supplierId?: SortOrder
    supplierName?: SortOrder
    orderNumber?: SortOrder
    sequence?: SortOrder
    issueDate?: SortOrder
    currency?: SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    netSubtotal?: SortOrder
    igv?: SortOrder
    total?: SortOrder
    totalsJson?: SortOrder
    itemsJson?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderLogAvgOrderByAggregateInput = {
    id?: SortOrder
    processId?: SortOrder
    quotationId?: SortOrder
    supplierId?: SortOrder
    sequence?: SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    netSubtotal?: SortOrder
    igv?: SortOrder
    total?: SortOrder
  }

  export type PurchaseOrderLogMaxOrderByAggregateInput = {
    id?: SortOrder
    processId?: SortOrder
    quotationId?: SortOrder
    supplierId?: SortOrder
    supplierName?: SortOrder
    orderNumber?: SortOrder
    sequence?: SortOrder
    issueDate?: SortOrder
    currency?: SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    netSubtotal?: SortOrder
    igv?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderLogMinOrderByAggregateInput = {
    id?: SortOrder
    processId?: SortOrder
    quotationId?: SortOrder
    supplierId?: SortOrder
    supplierName?: SortOrder
    orderNumber?: SortOrder
    sequence?: SortOrder
    issueDate?: SortOrder
    currency?: SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    netSubtotal?: SortOrder
    igv?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderLogSumOrderByAggregateInput = {
    id?: SortOrder
    processId?: SortOrder
    quotationId?: SortOrder
    supplierId?: SortOrder
    sequence?: SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    netSubtotal?: SortOrder
    igv?: SortOrder
    total?: SortOrder
  }

  export type PurchaseOrderLogScalarRelationFilter = {
    is?: PurchaseOrderLogWhereInput
    isNot?: PurchaseOrderLogWhereInput
  }

  export type PurchaseOrderLineCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    baselineId?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderLineAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    baselineId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type PurchaseOrderLineMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    baselineId?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderLineMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    baselineId?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderLineSumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    baselineId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type PurchaseOrderLogNullableScalarRelationFilter = {
    is?: PurchaseOrderLogWhereInput | null
    isNot?: PurchaseOrderLogWhereInput | null
  }

  export type PurchaseDeliveryLogCountOrderByAggregateInput = {
    id?: SortOrder
    processId?: SortOrder
    orderId?: SortOrder
    proveedorId?: SortOrder
    supplierName?: SortOrder
    guideNumber?: SortOrder
    date?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseDeliveryLogAvgOrderByAggregateInput = {
    id?: SortOrder
    processId?: SortOrder
    orderId?: SortOrder
    proveedorId?: SortOrder
  }

  export type PurchaseDeliveryLogMaxOrderByAggregateInput = {
    id?: SortOrder
    processId?: SortOrder
    orderId?: SortOrder
    proveedorId?: SortOrder
    supplierName?: SortOrder
    guideNumber?: SortOrder
    date?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseDeliveryLogMinOrderByAggregateInput = {
    id?: SortOrder
    processId?: SortOrder
    orderId?: SortOrder
    proveedorId?: SortOrder
    supplierName?: SortOrder
    guideNumber?: SortOrder
    date?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseDeliveryLogSumOrderByAggregateInput = {
    id?: SortOrder
    processId?: SortOrder
    orderId?: SortOrder
    proveedorId?: SortOrder
  }

  export type PurchaseDeliveryLogScalarRelationFilter = {
    is?: PurchaseDeliveryLogWhereInput
    isNot?: PurchaseDeliveryLogWhereInput
  }

  export type PurchaseOrderLineNullableScalarRelationFilter = {
    is?: PurchaseOrderLineWhereInput | null
    isNot?: PurchaseOrderLineWhereInput | null
  }

  export type PurchaseDeliveryItemCountOrderByAggregateInput = {
    id?: SortOrder
    deliveryId?: SortOrder
    orderLineId?: SortOrder
    baselineId?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    quantity?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseDeliveryItemAvgOrderByAggregateInput = {
    id?: SortOrder
    deliveryId?: SortOrder
    orderLineId?: SortOrder
    baselineId?: SortOrder
    quantity?: SortOrder
  }

  export type PurchaseDeliveryItemMaxOrderByAggregateInput = {
    id?: SortOrder
    deliveryId?: SortOrder
    orderLineId?: SortOrder
    baselineId?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    quantity?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseDeliveryItemMinOrderByAggregateInput = {
    id?: SortOrder
    deliveryId?: SortOrder
    orderLineId?: SortOrder
    baselineId?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    quantity?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseDeliveryItemSumOrderByAggregateInput = {
    id?: SortOrder
    deliveryId?: SortOrder
    orderLineId?: SortOrder
    baselineId?: SortOrder
    quantity?: SortOrder
  }

  export type FrenteCreateNestedManyWithoutObraInput = {
    create?: XOR<FrenteCreateWithoutObraInput, FrenteUncheckedCreateWithoutObraInput> | FrenteCreateWithoutObraInput[] | FrenteUncheckedCreateWithoutObraInput[]
    connectOrCreate?: FrenteCreateOrConnectWithoutObraInput | FrenteCreateOrConnectWithoutObraInput[]
    createMany?: FrenteCreateManyObraInputEnvelope
    connect?: FrenteWhereUniqueInput | FrenteWhereUniqueInput[]
  }

  export type MoveCreateNestedManyWithoutObraInput = {
    create?: XOR<MoveCreateWithoutObraInput, MoveUncheckedCreateWithoutObraInput> | MoveCreateWithoutObraInput[] | MoveUncheckedCreateWithoutObraInput[]
    connectOrCreate?: MoveCreateOrConnectWithoutObraInput | MoveCreateOrConnectWithoutObraInput[]
    createMany?: MoveCreateManyObraInputEnvelope
    connect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
  }

  export type IncomeCreateNestedManyWithoutObraInput = {
    create?: XOR<IncomeCreateWithoutObraInput, IncomeUncheckedCreateWithoutObraInput> | IncomeCreateWithoutObraInput[] | IncomeUncheckedCreateWithoutObraInput[]
    connectOrCreate?: IncomeCreateOrConnectWithoutObraInput | IncomeCreateOrConnectWithoutObraInput[]
    createMany?: IncomeCreateManyObraInputEnvelope
    connect?: IncomeWhereUniqueInput | IncomeWhereUniqueInput[]
  }

  export type ExpenseCreateNestedManyWithoutObraInput = {
    create?: XOR<ExpenseCreateWithoutObraInput, ExpenseUncheckedCreateWithoutObraInput> | ExpenseCreateWithoutObraInput[] | ExpenseUncheckedCreateWithoutObraInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutObraInput | ExpenseCreateOrConnectWithoutObraInput[]
    createMany?: ExpenseCreateManyObraInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type EmployeeCreateNestedManyWithoutObraInput = {
    create?: XOR<EmployeeCreateWithoutObraInput, EmployeeUncheckedCreateWithoutObraInput> | EmployeeCreateWithoutObraInput[] | EmployeeUncheckedCreateWithoutObraInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutObraInput | EmployeeCreateOrConnectWithoutObraInput[]
    createMany?: EmployeeCreateManyObraInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type PayrollPeriodCreateNestedManyWithoutObraInput = {
    create?: XOR<PayrollPeriodCreateWithoutObraInput, PayrollPeriodUncheckedCreateWithoutObraInput> | PayrollPeriodCreateWithoutObraInput[] | PayrollPeriodUncheckedCreateWithoutObraInput[]
    connectOrCreate?: PayrollPeriodCreateOrConnectWithoutObraInput | PayrollPeriodCreateOrConnectWithoutObraInput[]
    createMany?: PayrollPeriodCreateManyObraInputEnvelope
    connect?: PayrollPeriodWhereUniqueInput | PayrollPeriodWhereUniqueInput[]
  }

  export type DailyCashRenditionCreateNestedManyWithoutObraInput = {
    create?: XOR<DailyCashRenditionCreateWithoutObraInput, DailyCashRenditionUncheckedCreateWithoutObraInput> | DailyCashRenditionCreateWithoutObraInput[] | DailyCashRenditionUncheckedCreateWithoutObraInput[]
    connectOrCreate?: DailyCashRenditionCreateOrConnectWithoutObraInput | DailyCashRenditionCreateOrConnectWithoutObraInput[]
    createMany?: DailyCashRenditionCreateManyObraInputEnvelope
    connect?: DailyCashRenditionWhereUniqueInput | DailyCashRenditionWhereUniqueInput[]
  }

  export type FrenteUncheckedCreateNestedManyWithoutObraInput = {
    create?: XOR<FrenteCreateWithoutObraInput, FrenteUncheckedCreateWithoutObraInput> | FrenteCreateWithoutObraInput[] | FrenteUncheckedCreateWithoutObraInput[]
    connectOrCreate?: FrenteCreateOrConnectWithoutObraInput | FrenteCreateOrConnectWithoutObraInput[]
    createMany?: FrenteCreateManyObraInputEnvelope
    connect?: FrenteWhereUniqueInput | FrenteWhereUniqueInput[]
  }

  export type MoveUncheckedCreateNestedManyWithoutObraInput = {
    create?: XOR<MoveCreateWithoutObraInput, MoveUncheckedCreateWithoutObraInput> | MoveCreateWithoutObraInput[] | MoveUncheckedCreateWithoutObraInput[]
    connectOrCreate?: MoveCreateOrConnectWithoutObraInput | MoveCreateOrConnectWithoutObraInput[]
    createMany?: MoveCreateManyObraInputEnvelope
    connect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
  }

  export type IncomeUncheckedCreateNestedManyWithoutObraInput = {
    create?: XOR<IncomeCreateWithoutObraInput, IncomeUncheckedCreateWithoutObraInput> | IncomeCreateWithoutObraInput[] | IncomeUncheckedCreateWithoutObraInput[]
    connectOrCreate?: IncomeCreateOrConnectWithoutObraInput | IncomeCreateOrConnectWithoutObraInput[]
    createMany?: IncomeCreateManyObraInputEnvelope
    connect?: IncomeWhereUniqueInput | IncomeWhereUniqueInput[]
  }

  export type ExpenseUncheckedCreateNestedManyWithoutObraInput = {
    create?: XOR<ExpenseCreateWithoutObraInput, ExpenseUncheckedCreateWithoutObraInput> | ExpenseCreateWithoutObraInput[] | ExpenseUncheckedCreateWithoutObraInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutObraInput | ExpenseCreateOrConnectWithoutObraInput[]
    createMany?: ExpenseCreateManyObraInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutObraInput = {
    create?: XOR<EmployeeCreateWithoutObraInput, EmployeeUncheckedCreateWithoutObraInput> | EmployeeCreateWithoutObraInput[] | EmployeeUncheckedCreateWithoutObraInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutObraInput | EmployeeCreateOrConnectWithoutObraInput[]
    createMany?: EmployeeCreateManyObraInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type PayrollPeriodUncheckedCreateNestedManyWithoutObraInput = {
    create?: XOR<PayrollPeriodCreateWithoutObraInput, PayrollPeriodUncheckedCreateWithoutObraInput> | PayrollPeriodCreateWithoutObraInput[] | PayrollPeriodUncheckedCreateWithoutObraInput[]
    connectOrCreate?: PayrollPeriodCreateOrConnectWithoutObraInput | PayrollPeriodCreateOrConnectWithoutObraInput[]
    createMany?: PayrollPeriodCreateManyObraInputEnvelope
    connect?: PayrollPeriodWhereUniqueInput | PayrollPeriodWhereUniqueInput[]
  }

  export type DailyCashRenditionUncheckedCreateNestedManyWithoutObraInput = {
    create?: XOR<DailyCashRenditionCreateWithoutObraInput, DailyCashRenditionUncheckedCreateWithoutObraInput> | DailyCashRenditionCreateWithoutObraInput[] | DailyCashRenditionUncheckedCreateWithoutObraInput[]
    connectOrCreate?: DailyCashRenditionCreateOrConnectWithoutObraInput | DailyCashRenditionCreateOrConnectWithoutObraInput[]
    createMany?: DailyCashRenditionCreateManyObraInputEnvelope
    connect?: DailyCashRenditionWhereUniqueInput | DailyCashRenditionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type FrenteUpdateManyWithoutObraNestedInput = {
    create?: XOR<FrenteCreateWithoutObraInput, FrenteUncheckedCreateWithoutObraInput> | FrenteCreateWithoutObraInput[] | FrenteUncheckedCreateWithoutObraInput[]
    connectOrCreate?: FrenteCreateOrConnectWithoutObraInput | FrenteCreateOrConnectWithoutObraInput[]
    upsert?: FrenteUpsertWithWhereUniqueWithoutObraInput | FrenteUpsertWithWhereUniqueWithoutObraInput[]
    createMany?: FrenteCreateManyObraInputEnvelope
    set?: FrenteWhereUniqueInput | FrenteWhereUniqueInput[]
    disconnect?: FrenteWhereUniqueInput | FrenteWhereUniqueInput[]
    delete?: FrenteWhereUniqueInput | FrenteWhereUniqueInput[]
    connect?: FrenteWhereUniqueInput | FrenteWhereUniqueInput[]
    update?: FrenteUpdateWithWhereUniqueWithoutObraInput | FrenteUpdateWithWhereUniqueWithoutObraInput[]
    updateMany?: FrenteUpdateManyWithWhereWithoutObraInput | FrenteUpdateManyWithWhereWithoutObraInput[]
    deleteMany?: FrenteScalarWhereInput | FrenteScalarWhereInput[]
  }

  export type MoveUpdateManyWithoutObraNestedInput = {
    create?: XOR<MoveCreateWithoutObraInput, MoveUncheckedCreateWithoutObraInput> | MoveCreateWithoutObraInput[] | MoveUncheckedCreateWithoutObraInput[]
    connectOrCreate?: MoveCreateOrConnectWithoutObraInput | MoveCreateOrConnectWithoutObraInput[]
    upsert?: MoveUpsertWithWhereUniqueWithoutObraInput | MoveUpsertWithWhereUniqueWithoutObraInput[]
    createMany?: MoveCreateManyObraInputEnvelope
    set?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    disconnect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    delete?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    connect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    update?: MoveUpdateWithWhereUniqueWithoutObraInput | MoveUpdateWithWhereUniqueWithoutObraInput[]
    updateMany?: MoveUpdateManyWithWhereWithoutObraInput | MoveUpdateManyWithWhereWithoutObraInput[]
    deleteMany?: MoveScalarWhereInput | MoveScalarWhereInput[]
  }

  export type IncomeUpdateManyWithoutObraNestedInput = {
    create?: XOR<IncomeCreateWithoutObraInput, IncomeUncheckedCreateWithoutObraInput> | IncomeCreateWithoutObraInput[] | IncomeUncheckedCreateWithoutObraInput[]
    connectOrCreate?: IncomeCreateOrConnectWithoutObraInput | IncomeCreateOrConnectWithoutObraInput[]
    upsert?: IncomeUpsertWithWhereUniqueWithoutObraInput | IncomeUpsertWithWhereUniqueWithoutObraInput[]
    createMany?: IncomeCreateManyObraInputEnvelope
    set?: IncomeWhereUniqueInput | IncomeWhereUniqueInput[]
    disconnect?: IncomeWhereUniqueInput | IncomeWhereUniqueInput[]
    delete?: IncomeWhereUniqueInput | IncomeWhereUniqueInput[]
    connect?: IncomeWhereUniqueInput | IncomeWhereUniqueInput[]
    update?: IncomeUpdateWithWhereUniqueWithoutObraInput | IncomeUpdateWithWhereUniqueWithoutObraInput[]
    updateMany?: IncomeUpdateManyWithWhereWithoutObraInput | IncomeUpdateManyWithWhereWithoutObraInput[]
    deleteMany?: IncomeScalarWhereInput | IncomeScalarWhereInput[]
  }

  export type ExpenseUpdateManyWithoutObraNestedInput = {
    create?: XOR<ExpenseCreateWithoutObraInput, ExpenseUncheckedCreateWithoutObraInput> | ExpenseCreateWithoutObraInput[] | ExpenseUncheckedCreateWithoutObraInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutObraInput | ExpenseCreateOrConnectWithoutObraInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutObraInput | ExpenseUpsertWithWhereUniqueWithoutObraInput[]
    createMany?: ExpenseCreateManyObraInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutObraInput | ExpenseUpdateWithWhereUniqueWithoutObraInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutObraInput | ExpenseUpdateManyWithWhereWithoutObraInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type EmployeeUpdateManyWithoutObraNestedInput = {
    create?: XOR<EmployeeCreateWithoutObraInput, EmployeeUncheckedCreateWithoutObraInput> | EmployeeCreateWithoutObraInput[] | EmployeeUncheckedCreateWithoutObraInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutObraInput | EmployeeCreateOrConnectWithoutObraInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutObraInput | EmployeeUpsertWithWhereUniqueWithoutObraInput[]
    createMany?: EmployeeCreateManyObraInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutObraInput | EmployeeUpdateWithWhereUniqueWithoutObraInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutObraInput | EmployeeUpdateManyWithWhereWithoutObraInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type PayrollPeriodUpdateManyWithoutObraNestedInput = {
    create?: XOR<PayrollPeriodCreateWithoutObraInput, PayrollPeriodUncheckedCreateWithoutObraInput> | PayrollPeriodCreateWithoutObraInput[] | PayrollPeriodUncheckedCreateWithoutObraInput[]
    connectOrCreate?: PayrollPeriodCreateOrConnectWithoutObraInput | PayrollPeriodCreateOrConnectWithoutObraInput[]
    upsert?: PayrollPeriodUpsertWithWhereUniqueWithoutObraInput | PayrollPeriodUpsertWithWhereUniqueWithoutObraInput[]
    createMany?: PayrollPeriodCreateManyObraInputEnvelope
    set?: PayrollPeriodWhereUniqueInput | PayrollPeriodWhereUniqueInput[]
    disconnect?: PayrollPeriodWhereUniqueInput | PayrollPeriodWhereUniqueInput[]
    delete?: PayrollPeriodWhereUniqueInput | PayrollPeriodWhereUniqueInput[]
    connect?: PayrollPeriodWhereUniqueInput | PayrollPeriodWhereUniqueInput[]
    update?: PayrollPeriodUpdateWithWhereUniqueWithoutObraInput | PayrollPeriodUpdateWithWhereUniqueWithoutObraInput[]
    updateMany?: PayrollPeriodUpdateManyWithWhereWithoutObraInput | PayrollPeriodUpdateManyWithWhereWithoutObraInput[]
    deleteMany?: PayrollPeriodScalarWhereInput | PayrollPeriodScalarWhereInput[]
  }

  export type DailyCashRenditionUpdateManyWithoutObraNestedInput = {
    create?: XOR<DailyCashRenditionCreateWithoutObraInput, DailyCashRenditionUncheckedCreateWithoutObraInput> | DailyCashRenditionCreateWithoutObraInput[] | DailyCashRenditionUncheckedCreateWithoutObraInput[]
    connectOrCreate?: DailyCashRenditionCreateOrConnectWithoutObraInput | DailyCashRenditionCreateOrConnectWithoutObraInput[]
    upsert?: DailyCashRenditionUpsertWithWhereUniqueWithoutObraInput | DailyCashRenditionUpsertWithWhereUniqueWithoutObraInput[]
    createMany?: DailyCashRenditionCreateManyObraInputEnvelope
    set?: DailyCashRenditionWhereUniqueInput | DailyCashRenditionWhereUniqueInput[]
    disconnect?: DailyCashRenditionWhereUniqueInput | DailyCashRenditionWhereUniqueInput[]
    delete?: DailyCashRenditionWhereUniqueInput | DailyCashRenditionWhereUniqueInput[]
    connect?: DailyCashRenditionWhereUniqueInput | DailyCashRenditionWhereUniqueInput[]
    update?: DailyCashRenditionUpdateWithWhereUniqueWithoutObraInput | DailyCashRenditionUpdateWithWhereUniqueWithoutObraInput[]
    updateMany?: DailyCashRenditionUpdateManyWithWhereWithoutObraInput | DailyCashRenditionUpdateManyWithWhereWithoutObraInput[]
    deleteMany?: DailyCashRenditionScalarWhereInput | DailyCashRenditionScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FrenteUncheckedUpdateManyWithoutObraNestedInput = {
    create?: XOR<FrenteCreateWithoutObraInput, FrenteUncheckedCreateWithoutObraInput> | FrenteCreateWithoutObraInput[] | FrenteUncheckedCreateWithoutObraInput[]
    connectOrCreate?: FrenteCreateOrConnectWithoutObraInput | FrenteCreateOrConnectWithoutObraInput[]
    upsert?: FrenteUpsertWithWhereUniqueWithoutObraInput | FrenteUpsertWithWhereUniqueWithoutObraInput[]
    createMany?: FrenteCreateManyObraInputEnvelope
    set?: FrenteWhereUniqueInput | FrenteWhereUniqueInput[]
    disconnect?: FrenteWhereUniqueInput | FrenteWhereUniqueInput[]
    delete?: FrenteWhereUniqueInput | FrenteWhereUniqueInput[]
    connect?: FrenteWhereUniqueInput | FrenteWhereUniqueInput[]
    update?: FrenteUpdateWithWhereUniqueWithoutObraInput | FrenteUpdateWithWhereUniqueWithoutObraInput[]
    updateMany?: FrenteUpdateManyWithWhereWithoutObraInput | FrenteUpdateManyWithWhereWithoutObraInput[]
    deleteMany?: FrenteScalarWhereInput | FrenteScalarWhereInput[]
  }

  export type MoveUncheckedUpdateManyWithoutObraNestedInput = {
    create?: XOR<MoveCreateWithoutObraInput, MoveUncheckedCreateWithoutObraInput> | MoveCreateWithoutObraInput[] | MoveUncheckedCreateWithoutObraInput[]
    connectOrCreate?: MoveCreateOrConnectWithoutObraInput | MoveCreateOrConnectWithoutObraInput[]
    upsert?: MoveUpsertWithWhereUniqueWithoutObraInput | MoveUpsertWithWhereUniqueWithoutObraInput[]
    createMany?: MoveCreateManyObraInputEnvelope
    set?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    disconnect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    delete?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    connect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    update?: MoveUpdateWithWhereUniqueWithoutObraInput | MoveUpdateWithWhereUniqueWithoutObraInput[]
    updateMany?: MoveUpdateManyWithWhereWithoutObraInput | MoveUpdateManyWithWhereWithoutObraInput[]
    deleteMany?: MoveScalarWhereInput | MoveScalarWhereInput[]
  }

  export type IncomeUncheckedUpdateManyWithoutObraNestedInput = {
    create?: XOR<IncomeCreateWithoutObraInput, IncomeUncheckedCreateWithoutObraInput> | IncomeCreateWithoutObraInput[] | IncomeUncheckedCreateWithoutObraInput[]
    connectOrCreate?: IncomeCreateOrConnectWithoutObraInput | IncomeCreateOrConnectWithoutObraInput[]
    upsert?: IncomeUpsertWithWhereUniqueWithoutObraInput | IncomeUpsertWithWhereUniqueWithoutObraInput[]
    createMany?: IncomeCreateManyObraInputEnvelope
    set?: IncomeWhereUniqueInput | IncomeWhereUniqueInput[]
    disconnect?: IncomeWhereUniqueInput | IncomeWhereUniqueInput[]
    delete?: IncomeWhereUniqueInput | IncomeWhereUniqueInput[]
    connect?: IncomeWhereUniqueInput | IncomeWhereUniqueInput[]
    update?: IncomeUpdateWithWhereUniqueWithoutObraInput | IncomeUpdateWithWhereUniqueWithoutObraInput[]
    updateMany?: IncomeUpdateManyWithWhereWithoutObraInput | IncomeUpdateManyWithWhereWithoutObraInput[]
    deleteMany?: IncomeScalarWhereInput | IncomeScalarWhereInput[]
  }

  export type ExpenseUncheckedUpdateManyWithoutObraNestedInput = {
    create?: XOR<ExpenseCreateWithoutObraInput, ExpenseUncheckedCreateWithoutObraInput> | ExpenseCreateWithoutObraInput[] | ExpenseUncheckedCreateWithoutObraInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutObraInput | ExpenseCreateOrConnectWithoutObraInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutObraInput | ExpenseUpsertWithWhereUniqueWithoutObraInput[]
    createMany?: ExpenseCreateManyObraInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutObraInput | ExpenseUpdateWithWhereUniqueWithoutObraInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutObraInput | ExpenseUpdateManyWithWhereWithoutObraInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutObraNestedInput = {
    create?: XOR<EmployeeCreateWithoutObraInput, EmployeeUncheckedCreateWithoutObraInput> | EmployeeCreateWithoutObraInput[] | EmployeeUncheckedCreateWithoutObraInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutObraInput | EmployeeCreateOrConnectWithoutObraInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutObraInput | EmployeeUpsertWithWhereUniqueWithoutObraInput[]
    createMany?: EmployeeCreateManyObraInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutObraInput | EmployeeUpdateWithWhereUniqueWithoutObraInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutObraInput | EmployeeUpdateManyWithWhereWithoutObraInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type PayrollPeriodUncheckedUpdateManyWithoutObraNestedInput = {
    create?: XOR<PayrollPeriodCreateWithoutObraInput, PayrollPeriodUncheckedCreateWithoutObraInput> | PayrollPeriodCreateWithoutObraInput[] | PayrollPeriodUncheckedCreateWithoutObraInput[]
    connectOrCreate?: PayrollPeriodCreateOrConnectWithoutObraInput | PayrollPeriodCreateOrConnectWithoutObraInput[]
    upsert?: PayrollPeriodUpsertWithWhereUniqueWithoutObraInput | PayrollPeriodUpsertWithWhereUniqueWithoutObraInput[]
    createMany?: PayrollPeriodCreateManyObraInputEnvelope
    set?: PayrollPeriodWhereUniqueInput | PayrollPeriodWhereUniqueInput[]
    disconnect?: PayrollPeriodWhereUniqueInput | PayrollPeriodWhereUniqueInput[]
    delete?: PayrollPeriodWhereUniqueInput | PayrollPeriodWhereUniqueInput[]
    connect?: PayrollPeriodWhereUniqueInput | PayrollPeriodWhereUniqueInput[]
    update?: PayrollPeriodUpdateWithWhereUniqueWithoutObraInput | PayrollPeriodUpdateWithWhereUniqueWithoutObraInput[]
    updateMany?: PayrollPeriodUpdateManyWithWhereWithoutObraInput | PayrollPeriodUpdateManyWithWhereWithoutObraInput[]
    deleteMany?: PayrollPeriodScalarWhereInput | PayrollPeriodScalarWhereInput[]
  }

  export type DailyCashRenditionUncheckedUpdateManyWithoutObraNestedInput = {
    create?: XOR<DailyCashRenditionCreateWithoutObraInput, DailyCashRenditionUncheckedCreateWithoutObraInput> | DailyCashRenditionCreateWithoutObraInput[] | DailyCashRenditionUncheckedCreateWithoutObraInput[]
    connectOrCreate?: DailyCashRenditionCreateOrConnectWithoutObraInput | DailyCashRenditionCreateOrConnectWithoutObraInput[]
    upsert?: DailyCashRenditionUpsertWithWhereUniqueWithoutObraInput | DailyCashRenditionUpsertWithWhereUniqueWithoutObraInput[]
    createMany?: DailyCashRenditionCreateManyObraInputEnvelope
    set?: DailyCashRenditionWhereUniqueInput | DailyCashRenditionWhereUniqueInput[]
    disconnect?: DailyCashRenditionWhereUniqueInput | DailyCashRenditionWhereUniqueInput[]
    delete?: DailyCashRenditionWhereUniqueInput | DailyCashRenditionWhereUniqueInput[]
    connect?: DailyCashRenditionWhereUniqueInput | DailyCashRenditionWhereUniqueInput[]
    update?: DailyCashRenditionUpdateWithWhereUniqueWithoutObraInput | DailyCashRenditionUpdateWithWhereUniqueWithoutObraInput[]
    updateMany?: DailyCashRenditionUpdateManyWithWhereWithoutObraInput | DailyCashRenditionUpdateManyWithWhereWithoutObraInput[]
    deleteMany?: DailyCashRenditionScalarWhereInput | DailyCashRenditionScalarWhereInput[]
  }

  export type MaterialGroupCreateNestedOneWithoutMaterialsInput = {
    create?: XOR<MaterialGroupCreateWithoutMaterialsInput, MaterialGroupUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: MaterialGroupCreateOrConnectWithoutMaterialsInput
    connect?: MaterialGroupWhereUniqueInput
  }

  export type MoveCreateNestedManyWithoutMaterialInput = {
    create?: XOR<MoveCreateWithoutMaterialInput, MoveUncheckedCreateWithoutMaterialInput> | MoveCreateWithoutMaterialInput[] | MoveUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: MoveCreateOrConnectWithoutMaterialInput | MoveCreateOrConnectWithoutMaterialInput[]
    createMany?: MoveCreateManyMaterialInputEnvelope
    connect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
  }

  export type ExpenseCreateNestedManyWithoutMaterialInput = {
    create?: XOR<ExpenseCreateWithoutMaterialInput, ExpenseUncheckedCreateWithoutMaterialInput> | ExpenseCreateWithoutMaterialInput[] | ExpenseUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutMaterialInput | ExpenseCreateOrConnectWithoutMaterialInput[]
    createMany?: ExpenseCreateManyMaterialInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type QuotationBaselineItemCreateNestedManyWithoutMaterialInput = {
    create?: XOR<QuotationBaselineItemCreateWithoutMaterialInput, QuotationBaselineItemUncheckedCreateWithoutMaterialInput> | QuotationBaselineItemCreateWithoutMaterialInput[] | QuotationBaselineItemUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: QuotationBaselineItemCreateOrConnectWithoutMaterialInput | QuotationBaselineItemCreateOrConnectWithoutMaterialInput[]
    createMany?: QuotationBaselineItemCreateManyMaterialInputEnvelope
    connect?: QuotationBaselineItemWhereUniqueInput | QuotationBaselineItemWhereUniqueInput[]
  }

  export type QuotationItemCreateNestedManyWithoutMaterialInput = {
    create?: XOR<QuotationItemCreateWithoutMaterialInput, QuotationItemUncheckedCreateWithoutMaterialInput> | QuotationItemCreateWithoutMaterialInput[] | QuotationItemUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: QuotationItemCreateOrConnectWithoutMaterialInput | QuotationItemCreateOrConnectWithoutMaterialInput[]
    createMany?: QuotationItemCreateManyMaterialInputEnvelope
    connect?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
  }

  export type MoveUncheckedCreateNestedManyWithoutMaterialInput = {
    create?: XOR<MoveCreateWithoutMaterialInput, MoveUncheckedCreateWithoutMaterialInput> | MoveCreateWithoutMaterialInput[] | MoveUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: MoveCreateOrConnectWithoutMaterialInput | MoveCreateOrConnectWithoutMaterialInput[]
    createMany?: MoveCreateManyMaterialInputEnvelope
    connect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
  }

  export type ExpenseUncheckedCreateNestedManyWithoutMaterialInput = {
    create?: XOR<ExpenseCreateWithoutMaterialInput, ExpenseUncheckedCreateWithoutMaterialInput> | ExpenseCreateWithoutMaterialInput[] | ExpenseUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutMaterialInput | ExpenseCreateOrConnectWithoutMaterialInput[]
    createMany?: ExpenseCreateManyMaterialInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type QuotationBaselineItemUncheckedCreateNestedManyWithoutMaterialInput = {
    create?: XOR<QuotationBaselineItemCreateWithoutMaterialInput, QuotationBaselineItemUncheckedCreateWithoutMaterialInput> | QuotationBaselineItemCreateWithoutMaterialInput[] | QuotationBaselineItemUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: QuotationBaselineItemCreateOrConnectWithoutMaterialInput | QuotationBaselineItemCreateOrConnectWithoutMaterialInput[]
    createMany?: QuotationBaselineItemCreateManyMaterialInputEnvelope
    connect?: QuotationBaselineItemWhereUniqueInput | QuotationBaselineItemWhereUniqueInput[]
  }

  export type QuotationItemUncheckedCreateNestedManyWithoutMaterialInput = {
    create?: XOR<QuotationItemCreateWithoutMaterialInput, QuotationItemUncheckedCreateWithoutMaterialInput> | QuotationItemCreateWithoutMaterialInput[] | QuotationItemUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: QuotationItemCreateOrConnectWithoutMaterialInput | QuotationItemCreateOrConnectWithoutMaterialInput[]
    createMany?: QuotationItemCreateManyMaterialInputEnvelope
    connect?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumAssetStatusFieldUpdateOperationsInput = {
    set?: $Enums.AssetStatus
  }

  export type MaterialGroupUpdateOneWithoutMaterialsNestedInput = {
    create?: XOR<MaterialGroupCreateWithoutMaterialsInput, MaterialGroupUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: MaterialGroupCreateOrConnectWithoutMaterialsInput
    upsert?: MaterialGroupUpsertWithoutMaterialsInput
    disconnect?: MaterialGroupWhereInput | boolean
    delete?: MaterialGroupWhereInput | boolean
    connect?: MaterialGroupWhereUniqueInput
    update?: XOR<XOR<MaterialGroupUpdateToOneWithWhereWithoutMaterialsInput, MaterialGroupUpdateWithoutMaterialsInput>, MaterialGroupUncheckedUpdateWithoutMaterialsInput>
  }

  export type MoveUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<MoveCreateWithoutMaterialInput, MoveUncheckedCreateWithoutMaterialInput> | MoveCreateWithoutMaterialInput[] | MoveUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: MoveCreateOrConnectWithoutMaterialInput | MoveCreateOrConnectWithoutMaterialInput[]
    upsert?: MoveUpsertWithWhereUniqueWithoutMaterialInput | MoveUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: MoveCreateManyMaterialInputEnvelope
    set?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    disconnect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    delete?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    connect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    update?: MoveUpdateWithWhereUniqueWithoutMaterialInput | MoveUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: MoveUpdateManyWithWhereWithoutMaterialInput | MoveUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: MoveScalarWhereInput | MoveScalarWhereInput[]
  }

  export type ExpenseUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<ExpenseCreateWithoutMaterialInput, ExpenseUncheckedCreateWithoutMaterialInput> | ExpenseCreateWithoutMaterialInput[] | ExpenseUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutMaterialInput | ExpenseCreateOrConnectWithoutMaterialInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutMaterialInput | ExpenseUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: ExpenseCreateManyMaterialInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutMaterialInput | ExpenseUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutMaterialInput | ExpenseUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type QuotationBaselineItemUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<QuotationBaselineItemCreateWithoutMaterialInput, QuotationBaselineItemUncheckedCreateWithoutMaterialInput> | QuotationBaselineItemCreateWithoutMaterialInput[] | QuotationBaselineItemUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: QuotationBaselineItemCreateOrConnectWithoutMaterialInput | QuotationBaselineItemCreateOrConnectWithoutMaterialInput[]
    upsert?: QuotationBaselineItemUpsertWithWhereUniqueWithoutMaterialInput | QuotationBaselineItemUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: QuotationBaselineItemCreateManyMaterialInputEnvelope
    set?: QuotationBaselineItemWhereUniqueInput | QuotationBaselineItemWhereUniqueInput[]
    disconnect?: QuotationBaselineItemWhereUniqueInput | QuotationBaselineItemWhereUniqueInput[]
    delete?: QuotationBaselineItemWhereUniqueInput | QuotationBaselineItemWhereUniqueInput[]
    connect?: QuotationBaselineItemWhereUniqueInput | QuotationBaselineItemWhereUniqueInput[]
    update?: QuotationBaselineItemUpdateWithWhereUniqueWithoutMaterialInput | QuotationBaselineItemUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: QuotationBaselineItemUpdateManyWithWhereWithoutMaterialInput | QuotationBaselineItemUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: QuotationBaselineItemScalarWhereInput | QuotationBaselineItemScalarWhereInput[]
  }

  export type QuotationItemUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<QuotationItemCreateWithoutMaterialInput, QuotationItemUncheckedCreateWithoutMaterialInput> | QuotationItemCreateWithoutMaterialInput[] | QuotationItemUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: QuotationItemCreateOrConnectWithoutMaterialInput | QuotationItemCreateOrConnectWithoutMaterialInput[]
    upsert?: QuotationItemUpsertWithWhereUniqueWithoutMaterialInput | QuotationItemUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: QuotationItemCreateManyMaterialInputEnvelope
    set?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    disconnect?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    delete?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    connect?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    update?: QuotationItemUpdateWithWhereUniqueWithoutMaterialInput | QuotationItemUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: QuotationItemUpdateManyWithWhereWithoutMaterialInput | QuotationItemUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: QuotationItemScalarWhereInput | QuotationItemScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MoveUncheckedUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<MoveCreateWithoutMaterialInput, MoveUncheckedCreateWithoutMaterialInput> | MoveCreateWithoutMaterialInput[] | MoveUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: MoveCreateOrConnectWithoutMaterialInput | MoveCreateOrConnectWithoutMaterialInput[]
    upsert?: MoveUpsertWithWhereUniqueWithoutMaterialInput | MoveUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: MoveCreateManyMaterialInputEnvelope
    set?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    disconnect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    delete?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    connect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    update?: MoveUpdateWithWhereUniqueWithoutMaterialInput | MoveUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: MoveUpdateManyWithWhereWithoutMaterialInput | MoveUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: MoveScalarWhereInput | MoveScalarWhereInput[]
  }

  export type ExpenseUncheckedUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<ExpenseCreateWithoutMaterialInput, ExpenseUncheckedCreateWithoutMaterialInput> | ExpenseCreateWithoutMaterialInput[] | ExpenseUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutMaterialInput | ExpenseCreateOrConnectWithoutMaterialInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutMaterialInput | ExpenseUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: ExpenseCreateManyMaterialInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutMaterialInput | ExpenseUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutMaterialInput | ExpenseUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type QuotationBaselineItemUncheckedUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<QuotationBaselineItemCreateWithoutMaterialInput, QuotationBaselineItemUncheckedCreateWithoutMaterialInput> | QuotationBaselineItemCreateWithoutMaterialInput[] | QuotationBaselineItemUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: QuotationBaselineItemCreateOrConnectWithoutMaterialInput | QuotationBaselineItemCreateOrConnectWithoutMaterialInput[]
    upsert?: QuotationBaselineItemUpsertWithWhereUniqueWithoutMaterialInput | QuotationBaselineItemUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: QuotationBaselineItemCreateManyMaterialInputEnvelope
    set?: QuotationBaselineItemWhereUniqueInput | QuotationBaselineItemWhereUniqueInput[]
    disconnect?: QuotationBaselineItemWhereUniqueInput | QuotationBaselineItemWhereUniqueInput[]
    delete?: QuotationBaselineItemWhereUniqueInput | QuotationBaselineItemWhereUniqueInput[]
    connect?: QuotationBaselineItemWhereUniqueInput | QuotationBaselineItemWhereUniqueInput[]
    update?: QuotationBaselineItemUpdateWithWhereUniqueWithoutMaterialInput | QuotationBaselineItemUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: QuotationBaselineItemUpdateManyWithWhereWithoutMaterialInput | QuotationBaselineItemUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: QuotationBaselineItemScalarWhereInput | QuotationBaselineItemScalarWhereInput[]
  }

  export type QuotationItemUncheckedUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<QuotationItemCreateWithoutMaterialInput, QuotationItemUncheckedCreateWithoutMaterialInput> | QuotationItemCreateWithoutMaterialInput[] | QuotationItemUncheckedCreateWithoutMaterialInput[]
    connectOrCreate?: QuotationItemCreateOrConnectWithoutMaterialInput | QuotationItemCreateOrConnectWithoutMaterialInput[]
    upsert?: QuotationItemUpsertWithWhereUniqueWithoutMaterialInput | QuotationItemUpsertWithWhereUniqueWithoutMaterialInput[]
    createMany?: QuotationItemCreateManyMaterialInputEnvelope
    set?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    disconnect?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    delete?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    connect?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    update?: QuotationItemUpdateWithWhereUniqueWithoutMaterialInput | QuotationItemUpdateWithWhereUniqueWithoutMaterialInput[]
    updateMany?: QuotationItemUpdateManyWithWhereWithoutMaterialInput | QuotationItemUpdateManyWithWhereWithoutMaterialInput[]
    deleteMany?: QuotationItemScalarWhereInput | QuotationItemScalarWhereInput[]
  }

  export type MoveCreateNestedManyWithoutProveedorInput = {
    create?: XOR<MoveCreateWithoutProveedorInput, MoveUncheckedCreateWithoutProveedorInput> | MoveCreateWithoutProveedorInput[] | MoveUncheckedCreateWithoutProveedorInput[]
    connectOrCreate?: MoveCreateOrConnectWithoutProveedorInput | MoveCreateOrConnectWithoutProveedorInput[]
    createMany?: MoveCreateManyProveedorInputEnvelope
    connect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
  }

  export type ExpenseCreateNestedManyWithoutProveedorInput = {
    create?: XOR<ExpenseCreateWithoutProveedorInput, ExpenseUncheckedCreateWithoutProveedorInput> | ExpenseCreateWithoutProveedorInput[] | ExpenseUncheckedCreateWithoutProveedorInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutProveedorInput | ExpenseCreateOrConnectWithoutProveedorInput[]
    createMany?: ExpenseCreateManyProveedorInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type QuotationCreateNestedManyWithoutProveedorInput = {
    create?: XOR<QuotationCreateWithoutProveedorInput, QuotationUncheckedCreateWithoutProveedorInput> | QuotationCreateWithoutProveedorInput[] | QuotationUncheckedCreateWithoutProveedorInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutProveedorInput | QuotationCreateOrConnectWithoutProveedorInput[]
    createMany?: QuotationCreateManyProveedorInputEnvelope
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
  }

  export type PurchaseDeliveryLogCreateNestedManyWithoutProveedorInput = {
    create?: XOR<PurchaseDeliveryLogCreateWithoutProveedorInput, PurchaseDeliveryLogUncheckedCreateWithoutProveedorInput> | PurchaseDeliveryLogCreateWithoutProveedorInput[] | PurchaseDeliveryLogUncheckedCreateWithoutProveedorInput[]
    connectOrCreate?: PurchaseDeliveryLogCreateOrConnectWithoutProveedorInput | PurchaseDeliveryLogCreateOrConnectWithoutProveedorInput[]
    createMany?: PurchaseDeliveryLogCreateManyProveedorInputEnvelope
    connect?: PurchaseDeliveryLogWhereUniqueInput | PurchaseDeliveryLogWhereUniqueInput[]
  }

  export type MoveUncheckedCreateNestedManyWithoutProveedorInput = {
    create?: XOR<MoveCreateWithoutProveedorInput, MoveUncheckedCreateWithoutProveedorInput> | MoveCreateWithoutProveedorInput[] | MoveUncheckedCreateWithoutProveedorInput[]
    connectOrCreate?: MoveCreateOrConnectWithoutProveedorInput | MoveCreateOrConnectWithoutProveedorInput[]
    createMany?: MoveCreateManyProveedorInputEnvelope
    connect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
  }

  export type ExpenseUncheckedCreateNestedManyWithoutProveedorInput = {
    create?: XOR<ExpenseCreateWithoutProveedorInput, ExpenseUncheckedCreateWithoutProveedorInput> | ExpenseCreateWithoutProveedorInput[] | ExpenseUncheckedCreateWithoutProveedorInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutProveedorInput | ExpenseCreateOrConnectWithoutProveedorInput[]
    createMany?: ExpenseCreateManyProveedorInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type QuotationUncheckedCreateNestedManyWithoutProveedorInput = {
    create?: XOR<QuotationCreateWithoutProveedorInput, QuotationUncheckedCreateWithoutProveedorInput> | QuotationCreateWithoutProveedorInput[] | QuotationUncheckedCreateWithoutProveedorInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutProveedorInput | QuotationCreateOrConnectWithoutProveedorInput[]
    createMany?: QuotationCreateManyProveedorInputEnvelope
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
  }

  export type PurchaseDeliveryLogUncheckedCreateNestedManyWithoutProveedorInput = {
    create?: XOR<PurchaseDeliveryLogCreateWithoutProveedorInput, PurchaseDeliveryLogUncheckedCreateWithoutProveedorInput> | PurchaseDeliveryLogCreateWithoutProveedorInput[] | PurchaseDeliveryLogUncheckedCreateWithoutProveedorInput[]
    connectOrCreate?: PurchaseDeliveryLogCreateOrConnectWithoutProveedorInput | PurchaseDeliveryLogCreateOrConnectWithoutProveedorInput[]
    createMany?: PurchaseDeliveryLogCreateManyProveedorInputEnvelope
    connect?: PurchaseDeliveryLogWhereUniqueInput | PurchaseDeliveryLogWhereUniqueInput[]
  }

  export type MoveUpdateManyWithoutProveedorNestedInput = {
    create?: XOR<MoveCreateWithoutProveedorInput, MoveUncheckedCreateWithoutProveedorInput> | MoveCreateWithoutProveedorInput[] | MoveUncheckedCreateWithoutProveedorInput[]
    connectOrCreate?: MoveCreateOrConnectWithoutProveedorInput | MoveCreateOrConnectWithoutProveedorInput[]
    upsert?: MoveUpsertWithWhereUniqueWithoutProveedorInput | MoveUpsertWithWhereUniqueWithoutProveedorInput[]
    createMany?: MoveCreateManyProveedorInputEnvelope
    set?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    disconnect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    delete?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    connect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    update?: MoveUpdateWithWhereUniqueWithoutProveedorInput | MoveUpdateWithWhereUniqueWithoutProveedorInput[]
    updateMany?: MoveUpdateManyWithWhereWithoutProveedorInput | MoveUpdateManyWithWhereWithoutProveedorInput[]
    deleteMany?: MoveScalarWhereInput | MoveScalarWhereInput[]
  }

  export type ExpenseUpdateManyWithoutProveedorNestedInput = {
    create?: XOR<ExpenseCreateWithoutProveedorInput, ExpenseUncheckedCreateWithoutProveedorInput> | ExpenseCreateWithoutProveedorInput[] | ExpenseUncheckedCreateWithoutProveedorInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutProveedorInput | ExpenseCreateOrConnectWithoutProveedorInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutProveedorInput | ExpenseUpsertWithWhereUniqueWithoutProveedorInput[]
    createMany?: ExpenseCreateManyProveedorInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutProveedorInput | ExpenseUpdateWithWhereUniqueWithoutProveedorInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutProveedorInput | ExpenseUpdateManyWithWhereWithoutProveedorInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type QuotationUpdateManyWithoutProveedorNestedInput = {
    create?: XOR<QuotationCreateWithoutProveedorInput, QuotationUncheckedCreateWithoutProveedorInput> | QuotationCreateWithoutProveedorInput[] | QuotationUncheckedCreateWithoutProveedorInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutProveedorInput | QuotationCreateOrConnectWithoutProveedorInput[]
    upsert?: QuotationUpsertWithWhereUniqueWithoutProveedorInput | QuotationUpsertWithWhereUniqueWithoutProveedorInput[]
    createMany?: QuotationCreateManyProveedorInputEnvelope
    set?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    disconnect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    delete?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    update?: QuotationUpdateWithWhereUniqueWithoutProveedorInput | QuotationUpdateWithWhereUniqueWithoutProveedorInput[]
    updateMany?: QuotationUpdateManyWithWhereWithoutProveedorInput | QuotationUpdateManyWithWhereWithoutProveedorInput[]
    deleteMany?: QuotationScalarWhereInput | QuotationScalarWhereInput[]
  }

  export type PurchaseDeliveryLogUpdateManyWithoutProveedorNestedInput = {
    create?: XOR<PurchaseDeliveryLogCreateWithoutProveedorInput, PurchaseDeliveryLogUncheckedCreateWithoutProveedorInput> | PurchaseDeliveryLogCreateWithoutProveedorInput[] | PurchaseDeliveryLogUncheckedCreateWithoutProveedorInput[]
    connectOrCreate?: PurchaseDeliveryLogCreateOrConnectWithoutProveedorInput | PurchaseDeliveryLogCreateOrConnectWithoutProveedorInput[]
    upsert?: PurchaseDeliveryLogUpsertWithWhereUniqueWithoutProveedorInput | PurchaseDeliveryLogUpsertWithWhereUniqueWithoutProveedorInput[]
    createMany?: PurchaseDeliveryLogCreateManyProveedorInputEnvelope
    set?: PurchaseDeliveryLogWhereUniqueInput | PurchaseDeliveryLogWhereUniqueInput[]
    disconnect?: PurchaseDeliveryLogWhereUniqueInput | PurchaseDeliveryLogWhereUniqueInput[]
    delete?: PurchaseDeliveryLogWhereUniqueInput | PurchaseDeliveryLogWhereUniqueInput[]
    connect?: PurchaseDeliveryLogWhereUniqueInput | PurchaseDeliveryLogWhereUniqueInput[]
    update?: PurchaseDeliveryLogUpdateWithWhereUniqueWithoutProveedorInput | PurchaseDeliveryLogUpdateWithWhereUniqueWithoutProveedorInput[]
    updateMany?: PurchaseDeliveryLogUpdateManyWithWhereWithoutProveedorInput | PurchaseDeliveryLogUpdateManyWithWhereWithoutProveedorInput[]
    deleteMany?: PurchaseDeliveryLogScalarWhereInput | PurchaseDeliveryLogScalarWhereInput[]
  }

  export type MoveUncheckedUpdateManyWithoutProveedorNestedInput = {
    create?: XOR<MoveCreateWithoutProveedorInput, MoveUncheckedCreateWithoutProveedorInput> | MoveCreateWithoutProveedorInput[] | MoveUncheckedCreateWithoutProveedorInput[]
    connectOrCreate?: MoveCreateOrConnectWithoutProveedorInput | MoveCreateOrConnectWithoutProveedorInput[]
    upsert?: MoveUpsertWithWhereUniqueWithoutProveedorInput | MoveUpsertWithWhereUniqueWithoutProveedorInput[]
    createMany?: MoveCreateManyProveedorInputEnvelope
    set?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    disconnect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    delete?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    connect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    update?: MoveUpdateWithWhereUniqueWithoutProveedorInput | MoveUpdateWithWhereUniqueWithoutProveedorInput[]
    updateMany?: MoveUpdateManyWithWhereWithoutProveedorInput | MoveUpdateManyWithWhereWithoutProveedorInput[]
    deleteMany?: MoveScalarWhereInput | MoveScalarWhereInput[]
  }

  export type ExpenseUncheckedUpdateManyWithoutProveedorNestedInput = {
    create?: XOR<ExpenseCreateWithoutProveedorInput, ExpenseUncheckedCreateWithoutProveedorInput> | ExpenseCreateWithoutProveedorInput[] | ExpenseUncheckedCreateWithoutProveedorInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutProveedorInput | ExpenseCreateOrConnectWithoutProveedorInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutProveedorInput | ExpenseUpsertWithWhereUniqueWithoutProveedorInput[]
    createMany?: ExpenseCreateManyProveedorInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutProveedorInput | ExpenseUpdateWithWhereUniqueWithoutProveedorInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutProveedorInput | ExpenseUpdateManyWithWhereWithoutProveedorInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type QuotationUncheckedUpdateManyWithoutProveedorNestedInput = {
    create?: XOR<QuotationCreateWithoutProveedorInput, QuotationUncheckedCreateWithoutProveedorInput> | QuotationCreateWithoutProveedorInput[] | QuotationUncheckedCreateWithoutProveedorInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutProveedorInput | QuotationCreateOrConnectWithoutProveedorInput[]
    upsert?: QuotationUpsertWithWhereUniqueWithoutProveedorInput | QuotationUpsertWithWhereUniqueWithoutProveedorInput[]
    createMany?: QuotationCreateManyProveedorInputEnvelope
    set?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    disconnect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    delete?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    update?: QuotationUpdateWithWhereUniqueWithoutProveedorInput | QuotationUpdateWithWhereUniqueWithoutProveedorInput[]
    updateMany?: QuotationUpdateManyWithWhereWithoutProveedorInput | QuotationUpdateManyWithWhereWithoutProveedorInput[]
    deleteMany?: QuotationScalarWhereInput | QuotationScalarWhereInput[]
  }

  export type PurchaseDeliveryLogUncheckedUpdateManyWithoutProveedorNestedInput = {
    create?: XOR<PurchaseDeliveryLogCreateWithoutProveedorInput, PurchaseDeliveryLogUncheckedCreateWithoutProveedorInput> | PurchaseDeliveryLogCreateWithoutProveedorInput[] | PurchaseDeliveryLogUncheckedCreateWithoutProveedorInput[]
    connectOrCreate?: PurchaseDeliveryLogCreateOrConnectWithoutProveedorInput | PurchaseDeliveryLogCreateOrConnectWithoutProveedorInput[]
    upsert?: PurchaseDeliveryLogUpsertWithWhereUniqueWithoutProveedorInput | PurchaseDeliveryLogUpsertWithWhereUniqueWithoutProveedorInput[]
    createMany?: PurchaseDeliveryLogCreateManyProveedorInputEnvelope
    set?: PurchaseDeliveryLogWhereUniqueInput | PurchaseDeliveryLogWhereUniqueInput[]
    disconnect?: PurchaseDeliveryLogWhereUniqueInput | PurchaseDeliveryLogWhereUniqueInput[]
    delete?: PurchaseDeliveryLogWhereUniqueInput | PurchaseDeliveryLogWhereUniqueInput[]
    connect?: PurchaseDeliveryLogWhereUniqueInput | PurchaseDeliveryLogWhereUniqueInput[]
    update?: PurchaseDeliveryLogUpdateWithWhereUniqueWithoutProveedorInput | PurchaseDeliveryLogUpdateWithWhereUniqueWithoutProveedorInput[]
    updateMany?: PurchaseDeliveryLogUpdateManyWithWhereWithoutProveedorInput | PurchaseDeliveryLogUpdateManyWithWhereWithoutProveedorInput[]
    deleteMany?: PurchaseDeliveryLogScalarWhereInput | PurchaseDeliveryLogScalarWhereInput[]
  }

  export type ObraCreateNestedOneWithoutFrentesInput = {
    create?: XOR<ObraCreateWithoutFrentesInput, ObraUncheckedCreateWithoutFrentesInput>
    connectOrCreate?: ObraCreateOrConnectWithoutFrentesInput
    connect?: ObraWhereUniqueInput
  }

  export type MoveCreateNestedManyWithoutFrenteInput = {
    create?: XOR<MoveCreateWithoutFrenteInput, MoveUncheckedCreateWithoutFrenteInput> | MoveCreateWithoutFrenteInput[] | MoveUncheckedCreateWithoutFrenteInput[]
    connectOrCreate?: MoveCreateOrConnectWithoutFrenteInput | MoveCreateOrConnectWithoutFrenteInput[]
    createMany?: MoveCreateManyFrenteInputEnvelope
    connect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
  }

  export type IncomeCreateNestedManyWithoutFrenteInput = {
    create?: XOR<IncomeCreateWithoutFrenteInput, IncomeUncheckedCreateWithoutFrenteInput> | IncomeCreateWithoutFrenteInput[] | IncomeUncheckedCreateWithoutFrenteInput[]
    connectOrCreate?: IncomeCreateOrConnectWithoutFrenteInput | IncomeCreateOrConnectWithoutFrenteInput[]
    createMany?: IncomeCreateManyFrenteInputEnvelope
    connect?: IncomeWhereUniqueInput | IncomeWhereUniqueInput[]
  }

  export type ExpenseCreateNestedManyWithoutFrenteInput = {
    create?: XOR<ExpenseCreateWithoutFrenteInput, ExpenseUncheckedCreateWithoutFrenteInput> | ExpenseCreateWithoutFrenteInput[] | ExpenseUncheckedCreateWithoutFrenteInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutFrenteInput | ExpenseCreateOrConnectWithoutFrenteInput[]
    createMany?: ExpenseCreateManyFrenteInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type MoveUncheckedCreateNestedManyWithoutFrenteInput = {
    create?: XOR<MoveCreateWithoutFrenteInput, MoveUncheckedCreateWithoutFrenteInput> | MoveCreateWithoutFrenteInput[] | MoveUncheckedCreateWithoutFrenteInput[]
    connectOrCreate?: MoveCreateOrConnectWithoutFrenteInput | MoveCreateOrConnectWithoutFrenteInput[]
    createMany?: MoveCreateManyFrenteInputEnvelope
    connect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
  }

  export type IncomeUncheckedCreateNestedManyWithoutFrenteInput = {
    create?: XOR<IncomeCreateWithoutFrenteInput, IncomeUncheckedCreateWithoutFrenteInput> | IncomeCreateWithoutFrenteInput[] | IncomeUncheckedCreateWithoutFrenteInput[]
    connectOrCreate?: IncomeCreateOrConnectWithoutFrenteInput | IncomeCreateOrConnectWithoutFrenteInput[]
    createMany?: IncomeCreateManyFrenteInputEnvelope
    connect?: IncomeWhereUniqueInput | IncomeWhereUniqueInput[]
  }

  export type ExpenseUncheckedCreateNestedManyWithoutFrenteInput = {
    create?: XOR<ExpenseCreateWithoutFrenteInput, ExpenseUncheckedCreateWithoutFrenteInput> | ExpenseCreateWithoutFrenteInput[] | ExpenseUncheckedCreateWithoutFrenteInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutFrenteInput | ExpenseCreateOrConnectWithoutFrenteInput[]
    createMany?: ExpenseCreateManyFrenteInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type ObraUpdateOneRequiredWithoutFrentesNestedInput = {
    create?: XOR<ObraCreateWithoutFrentesInput, ObraUncheckedCreateWithoutFrentesInput>
    connectOrCreate?: ObraCreateOrConnectWithoutFrentesInput
    upsert?: ObraUpsertWithoutFrentesInput
    connect?: ObraWhereUniqueInput
    update?: XOR<XOR<ObraUpdateToOneWithWhereWithoutFrentesInput, ObraUpdateWithoutFrentesInput>, ObraUncheckedUpdateWithoutFrentesInput>
  }

  export type MoveUpdateManyWithoutFrenteNestedInput = {
    create?: XOR<MoveCreateWithoutFrenteInput, MoveUncheckedCreateWithoutFrenteInput> | MoveCreateWithoutFrenteInput[] | MoveUncheckedCreateWithoutFrenteInput[]
    connectOrCreate?: MoveCreateOrConnectWithoutFrenteInput | MoveCreateOrConnectWithoutFrenteInput[]
    upsert?: MoveUpsertWithWhereUniqueWithoutFrenteInput | MoveUpsertWithWhereUniqueWithoutFrenteInput[]
    createMany?: MoveCreateManyFrenteInputEnvelope
    set?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    disconnect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    delete?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    connect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    update?: MoveUpdateWithWhereUniqueWithoutFrenteInput | MoveUpdateWithWhereUniqueWithoutFrenteInput[]
    updateMany?: MoveUpdateManyWithWhereWithoutFrenteInput | MoveUpdateManyWithWhereWithoutFrenteInput[]
    deleteMany?: MoveScalarWhereInput | MoveScalarWhereInput[]
  }

  export type IncomeUpdateManyWithoutFrenteNestedInput = {
    create?: XOR<IncomeCreateWithoutFrenteInput, IncomeUncheckedCreateWithoutFrenteInput> | IncomeCreateWithoutFrenteInput[] | IncomeUncheckedCreateWithoutFrenteInput[]
    connectOrCreate?: IncomeCreateOrConnectWithoutFrenteInput | IncomeCreateOrConnectWithoutFrenteInput[]
    upsert?: IncomeUpsertWithWhereUniqueWithoutFrenteInput | IncomeUpsertWithWhereUniqueWithoutFrenteInput[]
    createMany?: IncomeCreateManyFrenteInputEnvelope
    set?: IncomeWhereUniqueInput | IncomeWhereUniqueInput[]
    disconnect?: IncomeWhereUniqueInput | IncomeWhereUniqueInput[]
    delete?: IncomeWhereUniqueInput | IncomeWhereUniqueInput[]
    connect?: IncomeWhereUniqueInput | IncomeWhereUniqueInput[]
    update?: IncomeUpdateWithWhereUniqueWithoutFrenteInput | IncomeUpdateWithWhereUniqueWithoutFrenteInput[]
    updateMany?: IncomeUpdateManyWithWhereWithoutFrenteInput | IncomeUpdateManyWithWhereWithoutFrenteInput[]
    deleteMany?: IncomeScalarWhereInput | IncomeScalarWhereInput[]
  }

  export type ExpenseUpdateManyWithoutFrenteNestedInput = {
    create?: XOR<ExpenseCreateWithoutFrenteInput, ExpenseUncheckedCreateWithoutFrenteInput> | ExpenseCreateWithoutFrenteInput[] | ExpenseUncheckedCreateWithoutFrenteInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutFrenteInput | ExpenseCreateOrConnectWithoutFrenteInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutFrenteInput | ExpenseUpsertWithWhereUniqueWithoutFrenteInput[]
    createMany?: ExpenseCreateManyFrenteInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutFrenteInput | ExpenseUpdateWithWhereUniqueWithoutFrenteInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutFrenteInput | ExpenseUpdateManyWithWhereWithoutFrenteInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type MoveUncheckedUpdateManyWithoutFrenteNestedInput = {
    create?: XOR<MoveCreateWithoutFrenteInput, MoveUncheckedCreateWithoutFrenteInput> | MoveCreateWithoutFrenteInput[] | MoveUncheckedCreateWithoutFrenteInput[]
    connectOrCreate?: MoveCreateOrConnectWithoutFrenteInput | MoveCreateOrConnectWithoutFrenteInput[]
    upsert?: MoveUpsertWithWhereUniqueWithoutFrenteInput | MoveUpsertWithWhereUniqueWithoutFrenteInput[]
    createMany?: MoveCreateManyFrenteInputEnvelope
    set?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    disconnect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    delete?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    connect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    update?: MoveUpdateWithWhereUniqueWithoutFrenteInput | MoveUpdateWithWhereUniqueWithoutFrenteInput[]
    updateMany?: MoveUpdateManyWithWhereWithoutFrenteInput | MoveUpdateManyWithWhereWithoutFrenteInput[]
    deleteMany?: MoveScalarWhereInput | MoveScalarWhereInput[]
  }

  export type IncomeUncheckedUpdateManyWithoutFrenteNestedInput = {
    create?: XOR<IncomeCreateWithoutFrenteInput, IncomeUncheckedCreateWithoutFrenteInput> | IncomeCreateWithoutFrenteInput[] | IncomeUncheckedCreateWithoutFrenteInput[]
    connectOrCreate?: IncomeCreateOrConnectWithoutFrenteInput | IncomeCreateOrConnectWithoutFrenteInput[]
    upsert?: IncomeUpsertWithWhereUniqueWithoutFrenteInput | IncomeUpsertWithWhereUniqueWithoutFrenteInput[]
    createMany?: IncomeCreateManyFrenteInputEnvelope
    set?: IncomeWhereUniqueInput | IncomeWhereUniqueInput[]
    disconnect?: IncomeWhereUniqueInput | IncomeWhereUniqueInput[]
    delete?: IncomeWhereUniqueInput | IncomeWhereUniqueInput[]
    connect?: IncomeWhereUniqueInput | IncomeWhereUniqueInput[]
    update?: IncomeUpdateWithWhereUniqueWithoutFrenteInput | IncomeUpdateWithWhereUniqueWithoutFrenteInput[]
    updateMany?: IncomeUpdateManyWithWhereWithoutFrenteInput | IncomeUpdateManyWithWhereWithoutFrenteInput[]
    deleteMany?: IncomeScalarWhereInput | IncomeScalarWhereInput[]
  }

  export type ExpenseUncheckedUpdateManyWithoutFrenteNestedInput = {
    create?: XOR<ExpenseCreateWithoutFrenteInput, ExpenseUncheckedCreateWithoutFrenteInput> | ExpenseCreateWithoutFrenteInput[] | ExpenseUncheckedCreateWithoutFrenteInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutFrenteInput | ExpenseCreateOrConnectWithoutFrenteInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutFrenteInput | ExpenseUpsertWithWhereUniqueWithoutFrenteInput[]
    createMany?: ExpenseCreateManyFrenteInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutFrenteInput | ExpenseUpdateWithWhereUniqueWithoutFrenteInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutFrenteInput | ExpenseUpdateManyWithWhereWithoutFrenteInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type MaterialGroupCreateNestedOneWithoutChildrenInput = {
    create?: XOR<MaterialGroupCreateWithoutChildrenInput, MaterialGroupUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: MaterialGroupCreateOrConnectWithoutChildrenInput
    connect?: MaterialGroupWhereUniqueInput
  }

  export type MaterialGroupCreateNestedManyWithoutParentInput = {
    create?: XOR<MaterialGroupCreateWithoutParentInput, MaterialGroupUncheckedCreateWithoutParentInput> | MaterialGroupCreateWithoutParentInput[] | MaterialGroupUncheckedCreateWithoutParentInput[]
    connectOrCreate?: MaterialGroupCreateOrConnectWithoutParentInput | MaterialGroupCreateOrConnectWithoutParentInput[]
    createMany?: MaterialGroupCreateManyParentInputEnvelope
    connect?: MaterialGroupWhereUniqueInput | MaterialGroupWhereUniqueInput[]
  }

  export type MaterialCreateNestedManyWithoutGroupInput = {
    create?: XOR<MaterialCreateWithoutGroupInput, MaterialUncheckedCreateWithoutGroupInput> | MaterialCreateWithoutGroupInput[] | MaterialUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutGroupInput | MaterialCreateOrConnectWithoutGroupInput[]
    createMany?: MaterialCreateManyGroupInputEnvelope
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
  }

  export type MaterialGroupUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<MaterialGroupCreateWithoutParentInput, MaterialGroupUncheckedCreateWithoutParentInput> | MaterialGroupCreateWithoutParentInput[] | MaterialGroupUncheckedCreateWithoutParentInput[]
    connectOrCreate?: MaterialGroupCreateOrConnectWithoutParentInput | MaterialGroupCreateOrConnectWithoutParentInput[]
    createMany?: MaterialGroupCreateManyParentInputEnvelope
    connect?: MaterialGroupWhereUniqueInput | MaterialGroupWhereUniqueInput[]
  }

  export type MaterialUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<MaterialCreateWithoutGroupInput, MaterialUncheckedCreateWithoutGroupInput> | MaterialCreateWithoutGroupInput[] | MaterialUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutGroupInput | MaterialCreateOrConnectWithoutGroupInput[]
    createMany?: MaterialCreateManyGroupInputEnvelope
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type MaterialGroupUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<MaterialGroupCreateWithoutChildrenInput, MaterialGroupUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: MaterialGroupCreateOrConnectWithoutChildrenInput
    upsert?: MaterialGroupUpsertWithoutChildrenInput
    disconnect?: MaterialGroupWhereInput | boolean
    delete?: MaterialGroupWhereInput | boolean
    connect?: MaterialGroupWhereUniqueInput
    update?: XOR<XOR<MaterialGroupUpdateToOneWithWhereWithoutChildrenInput, MaterialGroupUpdateWithoutChildrenInput>, MaterialGroupUncheckedUpdateWithoutChildrenInput>
  }

  export type MaterialGroupUpdateManyWithoutParentNestedInput = {
    create?: XOR<MaterialGroupCreateWithoutParentInput, MaterialGroupUncheckedCreateWithoutParentInput> | MaterialGroupCreateWithoutParentInput[] | MaterialGroupUncheckedCreateWithoutParentInput[]
    connectOrCreate?: MaterialGroupCreateOrConnectWithoutParentInput | MaterialGroupCreateOrConnectWithoutParentInput[]
    upsert?: MaterialGroupUpsertWithWhereUniqueWithoutParentInput | MaterialGroupUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: MaterialGroupCreateManyParentInputEnvelope
    set?: MaterialGroupWhereUniqueInput | MaterialGroupWhereUniqueInput[]
    disconnect?: MaterialGroupWhereUniqueInput | MaterialGroupWhereUniqueInput[]
    delete?: MaterialGroupWhereUniqueInput | MaterialGroupWhereUniqueInput[]
    connect?: MaterialGroupWhereUniqueInput | MaterialGroupWhereUniqueInput[]
    update?: MaterialGroupUpdateWithWhereUniqueWithoutParentInput | MaterialGroupUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: MaterialGroupUpdateManyWithWhereWithoutParentInput | MaterialGroupUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: MaterialGroupScalarWhereInput | MaterialGroupScalarWhereInput[]
  }

  export type MaterialUpdateManyWithoutGroupNestedInput = {
    create?: XOR<MaterialCreateWithoutGroupInput, MaterialUncheckedCreateWithoutGroupInput> | MaterialCreateWithoutGroupInput[] | MaterialUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutGroupInput | MaterialCreateOrConnectWithoutGroupInput[]
    upsert?: MaterialUpsertWithWhereUniqueWithoutGroupInput | MaterialUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: MaterialCreateManyGroupInputEnvelope
    set?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    disconnect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    delete?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    update?: MaterialUpdateWithWhereUniqueWithoutGroupInput | MaterialUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: MaterialUpdateManyWithWhereWithoutGroupInput | MaterialUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
  }

  export type MaterialGroupUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<MaterialGroupCreateWithoutParentInput, MaterialGroupUncheckedCreateWithoutParentInput> | MaterialGroupCreateWithoutParentInput[] | MaterialGroupUncheckedCreateWithoutParentInput[]
    connectOrCreate?: MaterialGroupCreateOrConnectWithoutParentInput | MaterialGroupCreateOrConnectWithoutParentInput[]
    upsert?: MaterialGroupUpsertWithWhereUniqueWithoutParentInput | MaterialGroupUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: MaterialGroupCreateManyParentInputEnvelope
    set?: MaterialGroupWhereUniqueInput | MaterialGroupWhereUniqueInput[]
    disconnect?: MaterialGroupWhereUniqueInput | MaterialGroupWhereUniqueInput[]
    delete?: MaterialGroupWhereUniqueInput | MaterialGroupWhereUniqueInput[]
    connect?: MaterialGroupWhereUniqueInput | MaterialGroupWhereUniqueInput[]
    update?: MaterialGroupUpdateWithWhereUniqueWithoutParentInput | MaterialGroupUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: MaterialGroupUpdateManyWithWhereWithoutParentInput | MaterialGroupUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: MaterialGroupScalarWhereInput | MaterialGroupScalarWhereInput[]
  }

  export type MaterialUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<MaterialCreateWithoutGroupInput, MaterialUncheckedCreateWithoutGroupInput> | MaterialCreateWithoutGroupInput[] | MaterialUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutGroupInput | MaterialCreateOrConnectWithoutGroupInput[]
    upsert?: MaterialUpsertWithWhereUniqueWithoutGroupInput | MaterialUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: MaterialCreateManyGroupInputEnvelope
    set?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    disconnect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    delete?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    update?: MaterialUpdateWithWhereUniqueWithoutGroupInput | MaterialUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: MaterialUpdateManyWithWhereWithoutGroupInput | MaterialUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
  }

  export type ObraCreateNestedOneWithoutMovesInput = {
    create?: XOR<ObraCreateWithoutMovesInput, ObraUncheckedCreateWithoutMovesInput>
    connectOrCreate?: ObraCreateOrConnectWithoutMovesInput
    connect?: ObraWhereUniqueInput
  }

  export type FrenteCreateNestedOneWithoutMovesInput = {
    create?: XOR<FrenteCreateWithoutMovesInput, FrenteUncheckedCreateWithoutMovesInput>
    connectOrCreate?: FrenteCreateOrConnectWithoutMovesInput
    connect?: FrenteWhereUniqueInput
  }

  export type MaterialCreateNestedOneWithoutMovesInput = {
    create?: XOR<MaterialCreateWithoutMovesInput, MaterialUncheckedCreateWithoutMovesInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutMovesInput
    connect?: MaterialWhereUniqueInput
  }

  export type ProveedorCreateNestedOneWithoutMovesInput = {
    create?: XOR<ProveedorCreateWithoutMovesInput, ProveedorUncheckedCreateWithoutMovesInput>
    connectOrCreate?: ProveedorCreateOrConnectWithoutMovesInput
    connect?: ProveedorWhereUniqueInput
  }

  export type ExpenseCreateNestedOneWithoutMoveInput = {
    create?: XOR<ExpenseCreateWithoutMoveInput, ExpenseUncheckedCreateWithoutMoveInput>
    connectOrCreate?: ExpenseCreateOrConnectWithoutMoveInput
    connect?: ExpenseWhereUniqueInput
  }

  export type ExpenseUncheckedCreateNestedOneWithoutMoveInput = {
    create?: XOR<ExpenseCreateWithoutMoveInput, ExpenseUncheckedCreateWithoutMoveInput>
    connectOrCreate?: ExpenseCreateOrConnectWithoutMoveInput
    connect?: ExpenseWhereUniqueInput
  }

  export type EnumMoveTypeFieldUpdateOperationsInput = {
    set?: $Enums.MoveType
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumDocTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocType | null
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableEnumAssetStatusFieldUpdateOperationsInput = {
    set?: $Enums.AssetStatus | null
  }

  export type ObraUpdateOneRequiredWithoutMovesNestedInput = {
    create?: XOR<ObraCreateWithoutMovesInput, ObraUncheckedCreateWithoutMovesInput>
    connectOrCreate?: ObraCreateOrConnectWithoutMovesInput
    upsert?: ObraUpsertWithoutMovesInput
    connect?: ObraWhereUniqueInput
    update?: XOR<XOR<ObraUpdateToOneWithWhereWithoutMovesInput, ObraUpdateWithoutMovesInput>, ObraUncheckedUpdateWithoutMovesInput>
  }

  export type FrenteUpdateOneWithoutMovesNestedInput = {
    create?: XOR<FrenteCreateWithoutMovesInput, FrenteUncheckedCreateWithoutMovesInput>
    connectOrCreate?: FrenteCreateOrConnectWithoutMovesInput
    upsert?: FrenteUpsertWithoutMovesInput
    disconnect?: FrenteWhereInput | boolean
    delete?: FrenteWhereInput | boolean
    connect?: FrenteWhereUniqueInput
    update?: XOR<XOR<FrenteUpdateToOneWithWhereWithoutMovesInput, FrenteUpdateWithoutMovesInput>, FrenteUncheckedUpdateWithoutMovesInput>
  }

  export type MaterialUpdateOneRequiredWithoutMovesNestedInput = {
    create?: XOR<MaterialCreateWithoutMovesInput, MaterialUncheckedCreateWithoutMovesInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutMovesInput
    upsert?: MaterialUpsertWithoutMovesInput
    connect?: MaterialWhereUniqueInput
    update?: XOR<XOR<MaterialUpdateToOneWithWhereWithoutMovesInput, MaterialUpdateWithoutMovesInput>, MaterialUncheckedUpdateWithoutMovesInput>
  }

  export type ProveedorUpdateOneWithoutMovesNestedInput = {
    create?: XOR<ProveedorCreateWithoutMovesInput, ProveedorUncheckedCreateWithoutMovesInput>
    connectOrCreate?: ProveedorCreateOrConnectWithoutMovesInput
    upsert?: ProveedorUpsertWithoutMovesInput
    disconnect?: ProveedorWhereInput | boolean
    delete?: ProveedorWhereInput | boolean
    connect?: ProveedorWhereUniqueInput
    update?: XOR<XOR<ProveedorUpdateToOneWithWhereWithoutMovesInput, ProveedorUpdateWithoutMovesInput>, ProveedorUncheckedUpdateWithoutMovesInput>
  }

  export type ExpenseUpdateOneWithoutMoveNestedInput = {
    create?: XOR<ExpenseCreateWithoutMoveInput, ExpenseUncheckedCreateWithoutMoveInput>
    connectOrCreate?: ExpenseCreateOrConnectWithoutMoveInput
    upsert?: ExpenseUpsertWithoutMoveInput
    disconnect?: ExpenseWhereInput | boolean
    delete?: ExpenseWhereInput | boolean
    connect?: ExpenseWhereUniqueInput
    update?: XOR<XOR<ExpenseUpdateToOneWithWhereWithoutMoveInput, ExpenseUpdateWithoutMoveInput>, ExpenseUncheckedUpdateWithoutMoveInput>
  }

  export type ExpenseUncheckedUpdateOneWithoutMoveNestedInput = {
    create?: XOR<ExpenseCreateWithoutMoveInput, ExpenseUncheckedCreateWithoutMoveInput>
    connectOrCreate?: ExpenseCreateOrConnectWithoutMoveInput
    upsert?: ExpenseUpsertWithoutMoveInput
    disconnect?: ExpenseWhereInput | boolean
    delete?: ExpenseWhereInput | boolean
    connect?: ExpenseWhereUniqueInput
    update?: XOR<XOR<ExpenseUpdateToOneWithWhereWithoutMoveInput, ExpenseUpdateWithoutMoveInput>, ExpenseUncheckedUpdateWithoutMoveInput>
  }

  export type ExpenseCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ExpenseCreateWithoutCategoryInput, ExpenseUncheckedCreateWithoutCategoryInput> | ExpenseCreateWithoutCategoryInput[] | ExpenseUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutCategoryInput | ExpenseCreateOrConnectWithoutCategoryInput[]
    createMany?: ExpenseCreateManyCategoryInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type ExpenseUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ExpenseCreateWithoutCategoryInput, ExpenseUncheckedCreateWithoutCategoryInput> | ExpenseCreateWithoutCategoryInput[] | ExpenseUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutCategoryInput | ExpenseCreateOrConnectWithoutCategoryInput[]
    createMany?: ExpenseCreateManyCategoryInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type EnumExpenseKindFieldUpdateOperationsInput = {
    set?: $Enums.ExpenseKind
  }

  export type ExpenseUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ExpenseCreateWithoutCategoryInput, ExpenseUncheckedCreateWithoutCategoryInput> | ExpenseCreateWithoutCategoryInput[] | ExpenseUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutCategoryInput | ExpenseCreateOrConnectWithoutCategoryInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutCategoryInput | ExpenseUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ExpenseCreateManyCategoryInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutCategoryInput | ExpenseUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutCategoryInput | ExpenseUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type ExpenseUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ExpenseCreateWithoutCategoryInput, ExpenseUncheckedCreateWithoutCategoryInput> | ExpenseCreateWithoutCategoryInput[] | ExpenseUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutCategoryInput | ExpenseCreateOrConnectWithoutCategoryInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutCategoryInput | ExpenseUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ExpenseCreateManyCategoryInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutCategoryInput | ExpenseUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutCategoryInput | ExpenseUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type ObraCreateNestedOneWithoutIncomesInput = {
    create?: XOR<ObraCreateWithoutIncomesInput, ObraUncheckedCreateWithoutIncomesInput>
    connectOrCreate?: ObraCreateOrConnectWithoutIncomesInput
    connect?: ObraWhereUniqueInput
  }

  export type FrenteCreateNestedOneWithoutIncomesInput = {
    create?: XOR<FrenteCreateWithoutIncomesInput, FrenteUncheckedCreateWithoutIncomesInput>
    connectOrCreate?: FrenteCreateOrConnectWithoutIncomesInput
    connect?: FrenteWhereUniqueInput
  }

  export type EnumDocTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocType
  }

  export type EnumIncomeStatusFieldUpdateOperationsInput = {
    set?: $Enums.IncomeStatus
  }

  export type ObraUpdateOneRequiredWithoutIncomesNestedInput = {
    create?: XOR<ObraCreateWithoutIncomesInput, ObraUncheckedCreateWithoutIncomesInput>
    connectOrCreate?: ObraCreateOrConnectWithoutIncomesInput
    upsert?: ObraUpsertWithoutIncomesInput
    connect?: ObraWhereUniqueInput
    update?: XOR<XOR<ObraUpdateToOneWithWhereWithoutIncomesInput, ObraUpdateWithoutIncomesInput>, ObraUncheckedUpdateWithoutIncomesInput>
  }

  export type FrenteUpdateOneWithoutIncomesNestedInput = {
    create?: XOR<FrenteCreateWithoutIncomesInput, FrenteUncheckedCreateWithoutIncomesInput>
    connectOrCreate?: FrenteCreateOrConnectWithoutIncomesInput
    upsert?: FrenteUpsertWithoutIncomesInput
    disconnect?: FrenteWhereInput | boolean
    delete?: FrenteWhereInput | boolean
    connect?: FrenteWhereUniqueInput
    update?: XOR<XOR<FrenteUpdateToOneWithWhereWithoutIncomesInput, FrenteUpdateWithoutIncomesInput>, FrenteUncheckedUpdateWithoutIncomesInput>
  }

  export type ObraCreateNestedOneWithoutExpensesInput = {
    create?: XOR<ObraCreateWithoutExpensesInput, ObraUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: ObraCreateOrConnectWithoutExpensesInput
    connect?: ObraWhereUniqueInput
  }

  export type FrenteCreateNestedOneWithoutExpensesInput = {
    create?: XOR<FrenteCreateWithoutExpensesInput, FrenteUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: FrenteCreateOrConnectWithoutExpensesInput
    connect?: FrenteWhereUniqueInput
  }

  export type ProveedorCreateNestedOneWithoutExpensesInput = {
    create?: XOR<ProveedorCreateWithoutExpensesInput, ProveedorUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: ProveedorCreateOrConnectWithoutExpensesInput
    connect?: ProveedorWhereUniqueInput
  }

  export type MaterialCreateNestedOneWithoutExpensesInput = {
    create?: XOR<MaterialCreateWithoutExpensesInput, MaterialUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutExpensesInput
    connect?: MaterialWhereUniqueInput
  }

  export type ExpenseCategoryCreateNestedOneWithoutExpensesInput = {
    create?: XOR<ExpenseCategoryCreateWithoutExpensesInput, ExpenseCategoryUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutExpensesInput
    connect?: ExpenseCategoryWhereUniqueInput
  }

  export type MoveCreateNestedOneWithoutExpenseInput = {
    create?: XOR<MoveCreateWithoutExpenseInput, MoveUncheckedCreateWithoutExpenseInput>
    connectOrCreate?: MoveCreateOrConnectWithoutExpenseInput
    connect?: MoveWhereUniqueInput
  }

  export type EnumExpenseTypeFieldUpdateOperationsInput = {
    set?: $Enums.ExpenseType
  }

  export type EnumVariableTypeFieldUpdateOperationsInput = {
    set?: $Enums.VariableType
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ObraUpdateOneRequiredWithoutExpensesNestedInput = {
    create?: XOR<ObraCreateWithoutExpensesInput, ObraUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: ObraCreateOrConnectWithoutExpensesInput
    upsert?: ObraUpsertWithoutExpensesInput
    connect?: ObraWhereUniqueInput
    update?: XOR<XOR<ObraUpdateToOneWithWhereWithoutExpensesInput, ObraUpdateWithoutExpensesInput>, ObraUncheckedUpdateWithoutExpensesInput>
  }

  export type FrenteUpdateOneWithoutExpensesNestedInput = {
    create?: XOR<FrenteCreateWithoutExpensesInput, FrenteUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: FrenteCreateOrConnectWithoutExpensesInput
    upsert?: FrenteUpsertWithoutExpensesInput
    disconnect?: FrenteWhereInput | boolean
    delete?: FrenteWhereInput | boolean
    connect?: FrenteWhereUniqueInput
    update?: XOR<XOR<FrenteUpdateToOneWithWhereWithoutExpensesInput, FrenteUpdateWithoutExpensesInput>, FrenteUncheckedUpdateWithoutExpensesInput>
  }

  export type ProveedorUpdateOneWithoutExpensesNestedInput = {
    create?: XOR<ProveedorCreateWithoutExpensesInput, ProveedorUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: ProveedorCreateOrConnectWithoutExpensesInput
    upsert?: ProveedorUpsertWithoutExpensesInput
    disconnect?: ProveedorWhereInput | boolean
    delete?: ProveedorWhereInput | boolean
    connect?: ProveedorWhereUniqueInput
    update?: XOR<XOR<ProveedorUpdateToOneWithWhereWithoutExpensesInput, ProveedorUpdateWithoutExpensesInput>, ProveedorUncheckedUpdateWithoutExpensesInput>
  }

  export type MaterialUpdateOneWithoutExpensesNestedInput = {
    create?: XOR<MaterialCreateWithoutExpensesInput, MaterialUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutExpensesInput
    upsert?: MaterialUpsertWithoutExpensesInput
    disconnect?: MaterialWhereInput | boolean
    delete?: MaterialWhereInput | boolean
    connect?: MaterialWhereUniqueInput
    update?: XOR<XOR<MaterialUpdateToOneWithWhereWithoutExpensesInput, MaterialUpdateWithoutExpensesInput>, MaterialUncheckedUpdateWithoutExpensesInput>
  }

  export type ExpenseCategoryUpdateOneWithoutExpensesNestedInput = {
    create?: XOR<ExpenseCategoryCreateWithoutExpensesInput, ExpenseCategoryUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutExpensesInput
    upsert?: ExpenseCategoryUpsertWithoutExpensesInput
    disconnect?: ExpenseCategoryWhereInput | boolean
    delete?: ExpenseCategoryWhereInput | boolean
    connect?: ExpenseCategoryWhereUniqueInput
    update?: XOR<XOR<ExpenseCategoryUpdateToOneWithWhereWithoutExpensesInput, ExpenseCategoryUpdateWithoutExpensesInput>, ExpenseCategoryUncheckedUpdateWithoutExpensesInput>
  }

  export type MoveUpdateOneWithoutExpenseNestedInput = {
    create?: XOR<MoveCreateWithoutExpenseInput, MoveUncheckedCreateWithoutExpenseInput>
    connectOrCreate?: MoveCreateOrConnectWithoutExpenseInput
    upsert?: MoveUpsertWithoutExpenseInput
    disconnect?: MoveWhereInput | boolean
    delete?: MoveWhereInput | boolean
    connect?: MoveWhereUniqueInput
    update?: XOR<XOR<MoveUpdateToOneWithWhereWithoutExpenseInput, MoveUpdateWithoutExpenseInput>, MoveUncheckedUpdateWithoutExpenseInput>
  }

  export type ObraCreateNestedOneWithoutDailyCashRenditionsInput = {
    create?: XOR<ObraCreateWithoutDailyCashRenditionsInput, ObraUncheckedCreateWithoutDailyCashRenditionsInput>
    connectOrCreate?: ObraCreateOrConnectWithoutDailyCashRenditionsInput
    connect?: ObraWhereUniqueInput
  }

  export type DailyCashExpenseCreateNestedManyWithoutRenditionInput = {
    create?: XOR<DailyCashExpenseCreateWithoutRenditionInput, DailyCashExpenseUncheckedCreateWithoutRenditionInput> | DailyCashExpenseCreateWithoutRenditionInput[] | DailyCashExpenseUncheckedCreateWithoutRenditionInput[]
    connectOrCreate?: DailyCashExpenseCreateOrConnectWithoutRenditionInput | DailyCashExpenseCreateOrConnectWithoutRenditionInput[]
    createMany?: DailyCashExpenseCreateManyRenditionInputEnvelope
    connect?: DailyCashExpenseWhereUniqueInput | DailyCashExpenseWhereUniqueInput[]
  }

  export type DailyCashExpenseUncheckedCreateNestedManyWithoutRenditionInput = {
    create?: XOR<DailyCashExpenseCreateWithoutRenditionInput, DailyCashExpenseUncheckedCreateWithoutRenditionInput> | DailyCashExpenseCreateWithoutRenditionInput[] | DailyCashExpenseUncheckedCreateWithoutRenditionInput[]
    connectOrCreate?: DailyCashExpenseCreateOrConnectWithoutRenditionInput | DailyCashExpenseCreateOrConnectWithoutRenditionInput[]
    createMany?: DailyCashExpenseCreateManyRenditionInputEnvelope
    connect?: DailyCashExpenseWhereUniqueInput | DailyCashExpenseWhereUniqueInput[]
  }

  export type ObraUpdateOneWithoutDailyCashRenditionsNestedInput = {
    create?: XOR<ObraCreateWithoutDailyCashRenditionsInput, ObraUncheckedCreateWithoutDailyCashRenditionsInput>
    connectOrCreate?: ObraCreateOrConnectWithoutDailyCashRenditionsInput
    upsert?: ObraUpsertWithoutDailyCashRenditionsInput
    disconnect?: ObraWhereInput | boolean
    delete?: ObraWhereInput | boolean
    connect?: ObraWhereUniqueInput
    update?: XOR<XOR<ObraUpdateToOneWithWhereWithoutDailyCashRenditionsInput, ObraUpdateWithoutDailyCashRenditionsInput>, ObraUncheckedUpdateWithoutDailyCashRenditionsInput>
  }

  export type DailyCashExpenseUpdateManyWithoutRenditionNestedInput = {
    create?: XOR<DailyCashExpenseCreateWithoutRenditionInput, DailyCashExpenseUncheckedCreateWithoutRenditionInput> | DailyCashExpenseCreateWithoutRenditionInput[] | DailyCashExpenseUncheckedCreateWithoutRenditionInput[]
    connectOrCreate?: DailyCashExpenseCreateOrConnectWithoutRenditionInput | DailyCashExpenseCreateOrConnectWithoutRenditionInput[]
    upsert?: DailyCashExpenseUpsertWithWhereUniqueWithoutRenditionInput | DailyCashExpenseUpsertWithWhereUniqueWithoutRenditionInput[]
    createMany?: DailyCashExpenseCreateManyRenditionInputEnvelope
    set?: DailyCashExpenseWhereUniqueInput | DailyCashExpenseWhereUniqueInput[]
    disconnect?: DailyCashExpenseWhereUniqueInput | DailyCashExpenseWhereUniqueInput[]
    delete?: DailyCashExpenseWhereUniqueInput | DailyCashExpenseWhereUniqueInput[]
    connect?: DailyCashExpenseWhereUniqueInput | DailyCashExpenseWhereUniqueInput[]
    update?: DailyCashExpenseUpdateWithWhereUniqueWithoutRenditionInput | DailyCashExpenseUpdateWithWhereUniqueWithoutRenditionInput[]
    updateMany?: DailyCashExpenseUpdateManyWithWhereWithoutRenditionInput | DailyCashExpenseUpdateManyWithWhereWithoutRenditionInput[]
    deleteMany?: DailyCashExpenseScalarWhereInput | DailyCashExpenseScalarWhereInput[]
  }

  export type DailyCashExpenseUncheckedUpdateManyWithoutRenditionNestedInput = {
    create?: XOR<DailyCashExpenseCreateWithoutRenditionInput, DailyCashExpenseUncheckedCreateWithoutRenditionInput> | DailyCashExpenseCreateWithoutRenditionInput[] | DailyCashExpenseUncheckedCreateWithoutRenditionInput[]
    connectOrCreate?: DailyCashExpenseCreateOrConnectWithoutRenditionInput | DailyCashExpenseCreateOrConnectWithoutRenditionInput[]
    upsert?: DailyCashExpenseUpsertWithWhereUniqueWithoutRenditionInput | DailyCashExpenseUpsertWithWhereUniqueWithoutRenditionInput[]
    createMany?: DailyCashExpenseCreateManyRenditionInputEnvelope
    set?: DailyCashExpenseWhereUniqueInput | DailyCashExpenseWhereUniqueInput[]
    disconnect?: DailyCashExpenseWhereUniqueInput | DailyCashExpenseWhereUniqueInput[]
    delete?: DailyCashExpenseWhereUniqueInput | DailyCashExpenseWhereUniqueInput[]
    connect?: DailyCashExpenseWhereUniqueInput | DailyCashExpenseWhereUniqueInput[]
    update?: DailyCashExpenseUpdateWithWhereUniqueWithoutRenditionInput | DailyCashExpenseUpdateWithWhereUniqueWithoutRenditionInput[]
    updateMany?: DailyCashExpenseUpdateManyWithWhereWithoutRenditionInput | DailyCashExpenseUpdateManyWithWhereWithoutRenditionInput[]
    deleteMany?: DailyCashExpenseScalarWhereInput | DailyCashExpenseScalarWhereInput[]
  }

  export type DailyCashRenditionCreateNestedOneWithoutExpensesInput = {
    create?: XOR<DailyCashRenditionCreateWithoutExpensesInput, DailyCashRenditionUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: DailyCashRenditionCreateOrConnectWithoutExpensesInput
    connect?: DailyCashRenditionWhereUniqueInput
  }

  export type DailyCashRenditionUpdateOneRequiredWithoutExpensesNestedInput = {
    create?: XOR<DailyCashRenditionCreateWithoutExpensesInput, DailyCashRenditionUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: DailyCashRenditionCreateOrConnectWithoutExpensesInput
    upsert?: DailyCashRenditionUpsertWithoutExpensesInput
    connect?: DailyCashRenditionWhereUniqueInput
    update?: XOR<XOR<DailyCashRenditionUpdateToOneWithWhereWithoutExpensesInput, DailyCashRenditionUpdateWithoutExpensesInput>, DailyCashRenditionUncheckedUpdateWithoutExpensesInput>
  }

  export type ObraCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<ObraCreateWithoutEmployeesInput, ObraUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: ObraCreateOrConnectWithoutEmployeesInput
    connect?: ObraWhereUniqueInput
  }

  export type AttendanceRecordCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AttendanceRecordCreateWithoutEmployeeInput, AttendanceRecordUncheckedCreateWithoutEmployeeInput> | AttendanceRecordCreateWithoutEmployeeInput[] | AttendanceRecordUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutEmployeeInput | AttendanceRecordCreateOrConnectWithoutEmployeeInput[]
    createMany?: AttendanceRecordCreateManyEmployeeInputEnvelope
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
  }

  export type PayrollEntryCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<PayrollEntryCreateWithoutEmployeeInput, PayrollEntryUncheckedCreateWithoutEmployeeInput> | PayrollEntryCreateWithoutEmployeeInput[] | PayrollEntryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PayrollEntryCreateOrConnectWithoutEmployeeInput | PayrollEntryCreateOrConnectWithoutEmployeeInput[]
    createMany?: PayrollEntryCreateManyEmployeeInputEnvelope
    connect?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
  }

  export type EmployeeAccumulationPaymentCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<EmployeeAccumulationPaymentCreateWithoutEmployeeInput, EmployeeAccumulationPaymentUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: EmployeeAccumulationPaymentCreateOrConnectWithoutEmployeeInput
    connect?: EmployeeAccumulationPaymentWhereUniqueInput
  }

  export type AttendanceRecordUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AttendanceRecordCreateWithoutEmployeeInput, AttendanceRecordUncheckedCreateWithoutEmployeeInput> | AttendanceRecordCreateWithoutEmployeeInput[] | AttendanceRecordUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutEmployeeInput | AttendanceRecordCreateOrConnectWithoutEmployeeInput[]
    createMany?: AttendanceRecordCreateManyEmployeeInputEnvelope
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
  }

  export type PayrollEntryUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<PayrollEntryCreateWithoutEmployeeInput, PayrollEntryUncheckedCreateWithoutEmployeeInput> | PayrollEntryCreateWithoutEmployeeInput[] | PayrollEntryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PayrollEntryCreateOrConnectWithoutEmployeeInput | PayrollEntryCreateOrConnectWithoutEmployeeInput[]
    createMany?: PayrollEntryCreateManyEmployeeInputEnvelope
    connect?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
  }

  export type EmployeeAccumulationPaymentUncheckedCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<EmployeeAccumulationPaymentCreateWithoutEmployeeInput, EmployeeAccumulationPaymentUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: EmployeeAccumulationPaymentCreateOrConnectWithoutEmployeeInput
    connect?: EmployeeAccumulationPaymentWhereUniqueInput
  }

  export type NullableEnumDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocumentType | null
  }

  export type EnumBankTypeFieldUpdateOperationsInput = {
    set?: $Enums.BankType
  }

  export type EnumPensionSystemFieldUpdateOperationsInput = {
    set?: $Enums.PensionSystem
  }

  export type EnumEmployeeAreaFieldUpdateOperationsInput = {
    set?: $Enums.EmployeeArea
  }

  export type ObraUpdateOneWithoutEmployeesNestedInput = {
    create?: XOR<ObraCreateWithoutEmployeesInput, ObraUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: ObraCreateOrConnectWithoutEmployeesInput
    upsert?: ObraUpsertWithoutEmployeesInput
    disconnect?: ObraWhereInput | boolean
    delete?: ObraWhereInput | boolean
    connect?: ObraWhereUniqueInput
    update?: XOR<XOR<ObraUpdateToOneWithWhereWithoutEmployeesInput, ObraUpdateWithoutEmployeesInput>, ObraUncheckedUpdateWithoutEmployeesInput>
  }

  export type AttendanceRecordUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AttendanceRecordCreateWithoutEmployeeInput, AttendanceRecordUncheckedCreateWithoutEmployeeInput> | AttendanceRecordCreateWithoutEmployeeInput[] | AttendanceRecordUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutEmployeeInput | AttendanceRecordCreateOrConnectWithoutEmployeeInput[]
    upsert?: AttendanceRecordUpsertWithWhereUniqueWithoutEmployeeInput | AttendanceRecordUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AttendanceRecordCreateManyEmployeeInputEnvelope
    set?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    disconnect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    delete?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    update?: AttendanceRecordUpdateWithWhereUniqueWithoutEmployeeInput | AttendanceRecordUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AttendanceRecordUpdateManyWithWhereWithoutEmployeeInput | AttendanceRecordUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
  }

  export type PayrollEntryUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<PayrollEntryCreateWithoutEmployeeInput, PayrollEntryUncheckedCreateWithoutEmployeeInput> | PayrollEntryCreateWithoutEmployeeInput[] | PayrollEntryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PayrollEntryCreateOrConnectWithoutEmployeeInput | PayrollEntryCreateOrConnectWithoutEmployeeInput[]
    upsert?: PayrollEntryUpsertWithWhereUniqueWithoutEmployeeInput | PayrollEntryUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: PayrollEntryCreateManyEmployeeInputEnvelope
    set?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    disconnect?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    delete?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    connect?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    update?: PayrollEntryUpdateWithWhereUniqueWithoutEmployeeInput | PayrollEntryUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: PayrollEntryUpdateManyWithWhereWithoutEmployeeInput | PayrollEntryUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: PayrollEntryScalarWhereInput | PayrollEntryScalarWhereInput[]
  }

  export type EmployeeAccumulationPaymentUpdateOneWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeAccumulationPaymentCreateWithoutEmployeeInput, EmployeeAccumulationPaymentUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: EmployeeAccumulationPaymentCreateOrConnectWithoutEmployeeInput
    upsert?: EmployeeAccumulationPaymentUpsertWithoutEmployeeInput
    disconnect?: EmployeeAccumulationPaymentWhereInput | boolean
    delete?: EmployeeAccumulationPaymentWhereInput | boolean
    connect?: EmployeeAccumulationPaymentWhereUniqueInput
    update?: XOR<XOR<EmployeeAccumulationPaymentUpdateToOneWithWhereWithoutEmployeeInput, EmployeeAccumulationPaymentUpdateWithoutEmployeeInput>, EmployeeAccumulationPaymentUncheckedUpdateWithoutEmployeeInput>
  }

  export type AttendanceRecordUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AttendanceRecordCreateWithoutEmployeeInput, AttendanceRecordUncheckedCreateWithoutEmployeeInput> | AttendanceRecordCreateWithoutEmployeeInput[] | AttendanceRecordUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutEmployeeInput | AttendanceRecordCreateOrConnectWithoutEmployeeInput[]
    upsert?: AttendanceRecordUpsertWithWhereUniqueWithoutEmployeeInput | AttendanceRecordUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AttendanceRecordCreateManyEmployeeInputEnvelope
    set?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    disconnect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    delete?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    update?: AttendanceRecordUpdateWithWhereUniqueWithoutEmployeeInput | AttendanceRecordUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AttendanceRecordUpdateManyWithWhereWithoutEmployeeInput | AttendanceRecordUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
  }

  export type PayrollEntryUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<PayrollEntryCreateWithoutEmployeeInput, PayrollEntryUncheckedCreateWithoutEmployeeInput> | PayrollEntryCreateWithoutEmployeeInput[] | PayrollEntryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PayrollEntryCreateOrConnectWithoutEmployeeInput | PayrollEntryCreateOrConnectWithoutEmployeeInput[]
    upsert?: PayrollEntryUpsertWithWhereUniqueWithoutEmployeeInput | PayrollEntryUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: PayrollEntryCreateManyEmployeeInputEnvelope
    set?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    disconnect?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    delete?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    connect?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    update?: PayrollEntryUpdateWithWhereUniqueWithoutEmployeeInput | PayrollEntryUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: PayrollEntryUpdateManyWithWhereWithoutEmployeeInput | PayrollEntryUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: PayrollEntryScalarWhereInput | PayrollEntryScalarWhereInput[]
  }

  export type EmployeeAccumulationPaymentUncheckedUpdateOneWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeAccumulationPaymentCreateWithoutEmployeeInput, EmployeeAccumulationPaymentUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: EmployeeAccumulationPaymentCreateOrConnectWithoutEmployeeInput
    upsert?: EmployeeAccumulationPaymentUpsertWithoutEmployeeInput
    disconnect?: EmployeeAccumulationPaymentWhereInput | boolean
    delete?: EmployeeAccumulationPaymentWhereInput | boolean
    connect?: EmployeeAccumulationPaymentWhereUniqueInput
    update?: XOR<XOR<EmployeeAccumulationPaymentUpdateToOneWithWhereWithoutEmployeeInput, EmployeeAccumulationPaymentUpdateWithoutEmployeeInput>, EmployeeAccumulationPaymentUncheckedUpdateWithoutEmployeeInput>
  }

  export type EmployeeCreateNestedOneWithoutAccumulationPaymentInput = {
    create?: XOR<EmployeeCreateWithoutAccumulationPaymentInput, EmployeeUncheckedCreateWithoutAccumulationPaymentInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAccumulationPaymentInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutAccumulationPaymentNestedInput = {
    create?: XOR<EmployeeCreateWithoutAccumulationPaymentInput, EmployeeUncheckedCreateWithoutAccumulationPaymentInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAccumulationPaymentInput
    upsert?: EmployeeUpsertWithoutAccumulationPaymentInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutAccumulationPaymentInput, EmployeeUpdateWithoutAccumulationPaymentInput>, EmployeeUncheckedUpdateWithoutAccumulationPaymentInput>
  }

  export type EmployeeCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<EmployeeCreateWithoutAttendancesInput, EmployeeUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAttendancesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EnumAttendanceStatusFieldUpdateOperationsInput = {
    set?: $Enums.AttendanceStatus
  }

  export type EmployeeUpdateOneRequiredWithoutAttendancesNestedInput = {
    create?: XOR<EmployeeCreateWithoutAttendancesInput, EmployeeUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAttendancesInput
    upsert?: EmployeeUpsertWithoutAttendancesInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutAttendancesInput, EmployeeUpdateWithoutAttendancesInput>, EmployeeUncheckedUpdateWithoutAttendancesInput>
  }

  export type ObraCreateNestedOneWithoutPayrollPeriodsInput = {
    create?: XOR<ObraCreateWithoutPayrollPeriodsInput, ObraUncheckedCreateWithoutPayrollPeriodsInput>
    connectOrCreate?: ObraCreateOrConnectWithoutPayrollPeriodsInput
    connect?: ObraWhereUniqueInput
  }

  export type PayrollEntryCreateNestedManyWithoutPeriodInput = {
    create?: XOR<PayrollEntryCreateWithoutPeriodInput, PayrollEntryUncheckedCreateWithoutPeriodInput> | PayrollEntryCreateWithoutPeriodInput[] | PayrollEntryUncheckedCreateWithoutPeriodInput[]
    connectOrCreate?: PayrollEntryCreateOrConnectWithoutPeriodInput | PayrollEntryCreateOrConnectWithoutPeriodInput[]
    createMany?: PayrollEntryCreateManyPeriodInputEnvelope
    connect?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
  }

  export type PayrollEntryUncheckedCreateNestedManyWithoutPeriodInput = {
    create?: XOR<PayrollEntryCreateWithoutPeriodInput, PayrollEntryUncheckedCreateWithoutPeriodInput> | PayrollEntryCreateWithoutPeriodInput[] | PayrollEntryUncheckedCreateWithoutPeriodInput[]
    connectOrCreate?: PayrollEntryCreateOrConnectWithoutPeriodInput | PayrollEntryCreateOrConnectWithoutPeriodInput[]
    createMany?: PayrollEntryCreateManyPeriodInputEnvelope
    connect?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
  }

  export type EnumPayrollPeriodStatusFieldUpdateOperationsInput = {
    set?: $Enums.PayrollPeriodStatus
  }

  export type ObraUpdateOneWithoutPayrollPeriodsNestedInput = {
    create?: XOR<ObraCreateWithoutPayrollPeriodsInput, ObraUncheckedCreateWithoutPayrollPeriodsInput>
    connectOrCreate?: ObraCreateOrConnectWithoutPayrollPeriodsInput
    upsert?: ObraUpsertWithoutPayrollPeriodsInput
    disconnect?: ObraWhereInput | boolean
    delete?: ObraWhereInput | boolean
    connect?: ObraWhereUniqueInput
    update?: XOR<XOR<ObraUpdateToOneWithWhereWithoutPayrollPeriodsInput, ObraUpdateWithoutPayrollPeriodsInput>, ObraUncheckedUpdateWithoutPayrollPeriodsInput>
  }

  export type PayrollEntryUpdateManyWithoutPeriodNestedInput = {
    create?: XOR<PayrollEntryCreateWithoutPeriodInput, PayrollEntryUncheckedCreateWithoutPeriodInput> | PayrollEntryCreateWithoutPeriodInput[] | PayrollEntryUncheckedCreateWithoutPeriodInput[]
    connectOrCreate?: PayrollEntryCreateOrConnectWithoutPeriodInput | PayrollEntryCreateOrConnectWithoutPeriodInput[]
    upsert?: PayrollEntryUpsertWithWhereUniqueWithoutPeriodInput | PayrollEntryUpsertWithWhereUniqueWithoutPeriodInput[]
    createMany?: PayrollEntryCreateManyPeriodInputEnvelope
    set?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    disconnect?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    delete?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    connect?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    update?: PayrollEntryUpdateWithWhereUniqueWithoutPeriodInput | PayrollEntryUpdateWithWhereUniqueWithoutPeriodInput[]
    updateMany?: PayrollEntryUpdateManyWithWhereWithoutPeriodInput | PayrollEntryUpdateManyWithWhereWithoutPeriodInput[]
    deleteMany?: PayrollEntryScalarWhereInput | PayrollEntryScalarWhereInput[]
  }

  export type PayrollEntryUncheckedUpdateManyWithoutPeriodNestedInput = {
    create?: XOR<PayrollEntryCreateWithoutPeriodInput, PayrollEntryUncheckedCreateWithoutPeriodInput> | PayrollEntryCreateWithoutPeriodInput[] | PayrollEntryUncheckedCreateWithoutPeriodInput[]
    connectOrCreate?: PayrollEntryCreateOrConnectWithoutPeriodInput | PayrollEntryCreateOrConnectWithoutPeriodInput[]
    upsert?: PayrollEntryUpsertWithWhereUniqueWithoutPeriodInput | PayrollEntryUpsertWithWhereUniqueWithoutPeriodInput[]
    createMany?: PayrollEntryCreateManyPeriodInputEnvelope
    set?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    disconnect?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    delete?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    connect?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    update?: PayrollEntryUpdateWithWhereUniqueWithoutPeriodInput | PayrollEntryUpdateWithWhereUniqueWithoutPeriodInput[]
    updateMany?: PayrollEntryUpdateManyWithWhereWithoutPeriodInput | PayrollEntryUpdateManyWithWhereWithoutPeriodInput[]
    deleteMany?: PayrollEntryScalarWhereInput | PayrollEntryScalarWhereInput[]
  }

  export type PayrollPeriodCreateNestedOneWithoutEntriesInput = {
    create?: XOR<PayrollPeriodCreateWithoutEntriesInput, PayrollPeriodUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: PayrollPeriodCreateOrConnectWithoutEntriesInput
    connect?: PayrollPeriodWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutPayrollEntriesInput = {
    create?: XOR<EmployeeCreateWithoutPayrollEntriesInput, EmployeeUncheckedCreateWithoutPayrollEntriesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPayrollEntriesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type PayrollAdjustmentCreateNestedManyWithoutEntryInput = {
    create?: XOR<PayrollAdjustmentCreateWithoutEntryInput, PayrollAdjustmentUncheckedCreateWithoutEntryInput> | PayrollAdjustmentCreateWithoutEntryInput[] | PayrollAdjustmentUncheckedCreateWithoutEntryInput[]
    connectOrCreate?: PayrollAdjustmentCreateOrConnectWithoutEntryInput | PayrollAdjustmentCreateOrConnectWithoutEntryInput[]
    createMany?: PayrollAdjustmentCreateManyEntryInputEnvelope
    connect?: PayrollAdjustmentWhereUniqueInput | PayrollAdjustmentWhereUniqueInput[]
  }

  export type PayrollAdjustmentUncheckedCreateNestedManyWithoutEntryInput = {
    create?: XOR<PayrollAdjustmentCreateWithoutEntryInput, PayrollAdjustmentUncheckedCreateWithoutEntryInput> | PayrollAdjustmentCreateWithoutEntryInput[] | PayrollAdjustmentUncheckedCreateWithoutEntryInput[]
    connectOrCreate?: PayrollAdjustmentCreateOrConnectWithoutEntryInput | PayrollAdjustmentCreateOrConnectWithoutEntryInput[]
    createMany?: PayrollAdjustmentCreateManyEntryInputEnvelope
    connect?: PayrollAdjustmentWhereUniqueInput | PayrollAdjustmentWhereUniqueInput[]
  }

  export type PayrollPeriodUpdateOneRequiredWithoutEntriesNestedInput = {
    create?: XOR<PayrollPeriodCreateWithoutEntriesInput, PayrollPeriodUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: PayrollPeriodCreateOrConnectWithoutEntriesInput
    upsert?: PayrollPeriodUpsertWithoutEntriesInput
    connect?: PayrollPeriodWhereUniqueInput
    update?: XOR<XOR<PayrollPeriodUpdateToOneWithWhereWithoutEntriesInput, PayrollPeriodUpdateWithoutEntriesInput>, PayrollPeriodUncheckedUpdateWithoutEntriesInput>
  }

  export type EmployeeUpdateOneRequiredWithoutPayrollEntriesNestedInput = {
    create?: XOR<EmployeeCreateWithoutPayrollEntriesInput, EmployeeUncheckedCreateWithoutPayrollEntriesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPayrollEntriesInput
    upsert?: EmployeeUpsertWithoutPayrollEntriesInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutPayrollEntriesInput, EmployeeUpdateWithoutPayrollEntriesInput>, EmployeeUncheckedUpdateWithoutPayrollEntriesInput>
  }

  export type PayrollAdjustmentUpdateManyWithoutEntryNestedInput = {
    create?: XOR<PayrollAdjustmentCreateWithoutEntryInput, PayrollAdjustmentUncheckedCreateWithoutEntryInput> | PayrollAdjustmentCreateWithoutEntryInput[] | PayrollAdjustmentUncheckedCreateWithoutEntryInput[]
    connectOrCreate?: PayrollAdjustmentCreateOrConnectWithoutEntryInput | PayrollAdjustmentCreateOrConnectWithoutEntryInput[]
    upsert?: PayrollAdjustmentUpsertWithWhereUniqueWithoutEntryInput | PayrollAdjustmentUpsertWithWhereUniqueWithoutEntryInput[]
    createMany?: PayrollAdjustmentCreateManyEntryInputEnvelope
    set?: PayrollAdjustmentWhereUniqueInput | PayrollAdjustmentWhereUniqueInput[]
    disconnect?: PayrollAdjustmentWhereUniqueInput | PayrollAdjustmentWhereUniqueInput[]
    delete?: PayrollAdjustmentWhereUniqueInput | PayrollAdjustmentWhereUniqueInput[]
    connect?: PayrollAdjustmentWhereUniqueInput | PayrollAdjustmentWhereUniqueInput[]
    update?: PayrollAdjustmentUpdateWithWhereUniqueWithoutEntryInput | PayrollAdjustmentUpdateWithWhereUniqueWithoutEntryInput[]
    updateMany?: PayrollAdjustmentUpdateManyWithWhereWithoutEntryInput | PayrollAdjustmentUpdateManyWithWhereWithoutEntryInput[]
    deleteMany?: PayrollAdjustmentScalarWhereInput | PayrollAdjustmentScalarWhereInput[]
  }

  export type PayrollAdjustmentUncheckedUpdateManyWithoutEntryNestedInput = {
    create?: XOR<PayrollAdjustmentCreateWithoutEntryInput, PayrollAdjustmentUncheckedCreateWithoutEntryInput> | PayrollAdjustmentCreateWithoutEntryInput[] | PayrollAdjustmentUncheckedCreateWithoutEntryInput[]
    connectOrCreate?: PayrollAdjustmentCreateOrConnectWithoutEntryInput | PayrollAdjustmentCreateOrConnectWithoutEntryInput[]
    upsert?: PayrollAdjustmentUpsertWithWhereUniqueWithoutEntryInput | PayrollAdjustmentUpsertWithWhereUniqueWithoutEntryInput[]
    createMany?: PayrollAdjustmentCreateManyEntryInputEnvelope
    set?: PayrollAdjustmentWhereUniqueInput | PayrollAdjustmentWhereUniqueInput[]
    disconnect?: PayrollAdjustmentWhereUniqueInput | PayrollAdjustmentWhereUniqueInput[]
    delete?: PayrollAdjustmentWhereUniqueInput | PayrollAdjustmentWhereUniqueInput[]
    connect?: PayrollAdjustmentWhereUniqueInput | PayrollAdjustmentWhereUniqueInput[]
    update?: PayrollAdjustmentUpdateWithWhereUniqueWithoutEntryInput | PayrollAdjustmentUpdateWithWhereUniqueWithoutEntryInput[]
    updateMany?: PayrollAdjustmentUpdateManyWithWhereWithoutEntryInput | PayrollAdjustmentUpdateManyWithWhereWithoutEntryInput[]
    deleteMany?: PayrollAdjustmentScalarWhereInput | PayrollAdjustmentScalarWhereInput[]
  }

  export type PayrollEntryCreateNestedOneWithoutAdjustmentsInput = {
    create?: XOR<PayrollEntryCreateWithoutAdjustmentsInput, PayrollEntryUncheckedCreateWithoutAdjustmentsInput>
    connectOrCreate?: PayrollEntryCreateOrConnectWithoutAdjustmentsInput
    connect?: PayrollEntryWhereUniqueInput
  }

  export type EnumPayrollAdjustmentTypeFieldUpdateOperationsInput = {
    set?: $Enums.PayrollAdjustmentType
  }

  export type PayrollEntryUpdateOneRequiredWithoutAdjustmentsNestedInput = {
    create?: XOR<PayrollEntryCreateWithoutAdjustmentsInput, PayrollEntryUncheckedCreateWithoutAdjustmentsInput>
    connectOrCreate?: PayrollEntryCreateOrConnectWithoutAdjustmentsInput
    upsert?: PayrollEntryUpsertWithoutAdjustmentsInput
    connect?: PayrollEntryWhereUniqueInput
    update?: XOR<XOR<PayrollEntryUpdateToOneWithWhereWithoutAdjustmentsInput, PayrollEntryUpdateWithoutAdjustmentsInput>, PayrollEntryUncheckedUpdateWithoutAdjustmentsInput>
  }

  export type PartnerLoanCreateNestedManyWithoutGiverInput = {
    create?: XOR<PartnerLoanCreateWithoutGiverInput, PartnerLoanUncheckedCreateWithoutGiverInput> | PartnerLoanCreateWithoutGiverInput[] | PartnerLoanUncheckedCreateWithoutGiverInput[]
    connectOrCreate?: PartnerLoanCreateOrConnectWithoutGiverInput | PartnerLoanCreateOrConnectWithoutGiverInput[]
    createMany?: PartnerLoanCreateManyGiverInputEnvelope
    connect?: PartnerLoanWhereUniqueInput | PartnerLoanWhereUniqueInput[]
  }

  export type PartnerLoanCreateNestedManyWithoutReceiverInput = {
    create?: XOR<PartnerLoanCreateWithoutReceiverInput, PartnerLoanUncheckedCreateWithoutReceiverInput> | PartnerLoanCreateWithoutReceiverInput[] | PartnerLoanUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: PartnerLoanCreateOrConnectWithoutReceiverInput | PartnerLoanCreateOrConnectWithoutReceiverInput[]
    createMany?: PartnerLoanCreateManyReceiverInputEnvelope
    connect?: PartnerLoanWhereUniqueInput | PartnerLoanWhereUniqueInput[]
  }

  export type PartnerLoanUncheckedCreateNestedManyWithoutGiverInput = {
    create?: XOR<PartnerLoanCreateWithoutGiverInput, PartnerLoanUncheckedCreateWithoutGiverInput> | PartnerLoanCreateWithoutGiverInput[] | PartnerLoanUncheckedCreateWithoutGiverInput[]
    connectOrCreate?: PartnerLoanCreateOrConnectWithoutGiverInput | PartnerLoanCreateOrConnectWithoutGiverInput[]
    createMany?: PartnerLoanCreateManyGiverInputEnvelope
    connect?: PartnerLoanWhereUniqueInput | PartnerLoanWhereUniqueInput[]
  }

  export type PartnerLoanUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<PartnerLoanCreateWithoutReceiverInput, PartnerLoanUncheckedCreateWithoutReceiverInput> | PartnerLoanCreateWithoutReceiverInput[] | PartnerLoanUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: PartnerLoanCreateOrConnectWithoutReceiverInput | PartnerLoanCreateOrConnectWithoutReceiverInput[]
    createMany?: PartnerLoanCreateManyReceiverInputEnvelope
    connect?: PartnerLoanWhereUniqueInput | PartnerLoanWhereUniqueInput[]
  }

  export type PartnerLoanUpdateManyWithoutGiverNestedInput = {
    create?: XOR<PartnerLoanCreateWithoutGiverInput, PartnerLoanUncheckedCreateWithoutGiverInput> | PartnerLoanCreateWithoutGiverInput[] | PartnerLoanUncheckedCreateWithoutGiverInput[]
    connectOrCreate?: PartnerLoanCreateOrConnectWithoutGiverInput | PartnerLoanCreateOrConnectWithoutGiverInput[]
    upsert?: PartnerLoanUpsertWithWhereUniqueWithoutGiverInput | PartnerLoanUpsertWithWhereUniqueWithoutGiverInput[]
    createMany?: PartnerLoanCreateManyGiverInputEnvelope
    set?: PartnerLoanWhereUniqueInput | PartnerLoanWhereUniqueInput[]
    disconnect?: PartnerLoanWhereUniqueInput | PartnerLoanWhereUniqueInput[]
    delete?: PartnerLoanWhereUniqueInput | PartnerLoanWhereUniqueInput[]
    connect?: PartnerLoanWhereUniqueInput | PartnerLoanWhereUniqueInput[]
    update?: PartnerLoanUpdateWithWhereUniqueWithoutGiverInput | PartnerLoanUpdateWithWhereUniqueWithoutGiverInput[]
    updateMany?: PartnerLoanUpdateManyWithWhereWithoutGiverInput | PartnerLoanUpdateManyWithWhereWithoutGiverInput[]
    deleteMany?: PartnerLoanScalarWhereInput | PartnerLoanScalarWhereInput[]
  }

  export type PartnerLoanUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<PartnerLoanCreateWithoutReceiverInput, PartnerLoanUncheckedCreateWithoutReceiverInput> | PartnerLoanCreateWithoutReceiverInput[] | PartnerLoanUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: PartnerLoanCreateOrConnectWithoutReceiverInput | PartnerLoanCreateOrConnectWithoutReceiverInput[]
    upsert?: PartnerLoanUpsertWithWhereUniqueWithoutReceiverInput | PartnerLoanUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: PartnerLoanCreateManyReceiverInputEnvelope
    set?: PartnerLoanWhereUniqueInput | PartnerLoanWhereUniqueInput[]
    disconnect?: PartnerLoanWhereUniqueInput | PartnerLoanWhereUniqueInput[]
    delete?: PartnerLoanWhereUniqueInput | PartnerLoanWhereUniqueInput[]
    connect?: PartnerLoanWhereUniqueInput | PartnerLoanWhereUniqueInput[]
    update?: PartnerLoanUpdateWithWhereUniqueWithoutReceiverInput | PartnerLoanUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: PartnerLoanUpdateManyWithWhereWithoutReceiverInput | PartnerLoanUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: PartnerLoanScalarWhereInput | PartnerLoanScalarWhereInput[]
  }

  export type PartnerLoanUncheckedUpdateManyWithoutGiverNestedInput = {
    create?: XOR<PartnerLoanCreateWithoutGiverInput, PartnerLoanUncheckedCreateWithoutGiverInput> | PartnerLoanCreateWithoutGiverInput[] | PartnerLoanUncheckedCreateWithoutGiverInput[]
    connectOrCreate?: PartnerLoanCreateOrConnectWithoutGiverInput | PartnerLoanCreateOrConnectWithoutGiverInput[]
    upsert?: PartnerLoanUpsertWithWhereUniqueWithoutGiverInput | PartnerLoanUpsertWithWhereUniqueWithoutGiverInput[]
    createMany?: PartnerLoanCreateManyGiverInputEnvelope
    set?: PartnerLoanWhereUniqueInput | PartnerLoanWhereUniqueInput[]
    disconnect?: PartnerLoanWhereUniqueInput | PartnerLoanWhereUniqueInput[]
    delete?: PartnerLoanWhereUniqueInput | PartnerLoanWhereUniqueInput[]
    connect?: PartnerLoanWhereUniqueInput | PartnerLoanWhereUniqueInput[]
    update?: PartnerLoanUpdateWithWhereUniqueWithoutGiverInput | PartnerLoanUpdateWithWhereUniqueWithoutGiverInput[]
    updateMany?: PartnerLoanUpdateManyWithWhereWithoutGiverInput | PartnerLoanUpdateManyWithWhereWithoutGiverInput[]
    deleteMany?: PartnerLoanScalarWhereInput | PartnerLoanScalarWhereInput[]
  }

  export type PartnerLoanUncheckedUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<PartnerLoanCreateWithoutReceiverInput, PartnerLoanUncheckedCreateWithoutReceiverInput> | PartnerLoanCreateWithoutReceiverInput[] | PartnerLoanUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: PartnerLoanCreateOrConnectWithoutReceiverInput | PartnerLoanCreateOrConnectWithoutReceiverInput[]
    upsert?: PartnerLoanUpsertWithWhereUniqueWithoutReceiverInput | PartnerLoanUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: PartnerLoanCreateManyReceiverInputEnvelope
    set?: PartnerLoanWhereUniqueInput | PartnerLoanWhereUniqueInput[]
    disconnect?: PartnerLoanWhereUniqueInput | PartnerLoanWhereUniqueInput[]
    delete?: PartnerLoanWhereUniqueInput | PartnerLoanWhereUniqueInput[]
    connect?: PartnerLoanWhereUniqueInput | PartnerLoanWhereUniqueInput[]
    update?: PartnerLoanUpdateWithWhereUniqueWithoutReceiverInput | PartnerLoanUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: PartnerLoanUpdateManyWithWhereWithoutReceiverInput | PartnerLoanUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: PartnerLoanScalarWhereInput | PartnerLoanScalarWhereInput[]
  }

  export type PartnerCreateNestedOneWithoutLoansGivenInput = {
    create?: XOR<PartnerCreateWithoutLoansGivenInput, PartnerUncheckedCreateWithoutLoansGivenInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutLoansGivenInput
    connect?: PartnerWhereUniqueInput
  }

  export type PartnerCreateNestedOneWithoutLoansReceivedInput = {
    create?: XOR<PartnerCreateWithoutLoansReceivedInput, PartnerUncheckedCreateWithoutLoansReceivedInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutLoansReceivedInput
    connect?: PartnerWhereUniqueInput
  }

  export type EnumPartnerLoanStatusFieldUpdateOperationsInput = {
    set?: $Enums.PartnerLoanStatus
  }

  export type PartnerUpdateOneRequiredWithoutLoansGivenNestedInput = {
    create?: XOR<PartnerCreateWithoutLoansGivenInput, PartnerUncheckedCreateWithoutLoansGivenInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutLoansGivenInput
    upsert?: PartnerUpsertWithoutLoansGivenInput
    connect?: PartnerWhereUniqueInput
    update?: XOR<XOR<PartnerUpdateToOneWithWhereWithoutLoansGivenInput, PartnerUpdateWithoutLoansGivenInput>, PartnerUncheckedUpdateWithoutLoansGivenInput>
  }

  export type PartnerUpdateOneRequiredWithoutLoansReceivedNestedInput = {
    create?: XOR<PartnerCreateWithoutLoansReceivedInput, PartnerUncheckedCreateWithoutLoansReceivedInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutLoansReceivedInput
    upsert?: PartnerUpsertWithoutLoansReceivedInput
    connect?: PartnerWhereUniqueInput
    update?: XOR<XOR<PartnerUpdateToOneWithWhereWithoutLoansReceivedInput, PartnerUpdateWithoutLoansReceivedInput>, PartnerUncheckedUpdateWithoutLoansReceivedInput>
  }

  export type FoodIngredientCostCreateNestedManyWithoutIngredientInput = {
    create?: XOR<FoodIngredientCostCreateWithoutIngredientInput, FoodIngredientCostUncheckedCreateWithoutIngredientInput> | FoodIngredientCostCreateWithoutIngredientInput[] | FoodIngredientCostUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: FoodIngredientCostCreateOrConnectWithoutIngredientInput | FoodIngredientCostCreateOrConnectWithoutIngredientInput[]
    createMany?: FoodIngredientCostCreateManyIngredientInputEnvelope
    connect?: FoodIngredientCostWhereUniqueInput | FoodIngredientCostWhereUniqueInput[]
  }

  export type FoodRecipeItemCreateNestedManyWithoutIngredientInput = {
    create?: XOR<FoodRecipeItemCreateWithoutIngredientInput, FoodRecipeItemUncheckedCreateWithoutIngredientInput> | FoodRecipeItemCreateWithoutIngredientInput[] | FoodRecipeItemUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: FoodRecipeItemCreateOrConnectWithoutIngredientInput | FoodRecipeItemCreateOrConnectWithoutIngredientInput[]
    createMany?: FoodRecipeItemCreateManyIngredientInputEnvelope
    connect?: FoodRecipeItemWhereUniqueInput | FoodRecipeItemWhereUniqueInput[]
  }

  export type FoodIngredientCostUncheckedCreateNestedManyWithoutIngredientInput = {
    create?: XOR<FoodIngredientCostCreateWithoutIngredientInput, FoodIngredientCostUncheckedCreateWithoutIngredientInput> | FoodIngredientCostCreateWithoutIngredientInput[] | FoodIngredientCostUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: FoodIngredientCostCreateOrConnectWithoutIngredientInput | FoodIngredientCostCreateOrConnectWithoutIngredientInput[]
    createMany?: FoodIngredientCostCreateManyIngredientInputEnvelope
    connect?: FoodIngredientCostWhereUniqueInput | FoodIngredientCostWhereUniqueInput[]
  }

  export type FoodRecipeItemUncheckedCreateNestedManyWithoutIngredientInput = {
    create?: XOR<FoodRecipeItemCreateWithoutIngredientInput, FoodRecipeItemUncheckedCreateWithoutIngredientInput> | FoodRecipeItemCreateWithoutIngredientInput[] | FoodRecipeItemUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: FoodRecipeItemCreateOrConnectWithoutIngredientInput | FoodRecipeItemCreateOrConnectWithoutIngredientInput[]
    createMany?: FoodRecipeItemCreateManyIngredientInputEnvelope
    connect?: FoodRecipeItemWhereUniqueInput | FoodRecipeItemWhereUniqueInput[]
  }

  export type FoodIngredientCostUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<FoodIngredientCostCreateWithoutIngredientInput, FoodIngredientCostUncheckedCreateWithoutIngredientInput> | FoodIngredientCostCreateWithoutIngredientInput[] | FoodIngredientCostUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: FoodIngredientCostCreateOrConnectWithoutIngredientInput | FoodIngredientCostCreateOrConnectWithoutIngredientInput[]
    upsert?: FoodIngredientCostUpsertWithWhereUniqueWithoutIngredientInput | FoodIngredientCostUpsertWithWhereUniqueWithoutIngredientInput[]
    createMany?: FoodIngredientCostCreateManyIngredientInputEnvelope
    set?: FoodIngredientCostWhereUniqueInput | FoodIngredientCostWhereUniqueInput[]
    disconnect?: FoodIngredientCostWhereUniqueInput | FoodIngredientCostWhereUniqueInput[]
    delete?: FoodIngredientCostWhereUniqueInput | FoodIngredientCostWhereUniqueInput[]
    connect?: FoodIngredientCostWhereUniqueInput | FoodIngredientCostWhereUniqueInput[]
    update?: FoodIngredientCostUpdateWithWhereUniqueWithoutIngredientInput | FoodIngredientCostUpdateWithWhereUniqueWithoutIngredientInput[]
    updateMany?: FoodIngredientCostUpdateManyWithWhereWithoutIngredientInput | FoodIngredientCostUpdateManyWithWhereWithoutIngredientInput[]
    deleteMany?: FoodIngredientCostScalarWhereInput | FoodIngredientCostScalarWhereInput[]
  }

  export type FoodRecipeItemUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<FoodRecipeItemCreateWithoutIngredientInput, FoodRecipeItemUncheckedCreateWithoutIngredientInput> | FoodRecipeItemCreateWithoutIngredientInput[] | FoodRecipeItemUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: FoodRecipeItemCreateOrConnectWithoutIngredientInput | FoodRecipeItemCreateOrConnectWithoutIngredientInput[]
    upsert?: FoodRecipeItemUpsertWithWhereUniqueWithoutIngredientInput | FoodRecipeItemUpsertWithWhereUniqueWithoutIngredientInput[]
    createMany?: FoodRecipeItemCreateManyIngredientInputEnvelope
    set?: FoodRecipeItemWhereUniqueInput | FoodRecipeItemWhereUniqueInput[]
    disconnect?: FoodRecipeItemWhereUniqueInput | FoodRecipeItemWhereUniqueInput[]
    delete?: FoodRecipeItemWhereUniqueInput | FoodRecipeItemWhereUniqueInput[]
    connect?: FoodRecipeItemWhereUniqueInput | FoodRecipeItemWhereUniqueInput[]
    update?: FoodRecipeItemUpdateWithWhereUniqueWithoutIngredientInput | FoodRecipeItemUpdateWithWhereUniqueWithoutIngredientInput[]
    updateMany?: FoodRecipeItemUpdateManyWithWhereWithoutIngredientInput | FoodRecipeItemUpdateManyWithWhereWithoutIngredientInput[]
    deleteMany?: FoodRecipeItemScalarWhereInput | FoodRecipeItemScalarWhereInput[]
  }

  export type FoodIngredientCostUncheckedUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<FoodIngredientCostCreateWithoutIngredientInput, FoodIngredientCostUncheckedCreateWithoutIngredientInput> | FoodIngredientCostCreateWithoutIngredientInput[] | FoodIngredientCostUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: FoodIngredientCostCreateOrConnectWithoutIngredientInput | FoodIngredientCostCreateOrConnectWithoutIngredientInput[]
    upsert?: FoodIngredientCostUpsertWithWhereUniqueWithoutIngredientInput | FoodIngredientCostUpsertWithWhereUniqueWithoutIngredientInput[]
    createMany?: FoodIngredientCostCreateManyIngredientInputEnvelope
    set?: FoodIngredientCostWhereUniqueInput | FoodIngredientCostWhereUniqueInput[]
    disconnect?: FoodIngredientCostWhereUniqueInput | FoodIngredientCostWhereUniqueInput[]
    delete?: FoodIngredientCostWhereUniqueInput | FoodIngredientCostWhereUniqueInput[]
    connect?: FoodIngredientCostWhereUniqueInput | FoodIngredientCostWhereUniqueInput[]
    update?: FoodIngredientCostUpdateWithWhereUniqueWithoutIngredientInput | FoodIngredientCostUpdateWithWhereUniqueWithoutIngredientInput[]
    updateMany?: FoodIngredientCostUpdateManyWithWhereWithoutIngredientInput | FoodIngredientCostUpdateManyWithWhereWithoutIngredientInput[]
    deleteMany?: FoodIngredientCostScalarWhereInput | FoodIngredientCostScalarWhereInput[]
  }

  export type FoodRecipeItemUncheckedUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<FoodRecipeItemCreateWithoutIngredientInput, FoodRecipeItemUncheckedCreateWithoutIngredientInput> | FoodRecipeItemCreateWithoutIngredientInput[] | FoodRecipeItemUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: FoodRecipeItemCreateOrConnectWithoutIngredientInput | FoodRecipeItemCreateOrConnectWithoutIngredientInput[]
    upsert?: FoodRecipeItemUpsertWithWhereUniqueWithoutIngredientInput | FoodRecipeItemUpsertWithWhereUniqueWithoutIngredientInput[]
    createMany?: FoodRecipeItemCreateManyIngredientInputEnvelope
    set?: FoodRecipeItemWhereUniqueInput | FoodRecipeItemWhereUniqueInput[]
    disconnect?: FoodRecipeItemWhereUniqueInput | FoodRecipeItemWhereUniqueInput[]
    delete?: FoodRecipeItemWhereUniqueInput | FoodRecipeItemWhereUniqueInput[]
    connect?: FoodRecipeItemWhereUniqueInput | FoodRecipeItemWhereUniqueInput[]
    update?: FoodRecipeItemUpdateWithWhereUniqueWithoutIngredientInput | FoodRecipeItemUpdateWithWhereUniqueWithoutIngredientInput[]
    updateMany?: FoodRecipeItemUpdateManyWithWhereWithoutIngredientInput | FoodRecipeItemUpdateManyWithWhereWithoutIngredientInput[]
    deleteMany?: FoodRecipeItemScalarWhereInput | FoodRecipeItemScalarWhereInput[]
  }

  export type FoodIngredientCreateNestedOneWithoutCostsInput = {
    create?: XOR<FoodIngredientCreateWithoutCostsInput, FoodIngredientUncheckedCreateWithoutCostsInput>
    connectOrCreate?: FoodIngredientCreateOrConnectWithoutCostsInput
    connect?: FoodIngredientWhereUniqueInput
  }

  export type FoodIngredientUpdateOneRequiredWithoutCostsNestedInput = {
    create?: XOR<FoodIngredientCreateWithoutCostsInput, FoodIngredientUncheckedCreateWithoutCostsInput>
    connectOrCreate?: FoodIngredientCreateOrConnectWithoutCostsInput
    upsert?: FoodIngredientUpsertWithoutCostsInput
    connect?: FoodIngredientWhereUniqueInput
    update?: XOR<XOR<FoodIngredientUpdateToOneWithWhereWithoutCostsInput, FoodIngredientUpdateWithoutCostsInput>, FoodIngredientUncheckedUpdateWithoutCostsInput>
  }

  export type FoodRecipeItemCreateNestedManyWithoutRecipeInput = {
    create?: XOR<FoodRecipeItemCreateWithoutRecipeInput, FoodRecipeItemUncheckedCreateWithoutRecipeInput> | FoodRecipeItemCreateWithoutRecipeInput[] | FoodRecipeItemUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: FoodRecipeItemCreateOrConnectWithoutRecipeInput | FoodRecipeItemCreateOrConnectWithoutRecipeInput[]
    createMany?: FoodRecipeItemCreateManyRecipeInputEnvelope
    connect?: FoodRecipeItemWhereUniqueInput | FoodRecipeItemWhereUniqueInput[]
  }

  export type FoodRecipeItemCreateNestedManyWithoutChildRecipeInput = {
    create?: XOR<FoodRecipeItemCreateWithoutChildRecipeInput, FoodRecipeItemUncheckedCreateWithoutChildRecipeInput> | FoodRecipeItemCreateWithoutChildRecipeInput[] | FoodRecipeItemUncheckedCreateWithoutChildRecipeInput[]
    connectOrCreate?: FoodRecipeItemCreateOrConnectWithoutChildRecipeInput | FoodRecipeItemCreateOrConnectWithoutChildRecipeInput[]
    createMany?: FoodRecipeItemCreateManyChildRecipeInputEnvelope
    connect?: FoodRecipeItemWhereUniqueInput | FoodRecipeItemWhereUniqueInput[]
  }

  export type FoodRecipeCostCreateNestedManyWithoutRecipeInput = {
    create?: XOR<FoodRecipeCostCreateWithoutRecipeInput, FoodRecipeCostUncheckedCreateWithoutRecipeInput> | FoodRecipeCostCreateWithoutRecipeInput[] | FoodRecipeCostUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: FoodRecipeCostCreateOrConnectWithoutRecipeInput | FoodRecipeCostCreateOrConnectWithoutRecipeInput[]
    createMany?: FoodRecipeCostCreateManyRecipeInputEnvelope
    connect?: FoodRecipeCostWhereUniqueInput | FoodRecipeCostWhereUniqueInput[]
  }

  export type FoodMealPlanEntryCreateNestedManyWithoutRecipeInput = {
    create?: XOR<FoodMealPlanEntryCreateWithoutRecipeInput, FoodMealPlanEntryUncheckedCreateWithoutRecipeInput> | FoodMealPlanEntryCreateWithoutRecipeInput[] | FoodMealPlanEntryUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: FoodMealPlanEntryCreateOrConnectWithoutRecipeInput | FoodMealPlanEntryCreateOrConnectWithoutRecipeInput[]
    createMany?: FoodMealPlanEntryCreateManyRecipeInputEnvelope
    connect?: FoodMealPlanEntryWhereUniqueInput | FoodMealPlanEntryWhereUniqueInput[]
  }

  export type FoodRecipeItemUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<FoodRecipeItemCreateWithoutRecipeInput, FoodRecipeItemUncheckedCreateWithoutRecipeInput> | FoodRecipeItemCreateWithoutRecipeInput[] | FoodRecipeItemUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: FoodRecipeItemCreateOrConnectWithoutRecipeInput | FoodRecipeItemCreateOrConnectWithoutRecipeInput[]
    createMany?: FoodRecipeItemCreateManyRecipeInputEnvelope
    connect?: FoodRecipeItemWhereUniqueInput | FoodRecipeItemWhereUniqueInput[]
  }

  export type FoodRecipeItemUncheckedCreateNestedManyWithoutChildRecipeInput = {
    create?: XOR<FoodRecipeItemCreateWithoutChildRecipeInput, FoodRecipeItemUncheckedCreateWithoutChildRecipeInput> | FoodRecipeItemCreateWithoutChildRecipeInput[] | FoodRecipeItemUncheckedCreateWithoutChildRecipeInput[]
    connectOrCreate?: FoodRecipeItemCreateOrConnectWithoutChildRecipeInput | FoodRecipeItemCreateOrConnectWithoutChildRecipeInput[]
    createMany?: FoodRecipeItemCreateManyChildRecipeInputEnvelope
    connect?: FoodRecipeItemWhereUniqueInput | FoodRecipeItemWhereUniqueInput[]
  }

  export type FoodRecipeCostUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<FoodRecipeCostCreateWithoutRecipeInput, FoodRecipeCostUncheckedCreateWithoutRecipeInput> | FoodRecipeCostCreateWithoutRecipeInput[] | FoodRecipeCostUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: FoodRecipeCostCreateOrConnectWithoutRecipeInput | FoodRecipeCostCreateOrConnectWithoutRecipeInput[]
    createMany?: FoodRecipeCostCreateManyRecipeInputEnvelope
    connect?: FoodRecipeCostWhereUniqueInput | FoodRecipeCostWhereUniqueInput[]
  }

  export type FoodMealPlanEntryUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<FoodMealPlanEntryCreateWithoutRecipeInput, FoodMealPlanEntryUncheckedCreateWithoutRecipeInput> | FoodMealPlanEntryCreateWithoutRecipeInput[] | FoodMealPlanEntryUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: FoodMealPlanEntryCreateOrConnectWithoutRecipeInput | FoodMealPlanEntryCreateOrConnectWithoutRecipeInput[]
    createMany?: FoodMealPlanEntryCreateManyRecipeInputEnvelope
    connect?: FoodMealPlanEntryWhereUniqueInput | FoodMealPlanEntryWhereUniqueInput[]
  }

  export type EnumFoodMealTypeFieldUpdateOperationsInput = {
    set?: $Enums.FoodMealType
  }

  export type FoodRecipeItemUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<FoodRecipeItemCreateWithoutRecipeInput, FoodRecipeItemUncheckedCreateWithoutRecipeInput> | FoodRecipeItemCreateWithoutRecipeInput[] | FoodRecipeItemUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: FoodRecipeItemCreateOrConnectWithoutRecipeInput | FoodRecipeItemCreateOrConnectWithoutRecipeInput[]
    upsert?: FoodRecipeItemUpsertWithWhereUniqueWithoutRecipeInput | FoodRecipeItemUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: FoodRecipeItemCreateManyRecipeInputEnvelope
    set?: FoodRecipeItemWhereUniqueInput | FoodRecipeItemWhereUniqueInput[]
    disconnect?: FoodRecipeItemWhereUniqueInput | FoodRecipeItemWhereUniqueInput[]
    delete?: FoodRecipeItemWhereUniqueInput | FoodRecipeItemWhereUniqueInput[]
    connect?: FoodRecipeItemWhereUniqueInput | FoodRecipeItemWhereUniqueInput[]
    update?: FoodRecipeItemUpdateWithWhereUniqueWithoutRecipeInput | FoodRecipeItemUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: FoodRecipeItemUpdateManyWithWhereWithoutRecipeInput | FoodRecipeItemUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: FoodRecipeItemScalarWhereInput | FoodRecipeItemScalarWhereInput[]
  }

  export type FoodRecipeItemUpdateManyWithoutChildRecipeNestedInput = {
    create?: XOR<FoodRecipeItemCreateWithoutChildRecipeInput, FoodRecipeItemUncheckedCreateWithoutChildRecipeInput> | FoodRecipeItemCreateWithoutChildRecipeInput[] | FoodRecipeItemUncheckedCreateWithoutChildRecipeInput[]
    connectOrCreate?: FoodRecipeItemCreateOrConnectWithoutChildRecipeInput | FoodRecipeItemCreateOrConnectWithoutChildRecipeInput[]
    upsert?: FoodRecipeItemUpsertWithWhereUniqueWithoutChildRecipeInput | FoodRecipeItemUpsertWithWhereUniqueWithoutChildRecipeInput[]
    createMany?: FoodRecipeItemCreateManyChildRecipeInputEnvelope
    set?: FoodRecipeItemWhereUniqueInput | FoodRecipeItemWhereUniqueInput[]
    disconnect?: FoodRecipeItemWhereUniqueInput | FoodRecipeItemWhereUniqueInput[]
    delete?: FoodRecipeItemWhereUniqueInput | FoodRecipeItemWhereUniqueInput[]
    connect?: FoodRecipeItemWhereUniqueInput | FoodRecipeItemWhereUniqueInput[]
    update?: FoodRecipeItemUpdateWithWhereUniqueWithoutChildRecipeInput | FoodRecipeItemUpdateWithWhereUniqueWithoutChildRecipeInput[]
    updateMany?: FoodRecipeItemUpdateManyWithWhereWithoutChildRecipeInput | FoodRecipeItemUpdateManyWithWhereWithoutChildRecipeInput[]
    deleteMany?: FoodRecipeItemScalarWhereInput | FoodRecipeItemScalarWhereInput[]
  }

  export type FoodRecipeCostUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<FoodRecipeCostCreateWithoutRecipeInput, FoodRecipeCostUncheckedCreateWithoutRecipeInput> | FoodRecipeCostCreateWithoutRecipeInput[] | FoodRecipeCostUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: FoodRecipeCostCreateOrConnectWithoutRecipeInput | FoodRecipeCostCreateOrConnectWithoutRecipeInput[]
    upsert?: FoodRecipeCostUpsertWithWhereUniqueWithoutRecipeInput | FoodRecipeCostUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: FoodRecipeCostCreateManyRecipeInputEnvelope
    set?: FoodRecipeCostWhereUniqueInput | FoodRecipeCostWhereUniqueInput[]
    disconnect?: FoodRecipeCostWhereUniqueInput | FoodRecipeCostWhereUniqueInput[]
    delete?: FoodRecipeCostWhereUniqueInput | FoodRecipeCostWhereUniqueInput[]
    connect?: FoodRecipeCostWhereUniqueInput | FoodRecipeCostWhereUniqueInput[]
    update?: FoodRecipeCostUpdateWithWhereUniqueWithoutRecipeInput | FoodRecipeCostUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: FoodRecipeCostUpdateManyWithWhereWithoutRecipeInput | FoodRecipeCostUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: FoodRecipeCostScalarWhereInput | FoodRecipeCostScalarWhereInput[]
  }

  export type FoodMealPlanEntryUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<FoodMealPlanEntryCreateWithoutRecipeInput, FoodMealPlanEntryUncheckedCreateWithoutRecipeInput> | FoodMealPlanEntryCreateWithoutRecipeInput[] | FoodMealPlanEntryUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: FoodMealPlanEntryCreateOrConnectWithoutRecipeInput | FoodMealPlanEntryCreateOrConnectWithoutRecipeInput[]
    upsert?: FoodMealPlanEntryUpsertWithWhereUniqueWithoutRecipeInput | FoodMealPlanEntryUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: FoodMealPlanEntryCreateManyRecipeInputEnvelope
    set?: FoodMealPlanEntryWhereUniqueInput | FoodMealPlanEntryWhereUniqueInput[]
    disconnect?: FoodMealPlanEntryWhereUniqueInput | FoodMealPlanEntryWhereUniqueInput[]
    delete?: FoodMealPlanEntryWhereUniqueInput | FoodMealPlanEntryWhereUniqueInput[]
    connect?: FoodMealPlanEntryWhereUniqueInput | FoodMealPlanEntryWhereUniqueInput[]
    update?: FoodMealPlanEntryUpdateWithWhereUniqueWithoutRecipeInput | FoodMealPlanEntryUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: FoodMealPlanEntryUpdateManyWithWhereWithoutRecipeInput | FoodMealPlanEntryUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: FoodMealPlanEntryScalarWhereInput | FoodMealPlanEntryScalarWhereInput[]
  }

  export type FoodRecipeItemUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<FoodRecipeItemCreateWithoutRecipeInput, FoodRecipeItemUncheckedCreateWithoutRecipeInput> | FoodRecipeItemCreateWithoutRecipeInput[] | FoodRecipeItemUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: FoodRecipeItemCreateOrConnectWithoutRecipeInput | FoodRecipeItemCreateOrConnectWithoutRecipeInput[]
    upsert?: FoodRecipeItemUpsertWithWhereUniqueWithoutRecipeInput | FoodRecipeItemUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: FoodRecipeItemCreateManyRecipeInputEnvelope
    set?: FoodRecipeItemWhereUniqueInput | FoodRecipeItemWhereUniqueInput[]
    disconnect?: FoodRecipeItemWhereUniqueInput | FoodRecipeItemWhereUniqueInput[]
    delete?: FoodRecipeItemWhereUniqueInput | FoodRecipeItemWhereUniqueInput[]
    connect?: FoodRecipeItemWhereUniqueInput | FoodRecipeItemWhereUniqueInput[]
    update?: FoodRecipeItemUpdateWithWhereUniqueWithoutRecipeInput | FoodRecipeItemUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: FoodRecipeItemUpdateManyWithWhereWithoutRecipeInput | FoodRecipeItemUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: FoodRecipeItemScalarWhereInput | FoodRecipeItemScalarWhereInput[]
  }

  export type FoodRecipeItemUncheckedUpdateManyWithoutChildRecipeNestedInput = {
    create?: XOR<FoodRecipeItemCreateWithoutChildRecipeInput, FoodRecipeItemUncheckedCreateWithoutChildRecipeInput> | FoodRecipeItemCreateWithoutChildRecipeInput[] | FoodRecipeItemUncheckedCreateWithoutChildRecipeInput[]
    connectOrCreate?: FoodRecipeItemCreateOrConnectWithoutChildRecipeInput | FoodRecipeItemCreateOrConnectWithoutChildRecipeInput[]
    upsert?: FoodRecipeItemUpsertWithWhereUniqueWithoutChildRecipeInput | FoodRecipeItemUpsertWithWhereUniqueWithoutChildRecipeInput[]
    createMany?: FoodRecipeItemCreateManyChildRecipeInputEnvelope
    set?: FoodRecipeItemWhereUniqueInput | FoodRecipeItemWhereUniqueInput[]
    disconnect?: FoodRecipeItemWhereUniqueInput | FoodRecipeItemWhereUniqueInput[]
    delete?: FoodRecipeItemWhereUniqueInput | FoodRecipeItemWhereUniqueInput[]
    connect?: FoodRecipeItemWhereUniqueInput | FoodRecipeItemWhereUniqueInput[]
    update?: FoodRecipeItemUpdateWithWhereUniqueWithoutChildRecipeInput | FoodRecipeItemUpdateWithWhereUniqueWithoutChildRecipeInput[]
    updateMany?: FoodRecipeItemUpdateManyWithWhereWithoutChildRecipeInput | FoodRecipeItemUpdateManyWithWhereWithoutChildRecipeInput[]
    deleteMany?: FoodRecipeItemScalarWhereInput | FoodRecipeItemScalarWhereInput[]
  }

  export type FoodRecipeCostUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<FoodRecipeCostCreateWithoutRecipeInput, FoodRecipeCostUncheckedCreateWithoutRecipeInput> | FoodRecipeCostCreateWithoutRecipeInput[] | FoodRecipeCostUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: FoodRecipeCostCreateOrConnectWithoutRecipeInput | FoodRecipeCostCreateOrConnectWithoutRecipeInput[]
    upsert?: FoodRecipeCostUpsertWithWhereUniqueWithoutRecipeInput | FoodRecipeCostUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: FoodRecipeCostCreateManyRecipeInputEnvelope
    set?: FoodRecipeCostWhereUniqueInput | FoodRecipeCostWhereUniqueInput[]
    disconnect?: FoodRecipeCostWhereUniqueInput | FoodRecipeCostWhereUniqueInput[]
    delete?: FoodRecipeCostWhereUniqueInput | FoodRecipeCostWhereUniqueInput[]
    connect?: FoodRecipeCostWhereUniqueInput | FoodRecipeCostWhereUniqueInput[]
    update?: FoodRecipeCostUpdateWithWhereUniqueWithoutRecipeInput | FoodRecipeCostUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: FoodRecipeCostUpdateManyWithWhereWithoutRecipeInput | FoodRecipeCostUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: FoodRecipeCostScalarWhereInput | FoodRecipeCostScalarWhereInput[]
  }

  export type FoodMealPlanEntryUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<FoodMealPlanEntryCreateWithoutRecipeInput, FoodMealPlanEntryUncheckedCreateWithoutRecipeInput> | FoodMealPlanEntryCreateWithoutRecipeInput[] | FoodMealPlanEntryUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: FoodMealPlanEntryCreateOrConnectWithoutRecipeInput | FoodMealPlanEntryCreateOrConnectWithoutRecipeInput[]
    upsert?: FoodMealPlanEntryUpsertWithWhereUniqueWithoutRecipeInput | FoodMealPlanEntryUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: FoodMealPlanEntryCreateManyRecipeInputEnvelope
    set?: FoodMealPlanEntryWhereUniqueInput | FoodMealPlanEntryWhereUniqueInput[]
    disconnect?: FoodMealPlanEntryWhereUniqueInput | FoodMealPlanEntryWhereUniqueInput[]
    delete?: FoodMealPlanEntryWhereUniqueInput | FoodMealPlanEntryWhereUniqueInput[]
    connect?: FoodMealPlanEntryWhereUniqueInput | FoodMealPlanEntryWhereUniqueInput[]
    update?: FoodMealPlanEntryUpdateWithWhereUniqueWithoutRecipeInput | FoodMealPlanEntryUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: FoodMealPlanEntryUpdateManyWithWhereWithoutRecipeInput | FoodMealPlanEntryUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: FoodMealPlanEntryScalarWhereInput | FoodMealPlanEntryScalarWhereInput[]
  }

  export type FoodRecipeCreateNestedOneWithoutItemsInput = {
    create?: XOR<FoodRecipeCreateWithoutItemsInput, FoodRecipeUncheckedCreateWithoutItemsInput>
    connectOrCreate?: FoodRecipeCreateOrConnectWithoutItemsInput
    connect?: FoodRecipeWhereUniqueInput
  }

  export type FoodIngredientCreateNestedOneWithoutItemsInput = {
    create?: XOR<FoodIngredientCreateWithoutItemsInput, FoodIngredientUncheckedCreateWithoutItemsInput>
    connectOrCreate?: FoodIngredientCreateOrConnectWithoutItemsInput
    connect?: FoodIngredientWhereUniqueInput
  }

  export type FoodRecipeCreateNestedOneWithoutChildItemsInput = {
    create?: XOR<FoodRecipeCreateWithoutChildItemsInput, FoodRecipeUncheckedCreateWithoutChildItemsInput>
    connectOrCreate?: FoodRecipeCreateOrConnectWithoutChildItemsInput
    connect?: FoodRecipeWhereUniqueInput
  }

  export type FoodRecipeUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<FoodRecipeCreateWithoutItemsInput, FoodRecipeUncheckedCreateWithoutItemsInput>
    connectOrCreate?: FoodRecipeCreateOrConnectWithoutItemsInput
    upsert?: FoodRecipeUpsertWithoutItemsInput
    connect?: FoodRecipeWhereUniqueInput
    update?: XOR<XOR<FoodRecipeUpdateToOneWithWhereWithoutItemsInput, FoodRecipeUpdateWithoutItemsInput>, FoodRecipeUncheckedUpdateWithoutItemsInput>
  }

  export type FoodIngredientUpdateOneWithoutItemsNestedInput = {
    create?: XOR<FoodIngredientCreateWithoutItemsInput, FoodIngredientUncheckedCreateWithoutItemsInput>
    connectOrCreate?: FoodIngredientCreateOrConnectWithoutItemsInput
    upsert?: FoodIngredientUpsertWithoutItemsInput
    disconnect?: FoodIngredientWhereInput | boolean
    delete?: FoodIngredientWhereInput | boolean
    connect?: FoodIngredientWhereUniqueInput
    update?: XOR<XOR<FoodIngredientUpdateToOneWithWhereWithoutItemsInput, FoodIngredientUpdateWithoutItemsInput>, FoodIngredientUncheckedUpdateWithoutItemsInput>
  }

  export type FoodRecipeUpdateOneWithoutChildItemsNestedInput = {
    create?: XOR<FoodRecipeCreateWithoutChildItemsInput, FoodRecipeUncheckedCreateWithoutChildItemsInput>
    connectOrCreate?: FoodRecipeCreateOrConnectWithoutChildItemsInput
    upsert?: FoodRecipeUpsertWithoutChildItemsInput
    disconnect?: FoodRecipeWhereInput | boolean
    delete?: FoodRecipeWhereInput | boolean
    connect?: FoodRecipeWhereUniqueInput
    update?: XOR<XOR<FoodRecipeUpdateToOneWithWhereWithoutChildItemsInput, FoodRecipeUpdateWithoutChildItemsInput>, FoodRecipeUncheckedUpdateWithoutChildItemsInput>
  }

  export type FoodRecipeCreateNestedOneWithoutExtraCostsInput = {
    create?: XOR<FoodRecipeCreateWithoutExtraCostsInput, FoodRecipeUncheckedCreateWithoutExtraCostsInput>
    connectOrCreate?: FoodRecipeCreateOrConnectWithoutExtraCostsInput
    connect?: FoodRecipeWhereUniqueInput
  }

  export type EnumFoodCostLineTypeFieldUpdateOperationsInput = {
    set?: $Enums.FoodCostLineType
  }

  export type EnumFoodCostPeriodFieldUpdateOperationsInput = {
    set?: $Enums.FoodCostPeriod
  }

  export type FoodRecipeUpdateOneRequiredWithoutExtraCostsNestedInput = {
    create?: XOR<FoodRecipeCreateWithoutExtraCostsInput, FoodRecipeUncheckedCreateWithoutExtraCostsInput>
    connectOrCreate?: FoodRecipeCreateOrConnectWithoutExtraCostsInput
    upsert?: FoodRecipeUpsertWithoutExtraCostsInput
    connect?: FoodRecipeWhereUniqueInput
    update?: XOR<XOR<FoodRecipeUpdateToOneWithWhereWithoutExtraCostsInput, FoodRecipeUpdateWithoutExtraCostsInput>, FoodRecipeUncheckedUpdateWithoutExtraCostsInput>
  }

  export type EnumFoodCostPoolTypeFieldUpdateOperationsInput = {
    set?: $Enums.FoodCostPoolType
  }

  export type NullableEnumFoodMealTypeFieldUpdateOperationsInput = {
    set?: $Enums.FoodMealType | null
  }

  export type EnumPoolAllocationMethodFieldUpdateOperationsInput = {
    set?: $Enums.PoolAllocationMethod
  }

  export type FoodMealPlanEntryCreateNestedManyWithoutPlanInput = {
    create?: XOR<FoodMealPlanEntryCreateWithoutPlanInput, FoodMealPlanEntryUncheckedCreateWithoutPlanInput> | FoodMealPlanEntryCreateWithoutPlanInput[] | FoodMealPlanEntryUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: FoodMealPlanEntryCreateOrConnectWithoutPlanInput | FoodMealPlanEntryCreateOrConnectWithoutPlanInput[]
    createMany?: FoodMealPlanEntryCreateManyPlanInputEnvelope
    connect?: FoodMealPlanEntryWhereUniqueInput | FoodMealPlanEntryWhereUniqueInput[]
  }

  export type FoodMealPlanEntryUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<FoodMealPlanEntryCreateWithoutPlanInput, FoodMealPlanEntryUncheckedCreateWithoutPlanInput> | FoodMealPlanEntryCreateWithoutPlanInput[] | FoodMealPlanEntryUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: FoodMealPlanEntryCreateOrConnectWithoutPlanInput | FoodMealPlanEntryCreateOrConnectWithoutPlanInput[]
    createMany?: FoodMealPlanEntryCreateManyPlanInputEnvelope
    connect?: FoodMealPlanEntryWhereUniqueInput | FoodMealPlanEntryWhereUniqueInput[]
  }

  export type FoodMealPlanEntryUpdateManyWithoutPlanNestedInput = {
    create?: XOR<FoodMealPlanEntryCreateWithoutPlanInput, FoodMealPlanEntryUncheckedCreateWithoutPlanInput> | FoodMealPlanEntryCreateWithoutPlanInput[] | FoodMealPlanEntryUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: FoodMealPlanEntryCreateOrConnectWithoutPlanInput | FoodMealPlanEntryCreateOrConnectWithoutPlanInput[]
    upsert?: FoodMealPlanEntryUpsertWithWhereUniqueWithoutPlanInput | FoodMealPlanEntryUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: FoodMealPlanEntryCreateManyPlanInputEnvelope
    set?: FoodMealPlanEntryWhereUniqueInput | FoodMealPlanEntryWhereUniqueInput[]
    disconnect?: FoodMealPlanEntryWhereUniqueInput | FoodMealPlanEntryWhereUniqueInput[]
    delete?: FoodMealPlanEntryWhereUniqueInput | FoodMealPlanEntryWhereUniqueInput[]
    connect?: FoodMealPlanEntryWhereUniqueInput | FoodMealPlanEntryWhereUniqueInput[]
    update?: FoodMealPlanEntryUpdateWithWhereUniqueWithoutPlanInput | FoodMealPlanEntryUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: FoodMealPlanEntryUpdateManyWithWhereWithoutPlanInput | FoodMealPlanEntryUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: FoodMealPlanEntryScalarWhereInput | FoodMealPlanEntryScalarWhereInput[]
  }

  export type FoodMealPlanEntryUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<FoodMealPlanEntryCreateWithoutPlanInput, FoodMealPlanEntryUncheckedCreateWithoutPlanInput> | FoodMealPlanEntryCreateWithoutPlanInput[] | FoodMealPlanEntryUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: FoodMealPlanEntryCreateOrConnectWithoutPlanInput | FoodMealPlanEntryCreateOrConnectWithoutPlanInput[]
    upsert?: FoodMealPlanEntryUpsertWithWhereUniqueWithoutPlanInput | FoodMealPlanEntryUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: FoodMealPlanEntryCreateManyPlanInputEnvelope
    set?: FoodMealPlanEntryWhereUniqueInput | FoodMealPlanEntryWhereUniqueInput[]
    disconnect?: FoodMealPlanEntryWhereUniqueInput | FoodMealPlanEntryWhereUniqueInput[]
    delete?: FoodMealPlanEntryWhereUniqueInput | FoodMealPlanEntryWhereUniqueInput[]
    connect?: FoodMealPlanEntryWhereUniqueInput | FoodMealPlanEntryWhereUniqueInput[]
    update?: FoodMealPlanEntryUpdateWithWhereUniqueWithoutPlanInput | FoodMealPlanEntryUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: FoodMealPlanEntryUpdateManyWithWhereWithoutPlanInput | FoodMealPlanEntryUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: FoodMealPlanEntryScalarWhereInput | FoodMealPlanEntryScalarWhereInput[]
  }

  export type FoodMealPlanCreateNestedOneWithoutEntriesInput = {
    create?: XOR<FoodMealPlanCreateWithoutEntriesInput, FoodMealPlanUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: FoodMealPlanCreateOrConnectWithoutEntriesInput
    connect?: FoodMealPlanWhereUniqueInput
  }

  export type FoodRecipeCreateNestedOneWithoutMealPlanEntriesInput = {
    create?: XOR<FoodRecipeCreateWithoutMealPlanEntriesInput, FoodRecipeUncheckedCreateWithoutMealPlanEntriesInput>
    connectOrCreate?: FoodRecipeCreateOrConnectWithoutMealPlanEntriesInput
    connect?: FoodRecipeWhereUniqueInput
  }

  export type FoodMealPlanUpdateOneRequiredWithoutEntriesNestedInput = {
    create?: XOR<FoodMealPlanCreateWithoutEntriesInput, FoodMealPlanUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: FoodMealPlanCreateOrConnectWithoutEntriesInput
    upsert?: FoodMealPlanUpsertWithoutEntriesInput
    connect?: FoodMealPlanWhereUniqueInput
    update?: XOR<XOR<FoodMealPlanUpdateToOneWithWhereWithoutEntriesInput, FoodMealPlanUpdateWithoutEntriesInput>, FoodMealPlanUncheckedUpdateWithoutEntriesInput>
  }

  export type FoodRecipeUpdateOneRequiredWithoutMealPlanEntriesNestedInput = {
    create?: XOR<FoodRecipeCreateWithoutMealPlanEntriesInput, FoodRecipeUncheckedCreateWithoutMealPlanEntriesInput>
    connectOrCreate?: FoodRecipeCreateOrConnectWithoutMealPlanEntriesInput
    upsert?: FoodRecipeUpsertWithoutMealPlanEntriesInput
    connect?: FoodRecipeWhereUniqueInput
    update?: XOR<XOR<FoodRecipeUpdateToOneWithWhereWithoutMealPlanEntriesInput, FoodRecipeUpdateWithoutMealPlanEntriesInput>, FoodRecipeUncheckedUpdateWithoutMealPlanEntriesInput>
  }

  export type QuotationAttachmentCreateNestedOneWithoutProcessInput = {
    create?: XOR<QuotationAttachmentCreateWithoutProcessInput, QuotationAttachmentUncheckedCreateWithoutProcessInput>
    connectOrCreate?: QuotationAttachmentCreateOrConnectWithoutProcessInput
    connect?: QuotationAttachmentWhereUniqueInput
  }

  export type QuotationBaselineItemCreateNestedManyWithoutProcessInput = {
    create?: XOR<QuotationBaselineItemCreateWithoutProcessInput, QuotationBaselineItemUncheckedCreateWithoutProcessInput> | QuotationBaselineItemCreateWithoutProcessInput[] | QuotationBaselineItemUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: QuotationBaselineItemCreateOrConnectWithoutProcessInput | QuotationBaselineItemCreateOrConnectWithoutProcessInput[]
    createMany?: QuotationBaselineItemCreateManyProcessInputEnvelope
    connect?: QuotationBaselineItemWhereUniqueInput | QuotationBaselineItemWhereUniqueInput[]
  }

  export type QuotationCreateNestedManyWithoutProcessInput = {
    create?: XOR<QuotationCreateWithoutProcessInput, QuotationUncheckedCreateWithoutProcessInput> | QuotationCreateWithoutProcessInput[] | QuotationUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutProcessInput | QuotationCreateOrConnectWithoutProcessInput[]
    createMany?: QuotationCreateManyProcessInputEnvelope
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
  }

  export type PurchaseOrderLogCreateNestedManyWithoutProcessInput = {
    create?: XOR<PurchaseOrderLogCreateWithoutProcessInput, PurchaseOrderLogUncheckedCreateWithoutProcessInput> | PurchaseOrderLogCreateWithoutProcessInput[] | PurchaseOrderLogUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: PurchaseOrderLogCreateOrConnectWithoutProcessInput | PurchaseOrderLogCreateOrConnectWithoutProcessInput[]
    createMany?: PurchaseOrderLogCreateManyProcessInputEnvelope
    connect?: PurchaseOrderLogWhereUniqueInput | PurchaseOrderLogWhereUniqueInput[]
  }

  export type PurchaseDeliveryLogCreateNestedManyWithoutProcessInput = {
    create?: XOR<PurchaseDeliveryLogCreateWithoutProcessInput, PurchaseDeliveryLogUncheckedCreateWithoutProcessInput> | PurchaseDeliveryLogCreateWithoutProcessInput[] | PurchaseDeliveryLogUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: PurchaseDeliveryLogCreateOrConnectWithoutProcessInput | PurchaseDeliveryLogCreateOrConnectWithoutProcessInput[]
    createMany?: PurchaseDeliveryLogCreateManyProcessInputEnvelope
    connect?: PurchaseDeliveryLogWhereUniqueInput | PurchaseDeliveryLogWhereUniqueInput[]
  }

  export type QuotationBaselineItemUncheckedCreateNestedManyWithoutProcessInput = {
    create?: XOR<QuotationBaselineItemCreateWithoutProcessInput, QuotationBaselineItemUncheckedCreateWithoutProcessInput> | QuotationBaselineItemCreateWithoutProcessInput[] | QuotationBaselineItemUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: QuotationBaselineItemCreateOrConnectWithoutProcessInput | QuotationBaselineItemCreateOrConnectWithoutProcessInput[]
    createMany?: QuotationBaselineItemCreateManyProcessInputEnvelope
    connect?: QuotationBaselineItemWhereUniqueInput | QuotationBaselineItemWhereUniqueInput[]
  }

  export type QuotationUncheckedCreateNestedManyWithoutProcessInput = {
    create?: XOR<QuotationCreateWithoutProcessInput, QuotationUncheckedCreateWithoutProcessInput> | QuotationCreateWithoutProcessInput[] | QuotationUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutProcessInput | QuotationCreateOrConnectWithoutProcessInput[]
    createMany?: QuotationCreateManyProcessInputEnvelope
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
  }

  export type PurchaseOrderLogUncheckedCreateNestedManyWithoutProcessInput = {
    create?: XOR<PurchaseOrderLogCreateWithoutProcessInput, PurchaseOrderLogUncheckedCreateWithoutProcessInput> | PurchaseOrderLogCreateWithoutProcessInput[] | PurchaseOrderLogUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: PurchaseOrderLogCreateOrConnectWithoutProcessInput | PurchaseOrderLogCreateOrConnectWithoutProcessInput[]
    createMany?: PurchaseOrderLogCreateManyProcessInputEnvelope
    connect?: PurchaseOrderLogWhereUniqueInput | PurchaseOrderLogWhereUniqueInput[]
  }

  export type PurchaseDeliveryLogUncheckedCreateNestedManyWithoutProcessInput = {
    create?: XOR<PurchaseDeliveryLogCreateWithoutProcessInput, PurchaseDeliveryLogUncheckedCreateWithoutProcessInput> | PurchaseDeliveryLogCreateWithoutProcessInput[] | PurchaseDeliveryLogUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: PurchaseDeliveryLogCreateOrConnectWithoutProcessInput | PurchaseDeliveryLogCreateOrConnectWithoutProcessInput[]
    createMany?: PurchaseDeliveryLogCreateManyProcessInputEnvelope
    connect?: PurchaseDeliveryLogWhereUniqueInput | PurchaseDeliveryLogWhereUniqueInput[]
  }

  export type EnumQuotationProcessStatusFieldUpdateOperationsInput = {
    set?: $Enums.QuotationProcessStatus
  }

  export type QuotationAttachmentUpdateOneWithoutProcessNestedInput = {
    create?: XOR<QuotationAttachmentCreateWithoutProcessInput, QuotationAttachmentUncheckedCreateWithoutProcessInput>
    connectOrCreate?: QuotationAttachmentCreateOrConnectWithoutProcessInput
    upsert?: QuotationAttachmentUpsertWithoutProcessInput
    disconnect?: QuotationAttachmentWhereInput | boolean
    delete?: QuotationAttachmentWhereInput | boolean
    connect?: QuotationAttachmentWhereUniqueInput
    update?: XOR<XOR<QuotationAttachmentUpdateToOneWithWhereWithoutProcessInput, QuotationAttachmentUpdateWithoutProcessInput>, QuotationAttachmentUncheckedUpdateWithoutProcessInput>
  }

  export type QuotationBaselineItemUpdateManyWithoutProcessNestedInput = {
    create?: XOR<QuotationBaselineItemCreateWithoutProcessInput, QuotationBaselineItemUncheckedCreateWithoutProcessInput> | QuotationBaselineItemCreateWithoutProcessInput[] | QuotationBaselineItemUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: QuotationBaselineItemCreateOrConnectWithoutProcessInput | QuotationBaselineItemCreateOrConnectWithoutProcessInput[]
    upsert?: QuotationBaselineItemUpsertWithWhereUniqueWithoutProcessInput | QuotationBaselineItemUpsertWithWhereUniqueWithoutProcessInput[]
    createMany?: QuotationBaselineItemCreateManyProcessInputEnvelope
    set?: QuotationBaselineItemWhereUniqueInput | QuotationBaselineItemWhereUniqueInput[]
    disconnect?: QuotationBaselineItemWhereUniqueInput | QuotationBaselineItemWhereUniqueInput[]
    delete?: QuotationBaselineItemWhereUniqueInput | QuotationBaselineItemWhereUniqueInput[]
    connect?: QuotationBaselineItemWhereUniqueInput | QuotationBaselineItemWhereUniqueInput[]
    update?: QuotationBaselineItemUpdateWithWhereUniqueWithoutProcessInput | QuotationBaselineItemUpdateWithWhereUniqueWithoutProcessInput[]
    updateMany?: QuotationBaselineItemUpdateManyWithWhereWithoutProcessInput | QuotationBaselineItemUpdateManyWithWhereWithoutProcessInput[]
    deleteMany?: QuotationBaselineItemScalarWhereInput | QuotationBaselineItemScalarWhereInput[]
  }

  export type QuotationUpdateManyWithoutProcessNestedInput = {
    create?: XOR<QuotationCreateWithoutProcessInput, QuotationUncheckedCreateWithoutProcessInput> | QuotationCreateWithoutProcessInput[] | QuotationUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutProcessInput | QuotationCreateOrConnectWithoutProcessInput[]
    upsert?: QuotationUpsertWithWhereUniqueWithoutProcessInput | QuotationUpsertWithWhereUniqueWithoutProcessInput[]
    createMany?: QuotationCreateManyProcessInputEnvelope
    set?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    disconnect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    delete?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    update?: QuotationUpdateWithWhereUniqueWithoutProcessInput | QuotationUpdateWithWhereUniqueWithoutProcessInput[]
    updateMany?: QuotationUpdateManyWithWhereWithoutProcessInput | QuotationUpdateManyWithWhereWithoutProcessInput[]
    deleteMany?: QuotationScalarWhereInput | QuotationScalarWhereInput[]
  }

  export type PurchaseOrderLogUpdateManyWithoutProcessNestedInput = {
    create?: XOR<PurchaseOrderLogCreateWithoutProcessInput, PurchaseOrderLogUncheckedCreateWithoutProcessInput> | PurchaseOrderLogCreateWithoutProcessInput[] | PurchaseOrderLogUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: PurchaseOrderLogCreateOrConnectWithoutProcessInput | PurchaseOrderLogCreateOrConnectWithoutProcessInput[]
    upsert?: PurchaseOrderLogUpsertWithWhereUniqueWithoutProcessInput | PurchaseOrderLogUpsertWithWhereUniqueWithoutProcessInput[]
    createMany?: PurchaseOrderLogCreateManyProcessInputEnvelope
    set?: PurchaseOrderLogWhereUniqueInput | PurchaseOrderLogWhereUniqueInput[]
    disconnect?: PurchaseOrderLogWhereUniqueInput | PurchaseOrderLogWhereUniqueInput[]
    delete?: PurchaseOrderLogWhereUniqueInput | PurchaseOrderLogWhereUniqueInput[]
    connect?: PurchaseOrderLogWhereUniqueInput | PurchaseOrderLogWhereUniqueInput[]
    update?: PurchaseOrderLogUpdateWithWhereUniqueWithoutProcessInput | PurchaseOrderLogUpdateWithWhereUniqueWithoutProcessInput[]
    updateMany?: PurchaseOrderLogUpdateManyWithWhereWithoutProcessInput | PurchaseOrderLogUpdateManyWithWhereWithoutProcessInput[]
    deleteMany?: PurchaseOrderLogScalarWhereInput | PurchaseOrderLogScalarWhereInput[]
  }

  export type PurchaseDeliveryLogUpdateManyWithoutProcessNestedInput = {
    create?: XOR<PurchaseDeliveryLogCreateWithoutProcessInput, PurchaseDeliveryLogUncheckedCreateWithoutProcessInput> | PurchaseDeliveryLogCreateWithoutProcessInput[] | PurchaseDeliveryLogUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: PurchaseDeliveryLogCreateOrConnectWithoutProcessInput | PurchaseDeliveryLogCreateOrConnectWithoutProcessInput[]
    upsert?: PurchaseDeliveryLogUpsertWithWhereUniqueWithoutProcessInput | PurchaseDeliveryLogUpsertWithWhereUniqueWithoutProcessInput[]
    createMany?: PurchaseDeliveryLogCreateManyProcessInputEnvelope
    set?: PurchaseDeliveryLogWhereUniqueInput | PurchaseDeliveryLogWhereUniqueInput[]
    disconnect?: PurchaseDeliveryLogWhereUniqueInput | PurchaseDeliveryLogWhereUniqueInput[]
    delete?: PurchaseDeliveryLogWhereUniqueInput | PurchaseDeliveryLogWhereUniqueInput[]
    connect?: PurchaseDeliveryLogWhereUniqueInput | PurchaseDeliveryLogWhereUniqueInput[]
    update?: PurchaseDeliveryLogUpdateWithWhereUniqueWithoutProcessInput | PurchaseDeliveryLogUpdateWithWhereUniqueWithoutProcessInput[]
    updateMany?: PurchaseDeliveryLogUpdateManyWithWhereWithoutProcessInput | PurchaseDeliveryLogUpdateManyWithWhereWithoutProcessInput[]
    deleteMany?: PurchaseDeliveryLogScalarWhereInput | PurchaseDeliveryLogScalarWhereInput[]
  }

  export type QuotationBaselineItemUncheckedUpdateManyWithoutProcessNestedInput = {
    create?: XOR<QuotationBaselineItemCreateWithoutProcessInput, QuotationBaselineItemUncheckedCreateWithoutProcessInput> | QuotationBaselineItemCreateWithoutProcessInput[] | QuotationBaselineItemUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: QuotationBaselineItemCreateOrConnectWithoutProcessInput | QuotationBaselineItemCreateOrConnectWithoutProcessInput[]
    upsert?: QuotationBaselineItemUpsertWithWhereUniqueWithoutProcessInput | QuotationBaselineItemUpsertWithWhereUniqueWithoutProcessInput[]
    createMany?: QuotationBaselineItemCreateManyProcessInputEnvelope
    set?: QuotationBaselineItemWhereUniqueInput | QuotationBaselineItemWhereUniqueInput[]
    disconnect?: QuotationBaselineItemWhereUniqueInput | QuotationBaselineItemWhereUniqueInput[]
    delete?: QuotationBaselineItemWhereUniqueInput | QuotationBaselineItemWhereUniqueInput[]
    connect?: QuotationBaselineItemWhereUniqueInput | QuotationBaselineItemWhereUniqueInput[]
    update?: QuotationBaselineItemUpdateWithWhereUniqueWithoutProcessInput | QuotationBaselineItemUpdateWithWhereUniqueWithoutProcessInput[]
    updateMany?: QuotationBaselineItemUpdateManyWithWhereWithoutProcessInput | QuotationBaselineItemUpdateManyWithWhereWithoutProcessInput[]
    deleteMany?: QuotationBaselineItemScalarWhereInput | QuotationBaselineItemScalarWhereInput[]
  }

  export type QuotationUncheckedUpdateManyWithoutProcessNestedInput = {
    create?: XOR<QuotationCreateWithoutProcessInput, QuotationUncheckedCreateWithoutProcessInput> | QuotationCreateWithoutProcessInput[] | QuotationUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutProcessInput | QuotationCreateOrConnectWithoutProcessInput[]
    upsert?: QuotationUpsertWithWhereUniqueWithoutProcessInput | QuotationUpsertWithWhereUniqueWithoutProcessInput[]
    createMany?: QuotationCreateManyProcessInputEnvelope
    set?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    disconnect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    delete?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    update?: QuotationUpdateWithWhereUniqueWithoutProcessInput | QuotationUpdateWithWhereUniqueWithoutProcessInput[]
    updateMany?: QuotationUpdateManyWithWhereWithoutProcessInput | QuotationUpdateManyWithWhereWithoutProcessInput[]
    deleteMany?: QuotationScalarWhereInput | QuotationScalarWhereInput[]
  }

  export type PurchaseOrderLogUncheckedUpdateManyWithoutProcessNestedInput = {
    create?: XOR<PurchaseOrderLogCreateWithoutProcessInput, PurchaseOrderLogUncheckedCreateWithoutProcessInput> | PurchaseOrderLogCreateWithoutProcessInput[] | PurchaseOrderLogUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: PurchaseOrderLogCreateOrConnectWithoutProcessInput | PurchaseOrderLogCreateOrConnectWithoutProcessInput[]
    upsert?: PurchaseOrderLogUpsertWithWhereUniqueWithoutProcessInput | PurchaseOrderLogUpsertWithWhereUniqueWithoutProcessInput[]
    createMany?: PurchaseOrderLogCreateManyProcessInputEnvelope
    set?: PurchaseOrderLogWhereUniqueInput | PurchaseOrderLogWhereUniqueInput[]
    disconnect?: PurchaseOrderLogWhereUniqueInput | PurchaseOrderLogWhereUniqueInput[]
    delete?: PurchaseOrderLogWhereUniqueInput | PurchaseOrderLogWhereUniqueInput[]
    connect?: PurchaseOrderLogWhereUniqueInput | PurchaseOrderLogWhereUniqueInput[]
    update?: PurchaseOrderLogUpdateWithWhereUniqueWithoutProcessInput | PurchaseOrderLogUpdateWithWhereUniqueWithoutProcessInput[]
    updateMany?: PurchaseOrderLogUpdateManyWithWhereWithoutProcessInput | PurchaseOrderLogUpdateManyWithWhereWithoutProcessInput[]
    deleteMany?: PurchaseOrderLogScalarWhereInput | PurchaseOrderLogScalarWhereInput[]
  }

  export type PurchaseDeliveryLogUncheckedUpdateManyWithoutProcessNestedInput = {
    create?: XOR<PurchaseDeliveryLogCreateWithoutProcessInput, PurchaseDeliveryLogUncheckedCreateWithoutProcessInput> | PurchaseDeliveryLogCreateWithoutProcessInput[] | PurchaseDeliveryLogUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: PurchaseDeliveryLogCreateOrConnectWithoutProcessInput | PurchaseDeliveryLogCreateOrConnectWithoutProcessInput[]
    upsert?: PurchaseDeliveryLogUpsertWithWhereUniqueWithoutProcessInput | PurchaseDeliveryLogUpsertWithWhereUniqueWithoutProcessInput[]
    createMany?: PurchaseDeliveryLogCreateManyProcessInputEnvelope
    set?: PurchaseDeliveryLogWhereUniqueInput | PurchaseDeliveryLogWhereUniqueInput[]
    disconnect?: PurchaseDeliveryLogWhereUniqueInput | PurchaseDeliveryLogWhereUniqueInput[]
    delete?: PurchaseDeliveryLogWhereUniqueInput | PurchaseDeliveryLogWhereUniqueInput[]
    connect?: PurchaseDeliveryLogWhereUniqueInput | PurchaseDeliveryLogWhereUniqueInput[]
    update?: PurchaseDeliveryLogUpdateWithWhereUniqueWithoutProcessInput | PurchaseDeliveryLogUpdateWithWhereUniqueWithoutProcessInput[]
    updateMany?: PurchaseDeliveryLogUpdateManyWithWhereWithoutProcessInput | PurchaseDeliveryLogUpdateManyWithWhereWithoutProcessInput[]
    deleteMany?: PurchaseDeliveryLogScalarWhereInput | PurchaseDeliveryLogScalarWhereInput[]
  }

  export type QuotationProcessCreateNestedOneWithoutBaselinesInput = {
    create?: XOR<QuotationProcessCreateWithoutBaselinesInput, QuotationProcessUncheckedCreateWithoutBaselinesInput>
    connectOrCreate?: QuotationProcessCreateOrConnectWithoutBaselinesInput
    connect?: QuotationProcessWhereUniqueInput
  }

  export type MaterialCreateNestedOneWithoutBaseQuotesInput = {
    create?: XOR<MaterialCreateWithoutBaseQuotesInput, MaterialUncheckedCreateWithoutBaseQuotesInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutBaseQuotesInput
    connect?: MaterialWhereUniqueInput
  }

  export type QuotationItemCreateNestedManyWithoutBaselineItemInput = {
    create?: XOR<QuotationItemCreateWithoutBaselineItemInput, QuotationItemUncheckedCreateWithoutBaselineItemInput> | QuotationItemCreateWithoutBaselineItemInput[] | QuotationItemUncheckedCreateWithoutBaselineItemInput[]
    connectOrCreate?: QuotationItemCreateOrConnectWithoutBaselineItemInput | QuotationItemCreateOrConnectWithoutBaselineItemInput[]
    createMany?: QuotationItemCreateManyBaselineItemInputEnvelope
    connect?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
  }

  export type PurchaseOrderLineCreateNestedManyWithoutBaselineInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutBaselineInput, PurchaseOrderLineUncheckedCreateWithoutBaselineInput> | PurchaseOrderLineCreateWithoutBaselineInput[] | PurchaseOrderLineUncheckedCreateWithoutBaselineInput[]
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutBaselineInput | PurchaseOrderLineCreateOrConnectWithoutBaselineInput[]
    createMany?: PurchaseOrderLineCreateManyBaselineInputEnvelope
    connect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
  }

  export type PurchaseDeliveryItemCreateNestedManyWithoutBaselineInput = {
    create?: XOR<PurchaseDeliveryItemCreateWithoutBaselineInput, PurchaseDeliveryItemUncheckedCreateWithoutBaselineInput> | PurchaseDeliveryItemCreateWithoutBaselineInput[] | PurchaseDeliveryItemUncheckedCreateWithoutBaselineInput[]
    connectOrCreate?: PurchaseDeliveryItemCreateOrConnectWithoutBaselineInput | PurchaseDeliveryItemCreateOrConnectWithoutBaselineInput[]
    createMany?: PurchaseDeliveryItemCreateManyBaselineInputEnvelope
    connect?: PurchaseDeliveryItemWhereUniqueInput | PurchaseDeliveryItemWhereUniqueInput[]
  }

  export type QuotationItemUncheckedCreateNestedManyWithoutBaselineItemInput = {
    create?: XOR<QuotationItemCreateWithoutBaselineItemInput, QuotationItemUncheckedCreateWithoutBaselineItemInput> | QuotationItemCreateWithoutBaselineItemInput[] | QuotationItemUncheckedCreateWithoutBaselineItemInput[]
    connectOrCreate?: QuotationItemCreateOrConnectWithoutBaselineItemInput | QuotationItemCreateOrConnectWithoutBaselineItemInput[]
    createMany?: QuotationItemCreateManyBaselineItemInputEnvelope
    connect?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
  }

  export type PurchaseOrderLineUncheckedCreateNestedManyWithoutBaselineInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutBaselineInput, PurchaseOrderLineUncheckedCreateWithoutBaselineInput> | PurchaseOrderLineCreateWithoutBaselineInput[] | PurchaseOrderLineUncheckedCreateWithoutBaselineInput[]
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutBaselineInput | PurchaseOrderLineCreateOrConnectWithoutBaselineInput[]
    createMany?: PurchaseOrderLineCreateManyBaselineInputEnvelope
    connect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
  }

  export type PurchaseDeliveryItemUncheckedCreateNestedManyWithoutBaselineInput = {
    create?: XOR<PurchaseDeliveryItemCreateWithoutBaselineInput, PurchaseDeliveryItemUncheckedCreateWithoutBaselineInput> | PurchaseDeliveryItemCreateWithoutBaselineInput[] | PurchaseDeliveryItemUncheckedCreateWithoutBaselineInput[]
    connectOrCreate?: PurchaseDeliveryItemCreateOrConnectWithoutBaselineInput | PurchaseDeliveryItemCreateOrConnectWithoutBaselineInput[]
    createMany?: PurchaseDeliveryItemCreateManyBaselineInputEnvelope
    connect?: PurchaseDeliveryItemWhereUniqueInput | PurchaseDeliveryItemWhereUniqueInput[]
  }

  export type QuotationProcessUpdateOneRequiredWithoutBaselinesNestedInput = {
    create?: XOR<QuotationProcessCreateWithoutBaselinesInput, QuotationProcessUncheckedCreateWithoutBaselinesInput>
    connectOrCreate?: QuotationProcessCreateOrConnectWithoutBaselinesInput
    upsert?: QuotationProcessUpsertWithoutBaselinesInput
    connect?: QuotationProcessWhereUniqueInput
    update?: XOR<XOR<QuotationProcessUpdateToOneWithWhereWithoutBaselinesInput, QuotationProcessUpdateWithoutBaselinesInput>, QuotationProcessUncheckedUpdateWithoutBaselinesInput>
  }

  export type MaterialUpdateOneWithoutBaseQuotesNestedInput = {
    create?: XOR<MaterialCreateWithoutBaseQuotesInput, MaterialUncheckedCreateWithoutBaseQuotesInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutBaseQuotesInput
    upsert?: MaterialUpsertWithoutBaseQuotesInput
    disconnect?: MaterialWhereInput | boolean
    delete?: MaterialWhereInput | boolean
    connect?: MaterialWhereUniqueInput
    update?: XOR<XOR<MaterialUpdateToOneWithWhereWithoutBaseQuotesInput, MaterialUpdateWithoutBaseQuotesInput>, MaterialUncheckedUpdateWithoutBaseQuotesInput>
  }

  export type QuotationItemUpdateManyWithoutBaselineItemNestedInput = {
    create?: XOR<QuotationItemCreateWithoutBaselineItemInput, QuotationItemUncheckedCreateWithoutBaselineItemInput> | QuotationItemCreateWithoutBaselineItemInput[] | QuotationItemUncheckedCreateWithoutBaselineItemInput[]
    connectOrCreate?: QuotationItemCreateOrConnectWithoutBaselineItemInput | QuotationItemCreateOrConnectWithoutBaselineItemInput[]
    upsert?: QuotationItemUpsertWithWhereUniqueWithoutBaselineItemInput | QuotationItemUpsertWithWhereUniqueWithoutBaselineItemInput[]
    createMany?: QuotationItemCreateManyBaselineItemInputEnvelope
    set?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    disconnect?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    delete?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    connect?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    update?: QuotationItemUpdateWithWhereUniqueWithoutBaselineItemInput | QuotationItemUpdateWithWhereUniqueWithoutBaselineItemInput[]
    updateMany?: QuotationItemUpdateManyWithWhereWithoutBaselineItemInput | QuotationItemUpdateManyWithWhereWithoutBaselineItemInput[]
    deleteMany?: QuotationItemScalarWhereInput | QuotationItemScalarWhereInput[]
  }

  export type PurchaseOrderLineUpdateManyWithoutBaselineNestedInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutBaselineInput, PurchaseOrderLineUncheckedCreateWithoutBaselineInput> | PurchaseOrderLineCreateWithoutBaselineInput[] | PurchaseOrderLineUncheckedCreateWithoutBaselineInput[]
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutBaselineInput | PurchaseOrderLineCreateOrConnectWithoutBaselineInput[]
    upsert?: PurchaseOrderLineUpsertWithWhereUniqueWithoutBaselineInput | PurchaseOrderLineUpsertWithWhereUniqueWithoutBaselineInput[]
    createMany?: PurchaseOrderLineCreateManyBaselineInputEnvelope
    set?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    disconnect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    delete?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    connect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    update?: PurchaseOrderLineUpdateWithWhereUniqueWithoutBaselineInput | PurchaseOrderLineUpdateWithWhereUniqueWithoutBaselineInput[]
    updateMany?: PurchaseOrderLineUpdateManyWithWhereWithoutBaselineInput | PurchaseOrderLineUpdateManyWithWhereWithoutBaselineInput[]
    deleteMany?: PurchaseOrderLineScalarWhereInput | PurchaseOrderLineScalarWhereInput[]
  }

  export type PurchaseDeliveryItemUpdateManyWithoutBaselineNestedInput = {
    create?: XOR<PurchaseDeliveryItemCreateWithoutBaselineInput, PurchaseDeliveryItemUncheckedCreateWithoutBaselineInput> | PurchaseDeliveryItemCreateWithoutBaselineInput[] | PurchaseDeliveryItemUncheckedCreateWithoutBaselineInput[]
    connectOrCreate?: PurchaseDeliveryItemCreateOrConnectWithoutBaselineInput | PurchaseDeliveryItemCreateOrConnectWithoutBaselineInput[]
    upsert?: PurchaseDeliveryItemUpsertWithWhereUniqueWithoutBaselineInput | PurchaseDeliveryItemUpsertWithWhereUniqueWithoutBaselineInput[]
    createMany?: PurchaseDeliveryItemCreateManyBaselineInputEnvelope
    set?: PurchaseDeliveryItemWhereUniqueInput | PurchaseDeliveryItemWhereUniqueInput[]
    disconnect?: PurchaseDeliveryItemWhereUniqueInput | PurchaseDeliveryItemWhereUniqueInput[]
    delete?: PurchaseDeliveryItemWhereUniqueInput | PurchaseDeliveryItemWhereUniqueInput[]
    connect?: PurchaseDeliveryItemWhereUniqueInput | PurchaseDeliveryItemWhereUniqueInput[]
    update?: PurchaseDeliveryItemUpdateWithWhereUniqueWithoutBaselineInput | PurchaseDeliveryItemUpdateWithWhereUniqueWithoutBaselineInput[]
    updateMany?: PurchaseDeliveryItemUpdateManyWithWhereWithoutBaselineInput | PurchaseDeliveryItemUpdateManyWithWhereWithoutBaselineInput[]
    deleteMany?: PurchaseDeliveryItemScalarWhereInput | PurchaseDeliveryItemScalarWhereInput[]
  }

  export type QuotationItemUncheckedUpdateManyWithoutBaselineItemNestedInput = {
    create?: XOR<QuotationItemCreateWithoutBaselineItemInput, QuotationItemUncheckedCreateWithoutBaselineItemInput> | QuotationItemCreateWithoutBaselineItemInput[] | QuotationItemUncheckedCreateWithoutBaselineItemInput[]
    connectOrCreate?: QuotationItemCreateOrConnectWithoutBaselineItemInput | QuotationItemCreateOrConnectWithoutBaselineItemInput[]
    upsert?: QuotationItemUpsertWithWhereUniqueWithoutBaselineItemInput | QuotationItemUpsertWithWhereUniqueWithoutBaselineItemInput[]
    createMany?: QuotationItemCreateManyBaselineItemInputEnvelope
    set?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    disconnect?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    delete?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    connect?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    update?: QuotationItemUpdateWithWhereUniqueWithoutBaselineItemInput | QuotationItemUpdateWithWhereUniqueWithoutBaselineItemInput[]
    updateMany?: QuotationItemUpdateManyWithWhereWithoutBaselineItemInput | QuotationItemUpdateManyWithWhereWithoutBaselineItemInput[]
    deleteMany?: QuotationItemScalarWhereInput | QuotationItemScalarWhereInput[]
  }

  export type PurchaseOrderLineUncheckedUpdateManyWithoutBaselineNestedInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutBaselineInput, PurchaseOrderLineUncheckedCreateWithoutBaselineInput> | PurchaseOrderLineCreateWithoutBaselineInput[] | PurchaseOrderLineUncheckedCreateWithoutBaselineInput[]
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutBaselineInput | PurchaseOrderLineCreateOrConnectWithoutBaselineInput[]
    upsert?: PurchaseOrderLineUpsertWithWhereUniqueWithoutBaselineInput | PurchaseOrderLineUpsertWithWhereUniqueWithoutBaselineInput[]
    createMany?: PurchaseOrderLineCreateManyBaselineInputEnvelope
    set?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    disconnect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    delete?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    connect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    update?: PurchaseOrderLineUpdateWithWhereUniqueWithoutBaselineInput | PurchaseOrderLineUpdateWithWhereUniqueWithoutBaselineInput[]
    updateMany?: PurchaseOrderLineUpdateManyWithWhereWithoutBaselineInput | PurchaseOrderLineUpdateManyWithWhereWithoutBaselineInput[]
    deleteMany?: PurchaseOrderLineScalarWhereInput | PurchaseOrderLineScalarWhereInput[]
  }

  export type PurchaseDeliveryItemUncheckedUpdateManyWithoutBaselineNestedInput = {
    create?: XOR<PurchaseDeliveryItemCreateWithoutBaselineInput, PurchaseDeliveryItemUncheckedCreateWithoutBaselineInput> | PurchaseDeliveryItemCreateWithoutBaselineInput[] | PurchaseDeliveryItemUncheckedCreateWithoutBaselineInput[]
    connectOrCreate?: PurchaseDeliveryItemCreateOrConnectWithoutBaselineInput | PurchaseDeliveryItemCreateOrConnectWithoutBaselineInput[]
    upsert?: PurchaseDeliveryItemUpsertWithWhereUniqueWithoutBaselineInput | PurchaseDeliveryItemUpsertWithWhereUniqueWithoutBaselineInput[]
    createMany?: PurchaseDeliveryItemCreateManyBaselineInputEnvelope
    set?: PurchaseDeliveryItemWhereUniqueInput | PurchaseDeliveryItemWhereUniqueInput[]
    disconnect?: PurchaseDeliveryItemWhereUniqueInput | PurchaseDeliveryItemWhereUniqueInput[]
    delete?: PurchaseDeliveryItemWhereUniqueInput | PurchaseDeliveryItemWhereUniqueInput[]
    connect?: PurchaseDeliveryItemWhereUniqueInput | PurchaseDeliveryItemWhereUniqueInput[]
    update?: PurchaseDeliveryItemUpdateWithWhereUniqueWithoutBaselineInput | PurchaseDeliveryItemUpdateWithWhereUniqueWithoutBaselineInput[]
    updateMany?: PurchaseDeliveryItemUpdateManyWithWhereWithoutBaselineInput | PurchaseDeliveryItemUpdateManyWithWhereWithoutBaselineInput[]
    deleteMany?: PurchaseDeliveryItemScalarWhereInput | PurchaseDeliveryItemScalarWhereInput[]
  }

  export type QuotationProcessCreateNestedOneWithoutQuotationsInput = {
    create?: XOR<QuotationProcessCreateWithoutQuotationsInput, QuotationProcessUncheckedCreateWithoutQuotationsInput>
    connectOrCreate?: QuotationProcessCreateOrConnectWithoutQuotationsInput
    connect?: QuotationProcessWhereUniqueInput
  }

  export type ProveedorCreateNestedOneWithoutQuotationsInput = {
    create?: XOR<ProveedorCreateWithoutQuotationsInput, ProveedorUncheckedCreateWithoutQuotationsInput>
    connectOrCreate?: ProveedorCreateOrConnectWithoutQuotationsInput
    connect?: ProveedorWhereUniqueInput
  }

  export type QuotationItemCreateNestedManyWithoutQuotationInput = {
    create?: XOR<QuotationItemCreateWithoutQuotationInput, QuotationItemUncheckedCreateWithoutQuotationInput> | QuotationItemCreateWithoutQuotationInput[] | QuotationItemUncheckedCreateWithoutQuotationInput[]
    connectOrCreate?: QuotationItemCreateOrConnectWithoutQuotationInput | QuotationItemCreateOrConnectWithoutQuotationInput[]
    createMany?: QuotationItemCreateManyQuotationInputEnvelope
    connect?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
  }

  export type QuotationAttachmentCreateNestedManyWithoutQuotationInput = {
    create?: XOR<QuotationAttachmentCreateWithoutQuotationInput, QuotationAttachmentUncheckedCreateWithoutQuotationInput> | QuotationAttachmentCreateWithoutQuotationInput[] | QuotationAttachmentUncheckedCreateWithoutQuotationInput[]
    connectOrCreate?: QuotationAttachmentCreateOrConnectWithoutQuotationInput | QuotationAttachmentCreateOrConnectWithoutQuotationInput[]
    createMany?: QuotationAttachmentCreateManyQuotationInputEnvelope
    connect?: QuotationAttachmentWhereUniqueInput | QuotationAttachmentWhereUniqueInput[]
  }

  export type PurchaseOrderLogCreateNestedManyWithoutQuotationInput = {
    create?: XOR<PurchaseOrderLogCreateWithoutQuotationInput, PurchaseOrderLogUncheckedCreateWithoutQuotationInput> | PurchaseOrderLogCreateWithoutQuotationInput[] | PurchaseOrderLogUncheckedCreateWithoutQuotationInput[]
    connectOrCreate?: PurchaseOrderLogCreateOrConnectWithoutQuotationInput | PurchaseOrderLogCreateOrConnectWithoutQuotationInput[]
    createMany?: PurchaseOrderLogCreateManyQuotationInputEnvelope
    connect?: PurchaseOrderLogWhereUniqueInput | PurchaseOrderLogWhereUniqueInput[]
  }

  export type QuotationItemUncheckedCreateNestedManyWithoutQuotationInput = {
    create?: XOR<QuotationItemCreateWithoutQuotationInput, QuotationItemUncheckedCreateWithoutQuotationInput> | QuotationItemCreateWithoutQuotationInput[] | QuotationItemUncheckedCreateWithoutQuotationInput[]
    connectOrCreate?: QuotationItemCreateOrConnectWithoutQuotationInput | QuotationItemCreateOrConnectWithoutQuotationInput[]
    createMany?: QuotationItemCreateManyQuotationInputEnvelope
    connect?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
  }

  export type QuotationAttachmentUncheckedCreateNestedManyWithoutQuotationInput = {
    create?: XOR<QuotationAttachmentCreateWithoutQuotationInput, QuotationAttachmentUncheckedCreateWithoutQuotationInput> | QuotationAttachmentCreateWithoutQuotationInput[] | QuotationAttachmentUncheckedCreateWithoutQuotationInput[]
    connectOrCreate?: QuotationAttachmentCreateOrConnectWithoutQuotationInput | QuotationAttachmentCreateOrConnectWithoutQuotationInput[]
    createMany?: QuotationAttachmentCreateManyQuotationInputEnvelope
    connect?: QuotationAttachmentWhereUniqueInput | QuotationAttachmentWhereUniqueInput[]
  }

  export type PurchaseOrderLogUncheckedCreateNestedManyWithoutQuotationInput = {
    create?: XOR<PurchaseOrderLogCreateWithoutQuotationInput, PurchaseOrderLogUncheckedCreateWithoutQuotationInput> | PurchaseOrderLogCreateWithoutQuotationInput[] | PurchaseOrderLogUncheckedCreateWithoutQuotationInput[]
    connectOrCreate?: PurchaseOrderLogCreateOrConnectWithoutQuotationInput | PurchaseOrderLogCreateOrConnectWithoutQuotationInput[]
    createMany?: PurchaseOrderLogCreateManyQuotationInputEnvelope
    connect?: PurchaseOrderLogWhereUniqueInput | PurchaseOrderLogWhereUniqueInput[]
  }

  export type EnumQuotationStatusFieldUpdateOperationsInput = {
    set?: $Enums.QuotationStatus
  }

  export type QuotationProcessUpdateOneRequiredWithoutQuotationsNestedInput = {
    create?: XOR<QuotationProcessCreateWithoutQuotationsInput, QuotationProcessUncheckedCreateWithoutQuotationsInput>
    connectOrCreate?: QuotationProcessCreateOrConnectWithoutQuotationsInput
    upsert?: QuotationProcessUpsertWithoutQuotationsInput
    connect?: QuotationProcessWhereUniqueInput
    update?: XOR<XOR<QuotationProcessUpdateToOneWithWhereWithoutQuotationsInput, QuotationProcessUpdateWithoutQuotationsInput>, QuotationProcessUncheckedUpdateWithoutQuotationsInput>
  }

  export type ProveedorUpdateOneWithoutQuotationsNestedInput = {
    create?: XOR<ProveedorCreateWithoutQuotationsInput, ProveedorUncheckedCreateWithoutQuotationsInput>
    connectOrCreate?: ProveedorCreateOrConnectWithoutQuotationsInput
    upsert?: ProveedorUpsertWithoutQuotationsInput
    disconnect?: ProveedorWhereInput | boolean
    delete?: ProveedorWhereInput | boolean
    connect?: ProveedorWhereUniqueInput
    update?: XOR<XOR<ProveedorUpdateToOneWithWhereWithoutQuotationsInput, ProveedorUpdateWithoutQuotationsInput>, ProveedorUncheckedUpdateWithoutQuotationsInput>
  }

  export type QuotationItemUpdateManyWithoutQuotationNestedInput = {
    create?: XOR<QuotationItemCreateWithoutQuotationInput, QuotationItemUncheckedCreateWithoutQuotationInput> | QuotationItemCreateWithoutQuotationInput[] | QuotationItemUncheckedCreateWithoutQuotationInput[]
    connectOrCreate?: QuotationItemCreateOrConnectWithoutQuotationInput | QuotationItemCreateOrConnectWithoutQuotationInput[]
    upsert?: QuotationItemUpsertWithWhereUniqueWithoutQuotationInput | QuotationItemUpsertWithWhereUniqueWithoutQuotationInput[]
    createMany?: QuotationItemCreateManyQuotationInputEnvelope
    set?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    disconnect?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    delete?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    connect?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    update?: QuotationItemUpdateWithWhereUniqueWithoutQuotationInput | QuotationItemUpdateWithWhereUniqueWithoutQuotationInput[]
    updateMany?: QuotationItemUpdateManyWithWhereWithoutQuotationInput | QuotationItemUpdateManyWithWhereWithoutQuotationInput[]
    deleteMany?: QuotationItemScalarWhereInput | QuotationItemScalarWhereInput[]
  }

  export type QuotationAttachmentUpdateManyWithoutQuotationNestedInput = {
    create?: XOR<QuotationAttachmentCreateWithoutQuotationInput, QuotationAttachmentUncheckedCreateWithoutQuotationInput> | QuotationAttachmentCreateWithoutQuotationInput[] | QuotationAttachmentUncheckedCreateWithoutQuotationInput[]
    connectOrCreate?: QuotationAttachmentCreateOrConnectWithoutQuotationInput | QuotationAttachmentCreateOrConnectWithoutQuotationInput[]
    upsert?: QuotationAttachmentUpsertWithWhereUniqueWithoutQuotationInput | QuotationAttachmentUpsertWithWhereUniqueWithoutQuotationInput[]
    createMany?: QuotationAttachmentCreateManyQuotationInputEnvelope
    set?: QuotationAttachmentWhereUniqueInput | QuotationAttachmentWhereUniqueInput[]
    disconnect?: QuotationAttachmentWhereUniqueInput | QuotationAttachmentWhereUniqueInput[]
    delete?: QuotationAttachmentWhereUniqueInput | QuotationAttachmentWhereUniqueInput[]
    connect?: QuotationAttachmentWhereUniqueInput | QuotationAttachmentWhereUniqueInput[]
    update?: QuotationAttachmentUpdateWithWhereUniqueWithoutQuotationInput | QuotationAttachmentUpdateWithWhereUniqueWithoutQuotationInput[]
    updateMany?: QuotationAttachmentUpdateManyWithWhereWithoutQuotationInput | QuotationAttachmentUpdateManyWithWhereWithoutQuotationInput[]
    deleteMany?: QuotationAttachmentScalarWhereInput | QuotationAttachmentScalarWhereInput[]
  }

  export type PurchaseOrderLogUpdateManyWithoutQuotationNestedInput = {
    create?: XOR<PurchaseOrderLogCreateWithoutQuotationInput, PurchaseOrderLogUncheckedCreateWithoutQuotationInput> | PurchaseOrderLogCreateWithoutQuotationInput[] | PurchaseOrderLogUncheckedCreateWithoutQuotationInput[]
    connectOrCreate?: PurchaseOrderLogCreateOrConnectWithoutQuotationInput | PurchaseOrderLogCreateOrConnectWithoutQuotationInput[]
    upsert?: PurchaseOrderLogUpsertWithWhereUniqueWithoutQuotationInput | PurchaseOrderLogUpsertWithWhereUniqueWithoutQuotationInput[]
    createMany?: PurchaseOrderLogCreateManyQuotationInputEnvelope
    set?: PurchaseOrderLogWhereUniqueInput | PurchaseOrderLogWhereUniqueInput[]
    disconnect?: PurchaseOrderLogWhereUniqueInput | PurchaseOrderLogWhereUniqueInput[]
    delete?: PurchaseOrderLogWhereUniqueInput | PurchaseOrderLogWhereUniqueInput[]
    connect?: PurchaseOrderLogWhereUniqueInput | PurchaseOrderLogWhereUniqueInput[]
    update?: PurchaseOrderLogUpdateWithWhereUniqueWithoutQuotationInput | PurchaseOrderLogUpdateWithWhereUniqueWithoutQuotationInput[]
    updateMany?: PurchaseOrderLogUpdateManyWithWhereWithoutQuotationInput | PurchaseOrderLogUpdateManyWithWhereWithoutQuotationInput[]
    deleteMany?: PurchaseOrderLogScalarWhereInput | PurchaseOrderLogScalarWhereInput[]
  }

  export type QuotationItemUncheckedUpdateManyWithoutQuotationNestedInput = {
    create?: XOR<QuotationItemCreateWithoutQuotationInput, QuotationItemUncheckedCreateWithoutQuotationInput> | QuotationItemCreateWithoutQuotationInput[] | QuotationItemUncheckedCreateWithoutQuotationInput[]
    connectOrCreate?: QuotationItemCreateOrConnectWithoutQuotationInput | QuotationItemCreateOrConnectWithoutQuotationInput[]
    upsert?: QuotationItemUpsertWithWhereUniqueWithoutQuotationInput | QuotationItemUpsertWithWhereUniqueWithoutQuotationInput[]
    createMany?: QuotationItemCreateManyQuotationInputEnvelope
    set?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    disconnect?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    delete?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    connect?: QuotationItemWhereUniqueInput | QuotationItemWhereUniqueInput[]
    update?: QuotationItemUpdateWithWhereUniqueWithoutQuotationInput | QuotationItemUpdateWithWhereUniqueWithoutQuotationInput[]
    updateMany?: QuotationItemUpdateManyWithWhereWithoutQuotationInput | QuotationItemUpdateManyWithWhereWithoutQuotationInput[]
    deleteMany?: QuotationItemScalarWhereInput | QuotationItemScalarWhereInput[]
  }

  export type QuotationAttachmentUncheckedUpdateManyWithoutQuotationNestedInput = {
    create?: XOR<QuotationAttachmentCreateWithoutQuotationInput, QuotationAttachmentUncheckedCreateWithoutQuotationInput> | QuotationAttachmentCreateWithoutQuotationInput[] | QuotationAttachmentUncheckedCreateWithoutQuotationInput[]
    connectOrCreate?: QuotationAttachmentCreateOrConnectWithoutQuotationInput | QuotationAttachmentCreateOrConnectWithoutQuotationInput[]
    upsert?: QuotationAttachmentUpsertWithWhereUniqueWithoutQuotationInput | QuotationAttachmentUpsertWithWhereUniqueWithoutQuotationInput[]
    createMany?: QuotationAttachmentCreateManyQuotationInputEnvelope
    set?: QuotationAttachmentWhereUniqueInput | QuotationAttachmentWhereUniqueInput[]
    disconnect?: QuotationAttachmentWhereUniqueInput | QuotationAttachmentWhereUniqueInput[]
    delete?: QuotationAttachmentWhereUniqueInput | QuotationAttachmentWhereUniqueInput[]
    connect?: QuotationAttachmentWhereUniqueInput | QuotationAttachmentWhereUniqueInput[]
    update?: QuotationAttachmentUpdateWithWhereUniqueWithoutQuotationInput | QuotationAttachmentUpdateWithWhereUniqueWithoutQuotationInput[]
    updateMany?: QuotationAttachmentUpdateManyWithWhereWithoutQuotationInput | QuotationAttachmentUpdateManyWithWhereWithoutQuotationInput[]
    deleteMany?: QuotationAttachmentScalarWhereInput | QuotationAttachmentScalarWhereInput[]
  }

  export type PurchaseOrderLogUncheckedUpdateManyWithoutQuotationNestedInput = {
    create?: XOR<PurchaseOrderLogCreateWithoutQuotationInput, PurchaseOrderLogUncheckedCreateWithoutQuotationInput> | PurchaseOrderLogCreateWithoutQuotationInput[] | PurchaseOrderLogUncheckedCreateWithoutQuotationInput[]
    connectOrCreate?: PurchaseOrderLogCreateOrConnectWithoutQuotationInput | PurchaseOrderLogCreateOrConnectWithoutQuotationInput[]
    upsert?: PurchaseOrderLogUpsertWithWhereUniqueWithoutQuotationInput | PurchaseOrderLogUpsertWithWhereUniqueWithoutQuotationInput[]
    createMany?: PurchaseOrderLogCreateManyQuotationInputEnvelope
    set?: PurchaseOrderLogWhereUniqueInput | PurchaseOrderLogWhereUniqueInput[]
    disconnect?: PurchaseOrderLogWhereUniqueInput | PurchaseOrderLogWhereUniqueInput[]
    delete?: PurchaseOrderLogWhereUniqueInput | PurchaseOrderLogWhereUniqueInput[]
    connect?: PurchaseOrderLogWhereUniqueInput | PurchaseOrderLogWhereUniqueInput[]
    update?: PurchaseOrderLogUpdateWithWhereUniqueWithoutQuotationInput | PurchaseOrderLogUpdateWithWhereUniqueWithoutQuotationInput[]
    updateMany?: PurchaseOrderLogUpdateManyWithWhereWithoutQuotationInput | PurchaseOrderLogUpdateManyWithWhereWithoutQuotationInput[]
    deleteMany?: PurchaseOrderLogScalarWhereInput | PurchaseOrderLogScalarWhereInput[]
  }

  export type QuotationCreateNestedOneWithoutItemsInput = {
    create?: XOR<QuotationCreateWithoutItemsInput, QuotationUncheckedCreateWithoutItemsInput>
    connectOrCreate?: QuotationCreateOrConnectWithoutItemsInput
    connect?: QuotationWhereUniqueInput
  }

  export type QuotationBaselineItemCreateNestedOneWithoutQuoteItemsInput = {
    create?: XOR<QuotationBaselineItemCreateWithoutQuoteItemsInput, QuotationBaselineItemUncheckedCreateWithoutQuoteItemsInput>
    connectOrCreate?: QuotationBaselineItemCreateOrConnectWithoutQuoteItemsInput
    connect?: QuotationBaselineItemWhereUniqueInput
  }

  export type MaterialCreateNestedOneWithoutQuoteItemsInput = {
    create?: XOR<MaterialCreateWithoutQuoteItemsInput, MaterialUncheckedCreateWithoutQuoteItemsInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutQuoteItemsInput
    connect?: MaterialWhereUniqueInput
  }

  export type QuotationUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<QuotationCreateWithoutItemsInput, QuotationUncheckedCreateWithoutItemsInput>
    connectOrCreate?: QuotationCreateOrConnectWithoutItemsInput
    upsert?: QuotationUpsertWithoutItemsInput
    connect?: QuotationWhereUniqueInput
    update?: XOR<XOR<QuotationUpdateToOneWithWhereWithoutItemsInput, QuotationUpdateWithoutItemsInput>, QuotationUncheckedUpdateWithoutItemsInput>
  }

  export type QuotationBaselineItemUpdateOneWithoutQuoteItemsNestedInput = {
    create?: XOR<QuotationBaselineItemCreateWithoutQuoteItemsInput, QuotationBaselineItemUncheckedCreateWithoutQuoteItemsInput>
    connectOrCreate?: QuotationBaselineItemCreateOrConnectWithoutQuoteItemsInput
    upsert?: QuotationBaselineItemUpsertWithoutQuoteItemsInput
    disconnect?: QuotationBaselineItemWhereInput | boolean
    delete?: QuotationBaselineItemWhereInput | boolean
    connect?: QuotationBaselineItemWhereUniqueInput
    update?: XOR<XOR<QuotationBaselineItemUpdateToOneWithWhereWithoutQuoteItemsInput, QuotationBaselineItemUpdateWithoutQuoteItemsInput>, QuotationBaselineItemUncheckedUpdateWithoutQuoteItemsInput>
  }

  export type MaterialUpdateOneWithoutQuoteItemsNestedInput = {
    create?: XOR<MaterialCreateWithoutQuoteItemsInput, MaterialUncheckedCreateWithoutQuoteItemsInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutQuoteItemsInput
    upsert?: MaterialUpsertWithoutQuoteItemsInput
    disconnect?: MaterialWhereInput | boolean
    delete?: MaterialWhereInput | boolean
    connect?: MaterialWhereUniqueInput
    update?: XOR<XOR<MaterialUpdateToOneWithWhereWithoutQuoteItemsInput, MaterialUpdateWithoutQuoteItemsInput>, MaterialUncheckedUpdateWithoutQuoteItemsInput>
  }

  export type QuotationCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<QuotationCreateWithoutAttachmentsInput, QuotationUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: QuotationCreateOrConnectWithoutAttachmentsInput
    connect?: QuotationWhereUniqueInput
  }

  export type QuotationProcessCreateNestedOneWithoutBaselineFileInput = {
    create?: XOR<QuotationProcessCreateWithoutBaselineFileInput, QuotationProcessUncheckedCreateWithoutBaselineFileInput>
    connectOrCreate?: QuotationProcessCreateOrConnectWithoutBaselineFileInput
    connect?: QuotationProcessWhereUniqueInput
  }

  export type QuotationProcessUncheckedCreateNestedOneWithoutBaselineFileInput = {
    create?: XOR<QuotationProcessCreateWithoutBaselineFileInput, QuotationProcessUncheckedCreateWithoutBaselineFileInput>
    connectOrCreate?: QuotationProcessCreateOrConnectWithoutBaselineFileInput
    connect?: QuotationProcessWhereUniqueInput
  }

  export type EnumQuotationAttachmentTypeFieldUpdateOperationsInput = {
    set?: $Enums.QuotationAttachmentType
  }

  export type QuotationUpdateOneWithoutAttachmentsNestedInput = {
    create?: XOR<QuotationCreateWithoutAttachmentsInput, QuotationUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: QuotationCreateOrConnectWithoutAttachmentsInput
    upsert?: QuotationUpsertWithoutAttachmentsInput
    disconnect?: QuotationWhereInput | boolean
    delete?: QuotationWhereInput | boolean
    connect?: QuotationWhereUniqueInput
    update?: XOR<XOR<QuotationUpdateToOneWithWhereWithoutAttachmentsInput, QuotationUpdateWithoutAttachmentsInput>, QuotationUncheckedUpdateWithoutAttachmentsInput>
  }

  export type QuotationProcessUpdateOneWithoutBaselineFileNestedInput = {
    create?: XOR<QuotationProcessCreateWithoutBaselineFileInput, QuotationProcessUncheckedCreateWithoutBaselineFileInput>
    connectOrCreate?: QuotationProcessCreateOrConnectWithoutBaselineFileInput
    upsert?: QuotationProcessUpsertWithoutBaselineFileInput
    disconnect?: QuotationProcessWhereInput | boolean
    delete?: QuotationProcessWhereInput | boolean
    connect?: QuotationProcessWhereUniqueInput
    update?: XOR<XOR<QuotationProcessUpdateToOneWithWhereWithoutBaselineFileInput, QuotationProcessUpdateWithoutBaselineFileInput>, QuotationProcessUncheckedUpdateWithoutBaselineFileInput>
  }

  export type QuotationProcessUncheckedUpdateOneWithoutBaselineFileNestedInput = {
    create?: XOR<QuotationProcessCreateWithoutBaselineFileInput, QuotationProcessUncheckedCreateWithoutBaselineFileInput>
    connectOrCreate?: QuotationProcessCreateOrConnectWithoutBaselineFileInput
    upsert?: QuotationProcessUpsertWithoutBaselineFileInput
    disconnect?: QuotationProcessWhereInput | boolean
    delete?: QuotationProcessWhereInput | boolean
    connect?: QuotationProcessWhereUniqueInput
    update?: XOR<XOR<QuotationProcessUpdateToOneWithWhereWithoutBaselineFileInput, QuotationProcessUpdateWithoutBaselineFileInput>, QuotationProcessUncheckedUpdateWithoutBaselineFileInput>
  }

  export type QuotationProcessCreateNestedOneWithoutPurchaseOrdersInput = {
    create?: XOR<QuotationProcessCreateWithoutPurchaseOrdersInput, QuotationProcessUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: QuotationProcessCreateOrConnectWithoutPurchaseOrdersInput
    connect?: QuotationProcessWhereUniqueInput
  }

  export type QuotationCreateNestedOneWithoutPurchaseOrdersInput = {
    create?: XOR<QuotationCreateWithoutPurchaseOrdersInput, QuotationUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: QuotationCreateOrConnectWithoutPurchaseOrdersInput
    connect?: QuotationWhereUniqueInput
  }

  export type PurchaseOrderLineCreateNestedManyWithoutOrderInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutOrderInput, PurchaseOrderLineUncheckedCreateWithoutOrderInput> | PurchaseOrderLineCreateWithoutOrderInput[] | PurchaseOrderLineUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutOrderInput | PurchaseOrderLineCreateOrConnectWithoutOrderInput[]
    createMany?: PurchaseOrderLineCreateManyOrderInputEnvelope
    connect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
  }

  export type PurchaseDeliveryLogCreateNestedManyWithoutOrderInput = {
    create?: XOR<PurchaseDeliveryLogCreateWithoutOrderInput, PurchaseDeliveryLogUncheckedCreateWithoutOrderInput> | PurchaseDeliveryLogCreateWithoutOrderInput[] | PurchaseDeliveryLogUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PurchaseDeliveryLogCreateOrConnectWithoutOrderInput | PurchaseDeliveryLogCreateOrConnectWithoutOrderInput[]
    createMany?: PurchaseDeliveryLogCreateManyOrderInputEnvelope
    connect?: PurchaseDeliveryLogWhereUniqueInput | PurchaseDeliveryLogWhereUniqueInput[]
  }

  export type PurchaseOrderLineUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutOrderInput, PurchaseOrderLineUncheckedCreateWithoutOrderInput> | PurchaseOrderLineCreateWithoutOrderInput[] | PurchaseOrderLineUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutOrderInput | PurchaseOrderLineCreateOrConnectWithoutOrderInput[]
    createMany?: PurchaseOrderLineCreateManyOrderInputEnvelope
    connect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
  }

  export type PurchaseDeliveryLogUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<PurchaseDeliveryLogCreateWithoutOrderInput, PurchaseDeliveryLogUncheckedCreateWithoutOrderInput> | PurchaseDeliveryLogCreateWithoutOrderInput[] | PurchaseDeliveryLogUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PurchaseDeliveryLogCreateOrConnectWithoutOrderInput | PurchaseDeliveryLogCreateOrConnectWithoutOrderInput[]
    createMany?: PurchaseDeliveryLogCreateManyOrderInputEnvelope
    connect?: PurchaseDeliveryLogWhereUniqueInput | PurchaseDeliveryLogWhereUniqueInput[]
  }

  export type QuotationProcessUpdateOneRequiredWithoutPurchaseOrdersNestedInput = {
    create?: XOR<QuotationProcessCreateWithoutPurchaseOrdersInput, QuotationProcessUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: QuotationProcessCreateOrConnectWithoutPurchaseOrdersInput
    upsert?: QuotationProcessUpsertWithoutPurchaseOrdersInput
    connect?: QuotationProcessWhereUniqueInput
    update?: XOR<XOR<QuotationProcessUpdateToOneWithWhereWithoutPurchaseOrdersInput, QuotationProcessUpdateWithoutPurchaseOrdersInput>, QuotationProcessUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type QuotationUpdateOneWithoutPurchaseOrdersNestedInput = {
    create?: XOR<QuotationCreateWithoutPurchaseOrdersInput, QuotationUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: QuotationCreateOrConnectWithoutPurchaseOrdersInput
    upsert?: QuotationUpsertWithoutPurchaseOrdersInput
    disconnect?: QuotationWhereInput | boolean
    delete?: QuotationWhereInput | boolean
    connect?: QuotationWhereUniqueInput
    update?: XOR<XOR<QuotationUpdateToOneWithWhereWithoutPurchaseOrdersInput, QuotationUpdateWithoutPurchaseOrdersInput>, QuotationUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type PurchaseOrderLineUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutOrderInput, PurchaseOrderLineUncheckedCreateWithoutOrderInput> | PurchaseOrderLineCreateWithoutOrderInput[] | PurchaseOrderLineUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutOrderInput | PurchaseOrderLineCreateOrConnectWithoutOrderInput[]
    upsert?: PurchaseOrderLineUpsertWithWhereUniqueWithoutOrderInput | PurchaseOrderLineUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PurchaseOrderLineCreateManyOrderInputEnvelope
    set?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    disconnect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    delete?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    connect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    update?: PurchaseOrderLineUpdateWithWhereUniqueWithoutOrderInput | PurchaseOrderLineUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PurchaseOrderLineUpdateManyWithWhereWithoutOrderInput | PurchaseOrderLineUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PurchaseOrderLineScalarWhereInput | PurchaseOrderLineScalarWhereInput[]
  }

  export type PurchaseDeliveryLogUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PurchaseDeliveryLogCreateWithoutOrderInput, PurchaseDeliveryLogUncheckedCreateWithoutOrderInput> | PurchaseDeliveryLogCreateWithoutOrderInput[] | PurchaseDeliveryLogUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PurchaseDeliveryLogCreateOrConnectWithoutOrderInput | PurchaseDeliveryLogCreateOrConnectWithoutOrderInput[]
    upsert?: PurchaseDeliveryLogUpsertWithWhereUniqueWithoutOrderInput | PurchaseDeliveryLogUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PurchaseDeliveryLogCreateManyOrderInputEnvelope
    set?: PurchaseDeliveryLogWhereUniqueInput | PurchaseDeliveryLogWhereUniqueInput[]
    disconnect?: PurchaseDeliveryLogWhereUniqueInput | PurchaseDeliveryLogWhereUniqueInput[]
    delete?: PurchaseDeliveryLogWhereUniqueInput | PurchaseDeliveryLogWhereUniqueInput[]
    connect?: PurchaseDeliveryLogWhereUniqueInput | PurchaseDeliveryLogWhereUniqueInput[]
    update?: PurchaseDeliveryLogUpdateWithWhereUniqueWithoutOrderInput | PurchaseDeliveryLogUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PurchaseDeliveryLogUpdateManyWithWhereWithoutOrderInput | PurchaseDeliveryLogUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PurchaseDeliveryLogScalarWhereInput | PurchaseDeliveryLogScalarWhereInput[]
  }

  export type PurchaseOrderLineUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutOrderInput, PurchaseOrderLineUncheckedCreateWithoutOrderInput> | PurchaseOrderLineCreateWithoutOrderInput[] | PurchaseOrderLineUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutOrderInput | PurchaseOrderLineCreateOrConnectWithoutOrderInput[]
    upsert?: PurchaseOrderLineUpsertWithWhereUniqueWithoutOrderInput | PurchaseOrderLineUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PurchaseOrderLineCreateManyOrderInputEnvelope
    set?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    disconnect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    delete?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    connect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    update?: PurchaseOrderLineUpdateWithWhereUniqueWithoutOrderInput | PurchaseOrderLineUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PurchaseOrderLineUpdateManyWithWhereWithoutOrderInput | PurchaseOrderLineUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PurchaseOrderLineScalarWhereInput | PurchaseOrderLineScalarWhereInput[]
  }

  export type PurchaseDeliveryLogUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PurchaseDeliveryLogCreateWithoutOrderInput, PurchaseDeliveryLogUncheckedCreateWithoutOrderInput> | PurchaseDeliveryLogCreateWithoutOrderInput[] | PurchaseDeliveryLogUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PurchaseDeliveryLogCreateOrConnectWithoutOrderInput | PurchaseDeliveryLogCreateOrConnectWithoutOrderInput[]
    upsert?: PurchaseDeliveryLogUpsertWithWhereUniqueWithoutOrderInput | PurchaseDeliveryLogUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PurchaseDeliveryLogCreateManyOrderInputEnvelope
    set?: PurchaseDeliveryLogWhereUniqueInput | PurchaseDeliveryLogWhereUniqueInput[]
    disconnect?: PurchaseDeliveryLogWhereUniqueInput | PurchaseDeliveryLogWhereUniqueInput[]
    delete?: PurchaseDeliveryLogWhereUniqueInput | PurchaseDeliveryLogWhereUniqueInput[]
    connect?: PurchaseDeliveryLogWhereUniqueInput | PurchaseDeliveryLogWhereUniqueInput[]
    update?: PurchaseDeliveryLogUpdateWithWhereUniqueWithoutOrderInput | PurchaseDeliveryLogUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PurchaseDeliveryLogUpdateManyWithWhereWithoutOrderInput | PurchaseDeliveryLogUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PurchaseDeliveryLogScalarWhereInput | PurchaseDeliveryLogScalarWhereInput[]
  }

  export type PurchaseOrderLogCreateNestedOneWithoutLinesInput = {
    create?: XOR<PurchaseOrderLogCreateWithoutLinesInput, PurchaseOrderLogUncheckedCreateWithoutLinesInput>
    connectOrCreate?: PurchaseOrderLogCreateOrConnectWithoutLinesInput
    connect?: PurchaseOrderLogWhereUniqueInput
  }

  export type QuotationBaselineItemCreateNestedOneWithoutOrderLinesInput = {
    create?: XOR<QuotationBaselineItemCreateWithoutOrderLinesInput, QuotationBaselineItemUncheckedCreateWithoutOrderLinesInput>
    connectOrCreate?: QuotationBaselineItemCreateOrConnectWithoutOrderLinesInput
    connect?: QuotationBaselineItemWhereUniqueInput
  }

  export type PurchaseDeliveryItemCreateNestedManyWithoutOrderLineInput = {
    create?: XOR<PurchaseDeliveryItemCreateWithoutOrderLineInput, PurchaseDeliveryItemUncheckedCreateWithoutOrderLineInput> | PurchaseDeliveryItemCreateWithoutOrderLineInput[] | PurchaseDeliveryItemUncheckedCreateWithoutOrderLineInput[]
    connectOrCreate?: PurchaseDeliveryItemCreateOrConnectWithoutOrderLineInput | PurchaseDeliveryItemCreateOrConnectWithoutOrderLineInput[]
    createMany?: PurchaseDeliveryItemCreateManyOrderLineInputEnvelope
    connect?: PurchaseDeliveryItemWhereUniqueInput | PurchaseDeliveryItemWhereUniqueInput[]
  }

  export type PurchaseDeliveryItemUncheckedCreateNestedManyWithoutOrderLineInput = {
    create?: XOR<PurchaseDeliveryItemCreateWithoutOrderLineInput, PurchaseDeliveryItemUncheckedCreateWithoutOrderLineInput> | PurchaseDeliveryItemCreateWithoutOrderLineInput[] | PurchaseDeliveryItemUncheckedCreateWithoutOrderLineInput[]
    connectOrCreate?: PurchaseDeliveryItemCreateOrConnectWithoutOrderLineInput | PurchaseDeliveryItemCreateOrConnectWithoutOrderLineInput[]
    createMany?: PurchaseDeliveryItemCreateManyOrderLineInputEnvelope
    connect?: PurchaseDeliveryItemWhereUniqueInput | PurchaseDeliveryItemWhereUniqueInput[]
  }

  export type PurchaseOrderLogUpdateOneRequiredWithoutLinesNestedInput = {
    create?: XOR<PurchaseOrderLogCreateWithoutLinesInput, PurchaseOrderLogUncheckedCreateWithoutLinesInput>
    connectOrCreate?: PurchaseOrderLogCreateOrConnectWithoutLinesInput
    upsert?: PurchaseOrderLogUpsertWithoutLinesInput
    connect?: PurchaseOrderLogWhereUniqueInput
    update?: XOR<XOR<PurchaseOrderLogUpdateToOneWithWhereWithoutLinesInput, PurchaseOrderLogUpdateWithoutLinesInput>, PurchaseOrderLogUncheckedUpdateWithoutLinesInput>
  }

  export type QuotationBaselineItemUpdateOneWithoutOrderLinesNestedInput = {
    create?: XOR<QuotationBaselineItemCreateWithoutOrderLinesInput, QuotationBaselineItemUncheckedCreateWithoutOrderLinesInput>
    connectOrCreate?: QuotationBaselineItemCreateOrConnectWithoutOrderLinesInput
    upsert?: QuotationBaselineItemUpsertWithoutOrderLinesInput
    disconnect?: QuotationBaselineItemWhereInput | boolean
    delete?: QuotationBaselineItemWhereInput | boolean
    connect?: QuotationBaselineItemWhereUniqueInput
    update?: XOR<XOR<QuotationBaselineItemUpdateToOneWithWhereWithoutOrderLinesInput, QuotationBaselineItemUpdateWithoutOrderLinesInput>, QuotationBaselineItemUncheckedUpdateWithoutOrderLinesInput>
  }

  export type PurchaseDeliveryItemUpdateManyWithoutOrderLineNestedInput = {
    create?: XOR<PurchaseDeliveryItemCreateWithoutOrderLineInput, PurchaseDeliveryItemUncheckedCreateWithoutOrderLineInput> | PurchaseDeliveryItemCreateWithoutOrderLineInput[] | PurchaseDeliveryItemUncheckedCreateWithoutOrderLineInput[]
    connectOrCreate?: PurchaseDeliveryItemCreateOrConnectWithoutOrderLineInput | PurchaseDeliveryItemCreateOrConnectWithoutOrderLineInput[]
    upsert?: PurchaseDeliveryItemUpsertWithWhereUniqueWithoutOrderLineInput | PurchaseDeliveryItemUpsertWithWhereUniqueWithoutOrderLineInput[]
    createMany?: PurchaseDeliveryItemCreateManyOrderLineInputEnvelope
    set?: PurchaseDeliveryItemWhereUniqueInput | PurchaseDeliveryItemWhereUniqueInput[]
    disconnect?: PurchaseDeliveryItemWhereUniqueInput | PurchaseDeliveryItemWhereUniqueInput[]
    delete?: PurchaseDeliveryItemWhereUniqueInput | PurchaseDeliveryItemWhereUniqueInput[]
    connect?: PurchaseDeliveryItemWhereUniqueInput | PurchaseDeliveryItemWhereUniqueInput[]
    update?: PurchaseDeliveryItemUpdateWithWhereUniqueWithoutOrderLineInput | PurchaseDeliveryItemUpdateWithWhereUniqueWithoutOrderLineInput[]
    updateMany?: PurchaseDeliveryItemUpdateManyWithWhereWithoutOrderLineInput | PurchaseDeliveryItemUpdateManyWithWhereWithoutOrderLineInput[]
    deleteMany?: PurchaseDeliveryItemScalarWhereInput | PurchaseDeliveryItemScalarWhereInput[]
  }

  export type PurchaseDeliveryItemUncheckedUpdateManyWithoutOrderLineNestedInput = {
    create?: XOR<PurchaseDeliveryItemCreateWithoutOrderLineInput, PurchaseDeliveryItemUncheckedCreateWithoutOrderLineInput> | PurchaseDeliveryItemCreateWithoutOrderLineInput[] | PurchaseDeliveryItemUncheckedCreateWithoutOrderLineInput[]
    connectOrCreate?: PurchaseDeliveryItemCreateOrConnectWithoutOrderLineInput | PurchaseDeliveryItemCreateOrConnectWithoutOrderLineInput[]
    upsert?: PurchaseDeliveryItemUpsertWithWhereUniqueWithoutOrderLineInput | PurchaseDeliveryItemUpsertWithWhereUniqueWithoutOrderLineInput[]
    createMany?: PurchaseDeliveryItemCreateManyOrderLineInputEnvelope
    set?: PurchaseDeliveryItemWhereUniqueInput | PurchaseDeliveryItemWhereUniqueInput[]
    disconnect?: PurchaseDeliveryItemWhereUniqueInput | PurchaseDeliveryItemWhereUniqueInput[]
    delete?: PurchaseDeliveryItemWhereUniqueInput | PurchaseDeliveryItemWhereUniqueInput[]
    connect?: PurchaseDeliveryItemWhereUniqueInput | PurchaseDeliveryItemWhereUniqueInput[]
    update?: PurchaseDeliveryItemUpdateWithWhereUniqueWithoutOrderLineInput | PurchaseDeliveryItemUpdateWithWhereUniqueWithoutOrderLineInput[]
    updateMany?: PurchaseDeliveryItemUpdateManyWithWhereWithoutOrderLineInput | PurchaseDeliveryItemUpdateManyWithWhereWithoutOrderLineInput[]
    deleteMany?: PurchaseDeliveryItemScalarWhereInput | PurchaseDeliveryItemScalarWhereInput[]
  }

  export type QuotationProcessCreateNestedOneWithoutDeliveryLogsInput = {
    create?: XOR<QuotationProcessCreateWithoutDeliveryLogsInput, QuotationProcessUncheckedCreateWithoutDeliveryLogsInput>
    connectOrCreate?: QuotationProcessCreateOrConnectWithoutDeliveryLogsInput
    connect?: QuotationProcessWhereUniqueInput
  }

  export type PurchaseOrderLogCreateNestedOneWithoutDeliveriesInput = {
    create?: XOR<PurchaseOrderLogCreateWithoutDeliveriesInput, PurchaseOrderLogUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: PurchaseOrderLogCreateOrConnectWithoutDeliveriesInput
    connect?: PurchaseOrderLogWhereUniqueInput
  }

  export type ProveedorCreateNestedOneWithoutDeliveriesInput = {
    create?: XOR<ProveedorCreateWithoutDeliveriesInput, ProveedorUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: ProveedorCreateOrConnectWithoutDeliveriesInput
    connect?: ProveedorWhereUniqueInput
  }

  export type PurchaseDeliveryItemCreateNestedManyWithoutDeliveryInput = {
    create?: XOR<PurchaseDeliveryItemCreateWithoutDeliveryInput, PurchaseDeliveryItemUncheckedCreateWithoutDeliveryInput> | PurchaseDeliveryItemCreateWithoutDeliveryInput[] | PurchaseDeliveryItemUncheckedCreateWithoutDeliveryInput[]
    connectOrCreate?: PurchaseDeliveryItemCreateOrConnectWithoutDeliveryInput | PurchaseDeliveryItemCreateOrConnectWithoutDeliveryInput[]
    createMany?: PurchaseDeliveryItemCreateManyDeliveryInputEnvelope
    connect?: PurchaseDeliveryItemWhereUniqueInput | PurchaseDeliveryItemWhereUniqueInput[]
  }

  export type PurchaseDeliveryItemUncheckedCreateNestedManyWithoutDeliveryInput = {
    create?: XOR<PurchaseDeliveryItemCreateWithoutDeliveryInput, PurchaseDeliveryItemUncheckedCreateWithoutDeliveryInput> | PurchaseDeliveryItemCreateWithoutDeliveryInput[] | PurchaseDeliveryItemUncheckedCreateWithoutDeliveryInput[]
    connectOrCreate?: PurchaseDeliveryItemCreateOrConnectWithoutDeliveryInput | PurchaseDeliveryItemCreateOrConnectWithoutDeliveryInput[]
    createMany?: PurchaseDeliveryItemCreateManyDeliveryInputEnvelope
    connect?: PurchaseDeliveryItemWhereUniqueInput | PurchaseDeliveryItemWhereUniqueInput[]
  }

  export type QuotationProcessUpdateOneRequiredWithoutDeliveryLogsNestedInput = {
    create?: XOR<QuotationProcessCreateWithoutDeliveryLogsInput, QuotationProcessUncheckedCreateWithoutDeliveryLogsInput>
    connectOrCreate?: QuotationProcessCreateOrConnectWithoutDeliveryLogsInput
    upsert?: QuotationProcessUpsertWithoutDeliveryLogsInput
    connect?: QuotationProcessWhereUniqueInput
    update?: XOR<XOR<QuotationProcessUpdateToOneWithWhereWithoutDeliveryLogsInput, QuotationProcessUpdateWithoutDeliveryLogsInput>, QuotationProcessUncheckedUpdateWithoutDeliveryLogsInput>
  }

  export type PurchaseOrderLogUpdateOneWithoutDeliveriesNestedInput = {
    create?: XOR<PurchaseOrderLogCreateWithoutDeliveriesInput, PurchaseOrderLogUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: PurchaseOrderLogCreateOrConnectWithoutDeliveriesInput
    upsert?: PurchaseOrderLogUpsertWithoutDeliveriesInput
    disconnect?: PurchaseOrderLogWhereInput | boolean
    delete?: PurchaseOrderLogWhereInput | boolean
    connect?: PurchaseOrderLogWhereUniqueInput
    update?: XOR<XOR<PurchaseOrderLogUpdateToOneWithWhereWithoutDeliveriesInput, PurchaseOrderLogUpdateWithoutDeliveriesInput>, PurchaseOrderLogUncheckedUpdateWithoutDeliveriesInput>
  }

  export type ProveedorUpdateOneWithoutDeliveriesNestedInput = {
    create?: XOR<ProveedorCreateWithoutDeliveriesInput, ProveedorUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: ProveedorCreateOrConnectWithoutDeliveriesInput
    upsert?: ProveedorUpsertWithoutDeliveriesInput
    disconnect?: ProveedorWhereInput | boolean
    delete?: ProveedorWhereInput | boolean
    connect?: ProveedorWhereUniqueInput
    update?: XOR<XOR<ProveedorUpdateToOneWithWhereWithoutDeliveriesInput, ProveedorUpdateWithoutDeliveriesInput>, ProveedorUncheckedUpdateWithoutDeliveriesInput>
  }

  export type PurchaseDeliveryItemUpdateManyWithoutDeliveryNestedInput = {
    create?: XOR<PurchaseDeliveryItemCreateWithoutDeliveryInput, PurchaseDeliveryItemUncheckedCreateWithoutDeliveryInput> | PurchaseDeliveryItemCreateWithoutDeliveryInput[] | PurchaseDeliveryItemUncheckedCreateWithoutDeliveryInput[]
    connectOrCreate?: PurchaseDeliveryItemCreateOrConnectWithoutDeliveryInput | PurchaseDeliveryItemCreateOrConnectWithoutDeliveryInput[]
    upsert?: PurchaseDeliveryItemUpsertWithWhereUniqueWithoutDeliveryInput | PurchaseDeliveryItemUpsertWithWhereUniqueWithoutDeliveryInput[]
    createMany?: PurchaseDeliveryItemCreateManyDeliveryInputEnvelope
    set?: PurchaseDeliveryItemWhereUniqueInput | PurchaseDeliveryItemWhereUniqueInput[]
    disconnect?: PurchaseDeliveryItemWhereUniqueInput | PurchaseDeliveryItemWhereUniqueInput[]
    delete?: PurchaseDeliveryItemWhereUniqueInput | PurchaseDeliveryItemWhereUniqueInput[]
    connect?: PurchaseDeliveryItemWhereUniqueInput | PurchaseDeliveryItemWhereUniqueInput[]
    update?: PurchaseDeliveryItemUpdateWithWhereUniqueWithoutDeliveryInput | PurchaseDeliveryItemUpdateWithWhereUniqueWithoutDeliveryInput[]
    updateMany?: PurchaseDeliveryItemUpdateManyWithWhereWithoutDeliveryInput | PurchaseDeliveryItemUpdateManyWithWhereWithoutDeliveryInput[]
    deleteMany?: PurchaseDeliveryItemScalarWhereInput | PurchaseDeliveryItemScalarWhereInput[]
  }

  export type PurchaseDeliveryItemUncheckedUpdateManyWithoutDeliveryNestedInput = {
    create?: XOR<PurchaseDeliveryItemCreateWithoutDeliveryInput, PurchaseDeliveryItemUncheckedCreateWithoutDeliveryInput> | PurchaseDeliveryItemCreateWithoutDeliveryInput[] | PurchaseDeliveryItemUncheckedCreateWithoutDeliveryInput[]
    connectOrCreate?: PurchaseDeliveryItemCreateOrConnectWithoutDeliveryInput | PurchaseDeliveryItemCreateOrConnectWithoutDeliveryInput[]
    upsert?: PurchaseDeliveryItemUpsertWithWhereUniqueWithoutDeliveryInput | PurchaseDeliveryItemUpsertWithWhereUniqueWithoutDeliveryInput[]
    createMany?: PurchaseDeliveryItemCreateManyDeliveryInputEnvelope
    set?: PurchaseDeliveryItemWhereUniqueInput | PurchaseDeliveryItemWhereUniqueInput[]
    disconnect?: PurchaseDeliveryItemWhereUniqueInput | PurchaseDeliveryItemWhereUniqueInput[]
    delete?: PurchaseDeliveryItemWhereUniqueInput | PurchaseDeliveryItemWhereUniqueInput[]
    connect?: PurchaseDeliveryItemWhereUniqueInput | PurchaseDeliveryItemWhereUniqueInput[]
    update?: PurchaseDeliveryItemUpdateWithWhereUniqueWithoutDeliveryInput | PurchaseDeliveryItemUpdateWithWhereUniqueWithoutDeliveryInput[]
    updateMany?: PurchaseDeliveryItemUpdateManyWithWhereWithoutDeliveryInput | PurchaseDeliveryItemUpdateManyWithWhereWithoutDeliveryInput[]
    deleteMany?: PurchaseDeliveryItemScalarWhereInput | PurchaseDeliveryItemScalarWhereInput[]
  }

  export type PurchaseDeliveryLogCreateNestedOneWithoutItemsInput = {
    create?: XOR<PurchaseDeliveryLogCreateWithoutItemsInput, PurchaseDeliveryLogUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchaseDeliveryLogCreateOrConnectWithoutItemsInput
    connect?: PurchaseDeliveryLogWhereUniqueInput
  }

  export type PurchaseOrderLineCreateNestedOneWithoutDeliveriesInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutDeliveriesInput, PurchaseOrderLineUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutDeliveriesInput
    connect?: PurchaseOrderLineWhereUniqueInput
  }

  export type QuotationBaselineItemCreateNestedOneWithoutDeliveryItemsInput = {
    create?: XOR<QuotationBaselineItemCreateWithoutDeliveryItemsInput, QuotationBaselineItemUncheckedCreateWithoutDeliveryItemsInput>
    connectOrCreate?: QuotationBaselineItemCreateOrConnectWithoutDeliveryItemsInput
    connect?: QuotationBaselineItemWhereUniqueInput
  }

  export type PurchaseDeliveryLogUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<PurchaseDeliveryLogCreateWithoutItemsInput, PurchaseDeliveryLogUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchaseDeliveryLogCreateOrConnectWithoutItemsInput
    upsert?: PurchaseDeliveryLogUpsertWithoutItemsInput
    connect?: PurchaseDeliveryLogWhereUniqueInput
    update?: XOR<XOR<PurchaseDeliveryLogUpdateToOneWithWhereWithoutItemsInput, PurchaseDeliveryLogUpdateWithoutItemsInput>, PurchaseDeliveryLogUncheckedUpdateWithoutItemsInput>
  }

  export type PurchaseOrderLineUpdateOneWithoutDeliveriesNestedInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutDeliveriesInput, PurchaseOrderLineUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutDeliveriesInput
    upsert?: PurchaseOrderLineUpsertWithoutDeliveriesInput
    disconnect?: PurchaseOrderLineWhereInput | boolean
    delete?: PurchaseOrderLineWhereInput | boolean
    connect?: PurchaseOrderLineWhereUniqueInput
    update?: XOR<XOR<PurchaseOrderLineUpdateToOneWithWhereWithoutDeliveriesInput, PurchaseOrderLineUpdateWithoutDeliveriesInput>, PurchaseOrderLineUncheckedUpdateWithoutDeliveriesInput>
  }

  export type QuotationBaselineItemUpdateOneWithoutDeliveryItemsNestedInput = {
    create?: XOR<QuotationBaselineItemCreateWithoutDeliveryItemsInput, QuotationBaselineItemUncheckedCreateWithoutDeliveryItemsInput>
    connectOrCreate?: QuotationBaselineItemCreateOrConnectWithoutDeliveryItemsInput
    upsert?: QuotationBaselineItemUpsertWithoutDeliveryItemsInput
    disconnect?: QuotationBaselineItemWhereInput | boolean
    delete?: QuotationBaselineItemWhereInput | boolean
    connect?: QuotationBaselineItemWhereUniqueInput
    update?: XOR<XOR<QuotationBaselineItemUpdateToOneWithWhereWithoutDeliveryItemsInput, QuotationBaselineItemUpdateWithoutDeliveryItemsInput>, QuotationBaselineItemUncheckedUpdateWithoutDeliveryItemsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumAssetStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetStatus | EnumAssetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssetStatus[]
    notIn?: $Enums.AssetStatus[]
    not?: NestedEnumAssetStatusFilter<$PrismaModel> | $Enums.AssetStatus
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumAssetStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetStatus | EnumAssetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssetStatus[]
    notIn?: $Enums.AssetStatus[]
    not?: NestedEnumAssetStatusWithAggregatesFilter<$PrismaModel> | $Enums.AssetStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssetStatusFilter<$PrismaModel>
    _max?: NestedEnumAssetStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumMoveTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MoveType | EnumMoveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MoveType[]
    notIn?: $Enums.MoveType[]
    not?: NestedEnumMoveTypeFilter<$PrismaModel> | $Enums.MoveType
  }

  export type NestedEnumDocTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DocType | EnumDocTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DocType[] | null
    notIn?: $Enums.DocType[] | null
    not?: NestedEnumDocTypeNullableFilter<$PrismaModel> | $Enums.DocType | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumAssetStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetStatus | EnumAssetStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.AssetStatus[] | null
    notIn?: $Enums.AssetStatus[] | null
    not?: NestedEnumAssetStatusNullableFilter<$PrismaModel> | $Enums.AssetStatus | null
  }

  export type NestedEnumMoveTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MoveType | EnumMoveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MoveType[]
    notIn?: $Enums.MoveType[]
    not?: NestedEnumMoveTypeWithAggregatesFilter<$PrismaModel> | $Enums.MoveType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMoveTypeFilter<$PrismaModel>
    _max?: NestedEnumMoveTypeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumDocTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocType | EnumDocTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DocType[] | null
    notIn?: $Enums.DocType[] | null
    not?: NestedEnumDocTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.DocType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDocTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumDocTypeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumAssetStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetStatus | EnumAssetStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.AssetStatus[] | null
    notIn?: $Enums.AssetStatus[] | null
    not?: NestedEnumAssetStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.AssetStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAssetStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumAssetStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumExpenseKindFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseKind | EnumExpenseKindFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseKind[]
    notIn?: $Enums.ExpenseKind[]
    not?: NestedEnumExpenseKindFilter<$PrismaModel> | $Enums.ExpenseKind
  }

  export type NestedEnumExpenseKindWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseKind | EnumExpenseKindFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseKind[]
    notIn?: $Enums.ExpenseKind[]
    not?: NestedEnumExpenseKindWithAggregatesFilter<$PrismaModel> | $Enums.ExpenseKind
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExpenseKindFilter<$PrismaModel>
    _max?: NestedEnumExpenseKindFilter<$PrismaModel>
  }

  export type NestedEnumDocTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocType | EnumDocTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocType[]
    notIn?: $Enums.DocType[]
    not?: NestedEnumDocTypeFilter<$PrismaModel> | $Enums.DocType
  }

  export type NestedEnumIncomeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.IncomeStatus | EnumIncomeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IncomeStatus[]
    notIn?: $Enums.IncomeStatus[]
    not?: NestedEnumIncomeStatusFilter<$PrismaModel> | $Enums.IncomeStatus
  }

  export type NestedEnumDocTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocType | EnumDocTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocType[]
    notIn?: $Enums.DocType[]
    not?: NestedEnumDocTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocTypeFilter<$PrismaModel>
    _max?: NestedEnumDocTypeFilter<$PrismaModel>
  }

  export type NestedEnumIncomeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncomeStatus | EnumIncomeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IncomeStatus[]
    notIn?: $Enums.IncomeStatus[]
    not?: NestedEnumIncomeStatusWithAggregatesFilter<$PrismaModel> | $Enums.IncomeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncomeStatusFilter<$PrismaModel>
    _max?: NestedEnumIncomeStatusFilter<$PrismaModel>
  }

  export type NestedEnumExpenseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseType | EnumExpenseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseType[]
    notIn?: $Enums.ExpenseType[]
    not?: NestedEnumExpenseTypeFilter<$PrismaModel> | $Enums.ExpenseType
  }

  export type NestedEnumVariableTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VariableType | EnumVariableTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VariableType[]
    notIn?: $Enums.VariableType[]
    not?: NestedEnumVariableTypeFilter<$PrismaModel> | $Enums.VariableType
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumExpenseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseType | EnumExpenseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseType[]
    notIn?: $Enums.ExpenseType[]
    not?: NestedEnumExpenseTypeWithAggregatesFilter<$PrismaModel> | $Enums.ExpenseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExpenseTypeFilter<$PrismaModel>
    _max?: NestedEnumExpenseTypeFilter<$PrismaModel>
  }

  export type NestedEnumVariableTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VariableType | EnumVariableTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VariableType[]
    notIn?: $Enums.VariableType[]
    not?: NestedEnumVariableTypeWithAggregatesFilter<$PrismaModel> | $Enums.VariableType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVariableTypeFilter<$PrismaModel>
    _max?: NestedEnumVariableTypeFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumDocumentTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DocumentType[] | null
    notIn?: $Enums.DocumentType[] | null
    not?: NestedEnumDocumentTypeNullableFilter<$PrismaModel> | $Enums.DocumentType | null
  }

  export type NestedEnumBankTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BankType | EnumBankTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BankType[]
    notIn?: $Enums.BankType[]
    not?: NestedEnumBankTypeFilter<$PrismaModel> | $Enums.BankType
  }

  export type NestedEnumPensionSystemFilter<$PrismaModel = never> = {
    equals?: $Enums.PensionSystem | EnumPensionSystemFieldRefInput<$PrismaModel>
    in?: $Enums.PensionSystem[]
    notIn?: $Enums.PensionSystem[]
    not?: NestedEnumPensionSystemFilter<$PrismaModel> | $Enums.PensionSystem
  }

  export type NestedEnumEmployeeAreaFilter<$PrismaModel = never> = {
    equals?: $Enums.EmployeeArea | EnumEmployeeAreaFieldRefInput<$PrismaModel>
    in?: $Enums.EmployeeArea[]
    notIn?: $Enums.EmployeeArea[]
    not?: NestedEnumEmployeeAreaFilter<$PrismaModel> | $Enums.EmployeeArea
  }

  export type NestedEnumDocumentTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DocumentType[] | null
    notIn?: $Enums.DocumentType[] | null
    not?: NestedEnumDocumentTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumBankTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BankType | EnumBankTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BankType[]
    notIn?: $Enums.BankType[]
    not?: NestedEnumBankTypeWithAggregatesFilter<$PrismaModel> | $Enums.BankType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBankTypeFilter<$PrismaModel>
    _max?: NestedEnumBankTypeFilter<$PrismaModel>
  }

  export type NestedEnumPensionSystemWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PensionSystem | EnumPensionSystemFieldRefInput<$PrismaModel>
    in?: $Enums.PensionSystem[]
    notIn?: $Enums.PensionSystem[]
    not?: NestedEnumPensionSystemWithAggregatesFilter<$PrismaModel> | $Enums.PensionSystem
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPensionSystemFilter<$PrismaModel>
    _max?: NestedEnumPensionSystemFilter<$PrismaModel>
  }

  export type NestedEnumEmployeeAreaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmployeeArea | EnumEmployeeAreaFieldRefInput<$PrismaModel>
    in?: $Enums.EmployeeArea[]
    notIn?: $Enums.EmployeeArea[]
    not?: NestedEnumEmployeeAreaWithAggregatesFilter<$PrismaModel> | $Enums.EmployeeArea
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmployeeAreaFilter<$PrismaModel>
    _max?: NestedEnumEmployeeAreaFilter<$PrismaModel>
  }

  export type NestedEnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[]
    notIn?: $Enums.AttendanceStatus[]
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[]
    notIn?: $Enums.AttendanceStatus[]
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type NestedEnumPayrollPeriodStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PayrollPeriodStatus | EnumPayrollPeriodStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayrollPeriodStatus[]
    notIn?: $Enums.PayrollPeriodStatus[]
    not?: NestedEnumPayrollPeriodStatusFilter<$PrismaModel> | $Enums.PayrollPeriodStatus
  }

  export type NestedEnumPayrollPeriodStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayrollPeriodStatus | EnumPayrollPeriodStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayrollPeriodStatus[]
    notIn?: $Enums.PayrollPeriodStatus[]
    not?: NestedEnumPayrollPeriodStatusWithAggregatesFilter<$PrismaModel> | $Enums.PayrollPeriodStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayrollPeriodStatusFilter<$PrismaModel>
    _max?: NestedEnumPayrollPeriodStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumPayrollAdjustmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PayrollAdjustmentType | EnumPayrollAdjustmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PayrollAdjustmentType[]
    notIn?: $Enums.PayrollAdjustmentType[]
    not?: NestedEnumPayrollAdjustmentTypeFilter<$PrismaModel> | $Enums.PayrollAdjustmentType
  }

  export type NestedEnumPayrollAdjustmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayrollAdjustmentType | EnumPayrollAdjustmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PayrollAdjustmentType[]
    notIn?: $Enums.PayrollAdjustmentType[]
    not?: NestedEnumPayrollAdjustmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.PayrollAdjustmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayrollAdjustmentTypeFilter<$PrismaModel>
    _max?: NestedEnumPayrollAdjustmentTypeFilter<$PrismaModel>
  }

  export type NestedEnumPartnerLoanStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PartnerLoanStatus | EnumPartnerLoanStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PartnerLoanStatus[]
    notIn?: $Enums.PartnerLoanStatus[]
    not?: NestedEnumPartnerLoanStatusFilter<$PrismaModel> | $Enums.PartnerLoanStatus
  }

  export type NestedEnumPartnerLoanStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PartnerLoanStatus | EnumPartnerLoanStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PartnerLoanStatus[]
    notIn?: $Enums.PartnerLoanStatus[]
    not?: NestedEnumPartnerLoanStatusWithAggregatesFilter<$PrismaModel> | $Enums.PartnerLoanStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPartnerLoanStatusFilter<$PrismaModel>
    _max?: NestedEnumPartnerLoanStatusFilter<$PrismaModel>
  }

  export type NestedEnumFoodMealTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FoodMealType | EnumFoodMealTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FoodMealType[]
    notIn?: $Enums.FoodMealType[]
    not?: NestedEnumFoodMealTypeFilter<$PrismaModel> | $Enums.FoodMealType
  }

  export type NestedEnumFoodMealTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FoodMealType | EnumFoodMealTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FoodMealType[]
    notIn?: $Enums.FoodMealType[]
    not?: NestedEnumFoodMealTypeWithAggregatesFilter<$PrismaModel> | $Enums.FoodMealType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFoodMealTypeFilter<$PrismaModel>
    _max?: NestedEnumFoodMealTypeFilter<$PrismaModel>
  }

  export type NestedEnumFoodCostLineTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FoodCostLineType | EnumFoodCostLineTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FoodCostLineType[]
    notIn?: $Enums.FoodCostLineType[]
    not?: NestedEnumFoodCostLineTypeFilter<$PrismaModel> | $Enums.FoodCostLineType
  }

  export type NestedEnumFoodCostPeriodFilter<$PrismaModel = never> = {
    equals?: $Enums.FoodCostPeriod | EnumFoodCostPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.FoodCostPeriod[]
    notIn?: $Enums.FoodCostPeriod[]
    not?: NestedEnumFoodCostPeriodFilter<$PrismaModel> | $Enums.FoodCostPeriod
  }

  export type NestedEnumFoodCostLineTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FoodCostLineType | EnumFoodCostLineTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FoodCostLineType[]
    notIn?: $Enums.FoodCostLineType[]
    not?: NestedEnumFoodCostLineTypeWithAggregatesFilter<$PrismaModel> | $Enums.FoodCostLineType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFoodCostLineTypeFilter<$PrismaModel>
    _max?: NestedEnumFoodCostLineTypeFilter<$PrismaModel>
  }

  export type NestedEnumFoodCostPeriodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FoodCostPeriod | EnumFoodCostPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.FoodCostPeriod[]
    notIn?: $Enums.FoodCostPeriod[]
    not?: NestedEnumFoodCostPeriodWithAggregatesFilter<$PrismaModel> | $Enums.FoodCostPeriod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFoodCostPeriodFilter<$PrismaModel>
    _max?: NestedEnumFoodCostPeriodFilter<$PrismaModel>
  }

  export type NestedEnumFoodCostPoolTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FoodCostPoolType | EnumFoodCostPoolTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FoodCostPoolType[]
    notIn?: $Enums.FoodCostPoolType[]
    not?: NestedEnumFoodCostPoolTypeFilter<$PrismaModel> | $Enums.FoodCostPoolType
  }

  export type NestedEnumFoodMealTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.FoodMealType | EnumFoodMealTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.FoodMealType[] | null
    notIn?: $Enums.FoodMealType[] | null
    not?: NestedEnumFoodMealTypeNullableFilter<$PrismaModel> | $Enums.FoodMealType | null
  }

  export type NestedEnumPoolAllocationMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PoolAllocationMethod | EnumPoolAllocationMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PoolAllocationMethod[]
    notIn?: $Enums.PoolAllocationMethod[]
    not?: NestedEnumPoolAllocationMethodFilter<$PrismaModel> | $Enums.PoolAllocationMethod
  }

  export type NestedEnumFoodCostPoolTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FoodCostPoolType | EnumFoodCostPoolTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FoodCostPoolType[]
    notIn?: $Enums.FoodCostPoolType[]
    not?: NestedEnumFoodCostPoolTypeWithAggregatesFilter<$PrismaModel> | $Enums.FoodCostPoolType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFoodCostPoolTypeFilter<$PrismaModel>
    _max?: NestedEnumFoodCostPoolTypeFilter<$PrismaModel>
  }

  export type NestedEnumFoodMealTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FoodMealType | EnumFoodMealTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.FoodMealType[] | null
    notIn?: $Enums.FoodMealType[] | null
    not?: NestedEnumFoodMealTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.FoodMealType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumFoodMealTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumFoodMealTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumPoolAllocationMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PoolAllocationMethod | EnumPoolAllocationMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PoolAllocationMethod[]
    notIn?: $Enums.PoolAllocationMethod[]
    not?: NestedEnumPoolAllocationMethodWithAggregatesFilter<$PrismaModel> | $Enums.PoolAllocationMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPoolAllocationMethodFilter<$PrismaModel>
    _max?: NestedEnumPoolAllocationMethodFilter<$PrismaModel>
  }

  export type NestedEnumQuotationProcessStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotationProcessStatus | EnumQuotationProcessStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuotationProcessStatus[]
    notIn?: $Enums.QuotationProcessStatus[]
    not?: NestedEnumQuotationProcessStatusFilter<$PrismaModel> | $Enums.QuotationProcessStatus
  }

  export type NestedEnumQuotationProcessStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotationProcessStatus | EnumQuotationProcessStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuotationProcessStatus[]
    notIn?: $Enums.QuotationProcessStatus[]
    not?: NestedEnumQuotationProcessStatusWithAggregatesFilter<$PrismaModel> | $Enums.QuotationProcessStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuotationProcessStatusFilter<$PrismaModel>
    _max?: NestedEnumQuotationProcessStatusFilter<$PrismaModel>
  }

  export type NestedEnumQuotationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotationStatus | EnumQuotationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuotationStatus[]
    notIn?: $Enums.QuotationStatus[]
    not?: NestedEnumQuotationStatusFilter<$PrismaModel> | $Enums.QuotationStatus
  }

  export type NestedEnumQuotationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotationStatus | EnumQuotationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuotationStatus[]
    notIn?: $Enums.QuotationStatus[]
    not?: NestedEnumQuotationStatusWithAggregatesFilter<$PrismaModel> | $Enums.QuotationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuotationStatusFilter<$PrismaModel>
    _max?: NestedEnumQuotationStatusFilter<$PrismaModel>
  }

  export type NestedEnumQuotationAttachmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotationAttachmentType | EnumQuotationAttachmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuotationAttachmentType[]
    notIn?: $Enums.QuotationAttachmentType[]
    not?: NestedEnumQuotationAttachmentTypeFilter<$PrismaModel> | $Enums.QuotationAttachmentType
  }

  export type NestedEnumQuotationAttachmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotationAttachmentType | EnumQuotationAttachmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuotationAttachmentType[]
    notIn?: $Enums.QuotationAttachmentType[]
    not?: NestedEnumQuotationAttachmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.QuotationAttachmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuotationAttachmentTypeFilter<$PrismaModel>
    _max?: NestedEnumQuotationAttachmentTypeFilter<$PrismaModel>
  }

  export type FrenteCreateWithoutObraInput = {
    name: string
    moves?: MoveCreateNestedManyWithoutFrenteInput
    incomes?: IncomeCreateNestedManyWithoutFrenteInput
    expenses?: ExpenseCreateNestedManyWithoutFrenteInput
  }

  export type FrenteUncheckedCreateWithoutObraInput = {
    id?: number
    name: string
    moves?: MoveUncheckedCreateNestedManyWithoutFrenteInput
    incomes?: IncomeUncheckedCreateNestedManyWithoutFrenteInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutFrenteInput
  }

  export type FrenteCreateOrConnectWithoutObraInput = {
    where: FrenteWhereUniqueInput
    create: XOR<FrenteCreateWithoutObraInput, FrenteUncheckedCreateWithoutObraInput>
  }

  export type FrenteCreateManyObraInputEnvelope = {
    data: FrenteCreateManyObraInput | FrenteCreateManyObraInput[]
  }

  export type MoveCreateWithoutObraInput = {
    type: $Enums.MoveType
    quantity: number
    unitCost?: number | null
    totalCost?: number | null
    date?: Date | string
    note?: string | null
    docType?: $Enums.DocType | null
    docSerie?: string | null
    docNumero?: string | null
    igvRate?: Decimal | DecimalJsLike | number | string | null
    isTaxable?: boolean | null
    responsible?: string | null
    assetStatus?: $Enums.AssetStatus | null
    frente?: FrenteCreateNestedOneWithoutMovesInput
    material: MaterialCreateNestedOneWithoutMovesInput
    proveedor?: ProveedorCreateNestedOneWithoutMovesInput
    expense?: ExpenseCreateNestedOneWithoutMoveInput
  }

  export type MoveUncheckedCreateWithoutObraInput = {
    id?: number
    frenteId?: number | null
    materialId: number
    proveedorId?: number | null
    type: $Enums.MoveType
    quantity: number
    unitCost?: number | null
    totalCost?: number | null
    date?: Date | string
    note?: string | null
    docType?: $Enums.DocType | null
    docSerie?: string | null
    docNumero?: string | null
    igvRate?: Decimal | DecimalJsLike | number | string | null
    isTaxable?: boolean | null
    responsible?: string | null
    assetStatus?: $Enums.AssetStatus | null
    expense?: ExpenseUncheckedCreateNestedOneWithoutMoveInput
  }

  export type MoveCreateOrConnectWithoutObraInput = {
    where: MoveWhereUniqueInput
    create: XOR<MoveCreateWithoutObraInput, MoveUncheckedCreateWithoutObraInput>
  }

  export type MoveCreateManyObraInputEnvelope = {
    data: MoveCreateManyObraInput | MoveCreateManyObraInput[]
  }

  export type IncomeCreateWithoutObraInput = {
    date?: Date | string
    description?: string | null
    docType?: $Enums.DocType
    docSerie?: string | null
    docNumero?: string | null
    status?: $Enums.IncomeStatus
    igvRate?: Decimal | DecimalJsLike | number | string
    isTaxable?: boolean
    base: Decimal | DecimalJsLike | number | string
    igv: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    frente?: FrenteCreateNestedOneWithoutIncomesInput
  }

  export type IncomeUncheckedCreateWithoutObraInput = {
    id?: number
    frenteId?: number | null
    date?: Date | string
    description?: string | null
    docType?: $Enums.DocType
    docSerie?: string | null
    docNumero?: string | null
    status?: $Enums.IncomeStatus
    igvRate?: Decimal | DecimalJsLike | number | string
    isTaxable?: boolean
    base: Decimal | DecimalJsLike | number | string
    igv: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncomeCreateOrConnectWithoutObraInput = {
    where: IncomeWhereUniqueInput
    create: XOR<IncomeCreateWithoutObraInput, IncomeUncheckedCreateWithoutObraInput>
  }

  export type IncomeCreateManyObraInputEnvelope = {
    data: IncomeCreateManyObraInput | IncomeCreateManyObraInput[]
  }

  export type ExpenseCreateWithoutObraInput = {
    docType?: $Enums.DocType
    docSerie?: string | null
    docNumero?: string | null
    date?: Date | string
    description?: string | null
    spentBy?: string | null
    type?: $Enums.ExpenseType
    variableType?: $Enums.VariableType
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
    igvRate?: Decimal | DecimalJsLike | number | string
    isTaxable?: boolean
    base: Decimal | DecimalJsLike | number | string
    igv: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paymentMethod?: $Enums.PaymentMethod
    paidAt?: Date | string | null
    status?: string
    reminderIntervalDays?: number | null
    reminderNextDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    frente?: FrenteCreateNestedOneWithoutExpensesInput
    proveedor?: ProveedorCreateNestedOneWithoutExpensesInput
    material?: MaterialCreateNestedOneWithoutExpensesInput
    category?: ExpenseCategoryCreateNestedOneWithoutExpensesInput
    move?: MoveCreateNestedOneWithoutExpenseInput
  }

  export type ExpenseUncheckedCreateWithoutObraInput = {
    id?: number
    frenteId?: number | null
    proveedorId?: number | null
    materialId?: number | null
    categoryId?: number | null
    moveId?: number | null
    docType?: $Enums.DocType
    docSerie?: string | null
    docNumero?: string | null
    date?: Date | string
    description?: string | null
    spentBy?: string | null
    type?: $Enums.ExpenseType
    variableType?: $Enums.VariableType
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
    igvRate?: Decimal | DecimalJsLike | number | string
    isTaxable?: boolean
    base: Decimal | DecimalJsLike | number | string
    igv: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paymentMethod?: $Enums.PaymentMethod
    paidAt?: Date | string | null
    status?: string
    reminderIntervalDays?: number | null
    reminderNextDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCreateOrConnectWithoutObraInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutObraInput, ExpenseUncheckedCreateWithoutObraInput>
  }

  export type ExpenseCreateManyObraInputEnvelope = {
    data: ExpenseCreateManyObraInput | ExpenseCreateManyObraInput[]
  }

  export type EmployeeCreateWithoutObraInput = {
    code?: string | null
    firstName: string
    lastName: string
    documentType?: $Enums.DocumentType | null
    documentNumber?: string | null
    position?: string | null
    phone?: string | null
    email?: string | null
    bankType?: $Enums.BankType
    accountNumber?: string | null
    cci?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    baseSalary?: Decimal | DecimalJsLike | number | string
    dailyHours?: Decimal | DecimalJsLike | number | string
    pensionSystem?: $Enums.PensionSystem
    pensionRate?: Decimal | DecimalJsLike | number | string
    healthRate?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    area?: $Enums.EmployeeArea
    notes?: string | null
    absenceSundayPenalty?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    attendances?: AttendanceRecordCreateNestedManyWithoutEmployeeInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutEmployeeInput
    accumulationPayment?: EmployeeAccumulationPaymentCreateNestedOneWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutObraInput = {
    id?: number
    code?: string | null
    firstName: string
    lastName: string
    documentType?: $Enums.DocumentType | null
    documentNumber?: string | null
    position?: string | null
    phone?: string | null
    email?: string | null
    bankType?: $Enums.BankType
    accountNumber?: string | null
    cci?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    baseSalary?: Decimal | DecimalJsLike | number | string
    dailyHours?: Decimal | DecimalJsLike | number | string
    pensionSystem?: $Enums.PensionSystem
    pensionRate?: Decimal | DecimalJsLike | number | string
    healthRate?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    area?: $Enums.EmployeeArea
    notes?: string | null
    absenceSundayPenalty?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    attendances?: AttendanceRecordUncheckedCreateNestedManyWithoutEmployeeInput
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutEmployeeInput
    accumulationPayment?: EmployeeAccumulationPaymentUncheckedCreateNestedOneWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutObraInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutObraInput, EmployeeUncheckedCreateWithoutObraInput>
  }

  export type EmployeeCreateManyObraInputEnvelope = {
    data: EmployeeCreateManyObraInput | EmployeeCreateManyObraInput[]
  }

  export type PayrollPeriodCreateWithoutObraInput = {
    month: number
    year: number
    startDate: Date | string
    endDate: Date | string
    workingDays: number
    status?: $Enums.PayrollPeriodStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    entries?: PayrollEntryCreateNestedManyWithoutPeriodInput
  }

  export type PayrollPeriodUncheckedCreateWithoutObraInput = {
    id?: number
    month: number
    year: number
    startDate: Date | string
    endDate: Date | string
    workingDays: number
    status?: $Enums.PayrollPeriodStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    entries?: PayrollEntryUncheckedCreateNestedManyWithoutPeriodInput
  }

  export type PayrollPeriodCreateOrConnectWithoutObraInput = {
    where: PayrollPeriodWhereUniqueInput
    create: XOR<PayrollPeriodCreateWithoutObraInput, PayrollPeriodUncheckedCreateWithoutObraInput>
  }

  export type PayrollPeriodCreateManyObraInputEnvelope = {
    data: PayrollPeriodCreateManyObraInput | PayrollPeriodCreateManyObraInput[]
  }

  export type DailyCashRenditionCreateWithoutObraInput = {
    date?: Date | string
    openingBalance?: Decimal | DecimalJsLike | number | string
    received?: Decimal | DecimalJsLike | number | string
    spent?: Decimal | DecimalJsLike | number | string
    personalContribution?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    expenses?: DailyCashExpenseCreateNestedManyWithoutRenditionInput
  }

  export type DailyCashRenditionUncheckedCreateWithoutObraInput = {
    id?: number
    date?: Date | string
    openingBalance?: Decimal | DecimalJsLike | number | string
    received?: Decimal | DecimalJsLike | number | string
    spent?: Decimal | DecimalJsLike | number | string
    personalContribution?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    expenses?: DailyCashExpenseUncheckedCreateNestedManyWithoutRenditionInput
  }

  export type DailyCashRenditionCreateOrConnectWithoutObraInput = {
    where: DailyCashRenditionWhereUniqueInput
    create: XOR<DailyCashRenditionCreateWithoutObraInput, DailyCashRenditionUncheckedCreateWithoutObraInput>
  }

  export type DailyCashRenditionCreateManyObraInputEnvelope = {
    data: DailyCashRenditionCreateManyObraInput | DailyCashRenditionCreateManyObraInput[]
  }

  export type FrenteUpsertWithWhereUniqueWithoutObraInput = {
    where: FrenteWhereUniqueInput
    update: XOR<FrenteUpdateWithoutObraInput, FrenteUncheckedUpdateWithoutObraInput>
    create: XOR<FrenteCreateWithoutObraInput, FrenteUncheckedCreateWithoutObraInput>
  }

  export type FrenteUpdateWithWhereUniqueWithoutObraInput = {
    where: FrenteWhereUniqueInput
    data: XOR<FrenteUpdateWithoutObraInput, FrenteUncheckedUpdateWithoutObraInput>
  }

  export type FrenteUpdateManyWithWhereWithoutObraInput = {
    where: FrenteScalarWhereInput
    data: XOR<FrenteUpdateManyMutationInput, FrenteUncheckedUpdateManyWithoutObraInput>
  }

  export type FrenteScalarWhereInput = {
    AND?: FrenteScalarWhereInput | FrenteScalarWhereInput[]
    OR?: FrenteScalarWhereInput[]
    NOT?: FrenteScalarWhereInput | FrenteScalarWhereInput[]
    id?: IntFilter<"Frente"> | number
    name?: StringFilter<"Frente"> | string
    obraId?: IntFilter<"Frente"> | number
  }

  export type MoveUpsertWithWhereUniqueWithoutObraInput = {
    where: MoveWhereUniqueInput
    update: XOR<MoveUpdateWithoutObraInput, MoveUncheckedUpdateWithoutObraInput>
    create: XOR<MoveCreateWithoutObraInput, MoveUncheckedCreateWithoutObraInput>
  }

  export type MoveUpdateWithWhereUniqueWithoutObraInput = {
    where: MoveWhereUniqueInput
    data: XOR<MoveUpdateWithoutObraInput, MoveUncheckedUpdateWithoutObraInput>
  }

  export type MoveUpdateManyWithWhereWithoutObraInput = {
    where: MoveScalarWhereInput
    data: XOR<MoveUpdateManyMutationInput, MoveUncheckedUpdateManyWithoutObraInput>
  }

  export type MoveScalarWhereInput = {
    AND?: MoveScalarWhereInput | MoveScalarWhereInput[]
    OR?: MoveScalarWhereInput[]
    NOT?: MoveScalarWhereInput | MoveScalarWhereInput[]
    id?: IntFilter<"Move"> | number
    obraId?: IntFilter<"Move"> | number
    frenteId?: IntNullableFilter<"Move"> | number | null
    materialId?: IntFilter<"Move"> | number
    proveedorId?: IntNullableFilter<"Move"> | number | null
    type?: EnumMoveTypeFilter<"Move"> | $Enums.MoveType
    quantity?: FloatFilter<"Move"> | number
    unitCost?: FloatNullableFilter<"Move"> | number | null
    totalCost?: FloatNullableFilter<"Move"> | number | null
    date?: DateTimeFilter<"Move"> | Date | string
    note?: StringNullableFilter<"Move"> | string | null
    docType?: EnumDocTypeNullableFilter<"Move"> | $Enums.DocType | null
    docSerie?: StringNullableFilter<"Move"> | string | null
    docNumero?: StringNullableFilter<"Move"> | string | null
    igvRate?: DecimalNullableFilter<"Move"> | Decimal | DecimalJsLike | number | string | null
    isTaxable?: BoolNullableFilter<"Move"> | boolean | null
    responsible?: StringNullableFilter<"Move"> | string | null
    assetStatus?: EnumAssetStatusNullableFilter<"Move"> | $Enums.AssetStatus | null
  }

  export type IncomeUpsertWithWhereUniqueWithoutObraInput = {
    where: IncomeWhereUniqueInput
    update: XOR<IncomeUpdateWithoutObraInput, IncomeUncheckedUpdateWithoutObraInput>
    create: XOR<IncomeCreateWithoutObraInput, IncomeUncheckedCreateWithoutObraInput>
  }

  export type IncomeUpdateWithWhereUniqueWithoutObraInput = {
    where: IncomeWhereUniqueInput
    data: XOR<IncomeUpdateWithoutObraInput, IncomeUncheckedUpdateWithoutObraInput>
  }

  export type IncomeUpdateManyWithWhereWithoutObraInput = {
    where: IncomeScalarWhereInput
    data: XOR<IncomeUpdateManyMutationInput, IncomeUncheckedUpdateManyWithoutObraInput>
  }

  export type IncomeScalarWhereInput = {
    AND?: IncomeScalarWhereInput | IncomeScalarWhereInput[]
    OR?: IncomeScalarWhereInput[]
    NOT?: IncomeScalarWhereInput | IncomeScalarWhereInput[]
    id?: IntFilter<"Income"> | number
    obraId?: IntFilter<"Income"> | number
    frenteId?: IntNullableFilter<"Income"> | number | null
    date?: DateTimeFilter<"Income"> | Date | string
    description?: StringNullableFilter<"Income"> | string | null
    docType?: EnumDocTypeFilter<"Income"> | $Enums.DocType
    docSerie?: StringNullableFilter<"Income"> | string | null
    docNumero?: StringNullableFilter<"Income"> | string | null
    status?: EnumIncomeStatusFilter<"Income"> | $Enums.IncomeStatus
    igvRate?: DecimalFilter<"Income"> | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFilter<"Income"> | boolean
    base?: DecimalFilter<"Income"> | Decimal | DecimalJsLike | number | string
    igv?: DecimalFilter<"Income"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Income"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Income"> | Date | string
    updatedAt?: DateTimeFilter<"Income"> | Date | string
  }

  export type ExpenseUpsertWithWhereUniqueWithoutObraInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutObraInput, ExpenseUncheckedUpdateWithoutObraInput>
    create: XOR<ExpenseCreateWithoutObraInput, ExpenseUncheckedCreateWithoutObraInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutObraInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutObraInput, ExpenseUncheckedUpdateWithoutObraInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutObraInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutObraInput>
  }

  export type ExpenseScalarWhereInput = {
    AND?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    OR?: ExpenseScalarWhereInput[]
    NOT?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    id?: IntFilter<"Expense"> | number
    obraId?: IntFilter<"Expense"> | number
    frenteId?: IntNullableFilter<"Expense"> | number | null
    proveedorId?: IntNullableFilter<"Expense"> | number | null
    materialId?: IntNullableFilter<"Expense"> | number | null
    categoryId?: IntNullableFilter<"Expense"> | number | null
    moveId?: IntNullableFilter<"Expense"> | number | null
    docType?: EnumDocTypeFilter<"Expense"> | $Enums.DocType
    docSerie?: StringNullableFilter<"Expense"> | string | null
    docNumero?: StringNullableFilter<"Expense"> | string | null
    date?: DateTimeFilter<"Expense"> | Date | string
    description?: StringNullableFilter<"Expense"> | string | null
    spentBy?: StringNullableFilter<"Expense"> | string | null
    type?: EnumExpenseTypeFilter<"Expense"> | $Enums.ExpenseType
    variableType?: EnumVariableTypeFilter<"Expense"> | $Enums.VariableType
    quantity?: DecimalNullableFilter<"Expense"> | Decimal | DecimalJsLike | number | string | null
    unitCost?: DecimalNullableFilter<"Expense"> | Decimal | DecimalJsLike | number | string | null
    igvRate?: DecimalFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFilter<"Expense"> | boolean
    base?: DecimalFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    igv?: DecimalFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFilter<"Expense"> | $Enums.PaymentMethod
    paidAt?: DateTimeNullableFilter<"Expense"> | Date | string | null
    status?: StringFilter<"Expense"> | string
    reminderIntervalDays?: IntNullableFilter<"Expense"> | number | null
    reminderNextDate?: DateTimeNullableFilter<"Expense"> | Date | string | null
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
  }

  export type EmployeeUpsertWithWhereUniqueWithoutObraInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutObraInput, EmployeeUncheckedUpdateWithoutObraInput>
    create: XOR<EmployeeCreateWithoutObraInput, EmployeeUncheckedCreateWithoutObraInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutObraInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutObraInput, EmployeeUncheckedUpdateWithoutObraInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutObraInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutObraInput>
  }

  export type EmployeeScalarWhereInput = {
    AND?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    OR?: EmployeeScalarWhereInput[]
    NOT?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    id?: IntFilter<"Employee"> | number
    code?: StringNullableFilter<"Employee"> | string | null
    firstName?: StringFilter<"Employee"> | string
    lastName?: StringFilter<"Employee"> | string
    documentType?: EnumDocumentTypeNullableFilter<"Employee"> | $Enums.DocumentType | null
    documentNumber?: StringNullableFilter<"Employee"> | string | null
    position?: StringNullableFilter<"Employee"> | string | null
    phone?: StringNullableFilter<"Employee"> | string | null
    email?: StringNullableFilter<"Employee"> | string | null
    bankType?: EnumBankTypeFilter<"Employee"> | $Enums.BankType
    accountNumber?: StringNullableFilter<"Employee"> | string | null
    cci?: StringNullableFilter<"Employee"> | string | null
    startDate?: DateTimeNullableFilter<"Employee"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Employee"> | Date | string | null
    baseSalary?: DecimalFilter<"Employee"> | Decimal | DecimalJsLike | number | string
    dailyHours?: DecimalFilter<"Employee"> | Decimal | DecimalJsLike | number | string
    pensionSystem?: EnumPensionSystemFilter<"Employee"> | $Enums.PensionSystem
    pensionRate?: DecimalFilter<"Employee"> | Decimal | DecimalJsLike | number | string
    healthRate?: DecimalFilter<"Employee"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"Employee"> | boolean
    area?: EnumEmployeeAreaFilter<"Employee"> | $Enums.EmployeeArea
    obraId?: IntNullableFilter<"Employee"> | number | null
    notes?: StringNullableFilter<"Employee"> | string | null
    absenceSundayPenalty?: BoolFilter<"Employee"> | boolean
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
  }

  export type PayrollPeriodUpsertWithWhereUniqueWithoutObraInput = {
    where: PayrollPeriodWhereUniqueInput
    update: XOR<PayrollPeriodUpdateWithoutObraInput, PayrollPeriodUncheckedUpdateWithoutObraInput>
    create: XOR<PayrollPeriodCreateWithoutObraInput, PayrollPeriodUncheckedCreateWithoutObraInput>
  }

  export type PayrollPeriodUpdateWithWhereUniqueWithoutObraInput = {
    where: PayrollPeriodWhereUniqueInput
    data: XOR<PayrollPeriodUpdateWithoutObraInput, PayrollPeriodUncheckedUpdateWithoutObraInput>
  }

  export type PayrollPeriodUpdateManyWithWhereWithoutObraInput = {
    where: PayrollPeriodScalarWhereInput
    data: XOR<PayrollPeriodUpdateManyMutationInput, PayrollPeriodUncheckedUpdateManyWithoutObraInput>
  }

  export type PayrollPeriodScalarWhereInput = {
    AND?: PayrollPeriodScalarWhereInput | PayrollPeriodScalarWhereInput[]
    OR?: PayrollPeriodScalarWhereInput[]
    NOT?: PayrollPeriodScalarWhereInput | PayrollPeriodScalarWhereInput[]
    id?: IntFilter<"PayrollPeriod"> | number
    obraId?: IntNullableFilter<"PayrollPeriod"> | number | null
    month?: IntFilter<"PayrollPeriod"> | number
    year?: IntFilter<"PayrollPeriod"> | number
    startDate?: DateTimeFilter<"PayrollPeriod"> | Date | string
    endDate?: DateTimeFilter<"PayrollPeriod"> | Date | string
    workingDays?: IntFilter<"PayrollPeriod"> | number
    status?: EnumPayrollPeriodStatusFilter<"PayrollPeriod"> | $Enums.PayrollPeriodStatus
    notes?: StringNullableFilter<"PayrollPeriod"> | string | null
    createdAt?: DateTimeFilter<"PayrollPeriod"> | Date | string
    updatedAt?: DateTimeFilter<"PayrollPeriod"> | Date | string
  }

  export type DailyCashRenditionUpsertWithWhereUniqueWithoutObraInput = {
    where: DailyCashRenditionWhereUniqueInput
    update: XOR<DailyCashRenditionUpdateWithoutObraInput, DailyCashRenditionUncheckedUpdateWithoutObraInput>
    create: XOR<DailyCashRenditionCreateWithoutObraInput, DailyCashRenditionUncheckedCreateWithoutObraInput>
  }

  export type DailyCashRenditionUpdateWithWhereUniqueWithoutObraInput = {
    where: DailyCashRenditionWhereUniqueInput
    data: XOR<DailyCashRenditionUpdateWithoutObraInput, DailyCashRenditionUncheckedUpdateWithoutObraInput>
  }

  export type DailyCashRenditionUpdateManyWithWhereWithoutObraInput = {
    where: DailyCashRenditionScalarWhereInput
    data: XOR<DailyCashRenditionUpdateManyMutationInput, DailyCashRenditionUncheckedUpdateManyWithoutObraInput>
  }

  export type DailyCashRenditionScalarWhereInput = {
    AND?: DailyCashRenditionScalarWhereInput | DailyCashRenditionScalarWhereInput[]
    OR?: DailyCashRenditionScalarWhereInput[]
    NOT?: DailyCashRenditionScalarWhereInput | DailyCashRenditionScalarWhereInput[]
    id?: IntFilter<"DailyCashRendition"> | number
    date?: DateTimeFilter<"DailyCashRendition"> | Date | string
    obraId?: IntNullableFilter<"DailyCashRendition"> | number | null
    openingBalance?: DecimalFilter<"DailyCashRendition"> | Decimal | DecimalJsLike | number | string
    received?: DecimalFilter<"DailyCashRendition"> | Decimal | DecimalJsLike | number | string
    spent?: DecimalFilter<"DailyCashRendition"> | Decimal | DecimalJsLike | number | string
    personalContribution?: DecimalFilter<"DailyCashRendition"> | Decimal | DecimalJsLike | number | string
    balance?: DecimalFilter<"DailyCashRendition"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"DailyCashRendition"> | string | null
    createdAt?: DateTimeFilter<"DailyCashRendition"> | Date | string
    updatedAt?: DateTimeFilter<"DailyCashRendition"> | Date | string
  }

  export type MaterialGroupCreateWithoutMaterialsInput = {
    name: string
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: MaterialGroupCreateNestedOneWithoutChildrenInput
    children?: MaterialGroupCreateNestedManyWithoutParentInput
  }

  export type MaterialGroupUncheckedCreateWithoutMaterialsInput = {
    id?: number
    name: string
    parentId?: number | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: MaterialGroupUncheckedCreateNestedManyWithoutParentInput
  }

  export type MaterialGroupCreateOrConnectWithoutMaterialsInput = {
    where: MaterialGroupWhereUniqueInput
    create: XOR<MaterialGroupCreateWithoutMaterialsInput, MaterialGroupUncheckedCreateWithoutMaterialsInput>
  }

  export type MoveCreateWithoutMaterialInput = {
    type: $Enums.MoveType
    quantity: number
    unitCost?: number | null
    totalCost?: number | null
    date?: Date | string
    note?: string | null
    docType?: $Enums.DocType | null
    docSerie?: string | null
    docNumero?: string | null
    igvRate?: Decimal | DecimalJsLike | number | string | null
    isTaxable?: boolean | null
    responsible?: string | null
    assetStatus?: $Enums.AssetStatus | null
    obra: ObraCreateNestedOneWithoutMovesInput
    frente?: FrenteCreateNestedOneWithoutMovesInput
    proveedor?: ProveedorCreateNestedOneWithoutMovesInput
    expense?: ExpenseCreateNestedOneWithoutMoveInput
  }

  export type MoveUncheckedCreateWithoutMaterialInput = {
    id?: number
    obraId: number
    frenteId?: number | null
    proveedorId?: number | null
    type: $Enums.MoveType
    quantity: number
    unitCost?: number | null
    totalCost?: number | null
    date?: Date | string
    note?: string | null
    docType?: $Enums.DocType | null
    docSerie?: string | null
    docNumero?: string | null
    igvRate?: Decimal | DecimalJsLike | number | string | null
    isTaxable?: boolean | null
    responsible?: string | null
    assetStatus?: $Enums.AssetStatus | null
    expense?: ExpenseUncheckedCreateNestedOneWithoutMoveInput
  }

  export type MoveCreateOrConnectWithoutMaterialInput = {
    where: MoveWhereUniqueInput
    create: XOR<MoveCreateWithoutMaterialInput, MoveUncheckedCreateWithoutMaterialInput>
  }

  export type MoveCreateManyMaterialInputEnvelope = {
    data: MoveCreateManyMaterialInput | MoveCreateManyMaterialInput[]
  }

  export type ExpenseCreateWithoutMaterialInput = {
    docType?: $Enums.DocType
    docSerie?: string | null
    docNumero?: string | null
    date?: Date | string
    description?: string | null
    spentBy?: string | null
    type?: $Enums.ExpenseType
    variableType?: $Enums.VariableType
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
    igvRate?: Decimal | DecimalJsLike | number | string
    isTaxable?: boolean
    base: Decimal | DecimalJsLike | number | string
    igv: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paymentMethod?: $Enums.PaymentMethod
    paidAt?: Date | string | null
    status?: string
    reminderIntervalDays?: number | null
    reminderNextDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    obra: ObraCreateNestedOneWithoutExpensesInput
    frente?: FrenteCreateNestedOneWithoutExpensesInput
    proveedor?: ProveedorCreateNestedOneWithoutExpensesInput
    category?: ExpenseCategoryCreateNestedOneWithoutExpensesInput
    move?: MoveCreateNestedOneWithoutExpenseInput
  }

  export type ExpenseUncheckedCreateWithoutMaterialInput = {
    id?: number
    obraId: number
    frenteId?: number | null
    proveedorId?: number | null
    categoryId?: number | null
    moveId?: number | null
    docType?: $Enums.DocType
    docSerie?: string | null
    docNumero?: string | null
    date?: Date | string
    description?: string | null
    spentBy?: string | null
    type?: $Enums.ExpenseType
    variableType?: $Enums.VariableType
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
    igvRate?: Decimal | DecimalJsLike | number | string
    isTaxable?: boolean
    base: Decimal | DecimalJsLike | number | string
    igv: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paymentMethod?: $Enums.PaymentMethod
    paidAt?: Date | string | null
    status?: string
    reminderIntervalDays?: number | null
    reminderNextDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCreateOrConnectWithoutMaterialInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutMaterialInput, ExpenseUncheckedCreateWithoutMaterialInput>
  }

  export type ExpenseCreateManyMaterialInputEnvelope = {
    data: ExpenseCreateManyMaterialInput | ExpenseCreateManyMaterialInput[]
  }

  export type QuotationBaselineItemCreateWithoutMaterialInput = {
    sheetName?: string | null
    sectionPath?: string | null
    itemCode?: string | null
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    process: QuotationProcessCreateNestedOneWithoutBaselinesInput
    quoteItems?: QuotationItemCreateNestedManyWithoutBaselineItemInput
    orderLines?: PurchaseOrderLineCreateNestedManyWithoutBaselineInput
    deliveryItems?: PurchaseDeliveryItemCreateNestedManyWithoutBaselineInput
  }

  export type QuotationBaselineItemUncheckedCreateWithoutMaterialInput = {
    id?: number
    processId: number
    sheetName?: string | null
    sectionPath?: string | null
    itemCode?: string | null
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    quoteItems?: QuotationItemUncheckedCreateNestedManyWithoutBaselineItemInput
    orderLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutBaselineInput
    deliveryItems?: PurchaseDeliveryItemUncheckedCreateNestedManyWithoutBaselineInput
  }

  export type QuotationBaselineItemCreateOrConnectWithoutMaterialInput = {
    where: QuotationBaselineItemWhereUniqueInput
    create: XOR<QuotationBaselineItemCreateWithoutMaterialInput, QuotationBaselineItemUncheckedCreateWithoutMaterialInput>
  }

  export type QuotationBaselineItemCreateManyMaterialInputEnvelope = {
    data: QuotationBaselineItemCreateManyMaterialInput | QuotationBaselineItemCreateManyMaterialInput[]
  }

  export type QuotationItemCreateWithoutMaterialInput = {
    sourceRow?: number | null
    itemCode?: string | null
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    normalizedPrice?: Decimal | DecimalJsLike | number | string | null
    matchScore?: number | null
    extraAttributes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    quotation: QuotationCreateNestedOneWithoutItemsInput
    baselineItem?: QuotationBaselineItemCreateNestedOneWithoutQuoteItemsInput
  }

  export type QuotationItemUncheckedCreateWithoutMaterialInput = {
    id?: number
    quotationId: number
    baselineItemId?: number | null
    sourceRow?: number | null
    itemCode?: string | null
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    normalizedPrice?: Decimal | DecimalJsLike | number | string | null
    matchScore?: number | null
    extraAttributes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuotationItemCreateOrConnectWithoutMaterialInput = {
    where: QuotationItemWhereUniqueInput
    create: XOR<QuotationItemCreateWithoutMaterialInput, QuotationItemUncheckedCreateWithoutMaterialInput>
  }

  export type QuotationItemCreateManyMaterialInputEnvelope = {
    data: QuotationItemCreateManyMaterialInput | QuotationItemCreateManyMaterialInput[]
  }

  export type MaterialGroupUpsertWithoutMaterialsInput = {
    update: XOR<MaterialGroupUpdateWithoutMaterialsInput, MaterialGroupUncheckedUpdateWithoutMaterialsInput>
    create: XOR<MaterialGroupCreateWithoutMaterialsInput, MaterialGroupUncheckedCreateWithoutMaterialsInput>
    where?: MaterialGroupWhereInput
  }

  export type MaterialGroupUpdateToOneWithWhereWithoutMaterialsInput = {
    where?: MaterialGroupWhereInput
    data: XOR<MaterialGroupUpdateWithoutMaterialsInput, MaterialGroupUncheckedUpdateWithoutMaterialsInput>
  }

  export type MaterialGroupUpdateWithoutMaterialsInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: MaterialGroupUpdateOneWithoutChildrenNestedInput
    children?: MaterialGroupUpdateManyWithoutParentNestedInput
  }

  export type MaterialGroupUncheckedUpdateWithoutMaterialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: MaterialGroupUncheckedUpdateManyWithoutParentNestedInput
  }

  export type MoveUpsertWithWhereUniqueWithoutMaterialInput = {
    where: MoveWhereUniqueInput
    update: XOR<MoveUpdateWithoutMaterialInput, MoveUncheckedUpdateWithoutMaterialInput>
    create: XOR<MoveCreateWithoutMaterialInput, MoveUncheckedCreateWithoutMaterialInput>
  }

  export type MoveUpdateWithWhereUniqueWithoutMaterialInput = {
    where: MoveWhereUniqueInput
    data: XOR<MoveUpdateWithoutMaterialInput, MoveUncheckedUpdateWithoutMaterialInput>
  }

  export type MoveUpdateManyWithWhereWithoutMaterialInput = {
    where: MoveScalarWhereInput
    data: XOR<MoveUpdateManyMutationInput, MoveUncheckedUpdateManyWithoutMaterialInput>
  }

  export type ExpenseUpsertWithWhereUniqueWithoutMaterialInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutMaterialInput, ExpenseUncheckedUpdateWithoutMaterialInput>
    create: XOR<ExpenseCreateWithoutMaterialInput, ExpenseUncheckedCreateWithoutMaterialInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutMaterialInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutMaterialInput, ExpenseUncheckedUpdateWithoutMaterialInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutMaterialInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutMaterialInput>
  }

  export type QuotationBaselineItemUpsertWithWhereUniqueWithoutMaterialInput = {
    where: QuotationBaselineItemWhereUniqueInput
    update: XOR<QuotationBaselineItemUpdateWithoutMaterialInput, QuotationBaselineItemUncheckedUpdateWithoutMaterialInput>
    create: XOR<QuotationBaselineItemCreateWithoutMaterialInput, QuotationBaselineItemUncheckedCreateWithoutMaterialInput>
  }

  export type QuotationBaselineItemUpdateWithWhereUniqueWithoutMaterialInput = {
    where: QuotationBaselineItemWhereUniqueInput
    data: XOR<QuotationBaselineItemUpdateWithoutMaterialInput, QuotationBaselineItemUncheckedUpdateWithoutMaterialInput>
  }

  export type QuotationBaselineItemUpdateManyWithWhereWithoutMaterialInput = {
    where: QuotationBaselineItemScalarWhereInput
    data: XOR<QuotationBaselineItemUpdateManyMutationInput, QuotationBaselineItemUncheckedUpdateManyWithoutMaterialInput>
  }

  export type QuotationBaselineItemScalarWhereInput = {
    AND?: QuotationBaselineItemScalarWhereInput | QuotationBaselineItemScalarWhereInput[]
    OR?: QuotationBaselineItemScalarWhereInput[]
    NOT?: QuotationBaselineItemScalarWhereInput | QuotationBaselineItemScalarWhereInput[]
    id?: IntFilter<"QuotationBaselineItem"> | number
    processId?: IntFilter<"QuotationBaselineItem"> | number
    materialId?: IntNullableFilter<"QuotationBaselineItem"> | number | null
    sheetName?: StringNullableFilter<"QuotationBaselineItem"> | string | null
    sectionPath?: StringNullableFilter<"QuotationBaselineItem"> | string | null
    itemCode?: StringNullableFilter<"QuotationBaselineItem"> | string | null
    description?: StringFilter<"QuotationBaselineItem"> | string
    unit?: StringNullableFilter<"QuotationBaselineItem"> | string | null
    quantity?: DecimalNullableFilter<"QuotationBaselineItem"> | Decimal | DecimalJsLike | number | string | null
    unitPrice?: DecimalNullableFilter<"QuotationBaselineItem"> | Decimal | DecimalJsLike | number | string | null
    totalPrice?: DecimalNullableFilter<"QuotationBaselineItem"> | Decimal | DecimalJsLike | number | string | null
    metadata?: JsonNullableFilter<"QuotationBaselineItem">
    createdAt?: DateTimeFilter<"QuotationBaselineItem"> | Date | string
    updatedAt?: DateTimeFilter<"QuotationBaselineItem"> | Date | string
  }

  export type QuotationItemUpsertWithWhereUniqueWithoutMaterialInput = {
    where: QuotationItemWhereUniqueInput
    update: XOR<QuotationItemUpdateWithoutMaterialInput, QuotationItemUncheckedUpdateWithoutMaterialInput>
    create: XOR<QuotationItemCreateWithoutMaterialInput, QuotationItemUncheckedCreateWithoutMaterialInput>
  }

  export type QuotationItemUpdateWithWhereUniqueWithoutMaterialInput = {
    where: QuotationItemWhereUniqueInput
    data: XOR<QuotationItemUpdateWithoutMaterialInput, QuotationItemUncheckedUpdateWithoutMaterialInput>
  }

  export type QuotationItemUpdateManyWithWhereWithoutMaterialInput = {
    where: QuotationItemScalarWhereInput
    data: XOR<QuotationItemUpdateManyMutationInput, QuotationItemUncheckedUpdateManyWithoutMaterialInput>
  }

  export type QuotationItemScalarWhereInput = {
    AND?: QuotationItemScalarWhereInput | QuotationItemScalarWhereInput[]
    OR?: QuotationItemScalarWhereInput[]
    NOT?: QuotationItemScalarWhereInput | QuotationItemScalarWhereInput[]
    id?: IntFilter<"QuotationItem"> | number
    quotationId?: IntFilter<"QuotationItem"> | number
    baselineItemId?: IntNullableFilter<"QuotationItem"> | number | null
    materialId?: IntNullableFilter<"QuotationItem"> | number | null
    sourceRow?: IntNullableFilter<"QuotationItem"> | number | null
    itemCode?: StringNullableFilter<"QuotationItem"> | string | null
    description?: StringFilter<"QuotationItem"> | string
    unit?: StringNullableFilter<"QuotationItem"> | string | null
    quantity?: DecimalNullableFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string | null
    unitPrice?: DecimalNullableFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string | null
    totalPrice?: DecimalNullableFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter<"QuotationItem"> | string | null
    normalizedPrice?: DecimalNullableFilter<"QuotationItem"> | Decimal | DecimalJsLike | number | string | null
    matchScore?: FloatNullableFilter<"QuotationItem"> | number | null
    extraAttributes?: JsonNullableFilter<"QuotationItem">
    createdAt?: DateTimeFilter<"QuotationItem"> | Date | string
    updatedAt?: DateTimeFilter<"QuotationItem"> | Date | string
  }

  export type MoveCreateWithoutProveedorInput = {
    type: $Enums.MoveType
    quantity: number
    unitCost?: number | null
    totalCost?: number | null
    date?: Date | string
    note?: string | null
    docType?: $Enums.DocType | null
    docSerie?: string | null
    docNumero?: string | null
    igvRate?: Decimal | DecimalJsLike | number | string | null
    isTaxable?: boolean | null
    responsible?: string | null
    assetStatus?: $Enums.AssetStatus | null
    obra: ObraCreateNestedOneWithoutMovesInput
    frente?: FrenteCreateNestedOneWithoutMovesInput
    material: MaterialCreateNestedOneWithoutMovesInput
    expense?: ExpenseCreateNestedOneWithoutMoveInput
  }

  export type MoveUncheckedCreateWithoutProveedorInput = {
    id?: number
    obraId: number
    frenteId?: number | null
    materialId: number
    type: $Enums.MoveType
    quantity: number
    unitCost?: number | null
    totalCost?: number | null
    date?: Date | string
    note?: string | null
    docType?: $Enums.DocType | null
    docSerie?: string | null
    docNumero?: string | null
    igvRate?: Decimal | DecimalJsLike | number | string | null
    isTaxable?: boolean | null
    responsible?: string | null
    assetStatus?: $Enums.AssetStatus | null
    expense?: ExpenseUncheckedCreateNestedOneWithoutMoveInput
  }

  export type MoveCreateOrConnectWithoutProveedorInput = {
    where: MoveWhereUniqueInput
    create: XOR<MoveCreateWithoutProveedorInput, MoveUncheckedCreateWithoutProveedorInput>
  }

  export type MoveCreateManyProveedorInputEnvelope = {
    data: MoveCreateManyProveedorInput | MoveCreateManyProveedorInput[]
  }

  export type ExpenseCreateWithoutProveedorInput = {
    docType?: $Enums.DocType
    docSerie?: string | null
    docNumero?: string | null
    date?: Date | string
    description?: string | null
    spentBy?: string | null
    type?: $Enums.ExpenseType
    variableType?: $Enums.VariableType
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
    igvRate?: Decimal | DecimalJsLike | number | string
    isTaxable?: boolean
    base: Decimal | DecimalJsLike | number | string
    igv: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paymentMethod?: $Enums.PaymentMethod
    paidAt?: Date | string | null
    status?: string
    reminderIntervalDays?: number | null
    reminderNextDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    obra: ObraCreateNestedOneWithoutExpensesInput
    frente?: FrenteCreateNestedOneWithoutExpensesInput
    material?: MaterialCreateNestedOneWithoutExpensesInput
    category?: ExpenseCategoryCreateNestedOneWithoutExpensesInput
    move?: MoveCreateNestedOneWithoutExpenseInput
  }

  export type ExpenseUncheckedCreateWithoutProveedorInput = {
    id?: number
    obraId: number
    frenteId?: number | null
    materialId?: number | null
    categoryId?: number | null
    moveId?: number | null
    docType?: $Enums.DocType
    docSerie?: string | null
    docNumero?: string | null
    date?: Date | string
    description?: string | null
    spentBy?: string | null
    type?: $Enums.ExpenseType
    variableType?: $Enums.VariableType
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
    igvRate?: Decimal | DecimalJsLike | number | string
    isTaxable?: boolean
    base: Decimal | DecimalJsLike | number | string
    igv: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paymentMethod?: $Enums.PaymentMethod
    paidAt?: Date | string | null
    status?: string
    reminderIntervalDays?: number | null
    reminderNextDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCreateOrConnectWithoutProveedorInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutProveedorInput, ExpenseUncheckedCreateWithoutProveedorInput>
  }

  export type ExpenseCreateManyProveedorInputEnvelope = {
    data: ExpenseCreateManyProveedorInput | ExpenseCreateManyProveedorInput[]
  }

  export type QuotationCreateWithoutProveedorInput = {
    supplierName?: string | null
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    submittedAt?: Date | string | null
    status?: $Enums.QuotationStatus
    totalAmount?: Decimal | DecimalJsLike | number | string | null
    totalAmountPen?: Decimal | DecimalJsLike | number | string | null
    qualityScore?: number | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    process: QuotationProcessCreateNestedOneWithoutQuotationsInput
    items?: QuotationItemCreateNestedManyWithoutQuotationInput
    attachments?: QuotationAttachmentCreateNestedManyWithoutQuotationInput
    purchaseOrders?: PurchaseOrderLogCreateNestedManyWithoutQuotationInput
  }

  export type QuotationUncheckedCreateWithoutProveedorInput = {
    id?: number
    processId: number
    supplierName?: string | null
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    submittedAt?: Date | string | null
    status?: $Enums.QuotationStatus
    totalAmount?: Decimal | DecimalJsLike | number | string | null
    totalAmountPen?: Decimal | DecimalJsLike | number | string | null
    qualityScore?: number | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: QuotationItemUncheckedCreateNestedManyWithoutQuotationInput
    attachments?: QuotationAttachmentUncheckedCreateNestedManyWithoutQuotationInput
    purchaseOrders?: PurchaseOrderLogUncheckedCreateNestedManyWithoutQuotationInput
  }

  export type QuotationCreateOrConnectWithoutProveedorInput = {
    where: QuotationWhereUniqueInput
    create: XOR<QuotationCreateWithoutProveedorInput, QuotationUncheckedCreateWithoutProveedorInput>
  }

  export type QuotationCreateManyProveedorInputEnvelope = {
    data: QuotationCreateManyProveedorInput | QuotationCreateManyProveedorInput[]
  }

  export type PurchaseDeliveryLogCreateWithoutProveedorInput = {
    supplierName?: string | null
    guideNumber?: string | null
    date?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    process: QuotationProcessCreateNestedOneWithoutDeliveryLogsInput
    order?: PurchaseOrderLogCreateNestedOneWithoutDeliveriesInput
    items?: PurchaseDeliveryItemCreateNestedManyWithoutDeliveryInput
  }

  export type PurchaseDeliveryLogUncheckedCreateWithoutProveedorInput = {
    id?: number
    processId: number
    orderId?: number | null
    supplierName?: string | null
    guideNumber?: string | null
    date?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseDeliveryItemUncheckedCreateNestedManyWithoutDeliveryInput
  }

  export type PurchaseDeliveryLogCreateOrConnectWithoutProveedorInput = {
    where: PurchaseDeliveryLogWhereUniqueInput
    create: XOR<PurchaseDeliveryLogCreateWithoutProveedorInput, PurchaseDeliveryLogUncheckedCreateWithoutProveedorInput>
  }

  export type PurchaseDeliveryLogCreateManyProveedorInputEnvelope = {
    data: PurchaseDeliveryLogCreateManyProveedorInput | PurchaseDeliveryLogCreateManyProveedorInput[]
  }

  export type MoveUpsertWithWhereUniqueWithoutProveedorInput = {
    where: MoveWhereUniqueInput
    update: XOR<MoveUpdateWithoutProveedorInput, MoveUncheckedUpdateWithoutProveedorInput>
    create: XOR<MoveCreateWithoutProveedorInput, MoveUncheckedCreateWithoutProveedorInput>
  }

  export type MoveUpdateWithWhereUniqueWithoutProveedorInput = {
    where: MoveWhereUniqueInput
    data: XOR<MoveUpdateWithoutProveedorInput, MoveUncheckedUpdateWithoutProveedorInput>
  }

  export type MoveUpdateManyWithWhereWithoutProveedorInput = {
    where: MoveScalarWhereInput
    data: XOR<MoveUpdateManyMutationInput, MoveUncheckedUpdateManyWithoutProveedorInput>
  }

  export type ExpenseUpsertWithWhereUniqueWithoutProveedorInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutProveedorInput, ExpenseUncheckedUpdateWithoutProveedorInput>
    create: XOR<ExpenseCreateWithoutProveedorInput, ExpenseUncheckedCreateWithoutProveedorInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutProveedorInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutProveedorInput, ExpenseUncheckedUpdateWithoutProveedorInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutProveedorInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutProveedorInput>
  }

  export type QuotationUpsertWithWhereUniqueWithoutProveedorInput = {
    where: QuotationWhereUniqueInput
    update: XOR<QuotationUpdateWithoutProveedorInput, QuotationUncheckedUpdateWithoutProveedorInput>
    create: XOR<QuotationCreateWithoutProveedorInput, QuotationUncheckedCreateWithoutProveedorInput>
  }

  export type QuotationUpdateWithWhereUniqueWithoutProveedorInput = {
    where: QuotationWhereUniqueInput
    data: XOR<QuotationUpdateWithoutProveedorInput, QuotationUncheckedUpdateWithoutProveedorInput>
  }

  export type QuotationUpdateManyWithWhereWithoutProveedorInput = {
    where: QuotationScalarWhereInput
    data: XOR<QuotationUpdateManyMutationInput, QuotationUncheckedUpdateManyWithoutProveedorInput>
  }

  export type QuotationScalarWhereInput = {
    AND?: QuotationScalarWhereInput | QuotationScalarWhereInput[]
    OR?: QuotationScalarWhereInput[]
    NOT?: QuotationScalarWhereInput | QuotationScalarWhereInput[]
    id?: IntFilter<"Quotation"> | number
    processId?: IntFilter<"Quotation"> | number
    proveedorId?: IntNullableFilter<"Quotation"> | number | null
    supplierName?: StringNullableFilter<"Quotation"> | string | null
    currency?: StringFilter<"Quotation"> | string
    exchangeRate?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    submittedAt?: DateTimeNullableFilter<"Quotation"> | Date | string | null
    status?: EnumQuotationStatusFilter<"Quotation"> | $Enums.QuotationStatus
    totalAmount?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    totalAmountPen?: DecimalNullableFilter<"Quotation"> | Decimal | DecimalJsLike | number | string | null
    qualityScore?: IntNullableFilter<"Quotation"> | number | null
    notes?: StringNullableFilter<"Quotation"> | string | null
    metadata?: JsonNullableFilter<"Quotation">
    createdAt?: DateTimeFilter<"Quotation"> | Date | string
    updatedAt?: DateTimeFilter<"Quotation"> | Date | string
  }

  export type PurchaseDeliveryLogUpsertWithWhereUniqueWithoutProveedorInput = {
    where: PurchaseDeliveryLogWhereUniqueInput
    update: XOR<PurchaseDeliveryLogUpdateWithoutProveedorInput, PurchaseDeliveryLogUncheckedUpdateWithoutProveedorInput>
    create: XOR<PurchaseDeliveryLogCreateWithoutProveedorInput, PurchaseDeliveryLogUncheckedCreateWithoutProveedorInput>
  }

  export type PurchaseDeliveryLogUpdateWithWhereUniqueWithoutProveedorInput = {
    where: PurchaseDeliveryLogWhereUniqueInput
    data: XOR<PurchaseDeliveryLogUpdateWithoutProveedorInput, PurchaseDeliveryLogUncheckedUpdateWithoutProveedorInput>
  }

  export type PurchaseDeliveryLogUpdateManyWithWhereWithoutProveedorInput = {
    where: PurchaseDeliveryLogScalarWhereInput
    data: XOR<PurchaseDeliveryLogUpdateManyMutationInput, PurchaseDeliveryLogUncheckedUpdateManyWithoutProveedorInput>
  }

  export type PurchaseDeliveryLogScalarWhereInput = {
    AND?: PurchaseDeliveryLogScalarWhereInput | PurchaseDeliveryLogScalarWhereInput[]
    OR?: PurchaseDeliveryLogScalarWhereInput[]
    NOT?: PurchaseDeliveryLogScalarWhereInput | PurchaseDeliveryLogScalarWhereInput[]
    id?: IntFilter<"PurchaseDeliveryLog"> | number
    processId?: IntFilter<"PurchaseDeliveryLog"> | number
    orderId?: IntNullableFilter<"PurchaseDeliveryLog"> | number | null
    proveedorId?: IntNullableFilter<"PurchaseDeliveryLog"> | number | null
    supplierName?: StringNullableFilter<"PurchaseDeliveryLog"> | string | null
    guideNumber?: StringNullableFilter<"PurchaseDeliveryLog"> | string | null
    date?: DateTimeFilter<"PurchaseDeliveryLog"> | Date | string
    notes?: StringNullableFilter<"PurchaseDeliveryLog"> | string | null
    createdAt?: DateTimeFilter<"PurchaseDeliveryLog"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseDeliveryLog"> | Date | string
  }

  export type ObraCreateWithoutFrentesInput = {
    name: string
    code?: string | null
    moves?: MoveCreateNestedManyWithoutObraInput
    incomes?: IncomeCreateNestedManyWithoutObraInput
    expenses?: ExpenseCreateNestedManyWithoutObraInput
    employees?: EmployeeCreateNestedManyWithoutObraInput
    payrollPeriods?: PayrollPeriodCreateNestedManyWithoutObraInput
    dailyCashRenditions?: DailyCashRenditionCreateNestedManyWithoutObraInput
  }

  export type ObraUncheckedCreateWithoutFrentesInput = {
    id?: number
    name: string
    code?: string | null
    moves?: MoveUncheckedCreateNestedManyWithoutObraInput
    incomes?: IncomeUncheckedCreateNestedManyWithoutObraInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutObraInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutObraInput
    payrollPeriods?: PayrollPeriodUncheckedCreateNestedManyWithoutObraInput
    dailyCashRenditions?: DailyCashRenditionUncheckedCreateNestedManyWithoutObraInput
  }

  export type ObraCreateOrConnectWithoutFrentesInput = {
    where: ObraWhereUniqueInput
    create: XOR<ObraCreateWithoutFrentesInput, ObraUncheckedCreateWithoutFrentesInput>
  }

  export type MoveCreateWithoutFrenteInput = {
    type: $Enums.MoveType
    quantity: number
    unitCost?: number | null
    totalCost?: number | null
    date?: Date | string
    note?: string | null
    docType?: $Enums.DocType | null
    docSerie?: string | null
    docNumero?: string | null
    igvRate?: Decimal | DecimalJsLike | number | string | null
    isTaxable?: boolean | null
    responsible?: string | null
    assetStatus?: $Enums.AssetStatus | null
    obra: ObraCreateNestedOneWithoutMovesInput
    material: MaterialCreateNestedOneWithoutMovesInput
    proveedor?: ProveedorCreateNestedOneWithoutMovesInput
    expense?: ExpenseCreateNestedOneWithoutMoveInput
  }

  export type MoveUncheckedCreateWithoutFrenteInput = {
    id?: number
    obraId: number
    materialId: number
    proveedorId?: number | null
    type: $Enums.MoveType
    quantity: number
    unitCost?: number | null
    totalCost?: number | null
    date?: Date | string
    note?: string | null
    docType?: $Enums.DocType | null
    docSerie?: string | null
    docNumero?: string | null
    igvRate?: Decimal | DecimalJsLike | number | string | null
    isTaxable?: boolean | null
    responsible?: string | null
    assetStatus?: $Enums.AssetStatus | null
    expense?: ExpenseUncheckedCreateNestedOneWithoutMoveInput
  }

  export type MoveCreateOrConnectWithoutFrenteInput = {
    where: MoveWhereUniqueInput
    create: XOR<MoveCreateWithoutFrenteInput, MoveUncheckedCreateWithoutFrenteInput>
  }

  export type MoveCreateManyFrenteInputEnvelope = {
    data: MoveCreateManyFrenteInput | MoveCreateManyFrenteInput[]
  }

  export type IncomeCreateWithoutFrenteInput = {
    date?: Date | string
    description?: string | null
    docType?: $Enums.DocType
    docSerie?: string | null
    docNumero?: string | null
    status?: $Enums.IncomeStatus
    igvRate?: Decimal | DecimalJsLike | number | string
    isTaxable?: boolean
    base: Decimal | DecimalJsLike | number | string
    igv: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    obra: ObraCreateNestedOneWithoutIncomesInput
  }

  export type IncomeUncheckedCreateWithoutFrenteInput = {
    id?: number
    obraId: number
    date?: Date | string
    description?: string | null
    docType?: $Enums.DocType
    docSerie?: string | null
    docNumero?: string | null
    status?: $Enums.IncomeStatus
    igvRate?: Decimal | DecimalJsLike | number | string
    isTaxable?: boolean
    base: Decimal | DecimalJsLike | number | string
    igv: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncomeCreateOrConnectWithoutFrenteInput = {
    where: IncomeWhereUniqueInput
    create: XOR<IncomeCreateWithoutFrenteInput, IncomeUncheckedCreateWithoutFrenteInput>
  }

  export type IncomeCreateManyFrenteInputEnvelope = {
    data: IncomeCreateManyFrenteInput | IncomeCreateManyFrenteInput[]
  }

  export type ExpenseCreateWithoutFrenteInput = {
    docType?: $Enums.DocType
    docSerie?: string | null
    docNumero?: string | null
    date?: Date | string
    description?: string | null
    spentBy?: string | null
    type?: $Enums.ExpenseType
    variableType?: $Enums.VariableType
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
    igvRate?: Decimal | DecimalJsLike | number | string
    isTaxable?: boolean
    base: Decimal | DecimalJsLike | number | string
    igv: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paymentMethod?: $Enums.PaymentMethod
    paidAt?: Date | string | null
    status?: string
    reminderIntervalDays?: number | null
    reminderNextDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    obra: ObraCreateNestedOneWithoutExpensesInput
    proveedor?: ProveedorCreateNestedOneWithoutExpensesInput
    material?: MaterialCreateNestedOneWithoutExpensesInput
    category?: ExpenseCategoryCreateNestedOneWithoutExpensesInput
    move?: MoveCreateNestedOneWithoutExpenseInput
  }

  export type ExpenseUncheckedCreateWithoutFrenteInput = {
    id?: number
    obraId: number
    proveedorId?: number | null
    materialId?: number | null
    categoryId?: number | null
    moveId?: number | null
    docType?: $Enums.DocType
    docSerie?: string | null
    docNumero?: string | null
    date?: Date | string
    description?: string | null
    spentBy?: string | null
    type?: $Enums.ExpenseType
    variableType?: $Enums.VariableType
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
    igvRate?: Decimal | DecimalJsLike | number | string
    isTaxable?: boolean
    base: Decimal | DecimalJsLike | number | string
    igv: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paymentMethod?: $Enums.PaymentMethod
    paidAt?: Date | string | null
    status?: string
    reminderIntervalDays?: number | null
    reminderNextDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCreateOrConnectWithoutFrenteInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutFrenteInput, ExpenseUncheckedCreateWithoutFrenteInput>
  }

  export type ExpenseCreateManyFrenteInputEnvelope = {
    data: ExpenseCreateManyFrenteInput | ExpenseCreateManyFrenteInput[]
  }

  export type ObraUpsertWithoutFrentesInput = {
    update: XOR<ObraUpdateWithoutFrentesInput, ObraUncheckedUpdateWithoutFrentesInput>
    create: XOR<ObraCreateWithoutFrentesInput, ObraUncheckedCreateWithoutFrentesInput>
    where?: ObraWhereInput
  }

  export type ObraUpdateToOneWithWhereWithoutFrentesInput = {
    where?: ObraWhereInput
    data: XOR<ObraUpdateWithoutFrentesInput, ObraUncheckedUpdateWithoutFrentesInput>
  }

  export type ObraUpdateWithoutFrentesInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    moves?: MoveUpdateManyWithoutObraNestedInput
    incomes?: IncomeUpdateManyWithoutObraNestedInput
    expenses?: ExpenseUpdateManyWithoutObraNestedInput
    employees?: EmployeeUpdateManyWithoutObraNestedInput
    payrollPeriods?: PayrollPeriodUpdateManyWithoutObraNestedInput
    dailyCashRenditions?: DailyCashRenditionUpdateManyWithoutObraNestedInput
  }

  export type ObraUncheckedUpdateWithoutFrentesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    moves?: MoveUncheckedUpdateManyWithoutObraNestedInput
    incomes?: IncomeUncheckedUpdateManyWithoutObraNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutObraNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutObraNestedInput
    payrollPeriods?: PayrollPeriodUncheckedUpdateManyWithoutObraNestedInput
    dailyCashRenditions?: DailyCashRenditionUncheckedUpdateManyWithoutObraNestedInput
  }

  export type MoveUpsertWithWhereUniqueWithoutFrenteInput = {
    where: MoveWhereUniqueInput
    update: XOR<MoveUpdateWithoutFrenteInput, MoveUncheckedUpdateWithoutFrenteInput>
    create: XOR<MoveCreateWithoutFrenteInput, MoveUncheckedCreateWithoutFrenteInput>
  }

  export type MoveUpdateWithWhereUniqueWithoutFrenteInput = {
    where: MoveWhereUniqueInput
    data: XOR<MoveUpdateWithoutFrenteInput, MoveUncheckedUpdateWithoutFrenteInput>
  }

  export type MoveUpdateManyWithWhereWithoutFrenteInput = {
    where: MoveScalarWhereInput
    data: XOR<MoveUpdateManyMutationInput, MoveUncheckedUpdateManyWithoutFrenteInput>
  }

  export type IncomeUpsertWithWhereUniqueWithoutFrenteInput = {
    where: IncomeWhereUniqueInput
    update: XOR<IncomeUpdateWithoutFrenteInput, IncomeUncheckedUpdateWithoutFrenteInput>
    create: XOR<IncomeCreateWithoutFrenteInput, IncomeUncheckedCreateWithoutFrenteInput>
  }

  export type IncomeUpdateWithWhereUniqueWithoutFrenteInput = {
    where: IncomeWhereUniqueInput
    data: XOR<IncomeUpdateWithoutFrenteInput, IncomeUncheckedUpdateWithoutFrenteInput>
  }

  export type IncomeUpdateManyWithWhereWithoutFrenteInput = {
    where: IncomeScalarWhereInput
    data: XOR<IncomeUpdateManyMutationInput, IncomeUncheckedUpdateManyWithoutFrenteInput>
  }

  export type ExpenseUpsertWithWhereUniqueWithoutFrenteInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutFrenteInput, ExpenseUncheckedUpdateWithoutFrenteInput>
    create: XOR<ExpenseCreateWithoutFrenteInput, ExpenseUncheckedCreateWithoutFrenteInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutFrenteInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutFrenteInput, ExpenseUncheckedUpdateWithoutFrenteInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutFrenteInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutFrenteInput>
  }

  export type MaterialGroupCreateWithoutChildrenInput = {
    name: string
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: MaterialGroupCreateNestedOneWithoutChildrenInput
    materials?: MaterialCreateNestedManyWithoutGroupInput
  }

  export type MaterialGroupUncheckedCreateWithoutChildrenInput = {
    id?: number
    name: string
    parentId?: number | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    materials?: MaterialUncheckedCreateNestedManyWithoutGroupInput
  }

  export type MaterialGroupCreateOrConnectWithoutChildrenInput = {
    where: MaterialGroupWhereUniqueInput
    create: XOR<MaterialGroupCreateWithoutChildrenInput, MaterialGroupUncheckedCreateWithoutChildrenInput>
  }

  export type MaterialGroupCreateWithoutParentInput = {
    name: string
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: MaterialGroupCreateNestedManyWithoutParentInput
    materials?: MaterialCreateNestedManyWithoutGroupInput
  }

  export type MaterialGroupUncheckedCreateWithoutParentInput = {
    id?: number
    name: string
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: MaterialGroupUncheckedCreateNestedManyWithoutParentInput
    materials?: MaterialUncheckedCreateNestedManyWithoutGroupInput
  }

  export type MaterialGroupCreateOrConnectWithoutParentInput = {
    where: MaterialGroupWhereUniqueInput
    create: XOR<MaterialGroupCreateWithoutParentInput, MaterialGroupUncheckedCreateWithoutParentInput>
  }

  export type MaterialGroupCreateManyParentInputEnvelope = {
    data: MaterialGroupCreateManyParentInput | MaterialGroupCreateManyParentInput[]
  }

  export type MaterialCreateWithoutGroupInput = {
    code?: string | null
    name: string
    unit?: string | null
    minStock?: Decimal | DecimalJsLike | number | string
    reorderQuantity?: Decimal | DecimalJsLike | number | string
    allowNegative?: boolean
    isCompanyAsset?: boolean
    assetStatus?: $Enums.AssetStatus
    assetResponsible?: string | null
    moves?: MoveCreateNestedManyWithoutMaterialInput
    expenses?: ExpenseCreateNestedManyWithoutMaterialInput
    baseQuotes?: QuotationBaselineItemCreateNestedManyWithoutMaterialInput
    quoteItems?: QuotationItemCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUncheckedCreateWithoutGroupInput = {
    id?: number
    code?: string | null
    name: string
    unit?: string | null
    minStock?: Decimal | DecimalJsLike | number | string
    reorderQuantity?: Decimal | DecimalJsLike | number | string
    allowNegative?: boolean
    isCompanyAsset?: boolean
    assetStatus?: $Enums.AssetStatus
    assetResponsible?: string | null
    moves?: MoveUncheckedCreateNestedManyWithoutMaterialInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutMaterialInput
    baseQuotes?: QuotationBaselineItemUncheckedCreateNestedManyWithoutMaterialInput
    quoteItems?: QuotationItemUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type MaterialCreateOrConnectWithoutGroupInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutGroupInput, MaterialUncheckedCreateWithoutGroupInput>
  }

  export type MaterialCreateManyGroupInputEnvelope = {
    data: MaterialCreateManyGroupInput | MaterialCreateManyGroupInput[]
  }

  export type MaterialGroupUpsertWithoutChildrenInput = {
    update: XOR<MaterialGroupUpdateWithoutChildrenInput, MaterialGroupUncheckedUpdateWithoutChildrenInput>
    create: XOR<MaterialGroupCreateWithoutChildrenInput, MaterialGroupUncheckedCreateWithoutChildrenInput>
    where?: MaterialGroupWhereInput
  }

  export type MaterialGroupUpdateToOneWithWhereWithoutChildrenInput = {
    where?: MaterialGroupWhereInput
    data: XOR<MaterialGroupUpdateWithoutChildrenInput, MaterialGroupUncheckedUpdateWithoutChildrenInput>
  }

  export type MaterialGroupUpdateWithoutChildrenInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: MaterialGroupUpdateOneWithoutChildrenNestedInput
    materials?: MaterialUpdateManyWithoutGroupNestedInput
  }

  export type MaterialGroupUncheckedUpdateWithoutChildrenInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materials?: MaterialUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type MaterialGroupUpsertWithWhereUniqueWithoutParentInput = {
    where: MaterialGroupWhereUniqueInput
    update: XOR<MaterialGroupUpdateWithoutParentInput, MaterialGroupUncheckedUpdateWithoutParentInput>
    create: XOR<MaterialGroupCreateWithoutParentInput, MaterialGroupUncheckedCreateWithoutParentInput>
  }

  export type MaterialGroupUpdateWithWhereUniqueWithoutParentInput = {
    where: MaterialGroupWhereUniqueInput
    data: XOR<MaterialGroupUpdateWithoutParentInput, MaterialGroupUncheckedUpdateWithoutParentInput>
  }

  export type MaterialGroupUpdateManyWithWhereWithoutParentInput = {
    where: MaterialGroupScalarWhereInput
    data: XOR<MaterialGroupUpdateManyMutationInput, MaterialGroupUncheckedUpdateManyWithoutParentInput>
  }

  export type MaterialGroupScalarWhereInput = {
    AND?: MaterialGroupScalarWhereInput | MaterialGroupScalarWhereInput[]
    OR?: MaterialGroupScalarWhereInput[]
    NOT?: MaterialGroupScalarWhereInput | MaterialGroupScalarWhereInput[]
    id?: IntFilter<"MaterialGroup"> | number
    name?: StringFilter<"MaterialGroup"> | string
    parentId?: IntNullableFilter<"MaterialGroup"> | number | null
    color?: StringNullableFilter<"MaterialGroup"> | string | null
    createdAt?: DateTimeFilter<"MaterialGroup"> | Date | string
    updatedAt?: DateTimeFilter<"MaterialGroup"> | Date | string
  }

  export type MaterialUpsertWithWhereUniqueWithoutGroupInput = {
    where: MaterialWhereUniqueInput
    update: XOR<MaterialUpdateWithoutGroupInput, MaterialUncheckedUpdateWithoutGroupInput>
    create: XOR<MaterialCreateWithoutGroupInput, MaterialUncheckedCreateWithoutGroupInput>
  }

  export type MaterialUpdateWithWhereUniqueWithoutGroupInput = {
    where: MaterialWhereUniqueInput
    data: XOR<MaterialUpdateWithoutGroupInput, MaterialUncheckedUpdateWithoutGroupInput>
  }

  export type MaterialUpdateManyWithWhereWithoutGroupInput = {
    where: MaterialScalarWhereInput
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyWithoutGroupInput>
  }

  export type MaterialScalarWhereInput = {
    AND?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
    OR?: MaterialScalarWhereInput[]
    NOT?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
    id?: IntFilter<"Material"> | number
    code?: StringNullableFilter<"Material"> | string | null
    name?: StringFilter<"Material"> | string
    unit?: StringNullableFilter<"Material"> | string | null
    groupId?: IntNullableFilter<"Material"> | number | null
    minStock?: DecimalFilter<"Material"> | Decimal | DecimalJsLike | number | string
    reorderQuantity?: DecimalFilter<"Material"> | Decimal | DecimalJsLike | number | string
    allowNegative?: BoolFilter<"Material"> | boolean
    isCompanyAsset?: BoolFilter<"Material"> | boolean
    assetStatus?: EnumAssetStatusFilter<"Material"> | $Enums.AssetStatus
    assetResponsible?: StringNullableFilter<"Material"> | string | null
  }

  export type ObraCreateWithoutMovesInput = {
    name: string
    code?: string | null
    frentes?: FrenteCreateNestedManyWithoutObraInput
    incomes?: IncomeCreateNestedManyWithoutObraInput
    expenses?: ExpenseCreateNestedManyWithoutObraInput
    employees?: EmployeeCreateNestedManyWithoutObraInput
    payrollPeriods?: PayrollPeriodCreateNestedManyWithoutObraInput
    dailyCashRenditions?: DailyCashRenditionCreateNestedManyWithoutObraInput
  }

  export type ObraUncheckedCreateWithoutMovesInput = {
    id?: number
    name: string
    code?: string | null
    frentes?: FrenteUncheckedCreateNestedManyWithoutObraInput
    incomes?: IncomeUncheckedCreateNestedManyWithoutObraInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutObraInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutObraInput
    payrollPeriods?: PayrollPeriodUncheckedCreateNestedManyWithoutObraInput
    dailyCashRenditions?: DailyCashRenditionUncheckedCreateNestedManyWithoutObraInput
  }

  export type ObraCreateOrConnectWithoutMovesInput = {
    where: ObraWhereUniqueInput
    create: XOR<ObraCreateWithoutMovesInput, ObraUncheckedCreateWithoutMovesInput>
  }

  export type FrenteCreateWithoutMovesInput = {
    name: string
    obra: ObraCreateNestedOneWithoutFrentesInput
    incomes?: IncomeCreateNestedManyWithoutFrenteInput
    expenses?: ExpenseCreateNestedManyWithoutFrenteInput
  }

  export type FrenteUncheckedCreateWithoutMovesInput = {
    id?: number
    name: string
    obraId: number
    incomes?: IncomeUncheckedCreateNestedManyWithoutFrenteInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutFrenteInput
  }

  export type FrenteCreateOrConnectWithoutMovesInput = {
    where: FrenteWhereUniqueInput
    create: XOR<FrenteCreateWithoutMovesInput, FrenteUncheckedCreateWithoutMovesInput>
  }

  export type MaterialCreateWithoutMovesInput = {
    code?: string | null
    name: string
    unit?: string | null
    minStock?: Decimal | DecimalJsLike | number | string
    reorderQuantity?: Decimal | DecimalJsLike | number | string
    allowNegative?: boolean
    isCompanyAsset?: boolean
    assetStatus?: $Enums.AssetStatus
    assetResponsible?: string | null
    group?: MaterialGroupCreateNestedOneWithoutMaterialsInput
    expenses?: ExpenseCreateNestedManyWithoutMaterialInput
    baseQuotes?: QuotationBaselineItemCreateNestedManyWithoutMaterialInput
    quoteItems?: QuotationItemCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUncheckedCreateWithoutMovesInput = {
    id?: number
    code?: string | null
    name: string
    unit?: string | null
    groupId?: number | null
    minStock?: Decimal | DecimalJsLike | number | string
    reorderQuantity?: Decimal | DecimalJsLike | number | string
    allowNegative?: boolean
    isCompanyAsset?: boolean
    assetStatus?: $Enums.AssetStatus
    assetResponsible?: string | null
    expenses?: ExpenseUncheckedCreateNestedManyWithoutMaterialInput
    baseQuotes?: QuotationBaselineItemUncheckedCreateNestedManyWithoutMaterialInput
    quoteItems?: QuotationItemUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type MaterialCreateOrConnectWithoutMovesInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutMovesInput, MaterialUncheckedCreateWithoutMovesInput>
  }

  export type ProveedorCreateWithoutMovesInput = {
    name: string
    ruc?: string | null
    phone?: string | null
    expenses?: ExpenseCreateNestedManyWithoutProveedorInput
    quotations?: QuotationCreateNestedManyWithoutProveedorInput
    deliveries?: PurchaseDeliveryLogCreateNestedManyWithoutProveedorInput
  }

  export type ProveedorUncheckedCreateWithoutMovesInput = {
    id?: number
    name: string
    ruc?: string | null
    phone?: string | null
    expenses?: ExpenseUncheckedCreateNestedManyWithoutProveedorInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutProveedorInput
    deliveries?: PurchaseDeliveryLogUncheckedCreateNestedManyWithoutProveedorInput
  }

  export type ProveedorCreateOrConnectWithoutMovesInput = {
    where: ProveedorWhereUniqueInput
    create: XOR<ProveedorCreateWithoutMovesInput, ProveedorUncheckedCreateWithoutMovesInput>
  }

  export type ExpenseCreateWithoutMoveInput = {
    docType?: $Enums.DocType
    docSerie?: string | null
    docNumero?: string | null
    date?: Date | string
    description?: string | null
    spentBy?: string | null
    type?: $Enums.ExpenseType
    variableType?: $Enums.VariableType
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
    igvRate?: Decimal | DecimalJsLike | number | string
    isTaxable?: boolean
    base: Decimal | DecimalJsLike | number | string
    igv: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paymentMethod?: $Enums.PaymentMethod
    paidAt?: Date | string | null
    status?: string
    reminderIntervalDays?: number | null
    reminderNextDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    obra: ObraCreateNestedOneWithoutExpensesInput
    frente?: FrenteCreateNestedOneWithoutExpensesInput
    proveedor?: ProveedorCreateNestedOneWithoutExpensesInput
    material?: MaterialCreateNestedOneWithoutExpensesInput
    category?: ExpenseCategoryCreateNestedOneWithoutExpensesInput
  }

  export type ExpenseUncheckedCreateWithoutMoveInput = {
    id?: number
    obraId: number
    frenteId?: number | null
    proveedorId?: number | null
    materialId?: number | null
    categoryId?: number | null
    docType?: $Enums.DocType
    docSerie?: string | null
    docNumero?: string | null
    date?: Date | string
    description?: string | null
    spentBy?: string | null
    type?: $Enums.ExpenseType
    variableType?: $Enums.VariableType
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
    igvRate?: Decimal | DecimalJsLike | number | string
    isTaxable?: boolean
    base: Decimal | DecimalJsLike | number | string
    igv: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paymentMethod?: $Enums.PaymentMethod
    paidAt?: Date | string | null
    status?: string
    reminderIntervalDays?: number | null
    reminderNextDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCreateOrConnectWithoutMoveInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutMoveInput, ExpenseUncheckedCreateWithoutMoveInput>
  }

  export type ObraUpsertWithoutMovesInput = {
    update: XOR<ObraUpdateWithoutMovesInput, ObraUncheckedUpdateWithoutMovesInput>
    create: XOR<ObraCreateWithoutMovesInput, ObraUncheckedCreateWithoutMovesInput>
    where?: ObraWhereInput
  }

  export type ObraUpdateToOneWithWhereWithoutMovesInput = {
    where?: ObraWhereInput
    data: XOR<ObraUpdateWithoutMovesInput, ObraUncheckedUpdateWithoutMovesInput>
  }

  export type ObraUpdateWithoutMovesInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    frentes?: FrenteUpdateManyWithoutObraNestedInput
    incomes?: IncomeUpdateManyWithoutObraNestedInput
    expenses?: ExpenseUpdateManyWithoutObraNestedInput
    employees?: EmployeeUpdateManyWithoutObraNestedInput
    payrollPeriods?: PayrollPeriodUpdateManyWithoutObraNestedInput
    dailyCashRenditions?: DailyCashRenditionUpdateManyWithoutObraNestedInput
  }

  export type ObraUncheckedUpdateWithoutMovesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    frentes?: FrenteUncheckedUpdateManyWithoutObraNestedInput
    incomes?: IncomeUncheckedUpdateManyWithoutObraNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutObraNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutObraNestedInput
    payrollPeriods?: PayrollPeriodUncheckedUpdateManyWithoutObraNestedInput
    dailyCashRenditions?: DailyCashRenditionUncheckedUpdateManyWithoutObraNestedInput
  }

  export type FrenteUpsertWithoutMovesInput = {
    update: XOR<FrenteUpdateWithoutMovesInput, FrenteUncheckedUpdateWithoutMovesInput>
    create: XOR<FrenteCreateWithoutMovesInput, FrenteUncheckedCreateWithoutMovesInput>
    where?: FrenteWhereInput
  }

  export type FrenteUpdateToOneWithWhereWithoutMovesInput = {
    where?: FrenteWhereInput
    data: XOR<FrenteUpdateWithoutMovesInput, FrenteUncheckedUpdateWithoutMovesInput>
  }

  export type FrenteUpdateWithoutMovesInput = {
    name?: StringFieldUpdateOperationsInput | string
    obra?: ObraUpdateOneRequiredWithoutFrentesNestedInput
    incomes?: IncomeUpdateManyWithoutFrenteNestedInput
    expenses?: ExpenseUpdateManyWithoutFrenteNestedInput
  }

  export type FrenteUncheckedUpdateWithoutMovesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    obraId?: IntFieldUpdateOperationsInput | number
    incomes?: IncomeUncheckedUpdateManyWithoutFrenteNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutFrenteNestedInput
  }

  export type MaterialUpsertWithoutMovesInput = {
    update: XOR<MaterialUpdateWithoutMovesInput, MaterialUncheckedUpdateWithoutMovesInput>
    create: XOR<MaterialCreateWithoutMovesInput, MaterialUncheckedCreateWithoutMovesInput>
    where?: MaterialWhereInput
  }

  export type MaterialUpdateToOneWithWhereWithoutMovesInput = {
    where?: MaterialWhereInput
    data: XOR<MaterialUpdateWithoutMovesInput, MaterialUncheckedUpdateWithoutMovesInput>
  }

  export type MaterialUpdateWithoutMovesInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowNegative?: BoolFieldUpdateOperationsInput | boolean
    isCompanyAsset?: BoolFieldUpdateOperationsInput | boolean
    assetStatus?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    assetResponsible?: NullableStringFieldUpdateOperationsInput | string | null
    group?: MaterialGroupUpdateOneWithoutMaterialsNestedInput
    expenses?: ExpenseUpdateManyWithoutMaterialNestedInput
    baseQuotes?: QuotationBaselineItemUpdateManyWithoutMaterialNestedInput
    quoteItems?: QuotationItemUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateWithoutMovesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: NullableIntFieldUpdateOperationsInput | number | null
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowNegative?: BoolFieldUpdateOperationsInput | boolean
    isCompanyAsset?: BoolFieldUpdateOperationsInput | boolean
    assetStatus?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    assetResponsible?: NullableStringFieldUpdateOperationsInput | string | null
    expenses?: ExpenseUncheckedUpdateManyWithoutMaterialNestedInput
    baseQuotes?: QuotationBaselineItemUncheckedUpdateManyWithoutMaterialNestedInput
    quoteItems?: QuotationItemUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type ProveedorUpsertWithoutMovesInput = {
    update: XOR<ProveedorUpdateWithoutMovesInput, ProveedorUncheckedUpdateWithoutMovesInput>
    create: XOR<ProveedorCreateWithoutMovesInput, ProveedorUncheckedCreateWithoutMovesInput>
    where?: ProveedorWhereInput
  }

  export type ProveedorUpdateToOneWithWhereWithoutMovesInput = {
    where?: ProveedorWhereInput
    data: XOR<ProveedorUpdateWithoutMovesInput, ProveedorUncheckedUpdateWithoutMovesInput>
  }

  export type ProveedorUpdateWithoutMovesInput = {
    name?: StringFieldUpdateOperationsInput | string
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    expenses?: ExpenseUpdateManyWithoutProveedorNestedInput
    quotations?: QuotationUpdateManyWithoutProveedorNestedInput
    deliveries?: PurchaseDeliveryLogUpdateManyWithoutProveedorNestedInput
  }

  export type ProveedorUncheckedUpdateWithoutMovesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    expenses?: ExpenseUncheckedUpdateManyWithoutProveedorNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutProveedorNestedInput
    deliveries?: PurchaseDeliveryLogUncheckedUpdateManyWithoutProveedorNestedInput
  }

  export type ExpenseUpsertWithoutMoveInput = {
    update: XOR<ExpenseUpdateWithoutMoveInput, ExpenseUncheckedUpdateWithoutMoveInput>
    create: XOR<ExpenseCreateWithoutMoveInput, ExpenseUncheckedCreateWithoutMoveInput>
    where?: ExpenseWhereInput
  }

  export type ExpenseUpdateToOneWithWhereWithoutMoveInput = {
    where?: ExpenseWhereInput
    data: XOR<ExpenseUpdateWithoutMoveInput, ExpenseUncheckedUpdateWithoutMoveInput>
  }

  export type ExpenseUpdateWithoutMoveInput = {
    docType?: EnumDocTypeFieldUpdateOperationsInput | $Enums.DocType
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    spentBy?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExpenseTypeFieldUpdateOperationsInput | $Enums.ExpenseType
    variableType?: EnumVariableTypeFieldUpdateOperationsInput | $Enums.VariableType
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    igvRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    base?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    igv?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    reminderIntervalDays?: NullableIntFieldUpdateOperationsInput | number | null
    reminderNextDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    obra?: ObraUpdateOneRequiredWithoutExpensesNestedInput
    frente?: FrenteUpdateOneWithoutExpensesNestedInput
    proveedor?: ProveedorUpdateOneWithoutExpensesNestedInput
    material?: MaterialUpdateOneWithoutExpensesNestedInput
    category?: ExpenseCategoryUpdateOneWithoutExpensesNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutMoveInput = {
    id?: IntFieldUpdateOperationsInput | number
    obraId?: IntFieldUpdateOperationsInput | number
    frenteId?: NullableIntFieldUpdateOperationsInput | number | null
    proveedorId?: NullableIntFieldUpdateOperationsInput | number | null
    materialId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    docType?: EnumDocTypeFieldUpdateOperationsInput | $Enums.DocType
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    spentBy?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExpenseTypeFieldUpdateOperationsInput | $Enums.ExpenseType
    variableType?: EnumVariableTypeFieldUpdateOperationsInput | $Enums.VariableType
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    igvRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    base?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    igv?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    reminderIntervalDays?: NullableIntFieldUpdateOperationsInput | number | null
    reminderNextDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCreateWithoutCategoryInput = {
    docType?: $Enums.DocType
    docSerie?: string | null
    docNumero?: string | null
    date?: Date | string
    description?: string | null
    spentBy?: string | null
    type?: $Enums.ExpenseType
    variableType?: $Enums.VariableType
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
    igvRate?: Decimal | DecimalJsLike | number | string
    isTaxable?: boolean
    base: Decimal | DecimalJsLike | number | string
    igv: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paymentMethod?: $Enums.PaymentMethod
    paidAt?: Date | string | null
    status?: string
    reminderIntervalDays?: number | null
    reminderNextDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    obra: ObraCreateNestedOneWithoutExpensesInput
    frente?: FrenteCreateNestedOneWithoutExpensesInput
    proveedor?: ProveedorCreateNestedOneWithoutExpensesInput
    material?: MaterialCreateNestedOneWithoutExpensesInput
    move?: MoveCreateNestedOneWithoutExpenseInput
  }

  export type ExpenseUncheckedCreateWithoutCategoryInput = {
    id?: number
    obraId: number
    frenteId?: number | null
    proveedorId?: number | null
    materialId?: number | null
    moveId?: number | null
    docType?: $Enums.DocType
    docSerie?: string | null
    docNumero?: string | null
    date?: Date | string
    description?: string | null
    spentBy?: string | null
    type?: $Enums.ExpenseType
    variableType?: $Enums.VariableType
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
    igvRate?: Decimal | DecimalJsLike | number | string
    isTaxable?: boolean
    base: Decimal | DecimalJsLike | number | string
    igv: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paymentMethod?: $Enums.PaymentMethod
    paidAt?: Date | string | null
    status?: string
    reminderIntervalDays?: number | null
    reminderNextDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCreateOrConnectWithoutCategoryInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutCategoryInput, ExpenseUncheckedCreateWithoutCategoryInput>
  }

  export type ExpenseCreateManyCategoryInputEnvelope = {
    data: ExpenseCreateManyCategoryInput | ExpenseCreateManyCategoryInput[]
  }

  export type ExpenseUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutCategoryInput, ExpenseUncheckedUpdateWithoutCategoryInput>
    create: XOR<ExpenseCreateWithoutCategoryInput, ExpenseUncheckedCreateWithoutCategoryInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutCategoryInput, ExpenseUncheckedUpdateWithoutCategoryInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutCategoryInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ObraCreateWithoutIncomesInput = {
    name: string
    code?: string | null
    frentes?: FrenteCreateNestedManyWithoutObraInput
    moves?: MoveCreateNestedManyWithoutObraInput
    expenses?: ExpenseCreateNestedManyWithoutObraInput
    employees?: EmployeeCreateNestedManyWithoutObraInput
    payrollPeriods?: PayrollPeriodCreateNestedManyWithoutObraInput
    dailyCashRenditions?: DailyCashRenditionCreateNestedManyWithoutObraInput
  }

  export type ObraUncheckedCreateWithoutIncomesInput = {
    id?: number
    name: string
    code?: string | null
    frentes?: FrenteUncheckedCreateNestedManyWithoutObraInput
    moves?: MoveUncheckedCreateNestedManyWithoutObraInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutObraInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutObraInput
    payrollPeriods?: PayrollPeriodUncheckedCreateNestedManyWithoutObraInput
    dailyCashRenditions?: DailyCashRenditionUncheckedCreateNestedManyWithoutObraInput
  }

  export type ObraCreateOrConnectWithoutIncomesInput = {
    where: ObraWhereUniqueInput
    create: XOR<ObraCreateWithoutIncomesInput, ObraUncheckedCreateWithoutIncomesInput>
  }

  export type FrenteCreateWithoutIncomesInput = {
    name: string
    obra: ObraCreateNestedOneWithoutFrentesInput
    moves?: MoveCreateNestedManyWithoutFrenteInput
    expenses?: ExpenseCreateNestedManyWithoutFrenteInput
  }

  export type FrenteUncheckedCreateWithoutIncomesInput = {
    id?: number
    name: string
    obraId: number
    moves?: MoveUncheckedCreateNestedManyWithoutFrenteInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutFrenteInput
  }

  export type FrenteCreateOrConnectWithoutIncomesInput = {
    where: FrenteWhereUniqueInput
    create: XOR<FrenteCreateWithoutIncomesInput, FrenteUncheckedCreateWithoutIncomesInput>
  }

  export type ObraUpsertWithoutIncomesInput = {
    update: XOR<ObraUpdateWithoutIncomesInput, ObraUncheckedUpdateWithoutIncomesInput>
    create: XOR<ObraCreateWithoutIncomesInput, ObraUncheckedCreateWithoutIncomesInput>
    where?: ObraWhereInput
  }

  export type ObraUpdateToOneWithWhereWithoutIncomesInput = {
    where?: ObraWhereInput
    data: XOR<ObraUpdateWithoutIncomesInput, ObraUncheckedUpdateWithoutIncomesInput>
  }

  export type ObraUpdateWithoutIncomesInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    frentes?: FrenteUpdateManyWithoutObraNestedInput
    moves?: MoveUpdateManyWithoutObraNestedInput
    expenses?: ExpenseUpdateManyWithoutObraNestedInput
    employees?: EmployeeUpdateManyWithoutObraNestedInput
    payrollPeriods?: PayrollPeriodUpdateManyWithoutObraNestedInput
    dailyCashRenditions?: DailyCashRenditionUpdateManyWithoutObraNestedInput
  }

  export type ObraUncheckedUpdateWithoutIncomesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    frentes?: FrenteUncheckedUpdateManyWithoutObraNestedInput
    moves?: MoveUncheckedUpdateManyWithoutObraNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutObraNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutObraNestedInput
    payrollPeriods?: PayrollPeriodUncheckedUpdateManyWithoutObraNestedInput
    dailyCashRenditions?: DailyCashRenditionUncheckedUpdateManyWithoutObraNestedInput
  }

  export type FrenteUpsertWithoutIncomesInput = {
    update: XOR<FrenteUpdateWithoutIncomesInput, FrenteUncheckedUpdateWithoutIncomesInput>
    create: XOR<FrenteCreateWithoutIncomesInput, FrenteUncheckedCreateWithoutIncomesInput>
    where?: FrenteWhereInput
  }

  export type FrenteUpdateToOneWithWhereWithoutIncomesInput = {
    where?: FrenteWhereInput
    data: XOR<FrenteUpdateWithoutIncomesInput, FrenteUncheckedUpdateWithoutIncomesInput>
  }

  export type FrenteUpdateWithoutIncomesInput = {
    name?: StringFieldUpdateOperationsInput | string
    obra?: ObraUpdateOneRequiredWithoutFrentesNestedInput
    moves?: MoveUpdateManyWithoutFrenteNestedInput
    expenses?: ExpenseUpdateManyWithoutFrenteNestedInput
  }

  export type FrenteUncheckedUpdateWithoutIncomesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    obraId?: IntFieldUpdateOperationsInput | number
    moves?: MoveUncheckedUpdateManyWithoutFrenteNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutFrenteNestedInput
  }

  export type ObraCreateWithoutExpensesInput = {
    name: string
    code?: string | null
    frentes?: FrenteCreateNestedManyWithoutObraInput
    moves?: MoveCreateNestedManyWithoutObraInput
    incomes?: IncomeCreateNestedManyWithoutObraInput
    employees?: EmployeeCreateNestedManyWithoutObraInput
    payrollPeriods?: PayrollPeriodCreateNestedManyWithoutObraInput
    dailyCashRenditions?: DailyCashRenditionCreateNestedManyWithoutObraInput
  }

  export type ObraUncheckedCreateWithoutExpensesInput = {
    id?: number
    name: string
    code?: string | null
    frentes?: FrenteUncheckedCreateNestedManyWithoutObraInput
    moves?: MoveUncheckedCreateNestedManyWithoutObraInput
    incomes?: IncomeUncheckedCreateNestedManyWithoutObraInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutObraInput
    payrollPeriods?: PayrollPeriodUncheckedCreateNestedManyWithoutObraInput
    dailyCashRenditions?: DailyCashRenditionUncheckedCreateNestedManyWithoutObraInput
  }

  export type ObraCreateOrConnectWithoutExpensesInput = {
    where: ObraWhereUniqueInput
    create: XOR<ObraCreateWithoutExpensesInput, ObraUncheckedCreateWithoutExpensesInput>
  }

  export type FrenteCreateWithoutExpensesInput = {
    name: string
    obra: ObraCreateNestedOneWithoutFrentesInput
    moves?: MoveCreateNestedManyWithoutFrenteInput
    incomes?: IncomeCreateNestedManyWithoutFrenteInput
  }

  export type FrenteUncheckedCreateWithoutExpensesInput = {
    id?: number
    name: string
    obraId: number
    moves?: MoveUncheckedCreateNestedManyWithoutFrenteInput
    incomes?: IncomeUncheckedCreateNestedManyWithoutFrenteInput
  }

  export type FrenteCreateOrConnectWithoutExpensesInput = {
    where: FrenteWhereUniqueInput
    create: XOR<FrenteCreateWithoutExpensesInput, FrenteUncheckedCreateWithoutExpensesInput>
  }

  export type ProveedorCreateWithoutExpensesInput = {
    name: string
    ruc?: string | null
    phone?: string | null
    moves?: MoveCreateNestedManyWithoutProveedorInput
    quotations?: QuotationCreateNestedManyWithoutProveedorInput
    deliveries?: PurchaseDeliveryLogCreateNestedManyWithoutProveedorInput
  }

  export type ProveedorUncheckedCreateWithoutExpensesInput = {
    id?: number
    name: string
    ruc?: string | null
    phone?: string | null
    moves?: MoveUncheckedCreateNestedManyWithoutProveedorInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutProveedorInput
    deliveries?: PurchaseDeliveryLogUncheckedCreateNestedManyWithoutProveedorInput
  }

  export type ProveedorCreateOrConnectWithoutExpensesInput = {
    where: ProveedorWhereUniqueInput
    create: XOR<ProveedorCreateWithoutExpensesInput, ProveedorUncheckedCreateWithoutExpensesInput>
  }

  export type MaterialCreateWithoutExpensesInput = {
    code?: string | null
    name: string
    unit?: string | null
    minStock?: Decimal | DecimalJsLike | number | string
    reorderQuantity?: Decimal | DecimalJsLike | number | string
    allowNegative?: boolean
    isCompanyAsset?: boolean
    assetStatus?: $Enums.AssetStatus
    assetResponsible?: string | null
    group?: MaterialGroupCreateNestedOneWithoutMaterialsInput
    moves?: MoveCreateNestedManyWithoutMaterialInput
    baseQuotes?: QuotationBaselineItemCreateNestedManyWithoutMaterialInput
    quoteItems?: QuotationItemCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUncheckedCreateWithoutExpensesInput = {
    id?: number
    code?: string | null
    name: string
    unit?: string | null
    groupId?: number | null
    minStock?: Decimal | DecimalJsLike | number | string
    reorderQuantity?: Decimal | DecimalJsLike | number | string
    allowNegative?: boolean
    isCompanyAsset?: boolean
    assetStatus?: $Enums.AssetStatus
    assetResponsible?: string | null
    moves?: MoveUncheckedCreateNestedManyWithoutMaterialInput
    baseQuotes?: QuotationBaselineItemUncheckedCreateNestedManyWithoutMaterialInput
    quoteItems?: QuotationItemUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type MaterialCreateOrConnectWithoutExpensesInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutExpensesInput, MaterialUncheckedCreateWithoutExpensesInput>
  }

  export type ExpenseCategoryCreateWithoutExpensesInput = {
    name: string
    createdAt?: Date | string
    kind?: $Enums.ExpenseKind
  }

  export type ExpenseCategoryUncheckedCreateWithoutExpensesInput = {
    id?: number
    name: string
    createdAt?: Date | string
    kind?: $Enums.ExpenseKind
  }

  export type ExpenseCategoryCreateOrConnectWithoutExpensesInput = {
    where: ExpenseCategoryWhereUniqueInput
    create: XOR<ExpenseCategoryCreateWithoutExpensesInput, ExpenseCategoryUncheckedCreateWithoutExpensesInput>
  }

  export type MoveCreateWithoutExpenseInput = {
    type: $Enums.MoveType
    quantity: number
    unitCost?: number | null
    totalCost?: number | null
    date?: Date | string
    note?: string | null
    docType?: $Enums.DocType | null
    docSerie?: string | null
    docNumero?: string | null
    igvRate?: Decimal | DecimalJsLike | number | string | null
    isTaxable?: boolean | null
    responsible?: string | null
    assetStatus?: $Enums.AssetStatus | null
    obra: ObraCreateNestedOneWithoutMovesInput
    frente?: FrenteCreateNestedOneWithoutMovesInput
    material: MaterialCreateNestedOneWithoutMovesInput
    proveedor?: ProveedorCreateNestedOneWithoutMovesInput
  }

  export type MoveUncheckedCreateWithoutExpenseInput = {
    id?: number
    obraId: number
    frenteId?: number | null
    materialId: number
    proveedorId?: number | null
    type: $Enums.MoveType
    quantity: number
    unitCost?: number | null
    totalCost?: number | null
    date?: Date | string
    note?: string | null
    docType?: $Enums.DocType | null
    docSerie?: string | null
    docNumero?: string | null
    igvRate?: Decimal | DecimalJsLike | number | string | null
    isTaxable?: boolean | null
    responsible?: string | null
    assetStatus?: $Enums.AssetStatus | null
  }

  export type MoveCreateOrConnectWithoutExpenseInput = {
    where: MoveWhereUniqueInput
    create: XOR<MoveCreateWithoutExpenseInput, MoveUncheckedCreateWithoutExpenseInput>
  }

  export type ObraUpsertWithoutExpensesInput = {
    update: XOR<ObraUpdateWithoutExpensesInput, ObraUncheckedUpdateWithoutExpensesInput>
    create: XOR<ObraCreateWithoutExpensesInput, ObraUncheckedCreateWithoutExpensesInput>
    where?: ObraWhereInput
  }

  export type ObraUpdateToOneWithWhereWithoutExpensesInput = {
    where?: ObraWhereInput
    data: XOR<ObraUpdateWithoutExpensesInput, ObraUncheckedUpdateWithoutExpensesInput>
  }

  export type ObraUpdateWithoutExpensesInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    frentes?: FrenteUpdateManyWithoutObraNestedInput
    moves?: MoveUpdateManyWithoutObraNestedInput
    incomes?: IncomeUpdateManyWithoutObraNestedInput
    employees?: EmployeeUpdateManyWithoutObraNestedInput
    payrollPeriods?: PayrollPeriodUpdateManyWithoutObraNestedInput
    dailyCashRenditions?: DailyCashRenditionUpdateManyWithoutObraNestedInput
  }

  export type ObraUncheckedUpdateWithoutExpensesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    frentes?: FrenteUncheckedUpdateManyWithoutObraNestedInput
    moves?: MoveUncheckedUpdateManyWithoutObraNestedInput
    incomes?: IncomeUncheckedUpdateManyWithoutObraNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutObraNestedInput
    payrollPeriods?: PayrollPeriodUncheckedUpdateManyWithoutObraNestedInput
    dailyCashRenditions?: DailyCashRenditionUncheckedUpdateManyWithoutObraNestedInput
  }

  export type FrenteUpsertWithoutExpensesInput = {
    update: XOR<FrenteUpdateWithoutExpensesInput, FrenteUncheckedUpdateWithoutExpensesInput>
    create: XOR<FrenteCreateWithoutExpensesInput, FrenteUncheckedCreateWithoutExpensesInput>
    where?: FrenteWhereInput
  }

  export type FrenteUpdateToOneWithWhereWithoutExpensesInput = {
    where?: FrenteWhereInput
    data: XOR<FrenteUpdateWithoutExpensesInput, FrenteUncheckedUpdateWithoutExpensesInput>
  }

  export type FrenteUpdateWithoutExpensesInput = {
    name?: StringFieldUpdateOperationsInput | string
    obra?: ObraUpdateOneRequiredWithoutFrentesNestedInput
    moves?: MoveUpdateManyWithoutFrenteNestedInput
    incomes?: IncomeUpdateManyWithoutFrenteNestedInput
  }

  export type FrenteUncheckedUpdateWithoutExpensesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    obraId?: IntFieldUpdateOperationsInput | number
    moves?: MoveUncheckedUpdateManyWithoutFrenteNestedInput
    incomes?: IncomeUncheckedUpdateManyWithoutFrenteNestedInput
  }

  export type ProveedorUpsertWithoutExpensesInput = {
    update: XOR<ProveedorUpdateWithoutExpensesInput, ProveedorUncheckedUpdateWithoutExpensesInput>
    create: XOR<ProveedorCreateWithoutExpensesInput, ProveedorUncheckedCreateWithoutExpensesInput>
    where?: ProveedorWhereInput
  }

  export type ProveedorUpdateToOneWithWhereWithoutExpensesInput = {
    where?: ProveedorWhereInput
    data: XOR<ProveedorUpdateWithoutExpensesInput, ProveedorUncheckedUpdateWithoutExpensesInput>
  }

  export type ProveedorUpdateWithoutExpensesInput = {
    name?: StringFieldUpdateOperationsInput | string
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    moves?: MoveUpdateManyWithoutProveedorNestedInput
    quotations?: QuotationUpdateManyWithoutProveedorNestedInput
    deliveries?: PurchaseDeliveryLogUpdateManyWithoutProveedorNestedInput
  }

  export type ProveedorUncheckedUpdateWithoutExpensesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    moves?: MoveUncheckedUpdateManyWithoutProveedorNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutProveedorNestedInput
    deliveries?: PurchaseDeliveryLogUncheckedUpdateManyWithoutProveedorNestedInput
  }

  export type MaterialUpsertWithoutExpensesInput = {
    update: XOR<MaterialUpdateWithoutExpensesInput, MaterialUncheckedUpdateWithoutExpensesInput>
    create: XOR<MaterialCreateWithoutExpensesInput, MaterialUncheckedCreateWithoutExpensesInput>
    where?: MaterialWhereInput
  }

  export type MaterialUpdateToOneWithWhereWithoutExpensesInput = {
    where?: MaterialWhereInput
    data: XOR<MaterialUpdateWithoutExpensesInput, MaterialUncheckedUpdateWithoutExpensesInput>
  }

  export type MaterialUpdateWithoutExpensesInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowNegative?: BoolFieldUpdateOperationsInput | boolean
    isCompanyAsset?: BoolFieldUpdateOperationsInput | boolean
    assetStatus?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    assetResponsible?: NullableStringFieldUpdateOperationsInput | string | null
    group?: MaterialGroupUpdateOneWithoutMaterialsNestedInput
    moves?: MoveUpdateManyWithoutMaterialNestedInput
    baseQuotes?: QuotationBaselineItemUpdateManyWithoutMaterialNestedInput
    quoteItems?: QuotationItemUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateWithoutExpensesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: NullableIntFieldUpdateOperationsInput | number | null
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowNegative?: BoolFieldUpdateOperationsInput | boolean
    isCompanyAsset?: BoolFieldUpdateOperationsInput | boolean
    assetStatus?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    assetResponsible?: NullableStringFieldUpdateOperationsInput | string | null
    moves?: MoveUncheckedUpdateManyWithoutMaterialNestedInput
    baseQuotes?: QuotationBaselineItemUncheckedUpdateManyWithoutMaterialNestedInput
    quoteItems?: QuotationItemUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type ExpenseCategoryUpsertWithoutExpensesInput = {
    update: XOR<ExpenseCategoryUpdateWithoutExpensesInput, ExpenseCategoryUncheckedUpdateWithoutExpensesInput>
    create: XOR<ExpenseCategoryCreateWithoutExpensesInput, ExpenseCategoryUncheckedCreateWithoutExpensesInput>
    where?: ExpenseCategoryWhereInput
  }

  export type ExpenseCategoryUpdateToOneWithWhereWithoutExpensesInput = {
    where?: ExpenseCategoryWhereInput
    data: XOR<ExpenseCategoryUpdateWithoutExpensesInput, ExpenseCategoryUncheckedUpdateWithoutExpensesInput>
  }

  export type ExpenseCategoryUpdateWithoutExpensesInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kind?: EnumExpenseKindFieldUpdateOperationsInput | $Enums.ExpenseKind
  }

  export type ExpenseCategoryUncheckedUpdateWithoutExpensesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kind?: EnumExpenseKindFieldUpdateOperationsInput | $Enums.ExpenseKind
  }

  export type MoveUpsertWithoutExpenseInput = {
    update: XOR<MoveUpdateWithoutExpenseInput, MoveUncheckedUpdateWithoutExpenseInput>
    create: XOR<MoveCreateWithoutExpenseInput, MoveUncheckedCreateWithoutExpenseInput>
    where?: MoveWhereInput
  }

  export type MoveUpdateToOneWithWhereWithoutExpenseInput = {
    where?: MoveWhereInput
    data: XOR<MoveUpdateWithoutExpenseInput, MoveUncheckedUpdateWithoutExpenseInput>
  }

  export type MoveUpdateWithoutExpenseInput = {
    type?: EnumMoveTypeFieldUpdateOperationsInput | $Enums.MoveType
    quantity?: FloatFieldUpdateOperationsInput | number
    unitCost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableEnumDocTypeFieldUpdateOperationsInput | $Enums.DocType | null
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    igvRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isTaxable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    responsible?: NullableStringFieldUpdateOperationsInput | string | null
    assetStatus?: NullableEnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus | null
    obra?: ObraUpdateOneRequiredWithoutMovesNestedInput
    frente?: FrenteUpdateOneWithoutMovesNestedInput
    material?: MaterialUpdateOneRequiredWithoutMovesNestedInput
    proveedor?: ProveedorUpdateOneWithoutMovesNestedInput
  }

  export type MoveUncheckedUpdateWithoutExpenseInput = {
    id?: IntFieldUpdateOperationsInput | number
    obraId?: IntFieldUpdateOperationsInput | number
    frenteId?: NullableIntFieldUpdateOperationsInput | number | null
    materialId?: IntFieldUpdateOperationsInput | number
    proveedorId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumMoveTypeFieldUpdateOperationsInput | $Enums.MoveType
    quantity?: FloatFieldUpdateOperationsInput | number
    unitCost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableEnumDocTypeFieldUpdateOperationsInput | $Enums.DocType | null
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    igvRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isTaxable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    responsible?: NullableStringFieldUpdateOperationsInput | string | null
    assetStatus?: NullableEnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus | null
  }

  export type ObraCreateWithoutDailyCashRenditionsInput = {
    name: string
    code?: string | null
    frentes?: FrenteCreateNestedManyWithoutObraInput
    moves?: MoveCreateNestedManyWithoutObraInput
    incomes?: IncomeCreateNestedManyWithoutObraInput
    expenses?: ExpenseCreateNestedManyWithoutObraInput
    employees?: EmployeeCreateNestedManyWithoutObraInput
    payrollPeriods?: PayrollPeriodCreateNestedManyWithoutObraInput
  }

  export type ObraUncheckedCreateWithoutDailyCashRenditionsInput = {
    id?: number
    name: string
    code?: string | null
    frentes?: FrenteUncheckedCreateNestedManyWithoutObraInput
    moves?: MoveUncheckedCreateNestedManyWithoutObraInput
    incomes?: IncomeUncheckedCreateNestedManyWithoutObraInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutObraInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutObraInput
    payrollPeriods?: PayrollPeriodUncheckedCreateNestedManyWithoutObraInput
  }

  export type ObraCreateOrConnectWithoutDailyCashRenditionsInput = {
    where: ObraWhereUniqueInput
    create: XOR<ObraCreateWithoutDailyCashRenditionsInput, ObraUncheckedCreateWithoutDailyCashRenditionsInput>
  }

  export type DailyCashExpenseCreateWithoutRenditionInput = {
    description: string
    amount: Decimal | DecimalJsLike | number | string
    personalAmount?: Decimal | DecimalJsLike | number | string
    paidWithPersonal?: boolean
    createdAt?: Date | string
  }

  export type DailyCashExpenseUncheckedCreateWithoutRenditionInput = {
    id?: number
    description: string
    amount: Decimal | DecimalJsLike | number | string
    personalAmount?: Decimal | DecimalJsLike | number | string
    paidWithPersonal?: boolean
    createdAt?: Date | string
  }

  export type DailyCashExpenseCreateOrConnectWithoutRenditionInput = {
    where: DailyCashExpenseWhereUniqueInput
    create: XOR<DailyCashExpenseCreateWithoutRenditionInput, DailyCashExpenseUncheckedCreateWithoutRenditionInput>
  }

  export type DailyCashExpenseCreateManyRenditionInputEnvelope = {
    data: DailyCashExpenseCreateManyRenditionInput | DailyCashExpenseCreateManyRenditionInput[]
  }

  export type ObraUpsertWithoutDailyCashRenditionsInput = {
    update: XOR<ObraUpdateWithoutDailyCashRenditionsInput, ObraUncheckedUpdateWithoutDailyCashRenditionsInput>
    create: XOR<ObraCreateWithoutDailyCashRenditionsInput, ObraUncheckedCreateWithoutDailyCashRenditionsInput>
    where?: ObraWhereInput
  }

  export type ObraUpdateToOneWithWhereWithoutDailyCashRenditionsInput = {
    where?: ObraWhereInput
    data: XOR<ObraUpdateWithoutDailyCashRenditionsInput, ObraUncheckedUpdateWithoutDailyCashRenditionsInput>
  }

  export type ObraUpdateWithoutDailyCashRenditionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    frentes?: FrenteUpdateManyWithoutObraNestedInput
    moves?: MoveUpdateManyWithoutObraNestedInput
    incomes?: IncomeUpdateManyWithoutObraNestedInput
    expenses?: ExpenseUpdateManyWithoutObraNestedInput
    employees?: EmployeeUpdateManyWithoutObraNestedInput
    payrollPeriods?: PayrollPeriodUpdateManyWithoutObraNestedInput
  }

  export type ObraUncheckedUpdateWithoutDailyCashRenditionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    frentes?: FrenteUncheckedUpdateManyWithoutObraNestedInput
    moves?: MoveUncheckedUpdateManyWithoutObraNestedInput
    incomes?: IncomeUncheckedUpdateManyWithoutObraNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutObraNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutObraNestedInput
    payrollPeriods?: PayrollPeriodUncheckedUpdateManyWithoutObraNestedInput
  }

  export type DailyCashExpenseUpsertWithWhereUniqueWithoutRenditionInput = {
    where: DailyCashExpenseWhereUniqueInput
    update: XOR<DailyCashExpenseUpdateWithoutRenditionInput, DailyCashExpenseUncheckedUpdateWithoutRenditionInput>
    create: XOR<DailyCashExpenseCreateWithoutRenditionInput, DailyCashExpenseUncheckedCreateWithoutRenditionInput>
  }

  export type DailyCashExpenseUpdateWithWhereUniqueWithoutRenditionInput = {
    where: DailyCashExpenseWhereUniqueInput
    data: XOR<DailyCashExpenseUpdateWithoutRenditionInput, DailyCashExpenseUncheckedUpdateWithoutRenditionInput>
  }

  export type DailyCashExpenseUpdateManyWithWhereWithoutRenditionInput = {
    where: DailyCashExpenseScalarWhereInput
    data: XOR<DailyCashExpenseUpdateManyMutationInput, DailyCashExpenseUncheckedUpdateManyWithoutRenditionInput>
  }

  export type DailyCashExpenseScalarWhereInput = {
    AND?: DailyCashExpenseScalarWhereInput | DailyCashExpenseScalarWhereInput[]
    OR?: DailyCashExpenseScalarWhereInput[]
    NOT?: DailyCashExpenseScalarWhereInput | DailyCashExpenseScalarWhereInput[]
    id?: IntFilter<"DailyCashExpense"> | number
    renditionId?: IntFilter<"DailyCashExpense"> | number
    description?: StringFilter<"DailyCashExpense"> | string
    amount?: DecimalFilter<"DailyCashExpense"> | Decimal | DecimalJsLike | number | string
    personalAmount?: DecimalFilter<"DailyCashExpense"> | Decimal | DecimalJsLike | number | string
    paidWithPersonal?: BoolFilter<"DailyCashExpense"> | boolean
    createdAt?: DateTimeFilter<"DailyCashExpense"> | Date | string
  }

  export type DailyCashRenditionCreateWithoutExpensesInput = {
    date?: Date | string
    openingBalance?: Decimal | DecimalJsLike | number | string
    received?: Decimal | DecimalJsLike | number | string
    spent?: Decimal | DecimalJsLike | number | string
    personalContribution?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    obra?: ObraCreateNestedOneWithoutDailyCashRenditionsInput
  }

  export type DailyCashRenditionUncheckedCreateWithoutExpensesInput = {
    id?: number
    date?: Date | string
    obraId?: number | null
    openingBalance?: Decimal | DecimalJsLike | number | string
    received?: Decimal | DecimalJsLike | number | string
    spent?: Decimal | DecimalJsLike | number | string
    personalContribution?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyCashRenditionCreateOrConnectWithoutExpensesInput = {
    where: DailyCashRenditionWhereUniqueInput
    create: XOR<DailyCashRenditionCreateWithoutExpensesInput, DailyCashRenditionUncheckedCreateWithoutExpensesInput>
  }

  export type DailyCashRenditionUpsertWithoutExpensesInput = {
    update: XOR<DailyCashRenditionUpdateWithoutExpensesInput, DailyCashRenditionUncheckedUpdateWithoutExpensesInput>
    create: XOR<DailyCashRenditionCreateWithoutExpensesInput, DailyCashRenditionUncheckedCreateWithoutExpensesInput>
    where?: DailyCashRenditionWhereInput
  }

  export type DailyCashRenditionUpdateToOneWithWhereWithoutExpensesInput = {
    where?: DailyCashRenditionWhereInput
    data: XOR<DailyCashRenditionUpdateWithoutExpensesInput, DailyCashRenditionUncheckedUpdateWithoutExpensesInput>
  }

  export type DailyCashRenditionUpdateWithoutExpensesInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    received?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    spent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personalContribution?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    obra?: ObraUpdateOneWithoutDailyCashRenditionsNestedInput
  }

  export type DailyCashRenditionUncheckedUpdateWithoutExpensesInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    obraId?: NullableIntFieldUpdateOperationsInput | number | null
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    received?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    spent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personalContribution?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ObraCreateWithoutEmployeesInput = {
    name: string
    code?: string | null
    frentes?: FrenteCreateNestedManyWithoutObraInput
    moves?: MoveCreateNestedManyWithoutObraInput
    incomes?: IncomeCreateNestedManyWithoutObraInput
    expenses?: ExpenseCreateNestedManyWithoutObraInput
    payrollPeriods?: PayrollPeriodCreateNestedManyWithoutObraInput
    dailyCashRenditions?: DailyCashRenditionCreateNestedManyWithoutObraInput
  }

  export type ObraUncheckedCreateWithoutEmployeesInput = {
    id?: number
    name: string
    code?: string | null
    frentes?: FrenteUncheckedCreateNestedManyWithoutObraInput
    moves?: MoveUncheckedCreateNestedManyWithoutObraInput
    incomes?: IncomeUncheckedCreateNestedManyWithoutObraInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutObraInput
    payrollPeriods?: PayrollPeriodUncheckedCreateNestedManyWithoutObraInput
    dailyCashRenditions?: DailyCashRenditionUncheckedCreateNestedManyWithoutObraInput
  }

  export type ObraCreateOrConnectWithoutEmployeesInput = {
    where: ObraWhereUniqueInput
    create: XOR<ObraCreateWithoutEmployeesInput, ObraUncheckedCreateWithoutEmployeesInput>
  }

  export type AttendanceRecordCreateWithoutEmployeeInput = {
    date: Date | string
    status?: $Enums.AttendanceStatus
    minutesLate?: number | null
    permissionHours?: Decimal | DecimalJsLike | number | string | null
    extraHours?: Decimal | DecimalJsLike | number | string | null
    permissionPaid?: boolean | null
    holidayWorked?: boolean
    holidayCount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceRecordUncheckedCreateWithoutEmployeeInput = {
    id?: number
    date: Date | string
    status?: $Enums.AttendanceStatus
    minutesLate?: number | null
    permissionHours?: Decimal | DecimalJsLike | number | string | null
    extraHours?: Decimal | DecimalJsLike | number | string | null
    permissionPaid?: boolean | null
    holidayWorked?: boolean
    holidayCount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceRecordCreateOrConnectWithoutEmployeeInput = {
    where: AttendanceRecordWhereUniqueInput
    create: XOR<AttendanceRecordCreateWithoutEmployeeInput, AttendanceRecordUncheckedCreateWithoutEmployeeInput>
  }

  export type AttendanceRecordCreateManyEmployeeInputEnvelope = {
    data: AttendanceRecordCreateManyEmployeeInput | AttendanceRecordCreateManyEmployeeInput[]
  }

  export type PayrollEntryCreateWithoutEmployeeInput = {
    baseSalary: Decimal | DecimalJsLike | number | string
    dailyRate: Decimal | DecimalJsLike | number | string
    hourlyRate: Decimal | DecimalJsLike | number | string
    workedDays?: number
    absenceDays?: number
    tardinessMinutes?: number
    permissionHours?: Decimal | DecimalJsLike | number | string
    overtimeHours?: Decimal | DecimalJsLike | number | string
    bonusesTotal?: Decimal | DecimalJsLike | number | string
    deductionsTotal?: Decimal | DecimalJsLike | number | string
    pensionAmount?: Decimal | DecimalJsLike | number | string
    healthAmount?: Decimal | DecimalJsLike | number | string
    grossEarnings?: Decimal | DecimalJsLike | number | string
    netPay?: Decimal | DecimalJsLike | number | string
    permissionDays?: number
    holidayDays?: number
    holidayBonus?: Decimal | DecimalJsLike | number | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    period: PayrollPeriodCreateNestedOneWithoutEntriesInput
    adjustments?: PayrollAdjustmentCreateNestedManyWithoutEntryInput
  }

  export type PayrollEntryUncheckedCreateWithoutEmployeeInput = {
    id?: number
    periodId: number
    baseSalary: Decimal | DecimalJsLike | number | string
    dailyRate: Decimal | DecimalJsLike | number | string
    hourlyRate: Decimal | DecimalJsLike | number | string
    workedDays?: number
    absenceDays?: number
    tardinessMinutes?: number
    permissionHours?: Decimal | DecimalJsLike | number | string
    overtimeHours?: Decimal | DecimalJsLike | number | string
    bonusesTotal?: Decimal | DecimalJsLike | number | string
    deductionsTotal?: Decimal | DecimalJsLike | number | string
    pensionAmount?: Decimal | DecimalJsLike | number | string
    healthAmount?: Decimal | DecimalJsLike | number | string
    grossEarnings?: Decimal | DecimalJsLike | number | string
    netPay?: Decimal | DecimalJsLike | number | string
    permissionDays?: number
    holidayDays?: number
    holidayBonus?: Decimal | DecimalJsLike | number | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    adjustments?: PayrollAdjustmentUncheckedCreateNestedManyWithoutEntryInput
  }

  export type PayrollEntryCreateOrConnectWithoutEmployeeInput = {
    where: PayrollEntryWhereUniqueInput
    create: XOR<PayrollEntryCreateWithoutEmployeeInput, PayrollEntryUncheckedCreateWithoutEmployeeInput>
  }

  export type PayrollEntryCreateManyEmployeeInputEnvelope = {
    data: PayrollEntryCreateManyEmployeeInput | PayrollEntryCreateManyEmployeeInput[]
  }

  export type EmployeeAccumulationPaymentCreateWithoutEmployeeInput = {
    paid?: boolean
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeAccumulationPaymentUncheckedCreateWithoutEmployeeInput = {
    paid?: boolean
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeAccumulationPaymentCreateOrConnectWithoutEmployeeInput = {
    where: EmployeeAccumulationPaymentWhereUniqueInput
    create: XOR<EmployeeAccumulationPaymentCreateWithoutEmployeeInput, EmployeeAccumulationPaymentUncheckedCreateWithoutEmployeeInput>
  }

  export type ObraUpsertWithoutEmployeesInput = {
    update: XOR<ObraUpdateWithoutEmployeesInput, ObraUncheckedUpdateWithoutEmployeesInput>
    create: XOR<ObraCreateWithoutEmployeesInput, ObraUncheckedCreateWithoutEmployeesInput>
    where?: ObraWhereInput
  }

  export type ObraUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: ObraWhereInput
    data: XOR<ObraUpdateWithoutEmployeesInput, ObraUncheckedUpdateWithoutEmployeesInput>
  }

  export type ObraUpdateWithoutEmployeesInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    frentes?: FrenteUpdateManyWithoutObraNestedInput
    moves?: MoveUpdateManyWithoutObraNestedInput
    incomes?: IncomeUpdateManyWithoutObraNestedInput
    expenses?: ExpenseUpdateManyWithoutObraNestedInput
    payrollPeriods?: PayrollPeriodUpdateManyWithoutObraNestedInput
    dailyCashRenditions?: DailyCashRenditionUpdateManyWithoutObraNestedInput
  }

  export type ObraUncheckedUpdateWithoutEmployeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    frentes?: FrenteUncheckedUpdateManyWithoutObraNestedInput
    moves?: MoveUncheckedUpdateManyWithoutObraNestedInput
    incomes?: IncomeUncheckedUpdateManyWithoutObraNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutObraNestedInput
    payrollPeriods?: PayrollPeriodUncheckedUpdateManyWithoutObraNestedInput
    dailyCashRenditions?: DailyCashRenditionUncheckedUpdateManyWithoutObraNestedInput
  }

  export type AttendanceRecordUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: AttendanceRecordWhereUniqueInput
    update: XOR<AttendanceRecordUpdateWithoutEmployeeInput, AttendanceRecordUncheckedUpdateWithoutEmployeeInput>
    create: XOR<AttendanceRecordCreateWithoutEmployeeInput, AttendanceRecordUncheckedCreateWithoutEmployeeInput>
  }

  export type AttendanceRecordUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: AttendanceRecordWhereUniqueInput
    data: XOR<AttendanceRecordUpdateWithoutEmployeeInput, AttendanceRecordUncheckedUpdateWithoutEmployeeInput>
  }

  export type AttendanceRecordUpdateManyWithWhereWithoutEmployeeInput = {
    where: AttendanceRecordScalarWhereInput
    data: XOR<AttendanceRecordUpdateManyMutationInput, AttendanceRecordUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type AttendanceRecordScalarWhereInput = {
    AND?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
    OR?: AttendanceRecordScalarWhereInput[]
    NOT?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
    id?: IntFilter<"AttendanceRecord"> | number
    employeeId?: IntFilter<"AttendanceRecord"> | number
    date?: DateTimeFilter<"AttendanceRecord"> | Date | string
    status?: EnumAttendanceStatusFilter<"AttendanceRecord"> | $Enums.AttendanceStatus
    minutesLate?: IntNullableFilter<"AttendanceRecord"> | number | null
    permissionHours?: DecimalNullableFilter<"AttendanceRecord"> | Decimal | DecimalJsLike | number | string | null
    extraHours?: DecimalNullableFilter<"AttendanceRecord"> | Decimal | DecimalJsLike | number | string | null
    permissionPaid?: BoolNullableFilter<"AttendanceRecord"> | boolean | null
    holidayWorked?: BoolFilter<"AttendanceRecord"> | boolean
    holidayCount?: IntFilter<"AttendanceRecord"> | number
    notes?: StringNullableFilter<"AttendanceRecord"> | string | null
    createdAt?: DateTimeFilter<"AttendanceRecord"> | Date | string
    updatedAt?: DateTimeFilter<"AttendanceRecord"> | Date | string
  }

  export type PayrollEntryUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: PayrollEntryWhereUniqueInput
    update: XOR<PayrollEntryUpdateWithoutEmployeeInput, PayrollEntryUncheckedUpdateWithoutEmployeeInput>
    create: XOR<PayrollEntryCreateWithoutEmployeeInput, PayrollEntryUncheckedCreateWithoutEmployeeInput>
  }

  export type PayrollEntryUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: PayrollEntryWhereUniqueInput
    data: XOR<PayrollEntryUpdateWithoutEmployeeInput, PayrollEntryUncheckedUpdateWithoutEmployeeInput>
  }

  export type PayrollEntryUpdateManyWithWhereWithoutEmployeeInput = {
    where: PayrollEntryScalarWhereInput
    data: XOR<PayrollEntryUpdateManyMutationInput, PayrollEntryUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type PayrollEntryScalarWhereInput = {
    AND?: PayrollEntryScalarWhereInput | PayrollEntryScalarWhereInput[]
    OR?: PayrollEntryScalarWhereInput[]
    NOT?: PayrollEntryScalarWhereInput | PayrollEntryScalarWhereInput[]
    id?: IntFilter<"PayrollEntry"> | number
    periodId?: IntFilter<"PayrollEntry"> | number
    employeeId?: IntFilter<"PayrollEntry"> | number
    baseSalary?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    dailyRate?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    hourlyRate?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    workedDays?: IntFilter<"PayrollEntry"> | number
    absenceDays?: IntFilter<"PayrollEntry"> | number
    tardinessMinutes?: IntFilter<"PayrollEntry"> | number
    permissionHours?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    overtimeHours?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    bonusesTotal?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    deductionsTotal?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    pensionAmount?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    healthAmount?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    grossEarnings?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    netPay?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    permissionDays?: IntFilter<"PayrollEntry"> | number
    holidayDays?: IntFilter<"PayrollEntry"> | number
    holidayBonus?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    details?: JsonNullableFilter<"PayrollEntry">
    createdAt?: DateTimeFilter<"PayrollEntry"> | Date | string
    updatedAt?: DateTimeFilter<"PayrollEntry"> | Date | string
  }

  export type EmployeeAccumulationPaymentUpsertWithoutEmployeeInput = {
    update: XOR<EmployeeAccumulationPaymentUpdateWithoutEmployeeInput, EmployeeAccumulationPaymentUncheckedUpdateWithoutEmployeeInput>
    create: XOR<EmployeeAccumulationPaymentCreateWithoutEmployeeInput, EmployeeAccumulationPaymentUncheckedCreateWithoutEmployeeInput>
    where?: EmployeeAccumulationPaymentWhereInput
  }

  export type EmployeeAccumulationPaymentUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: EmployeeAccumulationPaymentWhereInput
    data: XOR<EmployeeAccumulationPaymentUpdateWithoutEmployeeInput, EmployeeAccumulationPaymentUncheckedUpdateWithoutEmployeeInput>
  }

  export type EmployeeAccumulationPaymentUpdateWithoutEmployeeInput = {
    paid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeAccumulationPaymentUncheckedUpdateWithoutEmployeeInput = {
    paid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateWithoutAccumulationPaymentInput = {
    code?: string | null
    firstName: string
    lastName: string
    documentType?: $Enums.DocumentType | null
    documentNumber?: string | null
    position?: string | null
    phone?: string | null
    email?: string | null
    bankType?: $Enums.BankType
    accountNumber?: string | null
    cci?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    baseSalary?: Decimal | DecimalJsLike | number | string
    dailyHours?: Decimal | DecimalJsLike | number | string
    pensionSystem?: $Enums.PensionSystem
    pensionRate?: Decimal | DecimalJsLike | number | string
    healthRate?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    area?: $Enums.EmployeeArea
    notes?: string | null
    absenceSundayPenalty?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    obra?: ObraCreateNestedOneWithoutEmployeesInput
    attendances?: AttendanceRecordCreateNestedManyWithoutEmployeeInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutAccumulationPaymentInput = {
    id?: number
    code?: string | null
    firstName: string
    lastName: string
    documentType?: $Enums.DocumentType | null
    documentNumber?: string | null
    position?: string | null
    phone?: string | null
    email?: string | null
    bankType?: $Enums.BankType
    accountNumber?: string | null
    cci?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    baseSalary?: Decimal | DecimalJsLike | number | string
    dailyHours?: Decimal | DecimalJsLike | number | string
    pensionSystem?: $Enums.PensionSystem
    pensionRate?: Decimal | DecimalJsLike | number | string
    healthRate?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    area?: $Enums.EmployeeArea
    obraId?: number | null
    notes?: string | null
    absenceSundayPenalty?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    attendances?: AttendanceRecordUncheckedCreateNestedManyWithoutEmployeeInput
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutAccumulationPaymentInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutAccumulationPaymentInput, EmployeeUncheckedCreateWithoutAccumulationPaymentInput>
  }

  export type EmployeeUpsertWithoutAccumulationPaymentInput = {
    update: XOR<EmployeeUpdateWithoutAccumulationPaymentInput, EmployeeUncheckedUpdateWithoutAccumulationPaymentInput>
    create: XOR<EmployeeCreateWithoutAccumulationPaymentInput, EmployeeUncheckedCreateWithoutAccumulationPaymentInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutAccumulationPaymentInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutAccumulationPaymentInput, EmployeeUncheckedUpdateWithoutAccumulationPaymentInput>
  }

  export type EmployeeUpdateWithoutAccumulationPaymentInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    documentType?: NullableEnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    bankType?: EnumBankTypeFieldUpdateOperationsInput | $Enums.BankType
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cci?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dailyHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pensionSystem?: EnumPensionSystemFieldUpdateOperationsInput | $Enums.PensionSystem
    pensionRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    healthRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    area?: EnumEmployeeAreaFieldUpdateOperationsInput | $Enums.EmployeeArea
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    absenceSundayPenalty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    obra?: ObraUpdateOneWithoutEmployeesNestedInput
    attendances?: AttendanceRecordUpdateManyWithoutEmployeeNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutAccumulationPaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    documentType?: NullableEnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    bankType?: EnumBankTypeFieldUpdateOperationsInput | $Enums.BankType
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cci?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dailyHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pensionSystem?: EnumPensionSystemFieldUpdateOperationsInput | $Enums.PensionSystem
    pensionRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    healthRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    area?: EnumEmployeeAreaFieldUpdateOperationsInput | $Enums.EmployeeArea
    obraId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    absenceSundayPenalty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: AttendanceRecordUncheckedUpdateManyWithoutEmployeeNestedInput
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateWithoutAttendancesInput = {
    code?: string | null
    firstName: string
    lastName: string
    documentType?: $Enums.DocumentType | null
    documentNumber?: string | null
    position?: string | null
    phone?: string | null
    email?: string | null
    bankType?: $Enums.BankType
    accountNumber?: string | null
    cci?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    baseSalary?: Decimal | DecimalJsLike | number | string
    dailyHours?: Decimal | DecimalJsLike | number | string
    pensionSystem?: $Enums.PensionSystem
    pensionRate?: Decimal | DecimalJsLike | number | string
    healthRate?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    area?: $Enums.EmployeeArea
    notes?: string | null
    absenceSundayPenalty?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    obra?: ObraCreateNestedOneWithoutEmployeesInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutEmployeeInput
    accumulationPayment?: EmployeeAccumulationPaymentCreateNestedOneWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutAttendancesInput = {
    id?: number
    code?: string | null
    firstName: string
    lastName: string
    documentType?: $Enums.DocumentType | null
    documentNumber?: string | null
    position?: string | null
    phone?: string | null
    email?: string | null
    bankType?: $Enums.BankType
    accountNumber?: string | null
    cci?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    baseSalary?: Decimal | DecimalJsLike | number | string
    dailyHours?: Decimal | DecimalJsLike | number | string
    pensionSystem?: $Enums.PensionSystem
    pensionRate?: Decimal | DecimalJsLike | number | string
    healthRate?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    area?: $Enums.EmployeeArea
    obraId?: number | null
    notes?: string | null
    absenceSundayPenalty?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutEmployeeInput
    accumulationPayment?: EmployeeAccumulationPaymentUncheckedCreateNestedOneWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutAttendancesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutAttendancesInput, EmployeeUncheckedCreateWithoutAttendancesInput>
  }

  export type EmployeeUpsertWithoutAttendancesInput = {
    update: XOR<EmployeeUpdateWithoutAttendancesInput, EmployeeUncheckedUpdateWithoutAttendancesInput>
    create: XOR<EmployeeCreateWithoutAttendancesInput, EmployeeUncheckedCreateWithoutAttendancesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutAttendancesInput, EmployeeUncheckedUpdateWithoutAttendancesInput>
  }

  export type EmployeeUpdateWithoutAttendancesInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    documentType?: NullableEnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    bankType?: EnumBankTypeFieldUpdateOperationsInput | $Enums.BankType
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cci?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dailyHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pensionSystem?: EnumPensionSystemFieldUpdateOperationsInput | $Enums.PensionSystem
    pensionRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    healthRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    area?: EnumEmployeeAreaFieldUpdateOperationsInput | $Enums.EmployeeArea
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    absenceSundayPenalty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    obra?: ObraUpdateOneWithoutEmployeesNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutEmployeeNestedInput
    accumulationPayment?: EmployeeAccumulationPaymentUpdateOneWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutAttendancesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    documentType?: NullableEnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    bankType?: EnumBankTypeFieldUpdateOperationsInput | $Enums.BankType
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cci?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dailyHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pensionSystem?: EnumPensionSystemFieldUpdateOperationsInput | $Enums.PensionSystem
    pensionRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    healthRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    area?: EnumEmployeeAreaFieldUpdateOperationsInput | $Enums.EmployeeArea
    obraId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    absenceSundayPenalty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    accumulationPayment?: EmployeeAccumulationPaymentUncheckedUpdateOneWithoutEmployeeNestedInput
  }

  export type ObraCreateWithoutPayrollPeriodsInput = {
    name: string
    code?: string | null
    frentes?: FrenteCreateNestedManyWithoutObraInput
    moves?: MoveCreateNestedManyWithoutObraInput
    incomes?: IncomeCreateNestedManyWithoutObraInput
    expenses?: ExpenseCreateNestedManyWithoutObraInput
    employees?: EmployeeCreateNestedManyWithoutObraInput
    dailyCashRenditions?: DailyCashRenditionCreateNestedManyWithoutObraInput
  }

  export type ObraUncheckedCreateWithoutPayrollPeriodsInput = {
    id?: number
    name: string
    code?: string | null
    frentes?: FrenteUncheckedCreateNestedManyWithoutObraInput
    moves?: MoveUncheckedCreateNestedManyWithoutObraInput
    incomes?: IncomeUncheckedCreateNestedManyWithoutObraInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutObraInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutObraInput
    dailyCashRenditions?: DailyCashRenditionUncheckedCreateNestedManyWithoutObraInput
  }

  export type ObraCreateOrConnectWithoutPayrollPeriodsInput = {
    where: ObraWhereUniqueInput
    create: XOR<ObraCreateWithoutPayrollPeriodsInput, ObraUncheckedCreateWithoutPayrollPeriodsInput>
  }

  export type PayrollEntryCreateWithoutPeriodInput = {
    baseSalary: Decimal | DecimalJsLike | number | string
    dailyRate: Decimal | DecimalJsLike | number | string
    hourlyRate: Decimal | DecimalJsLike | number | string
    workedDays?: number
    absenceDays?: number
    tardinessMinutes?: number
    permissionHours?: Decimal | DecimalJsLike | number | string
    overtimeHours?: Decimal | DecimalJsLike | number | string
    bonusesTotal?: Decimal | DecimalJsLike | number | string
    deductionsTotal?: Decimal | DecimalJsLike | number | string
    pensionAmount?: Decimal | DecimalJsLike | number | string
    healthAmount?: Decimal | DecimalJsLike | number | string
    grossEarnings?: Decimal | DecimalJsLike | number | string
    netPay?: Decimal | DecimalJsLike | number | string
    permissionDays?: number
    holidayDays?: number
    holidayBonus?: Decimal | DecimalJsLike | number | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutPayrollEntriesInput
    adjustments?: PayrollAdjustmentCreateNestedManyWithoutEntryInput
  }

  export type PayrollEntryUncheckedCreateWithoutPeriodInput = {
    id?: number
    employeeId: number
    baseSalary: Decimal | DecimalJsLike | number | string
    dailyRate: Decimal | DecimalJsLike | number | string
    hourlyRate: Decimal | DecimalJsLike | number | string
    workedDays?: number
    absenceDays?: number
    tardinessMinutes?: number
    permissionHours?: Decimal | DecimalJsLike | number | string
    overtimeHours?: Decimal | DecimalJsLike | number | string
    bonusesTotal?: Decimal | DecimalJsLike | number | string
    deductionsTotal?: Decimal | DecimalJsLike | number | string
    pensionAmount?: Decimal | DecimalJsLike | number | string
    healthAmount?: Decimal | DecimalJsLike | number | string
    grossEarnings?: Decimal | DecimalJsLike | number | string
    netPay?: Decimal | DecimalJsLike | number | string
    permissionDays?: number
    holidayDays?: number
    holidayBonus?: Decimal | DecimalJsLike | number | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    adjustments?: PayrollAdjustmentUncheckedCreateNestedManyWithoutEntryInput
  }

  export type PayrollEntryCreateOrConnectWithoutPeriodInput = {
    where: PayrollEntryWhereUniqueInput
    create: XOR<PayrollEntryCreateWithoutPeriodInput, PayrollEntryUncheckedCreateWithoutPeriodInput>
  }

  export type PayrollEntryCreateManyPeriodInputEnvelope = {
    data: PayrollEntryCreateManyPeriodInput | PayrollEntryCreateManyPeriodInput[]
  }

  export type ObraUpsertWithoutPayrollPeriodsInput = {
    update: XOR<ObraUpdateWithoutPayrollPeriodsInput, ObraUncheckedUpdateWithoutPayrollPeriodsInput>
    create: XOR<ObraCreateWithoutPayrollPeriodsInput, ObraUncheckedCreateWithoutPayrollPeriodsInput>
    where?: ObraWhereInput
  }

  export type ObraUpdateToOneWithWhereWithoutPayrollPeriodsInput = {
    where?: ObraWhereInput
    data: XOR<ObraUpdateWithoutPayrollPeriodsInput, ObraUncheckedUpdateWithoutPayrollPeriodsInput>
  }

  export type ObraUpdateWithoutPayrollPeriodsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    frentes?: FrenteUpdateManyWithoutObraNestedInput
    moves?: MoveUpdateManyWithoutObraNestedInput
    incomes?: IncomeUpdateManyWithoutObraNestedInput
    expenses?: ExpenseUpdateManyWithoutObraNestedInput
    employees?: EmployeeUpdateManyWithoutObraNestedInput
    dailyCashRenditions?: DailyCashRenditionUpdateManyWithoutObraNestedInput
  }

  export type ObraUncheckedUpdateWithoutPayrollPeriodsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    frentes?: FrenteUncheckedUpdateManyWithoutObraNestedInput
    moves?: MoveUncheckedUpdateManyWithoutObraNestedInput
    incomes?: IncomeUncheckedUpdateManyWithoutObraNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutObraNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutObraNestedInput
    dailyCashRenditions?: DailyCashRenditionUncheckedUpdateManyWithoutObraNestedInput
  }

  export type PayrollEntryUpsertWithWhereUniqueWithoutPeriodInput = {
    where: PayrollEntryWhereUniqueInput
    update: XOR<PayrollEntryUpdateWithoutPeriodInput, PayrollEntryUncheckedUpdateWithoutPeriodInput>
    create: XOR<PayrollEntryCreateWithoutPeriodInput, PayrollEntryUncheckedCreateWithoutPeriodInput>
  }

  export type PayrollEntryUpdateWithWhereUniqueWithoutPeriodInput = {
    where: PayrollEntryWhereUniqueInput
    data: XOR<PayrollEntryUpdateWithoutPeriodInput, PayrollEntryUncheckedUpdateWithoutPeriodInput>
  }

  export type PayrollEntryUpdateManyWithWhereWithoutPeriodInput = {
    where: PayrollEntryScalarWhereInput
    data: XOR<PayrollEntryUpdateManyMutationInput, PayrollEntryUncheckedUpdateManyWithoutPeriodInput>
  }

  export type PayrollPeriodCreateWithoutEntriesInput = {
    month: number
    year: number
    startDate: Date | string
    endDate: Date | string
    workingDays: number
    status?: $Enums.PayrollPeriodStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    obra?: ObraCreateNestedOneWithoutPayrollPeriodsInput
  }

  export type PayrollPeriodUncheckedCreateWithoutEntriesInput = {
    id?: number
    obraId?: number | null
    month: number
    year: number
    startDate: Date | string
    endDate: Date | string
    workingDays: number
    status?: $Enums.PayrollPeriodStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollPeriodCreateOrConnectWithoutEntriesInput = {
    where: PayrollPeriodWhereUniqueInput
    create: XOR<PayrollPeriodCreateWithoutEntriesInput, PayrollPeriodUncheckedCreateWithoutEntriesInput>
  }

  export type EmployeeCreateWithoutPayrollEntriesInput = {
    code?: string | null
    firstName: string
    lastName: string
    documentType?: $Enums.DocumentType | null
    documentNumber?: string | null
    position?: string | null
    phone?: string | null
    email?: string | null
    bankType?: $Enums.BankType
    accountNumber?: string | null
    cci?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    baseSalary?: Decimal | DecimalJsLike | number | string
    dailyHours?: Decimal | DecimalJsLike | number | string
    pensionSystem?: $Enums.PensionSystem
    pensionRate?: Decimal | DecimalJsLike | number | string
    healthRate?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    area?: $Enums.EmployeeArea
    notes?: string | null
    absenceSundayPenalty?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    obra?: ObraCreateNestedOneWithoutEmployeesInput
    attendances?: AttendanceRecordCreateNestedManyWithoutEmployeeInput
    accumulationPayment?: EmployeeAccumulationPaymentCreateNestedOneWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutPayrollEntriesInput = {
    id?: number
    code?: string | null
    firstName: string
    lastName: string
    documentType?: $Enums.DocumentType | null
    documentNumber?: string | null
    position?: string | null
    phone?: string | null
    email?: string | null
    bankType?: $Enums.BankType
    accountNumber?: string | null
    cci?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    baseSalary?: Decimal | DecimalJsLike | number | string
    dailyHours?: Decimal | DecimalJsLike | number | string
    pensionSystem?: $Enums.PensionSystem
    pensionRate?: Decimal | DecimalJsLike | number | string
    healthRate?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    area?: $Enums.EmployeeArea
    obraId?: number | null
    notes?: string | null
    absenceSundayPenalty?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    attendances?: AttendanceRecordUncheckedCreateNestedManyWithoutEmployeeInput
    accumulationPayment?: EmployeeAccumulationPaymentUncheckedCreateNestedOneWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutPayrollEntriesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutPayrollEntriesInput, EmployeeUncheckedCreateWithoutPayrollEntriesInput>
  }

  export type PayrollAdjustmentCreateWithoutEntryInput = {
    type: $Enums.PayrollAdjustmentType
    concept: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollAdjustmentUncheckedCreateWithoutEntryInput = {
    id?: number
    type: $Enums.PayrollAdjustmentType
    concept: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollAdjustmentCreateOrConnectWithoutEntryInput = {
    where: PayrollAdjustmentWhereUniqueInput
    create: XOR<PayrollAdjustmentCreateWithoutEntryInput, PayrollAdjustmentUncheckedCreateWithoutEntryInput>
  }

  export type PayrollAdjustmentCreateManyEntryInputEnvelope = {
    data: PayrollAdjustmentCreateManyEntryInput | PayrollAdjustmentCreateManyEntryInput[]
  }

  export type PayrollPeriodUpsertWithoutEntriesInput = {
    update: XOR<PayrollPeriodUpdateWithoutEntriesInput, PayrollPeriodUncheckedUpdateWithoutEntriesInput>
    create: XOR<PayrollPeriodCreateWithoutEntriesInput, PayrollPeriodUncheckedCreateWithoutEntriesInput>
    where?: PayrollPeriodWhereInput
  }

  export type PayrollPeriodUpdateToOneWithWhereWithoutEntriesInput = {
    where?: PayrollPeriodWhereInput
    data: XOR<PayrollPeriodUpdateWithoutEntriesInput, PayrollPeriodUncheckedUpdateWithoutEntriesInput>
  }

  export type PayrollPeriodUpdateWithoutEntriesInput = {
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    workingDays?: IntFieldUpdateOperationsInput | number
    status?: EnumPayrollPeriodStatusFieldUpdateOperationsInput | $Enums.PayrollPeriodStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    obra?: ObraUpdateOneWithoutPayrollPeriodsNestedInput
  }

  export type PayrollPeriodUncheckedUpdateWithoutEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    obraId?: NullableIntFieldUpdateOperationsInput | number | null
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    workingDays?: IntFieldUpdateOperationsInput | number
    status?: EnumPayrollPeriodStatusFieldUpdateOperationsInput | $Enums.PayrollPeriodStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUpsertWithoutPayrollEntriesInput = {
    update: XOR<EmployeeUpdateWithoutPayrollEntriesInput, EmployeeUncheckedUpdateWithoutPayrollEntriesInput>
    create: XOR<EmployeeCreateWithoutPayrollEntriesInput, EmployeeUncheckedCreateWithoutPayrollEntriesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutPayrollEntriesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutPayrollEntriesInput, EmployeeUncheckedUpdateWithoutPayrollEntriesInput>
  }

  export type EmployeeUpdateWithoutPayrollEntriesInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    documentType?: NullableEnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    bankType?: EnumBankTypeFieldUpdateOperationsInput | $Enums.BankType
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cci?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dailyHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pensionSystem?: EnumPensionSystemFieldUpdateOperationsInput | $Enums.PensionSystem
    pensionRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    healthRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    area?: EnumEmployeeAreaFieldUpdateOperationsInput | $Enums.EmployeeArea
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    absenceSundayPenalty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    obra?: ObraUpdateOneWithoutEmployeesNestedInput
    attendances?: AttendanceRecordUpdateManyWithoutEmployeeNestedInput
    accumulationPayment?: EmployeeAccumulationPaymentUpdateOneWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutPayrollEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    documentType?: NullableEnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    bankType?: EnumBankTypeFieldUpdateOperationsInput | $Enums.BankType
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cci?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dailyHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pensionSystem?: EnumPensionSystemFieldUpdateOperationsInput | $Enums.PensionSystem
    pensionRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    healthRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    area?: EnumEmployeeAreaFieldUpdateOperationsInput | $Enums.EmployeeArea
    obraId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    absenceSundayPenalty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: AttendanceRecordUncheckedUpdateManyWithoutEmployeeNestedInput
    accumulationPayment?: EmployeeAccumulationPaymentUncheckedUpdateOneWithoutEmployeeNestedInput
  }

  export type PayrollAdjustmentUpsertWithWhereUniqueWithoutEntryInput = {
    where: PayrollAdjustmentWhereUniqueInput
    update: XOR<PayrollAdjustmentUpdateWithoutEntryInput, PayrollAdjustmentUncheckedUpdateWithoutEntryInput>
    create: XOR<PayrollAdjustmentCreateWithoutEntryInput, PayrollAdjustmentUncheckedCreateWithoutEntryInput>
  }

  export type PayrollAdjustmentUpdateWithWhereUniqueWithoutEntryInput = {
    where: PayrollAdjustmentWhereUniqueInput
    data: XOR<PayrollAdjustmentUpdateWithoutEntryInput, PayrollAdjustmentUncheckedUpdateWithoutEntryInput>
  }

  export type PayrollAdjustmentUpdateManyWithWhereWithoutEntryInput = {
    where: PayrollAdjustmentScalarWhereInput
    data: XOR<PayrollAdjustmentUpdateManyMutationInput, PayrollAdjustmentUncheckedUpdateManyWithoutEntryInput>
  }

  export type PayrollAdjustmentScalarWhereInput = {
    AND?: PayrollAdjustmentScalarWhereInput | PayrollAdjustmentScalarWhereInput[]
    OR?: PayrollAdjustmentScalarWhereInput[]
    NOT?: PayrollAdjustmentScalarWhereInput | PayrollAdjustmentScalarWhereInput[]
    id?: IntFilter<"PayrollAdjustment"> | number
    entryId?: IntFilter<"PayrollAdjustment"> | number
    type?: EnumPayrollAdjustmentTypeFilter<"PayrollAdjustment"> | $Enums.PayrollAdjustmentType
    concept?: StringFilter<"PayrollAdjustment"> | string
    amount?: DecimalFilter<"PayrollAdjustment"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"PayrollAdjustment"> | Date | string
    updatedAt?: DateTimeFilter<"PayrollAdjustment"> | Date | string
  }

  export type PayrollEntryCreateWithoutAdjustmentsInput = {
    baseSalary: Decimal | DecimalJsLike | number | string
    dailyRate: Decimal | DecimalJsLike | number | string
    hourlyRate: Decimal | DecimalJsLike | number | string
    workedDays?: number
    absenceDays?: number
    tardinessMinutes?: number
    permissionHours?: Decimal | DecimalJsLike | number | string
    overtimeHours?: Decimal | DecimalJsLike | number | string
    bonusesTotal?: Decimal | DecimalJsLike | number | string
    deductionsTotal?: Decimal | DecimalJsLike | number | string
    pensionAmount?: Decimal | DecimalJsLike | number | string
    healthAmount?: Decimal | DecimalJsLike | number | string
    grossEarnings?: Decimal | DecimalJsLike | number | string
    netPay?: Decimal | DecimalJsLike | number | string
    permissionDays?: number
    holidayDays?: number
    holidayBonus?: Decimal | DecimalJsLike | number | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    period: PayrollPeriodCreateNestedOneWithoutEntriesInput
    employee: EmployeeCreateNestedOneWithoutPayrollEntriesInput
  }

  export type PayrollEntryUncheckedCreateWithoutAdjustmentsInput = {
    id?: number
    periodId: number
    employeeId: number
    baseSalary: Decimal | DecimalJsLike | number | string
    dailyRate: Decimal | DecimalJsLike | number | string
    hourlyRate: Decimal | DecimalJsLike | number | string
    workedDays?: number
    absenceDays?: number
    tardinessMinutes?: number
    permissionHours?: Decimal | DecimalJsLike | number | string
    overtimeHours?: Decimal | DecimalJsLike | number | string
    bonusesTotal?: Decimal | DecimalJsLike | number | string
    deductionsTotal?: Decimal | DecimalJsLike | number | string
    pensionAmount?: Decimal | DecimalJsLike | number | string
    healthAmount?: Decimal | DecimalJsLike | number | string
    grossEarnings?: Decimal | DecimalJsLike | number | string
    netPay?: Decimal | DecimalJsLike | number | string
    permissionDays?: number
    holidayDays?: number
    holidayBonus?: Decimal | DecimalJsLike | number | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollEntryCreateOrConnectWithoutAdjustmentsInput = {
    where: PayrollEntryWhereUniqueInput
    create: XOR<PayrollEntryCreateWithoutAdjustmentsInput, PayrollEntryUncheckedCreateWithoutAdjustmentsInput>
  }

  export type PayrollEntryUpsertWithoutAdjustmentsInput = {
    update: XOR<PayrollEntryUpdateWithoutAdjustmentsInput, PayrollEntryUncheckedUpdateWithoutAdjustmentsInput>
    create: XOR<PayrollEntryCreateWithoutAdjustmentsInput, PayrollEntryUncheckedCreateWithoutAdjustmentsInput>
    where?: PayrollEntryWhereInput
  }

  export type PayrollEntryUpdateToOneWithWhereWithoutAdjustmentsInput = {
    where?: PayrollEntryWhereInput
    data: XOR<PayrollEntryUpdateWithoutAdjustmentsInput, PayrollEntryUncheckedUpdateWithoutAdjustmentsInput>
  }

  export type PayrollEntryUpdateWithoutAdjustmentsInput = {
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dailyRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hourlyRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    workedDays?: IntFieldUpdateOperationsInput | number
    absenceDays?: IntFieldUpdateOperationsInput | number
    tardinessMinutes?: IntFieldUpdateOperationsInput | number
    permissionHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusesTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductionsTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pensionAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    healthAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossEarnings?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    permissionDays?: IntFieldUpdateOperationsInput | number
    holidayDays?: IntFieldUpdateOperationsInput | number
    holidayBonus?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    period?: PayrollPeriodUpdateOneRequiredWithoutEntriesNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutPayrollEntriesNestedInput
  }

  export type PayrollEntryUncheckedUpdateWithoutAdjustmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    periodId?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dailyRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hourlyRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    workedDays?: IntFieldUpdateOperationsInput | number
    absenceDays?: IntFieldUpdateOperationsInput | number
    tardinessMinutes?: IntFieldUpdateOperationsInput | number
    permissionHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusesTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductionsTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pensionAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    healthAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossEarnings?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    permissionDays?: IntFieldUpdateOperationsInput | number
    holidayDays?: IntFieldUpdateOperationsInput | number
    holidayBonus?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerLoanCreateWithoutGiverInput = {
    date: Date | string
    amount: Decimal | DecimalJsLike | number | string
    note?: string | null
    status?: $Enums.PartnerLoanStatus
    financeRefs?: NullableJsonNullValueInput | InputJsonValue
    closeDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    receiver: PartnerCreateNestedOneWithoutLoansReceivedInput
  }

  export type PartnerLoanUncheckedCreateWithoutGiverInput = {
    id?: number
    date: Date | string
    receiverId: number
    amount: Decimal | DecimalJsLike | number | string
    note?: string | null
    status?: $Enums.PartnerLoanStatus
    financeRefs?: NullableJsonNullValueInput | InputJsonValue
    closeDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PartnerLoanCreateOrConnectWithoutGiverInput = {
    where: PartnerLoanWhereUniqueInput
    create: XOR<PartnerLoanCreateWithoutGiverInput, PartnerLoanUncheckedCreateWithoutGiverInput>
  }

  export type PartnerLoanCreateManyGiverInputEnvelope = {
    data: PartnerLoanCreateManyGiverInput | PartnerLoanCreateManyGiverInput[]
  }

  export type PartnerLoanCreateWithoutReceiverInput = {
    date: Date | string
    amount: Decimal | DecimalJsLike | number | string
    note?: string | null
    status?: $Enums.PartnerLoanStatus
    financeRefs?: NullableJsonNullValueInput | InputJsonValue
    closeDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    giver: PartnerCreateNestedOneWithoutLoansGivenInput
  }

  export type PartnerLoanUncheckedCreateWithoutReceiverInput = {
    id?: number
    date: Date | string
    giverId: number
    amount: Decimal | DecimalJsLike | number | string
    note?: string | null
    status?: $Enums.PartnerLoanStatus
    financeRefs?: NullableJsonNullValueInput | InputJsonValue
    closeDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PartnerLoanCreateOrConnectWithoutReceiverInput = {
    where: PartnerLoanWhereUniqueInput
    create: XOR<PartnerLoanCreateWithoutReceiverInput, PartnerLoanUncheckedCreateWithoutReceiverInput>
  }

  export type PartnerLoanCreateManyReceiverInputEnvelope = {
    data: PartnerLoanCreateManyReceiverInput | PartnerLoanCreateManyReceiverInput[]
  }

  export type PartnerLoanUpsertWithWhereUniqueWithoutGiverInput = {
    where: PartnerLoanWhereUniqueInput
    update: XOR<PartnerLoanUpdateWithoutGiverInput, PartnerLoanUncheckedUpdateWithoutGiverInput>
    create: XOR<PartnerLoanCreateWithoutGiverInput, PartnerLoanUncheckedCreateWithoutGiverInput>
  }

  export type PartnerLoanUpdateWithWhereUniqueWithoutGiverInput = {
    where: PartnerLoanWhereUniqueInput
    data: XOR<PartnerLoanUpdateWithoutGiverInput, PartnerLoanUncheckedUpdateWithoutGiverInput>
  }

  export type PartnerLoanUpdateManyWithWhereWithoutGiverInput = {
    where: PartnerLoanScalarWhereInput
    data: XOR<PartnerLoanUpdateManyMutationInput, PartnerLoanUncheckedUpdateManyWithoutGiverInput>
  }

  export type PartnerLoanScalarWhereInput = {
    AND?: PartnerLoanScalarWhereInput | PartnerLoanScalarWhereInput[]
    OR?: PartnerLoanScalarWhereInput[]
    NOT?: PartnerLoanScalarWhereInput | PartnerLoanScalarWhereInput[]
    id?: IntFilter<"PartnerLoan"> | number
    date?: DateTimeFilter<"PartnerLoan"> | Date | string
    giverId?: IntFilter<"PartnerLoan"> | number
    receiverId?: IntFilter<"PartnerLoan"> | number
    amount?: DecimalFilter<"PartnerLoan"> | Decimal | DecimalJsLike | number | string
    note?: StringNullableFilter<"PartnerLoan"> | string | null
    status?: EnumPartnerLoanStatusFilter<"PartnerLoan"> | $Enums.PartnerLoanStatus
    financeRefs?: JsonNullableFilter<"PartnerLoan">
    closeDate?: DateTimeNullableFilter<"PartnerLoan"> | Date | string | null
    createdAt?: DateTimeFilter<"PartnerLoan"> | Date | string
    updatedAt?: DateTimeFilter<"PartnerLoan"> | Date | string
  }

  export type PartnerLoanUpsertWithWhereUniqueWithoutReceiverInput = {
    where: PartnerLoanWhereUniqueInput
    update: XOR<PartnerLoanUpdateWithoutReceiverInput, PartnerLoanUncheckedUpdateWithoutReceiverInput>
    create: XOR<PartnerLoanCreateWithoutReceiverInput, PartnerLoanUncheckedCreateWithoutReceiverInput>
  }

  export type PartnerLoanUpdateWithWhereUniqueWithoutReceiverInput = {
    where: PartnerLoanWhereUniqueInput
    data: XOR<PartnerLoanUpdateWithoutReceiverInput, PartnerLoanUncheckedUpdateWithoutReceiverInput>
  }

  export type PartnerLoanUpdateManyWithWhereWithoutReceiverInput = {
    where: PartnerLoanScalarWhereInput
    data: XOR<PartnerLoanUpdateManyMutationInput, PartnerLoanUncheckedUpdateManyWithoutReceiverInput>
  }

  export type PartnerCreateWithoutLoansGivenInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    loansReceived?: PartnerLoanCreateNestedManyWithoutReceiverInput
  }

  export type PartnerUncheckedCreateWithoutLoansGivenInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    loansReceived?: PartnerLoanUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type PartnerCreateOrConnectWithoutLoansGivenInput = {
    where: PartnerWhereUniqueInput
    create: XOR<PartnerCreateWithoutLoansGivenInput, PartnerUncheckedCreateWithoutLoansGivenInput>
  }

  export type PartnerCreateWithoutLoansReceivedInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    loansGiven?: PartnerLoanCreateNestedManyWithoutGiverInput
  }

  export type PartnerUncheckedCreateWithoutLoansReceivedInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    loansGiven?: PartnerLoanUncheckedCreateNestedManyWithoutGiverInput
  }

  export type PartnerCreateOrConnectWithoutLoansReceivedInput = {
    where: PartnerWhereUniqueInput
    create: XOR<PartnerCreateWithoutLoansReceivedInput, PartnerUncheckedCreateWithoutLoansReceivedInput>
  }

  export type PartnerUpsertWithoutLoansGivenInput = {
    update: XOR<PartnerUpdateWithoutLoansGivenInput, PartnerUncheckedUpdateWithoutLoansGivenInput>
    create: XOR<PartnerCreateWithoutLoansGivenInput, PartnerUncheckedCreateWithoutLoansGivenInput>
    where?: PartnerWhereInput
  }

  export type PartnerUpdateToOneWithWhereWithoutLoansGivenInput = {
    where?: PartnerWhereInput
    data: XOR<PartnerUpdateWithoutLoansGivenInput, PartnerUncheckedUpdateWithoutLoansGivenInput>
  }

  export type PartnerUpdateWithoutLoansGivenInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loansReceived?: PartnerLoanUpdateManyWithoutReceiverNestedInput
  }

  export type PartnerUncheckedUpdateWithoutLoansGivenInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loansReceived?: PartnerLoanUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type PartnerUpsertWithoutLoansReceivedInput = {
    update: XOR<PartnerUpdateWithoutLoansReceivedInput, PartnerUncheckedUpdateWithoutLoansReceivedInput>
    create: XOR<PartnerCreateWithoutLoansReceivedInput, PartnerUncheckedCreateWithoutLoansReceivedInput>
    where?: PartnerWhereInput
  }

  export type PartnerUpdateToOneWithWhereWithoutLoansReceivedInput = {
    where?: PartnerWhereInput
    data: XOR<PartnerUpdateWithoutLoansReceivedInput, PartnerUncheckedUpdateWithoutLoansReceivedInput>
  }

  export type PartnerUpdateWithoutLoansReceivedInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loansGiven?: PartnerLoanUpdateManyWithoutGiverNestedInput
  }

  export type PartnerUncheckedUpdateWithoutLoansReceivedInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loansGiven?: PartnerLoanUncheckedUpdateManyWithoutGiverNestedInput
  }

  export type FoodIngredientCostCreateWithoutIngredientInput = {
    unitCost: Decimal | DecimalJsLike | number | string
    effectiveDate?: Date | string | null
    source?: string | null
    createdAt?: Date | string
  }

  export type FoodIngredientCostUncheckedCreateWithoutIngredientInput = {
    id?: number
    unitCost: Decimal | DecimalJsLike | number | string
    effectiveDate?: Date | string | null
    source?: string | null
    createdAt?: Date | string
  }

  export type FoodIngredientCostCreateOrConnectWithoutIngredientInput = {
    where: FoodIngredientCostWhereUniqueInput
    create: XOR<FoodIngredientCostCreateWithoutIngredientInput, FoodIngredientCostUncheckedCreateWithoutIngredientInput>
  }

  export type FoodIngredientCostCreateManyIngredientInputEnvelope = {
    data: FoodIngredientCostCreateManyIngredientInput | FoodIngredientCostCreateManyIngredientInput[]
  }

  export type FoodRecipeItemCreateWithoutIngredientInput = {
    quantity?: Decimal | DecimalJsLike | number | string
    unit?: string | null
    wastePct?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    recipe: FoodRecipeCreateNestedOneWithoutItemsInput
    childRecipe?: FoodRecipeCreateNestedOneWithoutChildItemsInput
  }

  export type FoodRecipeItemUncheckedCreateWithoutIngredientInput = {
    id?: number
    recipeId: number
    childRecipeId?: number | null
    quantity?: Decimal | DecimalJsLike | number | string
    unit?: string | null
    wastePct?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type FoodRecipeItemCreateOrConnectWithoutIngredientInput = {
    where: FoodRecipeItemWhereUniqueInput
    create: XOR<FoodRecipeItemCreateWithoutIngredientInput, FoodRecipeItemUncheckedCreateWithoutIngredientInput>
  }

  export type FoodRecipeItemCreateManyIngredientInputEnvelope = {
    data: FoodRecipeItemCreateManyIngredientInput | FoodRecipeItemCreateManyIngredientInput[]
  }

  export type FoodIngredientCostUpsertWithWhereUniqueWithoutIngredientInput = {
    where: FoodIngredientCostWhereUniqueInput
    update: XOR<FoodIngredientCostUpdateWithoutIngredientInput, FoodIngredientCostUncheckedUpdateWithoutIngredientInput>
    create: XOR<FoodIngredientCostCreateWithoutIngredientInput, FoodIngredientCostUncheckedCreateWithoutIngredientInput>
  }

  export type FoodIngredientCostUpdateWithWhereUniqueWithoutIngredientInput = {
    where: FoodIngredientCostWhereUniqueInput
    data: XOR<FoodIngredientCostUpdateWithoutIngredientInput, FoodIngredientCostUncheckedUpdateWithoutIngredientInput>
  }

  export type FoodIngredientCostUpdateManyWithWhereWithoutIngredientInput = {
    where: FoodIngredientCostScalarWhereInput
    data: XOR<FoodIngredientCostUpdateManyMutationInput, FoodIngredientCostUncheckedUpdateManyWithoutIngredientInput>
  }

  export type FoodIngredientCostScalarWhereInput = {
    AND?: FoodIngredientCostScalarWhereInput | FoodIngredientCostScalarWhereInput[]
    OR?: FoodIngredientCostScalarWhereInput[]
    NOT?: FoodIngredientCostScalarWhereInput | FoodIngredientCostScalarWhereInput[]
    id?: IntFilter<"FoodIngredientCost"> | number
    ingredientId?: IntFilter<"FoodIngredientCost"> | number
    unitCost?: DecimalFilter<"FoodIngredientCost"> | Decimal | DecimalJsLike | number | string
    effectiveDate?: DateTimeNullableFilter<"FoodIngredientCost"> | Date | string | null
    source?: StringNullableFilter<"FoodIngredientCost"> | string | null
    createdAt?: DateTimeFilter<"FoodIngredientCost"> | Date | string
  }

  export type FoodRecipeItemUpsertWithWhereUniqueWithoutIngredientInput = {
    where: FoodRecipeItemWhereUniqueInput
    update: XOR<FoodRecipeItemUpdateWithoutIngredientInput, FoodRecipeItemUncheckedUpdateWithoutIngredientInput>
    create: XOR<FoodRecipeItemCreateWithoutIngredientInput, FoodRecipeItemUncheckedCreateWithoutIngredientInput>
  }

  export type FoodRecipeItemUpdateWithWhereUniqueWithoutIngredientInput = {
    where: FoodRecipeItemWhereUniqueInput
    data: XOR<FoodRecipeItemUpdateWithoutIngredientInput, FoodRecipeItemUncheckedUpdateWithoutIngredientInput>
  }

  export type FoodRecipeItemUpdateManyWithWhereWithoutIngredientInput = {
    where: FoodRecipeItemScalarWhereInput
    data: XOR<FoodRecipeItemUpdateManyMutationInput, FoodRecipeItemUncheckedUpdateManyWithoutIngredientInput>
  }

  export type FoodRecipeItemScalarWhereInput = {
    AND?: FoodRecipeItemScalarWhereInput | FoodRecipeItemScalarWhereInput[]
    OR?: FoodRecipeItemScalarWhereInput[]
    NOT?: FoodRecipeItemScalarWhereInput | FoodRecipeItemScalarWhereInput[]
    id?: IntFilter<"FoodRecipeItem"> | number
    recipeId?: IntFilter<"FoodRecipeItem"> | number
    ingredientId?: IntNullableFilter<"FoodRecipeItem"> | number | null
    childRecipeId?: IntNullableFilter<"FoodRecipeItem"> | number | null
    quantity?: DecimalFilter<"FoodRecipeItem"> | Decimal | DecimalJsLike | number | string
    unit?: StringNullableFilter<"FoodRecipeItem"> | string | null
    wastePct?: DecimalNullableFilter<"FoodRecipeItem"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"FoodRecipeItem"> | string | null
    createdAt?: DateTimeFilter<"FoodRecipeItem"> | Date | string
  }

  export type FoodIngredientCreateWithoutCostsInput = {
    name: string
    category?: string | null
    unit?: string | null
    defaultWastePct?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: FoodRecipeItemCreateNestedManyWithoutIngredientInput
  }

  export type FoodIngredientUncheckedCreateWithoutCostsInput = {
    id?: number
    name: string
    category?: string | null
    unit?: string | null
    defaultWastePct?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: FoodRecipeItemUncheckedCreateNestedManyWithoutIngredientInput
  }

  export type FoodIngredientCreateOrConnectWithoutCostsInput = {
    where: FoodIngredientWhereUniqueInput
    create: XOR<FoodIngredientCreateWithoutCostsInput, FoodIngredientUncheckedCreateWithoutCostsInput>
  }

  export type FoodIngredientUpsertWithoutCostsInput = {
    update: XOR<FoodIngredientUpdateWithoutCostsInput, FoodIngredientUncheckedUpdateWithoutCostsInput>
    create: XOR<FoodIngredientCreateWithoutCostsInput, FoodIngredientUncheckedCreateWithoutCostsInput>
    where?: FoodIngredientWhereInput
  }

  export type FoodIngredientUpdateToOneWithWhereWithoutCostsInput = {
    where?: FoodIngredientWhereInput
    data: XOR<FoodIngredientUpdateWithoutCostsInput, FoodIngredientUncheckedUpdateWithoutCostsInput>
  }

  export type FoodIngredientUpdateWithoutCostsInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWastePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: FoodRecipeItemUpdateManyWithoutIngredientNestedInput
  }

  export type FoodIngredientUncheckedUpdateWithoutCostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWastePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: FoodRecipeItemUncheckedUpdateManyWithoutIngredientNestedInput
  }

  export type FoodRecipeItemCreateWithoutRecipeInput = {
    quantity?: Decimal | DecimalJsLike | number | string
    unit?: string | null
    wastePct?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    ingredient?: FoodIngredientCreateNestedOneWithoutItemsInput
    childRecipe?: FoodRecipeCreateNestedOneWithoutChildItemsInput
  }

  export type FoodRecipeItemUncheckedCreateWithoutRecipeInput = {
    id?: number
    ingredientId?: number | null
    childRecipeId?: number | null
    quantity?: Decimal | DecimalJsLike | number | string
    unit?: string | null
    wastePct?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type FoodRecipeItemCreateOrConnectWithoutRecipeInput = {
    where: FoodRecipeItemWhereUniqueInput
    create: XOR<FoodRecipeItemCreateWithoutRecipeInput, FoodRecipeItemUncheckedCreateWithoutRecipeInput>
  }

  export type FoodRecipeItemCreateManyRecipeInputEnvelope = {
    data: FoodRecipeItemCreateManyRecipeInput | FoodRecipeItemCreateManyRecipeInput[]
  }

  export type FoodRecipeItemCreateWithoutChildRecipeInput = {
    quantity?: Decimal | DecimalJsLike | number | string
    unit?: string | null
    wastePct?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    recipe: FoodRecipeCreateNestedOneWithoutItemsInput
    ingredient?: FoodIngredientCreateNestedOneWithoutItemsInput
  }

  export type FoodRecipeItemUncheckedCreateWithoutChildRecipeInput = {
    id?: number
    recipeId: number
    ingredientId?: number | null
    quantity?: Decimal | DecimalJsLike | number | string
    unit?: string | null
    wastePct?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type FoodRecipeItemCreateOrConnectWithoutChildRecipeInput = {
    where: FoodRecipeItemWhereUniqueInput
    create: XOR<FoodRecipeItemCreateWithoutChildRecipeInput, FoodRecipeItemUncheckedCreateWithoutChildRecipeInput>
  }

  export type FoodRecipeItemCreateManyChildRecipeInputEnvelope = {
    data: FoodRecipeItemCreateManyChildRecipeInput | FoodRecipeItemCreateManyChildRecipeInput[]
  }

  export type FoodRecipeCostCreateWithoutRecipeInput = {
    label: string
    amount?: Decimal | DecimalJsLike | number | string
    costType?: $Enums.FoodCostLineType
    period?: $Enums.FoodCostPeriod
    periodRations?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type FoodRecipeCostUncheckedCreateWithoutRecipeInput = {
    id?: number
    label: string
    amount?: Decimal | DecimalJsLike | number | string
    costType?: $Enums.FoodCostLineType
    period?: $Enums.FoodCostPeriod
    periodRations?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type FoodRecipeCostCreateOrConnectWithoutRecipeInput = {
    where: FoodRecipeCostWhereUniqueInput
    create: XOR<FoodRecipeCostCreateWithoutRecipeInput, FoodRecipeCostUncheckedCreateWithoutRecipeInput>
  }

  export type FoodRecipeCostCreateManyRecipeInputEnvelope = {
    data: FoodRecipeCostCreateManyRecipeInput | FoodRecipeCostCreateManyRecipeInput[]
  }

  export type FoodMealPlanEntryCreateWithoutRecipeInput = {
    dayIndex: number
    mealType: $Enums.FoodMealType
    servings?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: FoodMealPlanCreateNestedOneWithoutEntriesInput
  }

  export type FoodMealPlanEntryUncheckedCreateWithoutRecipeInput = {
    id?: number
    planId: number
    dayIndex: number
    mealType: $Enums.FoodMealType
    servings?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoodMealPlanEntryCreateOrConnectWithoutRecipeInput = {
    where: FoodMealPlanEntryWhereUniqueInput
    create: XOR<FoodMealPlanEntryCreateWithoutRecipeInput, FoodMealPlanEntryUncheckedCreateWithoutRecipeInput>
  }

  export type FoodMealPlanEntryCreateManyRecipeInputEnvelope = {
    data: FoodMealPlanEntryCreateManyRecipeInput | FoodMealPlanEntryCreateManyRecipeInput[]
  }

  export type FoodRecipeItemUpsertWithWhereUniqueWithoutRecipeInput = {
    where: FoodRecipeItemWhereUniqueInput
    update: XOR<FoodRecipeItemUpdateWithoutRecipeInput, FoodRecipeItemUncheckedUpdateWithoutRecipeInput>
    create: XOR<FoodRecipeItemCreateWithoutRecipeInput, FoodRecipeItemUncheckedCreateWithoutRecipeInput>
  }

  export type FoodRecipeItemUpdateWithWhereUniqueWithoutRecipeInput = {
    where: FoodRecipeItemWhereUniqueInput
    data: XOR<FoodRecipeItemUpdateWithoutRecipeInput, FoodRecipeItemUncheckedUpdateWithoutRecipeInput>
  }

  export type FoodRecipeItemUpdateManyWithWhereWithoutRecipeInput = {
    where: FoodRecipeItemScalarWhereInput
    data: XOR<FoodRecipeItemUpdateManyMutationInput, FoodRecipeItemUncheckedUpdateManyWithoutRecipeInput>
  }

  export type FoodRecipeItemUpsertWithWhereUniqueWithoutChildRecipeInput = {
    where: FoodRecipeItemWhereUniqueInput
    update: XOR<FoodRecipeItemUpdateWithoutChildRecipeInput, FoodRecipeItemUncheckedUpdateWithoutChildRecipeInput>
    create: XOR<FoodRecipeItemCreateWithoutChildRecipeInput, FoodRecipeItemUncheckedCreateWithoutChildRecipeInput>
  }

  export type FoodRecipeItemUpdateWithWhereUniqueWithoutChildRecipeInput = {
    where: FoodRecipeItemWhereUniqueInput
    data: XOR<FoodRecipeItemUpdateWithoutChildRecipeInput, FoodRecipeItemUncheckedUpdateWithoutChildRecipeInput>
  }

  export type FoodRecipeItemUpdateManyWithWhereWithoutChildRecipeInput = {
    where: FoodRecipeItemScalarWhereInput
    data: XOR<FoodRecipeItemUpdateManyMutationInput, FoodRecipeItemUncheckedUpdateManyWithoutChildRecipeInput>
  }

  export type FoodRecipeCostUpsertWithWhereUniqueWithoutRecipeInput = {
    where: FoodRecipeCostWhereUniqueInput
    update: XOR<FoodRecipeCostUpdateWithoutRecipeInput, FoodRecipeCostUncheckedUpdateWithoutRecipeInput>
    create: XOR<FoodRecipeCostCreateWithoutRecipeInput, FoodRecipeCostUncheckedCreateWithoutRecipeInput>
  }

  export type FoodRecipeCostUpdateWithWhereUniqueWithoutRecipeInput = {
    where: FoodRecipeCostWhereUniqueInput
    data: XOR<FoodRecipeCostUpdateWithoutRecipeInput, FoodRecipeCostUncheckedUpdateWithoutRecipeInput>
  }

  export type FoodRecipeCostUpdateManyWithWhereWithoutRecipeInput = {
    where: FoodRecipeCostScalarWhereInput
    data: XOR<FoodRecipeCostUpdateManyMutationInput, FoodRecipeCostUncheckedUpdateManyWithoutRecipeInput>
  }

  export type FoodRecipeCostScalarWhereInput = {
    AND?: FoodRecipeCostScalarWhereInput | FoodRecipeCostScalarWhereInput[]
    OR?: FoodRecipeCostScalarWhereInput[]
    NOT?: FoodRecipeCostScalarWhereInput | FoodRecipeCostScalarWhereInput[]
    id?: IntFilter<"FoodRecipeCost"> | number
    recipeId?: IntFilter<"FoodRecipeCost"> | number
    label?: StringFilter<"FoodRecipeCost"> | string
    amount?: DecimalFilter<"FoodRecipeCost"> | Decimal | DecimalJsLike | number | string
    costType?: EnumFoodCostLineTypeFilter<"FoodRecipeCost"> | $Enums.FoodCostLineType
    period?: EnumFoodCostPeriodFilter<"FoodRecipeCost"> | $Enums.FoodCostPeriod
    periodRations?: DecimalNullableFilter<"FoodRecipeCost"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"FoodRecipeCost"> | string | null
    createdAt?: DateTimeFilter<"FoodRecipeCost"> | Date | string
  }

  export type FoodMealPlanEntryUpsertWithWhereUniqueWithoutRecipeInput = {
    where: FoodMealPlanEntryWhereUniqueInput
    update: XOR<FoodMealPlanEntryUpdateWithoutRecipeInput, FoodMealPlanEntryUncheckedUpdateWithoutRecipeInput>
    create: XOR<FoodMealPlanEntryCreateWithoutRecipeInput, FoodMealPlanEntryUncheckedCreateWithoutRecipeInput>
  }

  export type FoodMealPlanEntryUpdateWithWhereUniqueWithoutRecipeInput = {
    where: FoodMealPlanEntryWhereUniqueInput
    data: XOR<FoodMealPlanEntryUpdateWithoutRecipeInput, FoodMealPlanEntryUncheckedUpdateWithoutRecipeInput>
  }

  export type FoodMealPlanEntryUpdateManyWithWhereWithoutRecipeInput = {
    where: FoodMealPlanEntryScalarWhereInput
    data: XOR<FoodMealPlanEntryUpdateManyMutationInput, FoodMealPlanEntryUncheckedUpdateManyWithoutRecipeInput>
  }

  export type FoodMealPlanEntryScalarWhereInput = {
    AND?: FoodMealPlanEntryScalarWhereInput | FoodMealPlanEntryScalarWhereInput[]
    OR?: FoodMealPlanEntryScalarWhereInput[]
    NOT?: FoodMealPlanEntryScalarWhereInput | FoodMealPlanEntryScalarWhereInput[]
    id?: IntFilter<"FoodMealPlanEntry"> | number
    planId?: IntFilter<"FoodMealPlanEntry"> | number
    dayIndex?: IntFilter<"FoodMealPlanEntry"> | number
    mealType?: EnumFoodMealTypeFilter<"FoodMealPlanEntry"> | $Enums.FoodMealType
    recipeId?: IntFilter<"FoodMealPlanEntry"> | number
    servings?: DecimalFilter<"FoodMealPlanEntry"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"FoodMealPlanEntry"> | string | null
    createdAt?: DateTimeFilter<"FoodMealPlanEntry"> | Date | string
    updatedAt?: DateTimeFilter<"FoodMealPlanEntry"> | Date | string
  }

  export type FoodRecipeCreateWithoutItemsInput = {
    name: string
    code?: string | null
    mealType?: $Enums.FoodMealType
    yield?: Decimal | DecimalJsLike | number | string
    yieldUnit?: string | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prepMinutes?: Decimal | DecimalJsLike | number | string | null
    dailyBlocks?: number | null
    childItems?: FoodRecipeItemCreateNestedManyWithoutChildRecipeInput
    extraCosts?: FoodRecipeCostCreateNestedManyWithoutRecipeInput
    mealPlanEntries?: FoodMealPlanEntryCreateNestedManyWithoutRecipeInput
  }

  export type FoodRecipeUncheckedCreateWithoutItemsInput = {
    id?: number
    name: string
    code?: string | null
    mealType?: $Enums.FoodMealType
    yield?: Decimal | DecimalJsLike | number | string
    yieldUnit?: string | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prepMinutes?: Decimal | DecimalJsLike | number | string | null
    dailyBlocks?: number | null
    childItems?: FoodRecipeItemUncheckedCreateNestedManyWithoutChildRecipeInput
    extraCosts?: FoodRecipeCostUncheckedCreateNestedManyWithoutRecipeInput
    mealPlanEntries?: FoodMealPlanEntryUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type FoodRecipeCreateOrConnectWithoutItemsInput = {
    where: FoodRecipeWhereUniqueInput
    create: XOR<FoodRecipeCreateWithoutItemsInput, FoodRecipeUncheckedCreateWithoutItemsInput>
  }

  export type FoodIngredientCreateWithoutItemsInput = {
    name: string
    category?: string | null
    unit?: string | null
    defaultWastePct?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    costs?: FoodIngredientCostCreateNestedManyWithoutIngredientInput
  }

  export type FoodIngredientUncheckedCreateWithoutItemsInput = {
    id?: number
    name: string
    category?: string | null
    unit?: string | null
    defaultWastePct?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    costs?: FoodIngredientCostUncheckedCreateNestedManyWithoutIngredientInput
  }

  export type FoodIngredientCreateOrConnectWithoutItemsInput = {
    where: FoodIngredientWhereUniqueInput
    create: XOR<FoodIngredientCreateWithoutItemsInput, FoodIngredientUncheckedCreateWithoutItemsInput>
  }

  export type FoodRecipeCreateWithoutChildItemsInput = {
    name: string
    code?: string | null
    mealType?: $Enums.FoodMealType
    yield?: Decimal | DecimalJsLike | number | string
    yieldUnit?: string | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prepMinutes?: Decimal | DecimalJsLike | number | string | null
    dailyBlocks?: number | null
    items?: FoodRecipeItemCreateNestedManyWithoutRecipeInput
    extraCosts?: FoodRecipeCostCreateNestedManyWithoutRecipeInput
    mealPlanEntries?: FoodMealPlanEntryCreateNestedManyWithoutRecipeInput
  }

  export type FoodRecipeUncheckedCreateWithoutChildItemsInput = {
    id?: number
    name: string
    code?: string | null
    mealType?: $Enums.FoodMealType
    yield?: Decimal | DecimalJsLike | number | string
    yieldUnit?: string | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prepMinutes?: Decimal | DecimalJsLike | number | string | null
    dailyBlocks?: number | null
    items?: FoodRecipeItemUncheckedCreateNestedManyWithoutRecipeInput
    extraCosts?: FoodRecipeCostUncheckedCreateNestedManyWithoutRecipeInput
    mealPlanEntries?: FoodMealPlanEntryUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type FoodRecipeCreateOrConnectWithoutChildItemsInput = {
    where: FoodRecipeWhereUniqueInput
    create: XOR<FoodRecipeCreateWithoutChildItemsInput, FoodRecipeUncheckedCreateWithoutChildItemsInput>
  }

  export type FoodRecipeUpsertWithoutItemsInput = {
    update: XOR<FoodRecipeUpdateWithoutItemsInput, FoodRecipeUncheckedUpdateWithoutItemsInput>
    create: XOR<FoodRecipeCreateWithoutItemsInput, FoodRecipeUncheckedCreateWithoutItemsInput>
    where?: FoodRecipeWhereInput
  }

  export type FoodRecipeUpdateToOneWithWhereWithoutItemsInput = {
    where?: FoodRecipeWhereInput
    data: XOR<FoodRecipeUpdateWithoutItemsInput, FoodRecipeUncheckedUpdateWithoutItemsInput>
  }

  export type FoodRecipeUpdateWithoutItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    mealType?: EnumFoodMealTypeFieldUpdateOperationsInput | $Enums.FoodMealType
    yield?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    yieldUnit?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepMinutes?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dailyBlocks?: NullableIntFieldUpdateOperationsInput | number | null
    childItems?: FoodRecipeItemUpdateManyWithoutChildRecipeNestedInput
    extraCosts?: FoodRecipeCostUpdateManyWithoutRecipeNestedInput
    mealPlanEntries?: FoodMealPlanEntryUpdateManyWithoutRecipeNestedInput
  }

  export type FoodRecipeUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    mealType?: EnumFoodMealTypeFieldUpdateOperationsInput | $Enums.FoodMealType
    yield?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    yieldUnit?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepMinutes?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dailyBlocks?: NullableIntFieldUpdateOperationsInput | number | null
    childItems?: FoodRecipeItemUncheckedUpdateManyWithoutChildRecipeNestedInput
    extraCosts?: FoodRecipeCostUncheckedUpdateManyWithoutRecipeNestedInput
    mealPlanEntries?: FoodMealPlanEntryUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type FoodIngredientUpsertWithoutItemsInput = {
    update: XOR<FoodIngredientUpdateWithoutItemsInput, FoodIngredientUncheckedUpdateWithoutItemsInput>
    create: XOR<FoodIngredientCreateWithoutItemsInput, FoodIngredientUncheckedCreateWithoutItemsInput>
    where?: FoodIngredientWhereInput
  }

  export type FoodIngredientUpdateToOneWithWhereWithoutItemsInput = {
    where?: FoodIngredientWhereInput
    data: XOR<FoodIngredientUpdateWithoutItemsInput, FoodIngredientUncheckedUpdateWithoutItemsInput>
  }

  export type FoodIngredientUpdateWithoutItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWastePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    costs?: FoodIngredientCostUpdateManyWithoutIngredientNestedInput
  }

  export type FoodIngredientUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWastePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    costs?: FoodIngredientCostUncheckedUpdateManyWithoutIngredientNestedInput
  }

  export type FoodRecipeUpsertWithoutChildItemsInput = {
    update: XOR<FoodRecipeUpdateWithoutChildItemsInput, FoodRecipeUncheckedUpdateWithoutChildItemsInput>
    create: XOR<FoodRecipeCreateWithoutChildItemsInput, FoodRecipeUncheckedCreateWithoutChildItemsInput>
    where?: FoodRecipeWhereInput
  }

  export type FoodRecipeUpdateToOneWithWhereWithoutChildItemsInput = {
    where?: FoodRecipeWhereInput
    data: XOR<FoodRecipeUpdateWithoutChildItemsInput, FoodRecipeUncheckedUpdateWithoutChildItemsInput>
  }

  export type FoodRecipeUpdateWithoutChildItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    mealType?: EnumFoodMealTypeFieldUpdateOperationsInput | $Enums.FoodMealType
    yield?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    yieldUnit?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepMinutes?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dailyBlocks?: NullableIntFieldUpdateOperationsInput | number | null
    items?: FoodRecipeItemUpdateManyWithoutRecipeNestedInput
    extraCosts?: FoodRecipeCostUpdateManyWithoutRecipeNestedInput
    mealPlanEntries?: FoodMealPlanEntryUpdateManyWithoutRecipeNestedInput
  }

  export type FoodRecipeUncheckedUpdateWithoutChildItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    mealType?: EnumFoodMealTypeFieldUpdateOperationsInput | $Enums.FoodMealType
    yield?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    yieldUnit?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepMinutes?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dailyBlocks?: NullableIntFieldUpdateOperationsInput | number | null
    items?: FoodRecipeItemUncheckedUpdateManyWithoutRecipeNestedInput
    extraCosts?: FoodRecipeCostUncheckedUpdateManyWithoutRecipeNestedInput
    mealPlanEntries?: FoodMealPlanEntryUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type FoodRecipeCreateWithoutExtraCostsInput = {
    name: string
    code?: string | null
    mealType?: $Enums.FoodMealType
    yield?: Decimal | DecimalJsLike | number | string
    yieldUnit?: string | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prepMinutes?: Decimal | DecimalJsLike | number | string | null
    dailyBlocks?: number | null
    items?: FoodRecipeItemCreateNestedManyWithoutRecipeInput
    childItems?: FoodRecipeItemCreateNestedManyWithoutChildRecipeInput
    mealPlanEntries?: FoodMealPlanEntryCreateNestedManyWithoutRecipeInput
  }

  export type FoodRecipeUncheckedCreateWithoutExtraCostsInput = {
    id?: number
    name: string
    code?: string | null
    mealType?: $Enums.FoodMealType
    yield?: Decimal | DecimalJsLike | number | string
    yieldUnit?: string | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prepMinutes?: Decimal | DecimalJsLike | number | string | null
    dailyBlocks?: number | null
    items?: FoodRecipeItemUncheckedCreateNestedManyWithoutRecipeInput
    childItems?: FoodRecipeItemUncheckedCreateNestedManyWithoutChildRecipeInput
    mealPlanEntries?: FoodMealPlanEntryUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type FoodRecipeCreateOrConnectWithoutExtraCostsInput = {
    where: FoodRecipeWhereUniqueInput
    create: XOR<FoodRecipeCreateWithoutExtraCostsInput, FoodRecipeUncheckedCreateWithoutExtraCostsInput>
  }

  export type FoodRecipeUpsertWithoutExtraCostsInput = {
    update: XOR<FoodRecipeUpdateWithoutExtraCostsInput, FoodRecipeUncheckedUpdateWithoutExtraCostsInput>
    create: XOR<FoodRecipeCreateWithoutExtraCostsInput, FoodRecipeUncheckedCreateWithoutExtraCostsInput>
    where?: FoodRecipeWhereInput
  }

  export type FoodRecipeUpdateToOneWithWhereWithoutExtraCostsInput = {
    where?: FoodRecipeWhereInput
    data: XOR<FoodRecipeUpdateWithoutExtraCostsInput, FoodRecipeUncheckedUpdateWithoutExtraCostsInput>
  }

  export type FoodRecipeUpdateWithoutExtraCostsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    mealType?: EnumFoodMealTypeFieldUpdateOperationsInput | $Enums.FoodMealType
    yield?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    yieldUnit?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepMinutes?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dailyBlocks?: NullableIntFieldUpdateOperationsInput | number | null
    items?: FoodRecipeItemUpdateManyWithoutRecipeNestedInput
    childItems?: FoodRecipeItemUpdateManyWithoutChildRecipeNestedInput
    mealPlanEntries?: FoodMealPlanEntryUpdateManyWithoutRecipeNestedInput
  }

  export type FoodRecipeUncheckedUpdateWithoutExtraCostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    mealType?: EnumFoodMealTypeFieldUpdateOperationsInput | $Enums.FoodMealType
    yield?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    yieldUnit?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepMinutes?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dailyBlocks?: NullableIntFieldUpdateOperationsInput | number | null
    items?: FoodRecipeItemUncheckedUpdateManyWithoutRecipeNestedInput
    childItems?: FoodRecipeItemUncheckedUpdateManyWithoutChildRecipeNestedInput
    mealPlanEntries?: FoodMealPlanEntryUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type FoodMealPlanEntryCreateWithoutPlanInput = {
    dayIndex: number
    mealType: $Enums.FoodMealType
    servings?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recipe: FoodRecipeCreateNestedOneWithoutMealPlanEntriesInput
  }

  export type FoodMealPlanEntryUncheckedCreateWithoutPlanInput = {
    id?: number
    dayIndex: number
    mealType: $Enums.FoodMealType
    recipeId: number
    servings?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoodMealPlanEntryCreateOrConnectWithoutPlanInput = {
    where: FoodMealPlanEntryWhereUniqueInput
    create: XOR<FoodMealPlanEntryCreateWithoutPlanInput, FoodMealPlanEntryUncheckedCreateWithoutPlanInput>
  }

  export type FoodMealPlanEntryCreateManyPlanInputEnvelope = {
    data: FoodMealPlanEntryCreateManyPlanInput | FoodMealPlanEntryCreateManyPlanInput[]
  }

  export type FoodMealPlanEntryUpsertWithWhereUniqueWithoutPlanInput = {
    where: FoodMealPlanEntryWhereUniqueInput
    update: XOR<FoodMealPlanEntryUpdateWithoutPlanInput, FoodMealPlanEntryUncheckedUpdateWithoutPlanInput>
    create: XOR<FoodMealPlanEntryCreateWithoutPlanInput, FoodMealPlanEntryUncheckedCreateWithoutPlanInput>
  }

  export type FoodMealPlanEntryUpdateWithWhereUniqueWithoutPlanInput = {
    where: FoodMealPlanEntryWhereUniqueInput
    data: XOR<FoodMealPlanEntryUpdateWithoutPlanInput, FoodMealPlanEntryUncheckedUpdateWithoutPlanInput>
  }

  export type FoodMealPlanEntryUpdateManyWithWhereWithoutPlanInput = {
    where: FoodMealPlanEntryScalarWhereInput
    data: XOR<FoodMealPlanEntryUpdateManyMutationInput, FoodMealPlanEntryUncheckedUpdateManyWithoutPlanInput>
  }

  export type FoodMealPlanCreateWithoutEntriesInput = {
    name: string
    weekStart?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoodMealPlanUncheckedCreateWithoutEntriesInput = {
    id?: number
    name: string
    weekStart?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoodMealPlanCreateOrConnectWithoutEntriesInput = {
    where: FoodMealPlanWhereUniqueInput
    create: XOR<FoodMealPlanCreateWithoutEntriesInput, FoodMealPlanUncheckedCreateWithoutEntriesInput>
  }

  export type FoodRecipeCreateWithoutMealPlanEntriesInput = {
    name: string
    code?: string | null
    mealType?: $Enums.FoodMealType
    yield?: Decimal | DecimalJsLike | number | string
    yieldUnit?: string | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prepMinutes?: Decimal | DecimalJsLike | number | string | null
    dailyBlocks?: number | null
    items?: FoodRecipeItemCreateNestedManyWithoutRecipeInput
    childItems?: FoodRecipeItemCreateNestedManyWithoutChildRecipeInput
    extraCosts?: FoodRecipeCostCreateNestedManyWithoutRecipeInput
  }

  export type FoodRecipeUncheckedCreateWithoutMealPlanEntriesInput = {
    id?: number
    name: string
    code?: string | null
    mealType?: $Enums.FoodMealType
    yield?: Decimal | DecimalJsLike | number | string
    yieldUnit?: string | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prepMinutes?: Decimal | DecimalJsLike | number | string | null
    dailyBlocks?: number | null
    items?: FoodRecipeItemUncheckedCreateNestedManyWithoutRecipeInput
    childItems?: FoodRecipeItemUncheckedCreateNestedManyWithoutChildRecipeInput
    extraCosts?: FoodRecipeCostUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type FoodRecipeCreateOrConnectWithoutMealPlanEntriesInput = {
    where: FoodRecipeWhereUniqueInput
    create: XOR<FoodRecipeCreateWithoutMealPlanEntriesInput, FoodRecipeUncheckedCreateWithoutMealPlanEntriesInput>
  }

  export type FoodMealPlanUpsertWithoutEntriesInput = {
    update: XOR<FoodMealPlanUpdateWithoutEntriesInput, FoodMealPlanUncheckedUpdateWithoutEntriesInput>
    create: XOR<FoodMealPlanCreateWithoutEntriesInput, FoodMealPlanUncheckedCreateWithoutEntriesInput>
    where?: FoodMealPlanWhereInput
  }

  export type FoodMealPlanUpdateToOneWithWhereWithoutEntriesInput = {
    where?: FoodMealPlanWhereInput
    data: XOR<FoodMealPlanUpdateWithoutEntriesInput, FoodMealPlanUncheckedUpdateWithoutEntriesInput>
  }

  export type FoodMealPlanUpdateWithoutEntriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    weekStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodMealPlanUncheckedUpdateWithoutEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    weekStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodRecipeUpsertWithoutMealPlanEntriesInput = {
    update: XOR<FoodRecipeUpdateWithoutMealPlanEntriesInput, FoodRecipeUncheckedUpdateWithoutMealPlanEntriesInput>
    create: XOR<FoodRecipeCreateWithoutMealPlanEntriesInput, FoodRecipeUncheckedCreateWithoutMealPlanEntriesInput>
    where?: FoodRecipeWhereInput
  }

  export type FoodRecipeUpdateToOneWithWhereWithoutMealPlanEntriesInput = {
    where?: FoodRecipeWhereInput
    data: XOR<FoodRecipeUpdateWithoutMealPlanEntriesInput, FoodRecipeUncheckedUpdateWithoutMealPlanEntriesInput>
  }

  export type FoodRecipeUpdateWithoutMealPlanEntriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    mealType?: EnumFoodMealTypeFieldUpdateOperationsInput | $Enums.FoodMealType
    yield?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    yieldUnit?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepMinutes?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dailyBlocks?: NullableIntFieldUpdateOperationsInput | number | null
    items?: FoodRecipeItemUpdateManyWithoutRecipeNestedInput
    childItems?: FoodRecipeItemUpdateManyWithoutChildRecipeNestedInput
    extraCosts?: FoodRecipeCostUpdateManyWithoutRecipeNestedInput
  }

  export type FoodRecipeUncheckedUpdateWithoutMealPlanEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    mealType?: EnumFoodMealTypeFieldUpdateOperationsInput | $Enums.FoodMealType
    yield?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    yieldUnit?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepMinutes?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dailyBlocks?: NullableIntFieldUpdateOperationsInput | number | null
    items?: FoodRecipeItemUncheckedUpdateManyWithoutRecipeNestedInput
    childItems?: FoodRecipeItemUncheckedUpdateManyWithoutChildRecipeNestedInput
    extraCosts?: FoodRecipeCostUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type QuotationAttachmentCreateWithoutProcessInput = {
    type?: $Enums.QuotationAttachmentType
    originalName: string
    storagePath: string
    mimeType?: string | null
    sizeBytes?: number | null
    checksum?: string | null
    parsed?: boolean
    parsedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    quotation?: QuotationCreateNestedOneWithoutAttachmentsInput
  }

  export type QuotationAttachmentUncheckedCreateWithoutProcessInput = {
    id?: number
    quotationId?: number | null
    type?: $Enums.QuotationAttachmentType
    originalName: string
    storagePath: string
    mimeType?: string | null
    sizeBytes?: number | null
    checksum?: string | null
    parsed?: boolean
    parsedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuotationAttachmentCreateOrConnectWithoutProcessInput = {
    where: QuotationAttachmentWhereUniqueInput
    create: XOR<QuotationAttachmentCreateWithoutProcessInput, QuotationAttachmentUncheckedCreateWithoutProcessInput>
  }

  export type QuotationBaselineItemCreateWithoutProcessInput = {
    sheetName?: string | null
    sectionPath?: string | null
    itemCode?: string | null
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    material?: MaterialCreateNestedOneWithoutBaseQuotesInput
    quoteItems?: QuotationItemCreateNestedManyWithoutBaselineItemInput
    orderLines?: PurchaseOrderLineCreateNestedManyWithoutBaselineInput
    deliveryItems?: PurchaseDeliveryItemCreateNestedManyWithoutBaselineInput
  }

  export type QuotationBaselineItemUncheckedCreateWithoutProcessInput = {
    id?: number
    materialId?: number | null
    sheetName?: string | null
    sectionPath?: string | null
    itemCode?: string | null
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    quoteItems?: QuotationItemUncheckedCreateNestedManyWithoutBaselineItemInput
    orderLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutBaselineInput
    deliveryItems?: PurchaseDeliveryItemUncheckedCreateNestedManyWithoutBaselineInput
  }

  export type QuotationBaselineItemCreateOrConnectWithoutProcessInput = {
    where: QuotationBaselineItemWhereUniqueInput
    create: XOR<QuotationBaselineItemCreateWithoutProcessInput, QuotationBaselineItemUncheckedCreateWithoutProcessInput>
  }

  export type QuotationBaselineItemCreateManyProcessInputEnvelope = {
    data: QuotationBaselineItemCreateManyProcessInput | QuotationBaselineItemCreateManyProcessInput[]
  }

  export type QuotationCreateWithoutProcessInput = {
    supplierName?: string | null
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    submittedAt?: Date | string | null
    status?: $Enums.QuotationStatus
    totalAmount?: Decimal | DecimalJsLike | number | string | null
    totalAmountPen?: Decimal | DecimalJsLike | number | string | null
    qualityScore?: number | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    proveedor?: ProveedorCreateNestedOneWithoutQuotationsInput
    items?: QuotationItemCreateNestedManyWithoutQuotationInput
    attachments?: QuotationAttachmentCreateNestedManyWithoutQuotationInput
    purchaseOrders?: PurchaseOrderLogCreateNestedManyWithoutQuotationInput
  }

  export type QuotationUncheckedCreateWithoutProcessInput = {
    id?: number
    proveedorId?: number | null
    supplierName?: string | null
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    submittedAt?: Date | string | null
    status?: $Enums.QuotationStatus
    totalAmount?: Decimal | DecimalJsLike | number | string | null
    totalAmountPen?: Decimal | DecimalJsLike | number | string | null
    qualityScore?: number | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: QuotationItemUncheckedCreateNestedManyWithoutQuotationInput
    attachments?: QuotationAttachmentUncheckedCreateNestedManyWithoutQuotationInput
    purchaseOrders?: PurchaseOrderLogUncheckedCreateNestedManyWithoutQuotationInput
  }

  export type QuotationCreateOrConnectWithoutProcessInput = {
    where: QuotationWhereUniqueInput
    create: XOR<QuotationCreateWithoutProcessInput, QuotationUncheckedCreateWithoutProcessInput>
  }

  export type QuotationCreateManyProcessInputEnvelope = {
    data: QuotationCreateManyProcessInput | QuotationCreateManyProcessInput[]
  }

  export type PurchaseOrderLogCreateWithoutProcessInput = {
    supplierId?: number | null
    supplierName: string
    orderNumber: string
    sequence?: number
    issueDate?: Date | string
    currency?: string
    subtotal?: Decimal | DecimalJsLike | number | string | null
    discount?: Decimal | DecimalJsLike | number | string | null
    netSubtotal?: Decimal | DecimalJsLike | number | string | null
    igv?: Decimal | DecimalJsLike | number | string | null
    total?: Decimal | DecimalJsLike | number | string | null
    totalsJson?: NullableJsonNullValueInput | InputJsonValue
    itemsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    quotation?: QuotationCreateNestedOneWithoutPurchaseOrdersInput
    lines?: PurchaseOrderLineCreateNestedManyWithoutOrderInput
    deliveries?: PurchaseDeliveryLogCreateNestedManyWithoutOrderInput
  }

  export type PurchaseOrderLogUncheckedCreateWithoutProcessInput = {
    id?: number
    quotationId?: number | null
    supplierId?: number | null
    supplierName: string
    orderNumber: string
    sequence?: number
    issueDate?: Date | string
    currency?: string
    subtotal?: Decimal | DecimalJsLike | number | string | null
    discount?: Decimal | DecimalJsLike | number | string | null
    netSubtotal?: Decimal | DecimalJsLike | number | string | null
    igv?: Decimal | DecimalJsLike | number | string | null
    total?: Decimal | DecimalJsLike | number | string | null
    totalsJson?: NullableJsonNullValueInput | InputJsonValue
    itemsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutOrderInput
    deliveries?: PurchaseDeliveryLogUncheckedCreateNestedManyWithoutOrderInput
  }

  export type PurchaseOrderLogCreateOrConnectWithoutProcessInput = {
    where: PurchaseOrderLogWhereUniqueInput
    create: XOR<PurchaseOrderLogCreateWithoutProcessInput, PurchaseOrderLogUncheckedCreateWithoutProcessInput>
  }

  export type PurchaseOrderLogCreateManyProcessInputEnvelope = {
    data: PurchaseOrderLogCreateManyProcessInput | PurchaseOrderLogCreateManyProcessInput[]
  }

  export type PurchaseDeliveryLogCreateWithoutProcessInput = {
    supplierName?: string | null
    guideNumber?: string | null
    date?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: PurchaseOrderLogCreateNestedOneWithoutDeliveriesInput
    proveedor?: ProveedorCreateNestedOneWithoutDeliveriesInput
    items?: PurchaseDeliveryItemCreateNestedManyWithoutDeliveryInput
  }

  export type PurchaseDeliveryLogUncheckedCreateWithoutProcessInput = {
    id?: number
    orderId?: number | null
    proveedorId?: number | null
    supplierName?: string | null
    guideNumber?: string | null
    date?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseDeliveryItemUncheckedCreateNestedManyWithoutDeliveryInput
  }

  export type PurchaseDeliveryLogCreateOrConnectWithoutProcessInput = {
    where: PurchaseDeliveryLogWhereUniqueInput
    create: XOR<PurchaseDeliveryLogCreateWithoutProcessInput, PurchaseDeliveryLogUncheckedCreateWithoutProcessInput>
  }

  export type PurchaseDeliveryLogCreateManyProcessInputEnvelope = {
    data: PurchaseDeliveryLogCreateManyProcessInput | PurchaseDeliveryLogCreateManyProcessInput[]
  }

  export type QuotationAttachmentUpsertWithoutProcessInput = {
    update: XOR<QuotationAttachmentUpdateWithoutProcessInput, QuotationAttachmentUncheckedUpdateWithoutProcessInput>
    create: XOR<QuotationAttachmentCreateWithoutProcessInput, QuotationAttachmentUncheckedCreateWithoutProcessInput>
    where?: QuotationAttachmentWhereInput
  }

  export type QuotationAttachmentUpdateToOneWithWhereWithoutProcessInput = {
    where?: QuotationAttachmentWhereInput
    data: XOR<QuotationAttachmentUpdateWithoutProcessInput, QuotationAttachmentUncheckedUpdateWithoutProcessInput>
  }

  export type QuotationAttachmentUpdateWithoutProcessInput = {
    type?: EnumQuotationAttachmentTypeFieldUpdateOperationsInput | $Enums.QuotationAttachmentType
    originalName?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    parsed?: BoolFieldUpdateOperationsInput | boolean
    parsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotation?: QuotationUpdateOneWithoutAttachmentsNestedInput
  }

  export type QuotationAttachmentUncheckedUpdateWithoutProcessInput = {
    id?: IntFieldUpdateOperationsInput | number
    quotationId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumQuotationAttachmentTypeFieldUpdateOperationsInput | $Enums.QuotationAttachmentType
    originalName?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    parsed?: BoolFieldUpdateOperationsInput | boolean
    parsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotationBaselineItemUpsertWithWhereUniqueWithoutProcessInput = {
    where: QuotationBaselineItemWhereUniqueInput
    update: XOR<QuotationBaselineItemUpdateWithoutProcessInput, QuotationBaselineItemUncheckedUpdateWithoutProcessInput>
    create: XOR<QuotationBaselineItemCreateWithoutProcessInput, QuotationBaselineItemUncheckedCreateWithoutProcessInput>
  }

  export type QuotationBaselineItemUpdateWithWhereUniqueWithoutProcessInput = {
    where: QuotationBaselineItemWhereUniqueInput
    data: XOR<QuotationBaselineItemUpdateWithoutProcessInput, QuotationBaselineItemUncheckedUpdateWithoutProcessInput>
  }

  export type QuotationBaselineItemUpdateManyWithWhereWithoutProcessInput = {
    where: QuotationBaselineItemScalarWhereInput
    data: XOR<QuotationBaselineItemUpdateManyMutationInput, QuotationBaselineItemUncheckedUpdateManyWithoutProcessInput>
  }

  export type QuotationUpsertWithWhereUniqueWithoutProcessInput = {
    where: QuotationWhereUniqueInput
    update: XOR<QuotationUpdateWithoutProcessInput, QuotationUncheckedUpdateWithoutProcessInput>
    create: XOR<QuotationCreateWithoutProcessInput, QuotationUncheckedCreateWithoutProcessInput>
  }

  export type QuotationUpdateWithWhereUniqueWithoutProcessInput = {
    where: QuotationWhereUniqueInput
    data: XOR<QuotationUpdateWithoutProcessInput, QuotationUncheckedUpdateWithoutProcessInput>
  }

  export type QuotationUpdateManyWithWhereWithoutProcessInput = {
    where: QuotationScalarWhereInput
    data: XOR<QuotationUpdateManyMutationInput, QuotationUncheckedUpdateManyWithoutProcessInput>
  }

  export type PurchaseOrderLogUpsertWithWhereUniqueWithoutProcessInput = {
    where: PurchaseOrderLogWhereUniqueInput
    update: XOR<PurchaseOrderLogUpdateWithoutProcessInput, PurchaseOrderLogUncheckedUpdateWithoutProcessInput>
    create: XOR<PurchaseOrderLogCreateWithoutProcessInput, PurchaseOrderLogUncheckedCreateWithoutProcessInput>
  }

  export type PurchaseOrderLogUpdateWithWhereUniqueWithoutProcessInput = {
    where: PurchaseOrderLogWhereUniqueInput
    data: XOR<PurchaseOrderLogUpdateWithoutProcessInput, PurchaseOrderLogUncheckedUpdateWithoutProcessInput>
  }

  export type PurchaseOrderLogUpdateManyWithWhereWithoutProcessInput = {
    where: PurchaseOrderLogScalarWhereInput
    data: XOR<PurchaseOrderLogUpdateManyMutationInput, PurchaseOrderLogUncheckedUpdateManyWithoutProcessInput>
  }

  export type PurchaseOrderLogScalarWhereInput = {
    AND?: PurchaseOrderLogScalarWhereInput | PurchaseOrderLogScalarWhereInput[]
    OR?: PurchaseOrderLogScalarWhereInput[]
    NOT?: PurchaseOrderLogScalarWhereInput | PurchaseOrderLogScalarWhereInput[]
    id?: IntFilter<"PurchaseOrderLog"> | number
    processId?: IntFilter<"PurchaseOrderLog"> | number
    quotationId?: IntNullableFilter<"PurchaseOrderLog"> | number | null
    supplierId?: IntNullableFilter<"PurchaseOrderLog"> | number | null
    supplierName?: StringFilter<"PurchaseOrderLog"> | string
    orderNumber?: StringFilter<"PurchaseOrderLog"> | string
    sequence?: IntFilter<"PurchaseOrderLog"> | number
    issueDate?: DateTimeFilter<"PurchaseOrderLog"> | Date | string
    currency?: StringFilter<"PurchaseOrderLog"> | string
    subtotal?: DecimalNullableFilter<"PurchaseOrderLog"> | Decimal | DecimalJsLike | number | string | null
    discount?: DecimalNullableFilter<"PurchaseOrderLog"> | Decimal | DecimalJsLike | number | string | null
    netSubtotal?: DecimalNullableFilter<"PurchaseOrderLog"> | Decimal | DecimalJsLike | number | string | null
    igv?: DecimalNullableFilter<"PurchaseOrderLog"> | Decimal | DecimalJsLike | number | string | null
    total?: DecimalNullableFilter<"PurchaseOrderLog"> | Decimal | DecimalJsLike | number | string | null
    totalsJson?: JsonNullableFilter<"PurchaseOrderLog">
    itemsJson?: JsonNullableFilter<"PurchaseOrderLog">
    createdAt?: DateTimeFilter<"PurchaseOrderLog"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrderLog"> | Date | string
  }

  export type PurchaseDeliveryLogUpsertWithWhereUniqueWithoutProcessInput = {
    where: PurchaseDeliveryLogWhereUniqueInput
    update: XOR<PurchaseDeliveryLogUpdateWithoutProcessInput, PurchaseDeliveryLogUncheckedUpdateWithoutProcessInput>
    create: XOR<PurchaseDeliveryLogCreateWithoutProcessInput, PurchaseDeliveryLogUncheckedCreateWithoutProcessInput>
  }

  export type PurchaseDeliveryLogUpdateWithWhereUniqueWithoutProcessInput = {
    where: PurchaseDeliveryLogWhereUniqueInput
    data: XOR<PurchaseDeliveryLogUpdateWithoutProcessInput, PurchaseDeliveryLogUncheckedUpdateWithoutProcessInput>
  }

  export type PurchaseDeliveryLogUpdateManyWithWhereWithoutProcessInput = {
    where: PurchaseDeliveryLogScalarWhereInput
    data: XOR<PurchaseDeliveryLogUpdateManyMutationInput, PurchaseDeliveryLogUncheckedUpdateManyWithoutProcessInput>
  }

  export type QuotationProcessCreateWithoutBaselinesInput = {
    name: string
    code?: string | null
    status?: $Enums.QuotationProcessStatus
    baseCurrency?: string
    targetCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    targetMarginPct?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    baselineFile?: QuotationAttachmentCreateNestedOneWithoutProcessInput
    quotations?: QuotationCreateNestedManyWithoutProcessInput
    purchaseOrders?: PurchaseOrderLogCreateNestedManyWithoutProcessInput
    deliveryLogs?: PurchaseDeliveryLogCreateNestedManyWithoutProcessInput
  }

  export type QuotationProcessUncheckedCreateWithoutBaselinesInput = {
    id?: number
    name: string
    code?: string | null
    status?: $Enums.QuotationProcessStatus
    baseCurrency?: string
    targetCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    targetMarginPct?: Decimal | DecimalJsLike | number | string | null
    baselineFileId?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quotations?: QuotationUncheckedCreateNestedManyWithoutProcessInput
    purchaseOrders?: PurchaseOrderLogUncheckedCreateNestedManyWithoutProcessInput
    deliveryLogs?: PurchaseDeliveryLogUncheckedCreateNestedManyWithoutProcessInput
  }

  export type QuotationProcessCreateOrConnectWithoutBaselinesInput = {
    where: QuotationProcessWhereUniqueInput
    create: XOR<QuotationProcessCreateWithoutBaselinesInput, QuotationProcessUncheckedCreateWithoutBaselinesInput>
  }

  export type MaterialCreateWithoutBaseQuotesInput = {
    code?: string | null
    name: string
    unit?: string | null
    minStock?: Decimal | DecimalJsLike | number | string
    reorderQuantity?: Decimal | DecimalJsLike | number | string
    allowNegative?: boolean
    isCompanyAsset?: boolean
    assetStatus?: $Enums.AssetStatus
    assetResponsible?: string | null
    group?: MaterialGroupCreateNestedOneWithoutMaterialsInput
    moves?: MoveCreateNestedManyWithoutMaterialInput
    expenses?: ExpenseCreateNestedManyWithoutMaterialInput
    quoteItems?: QuotationItemCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUncheckedCreateWithoutBaseQuotesInput = {
    id?: number
    code?: string | null
    name: string
    unit?: string | null
    groupId?: number | null
    minStock?: Decimal | DecimalJsLike | number | string
    reorderQuantity?: Decimal | DecimalJsLike | number | string
    allowNegative?: boolean
    isCompanyAsset?: boolean
    assetStatus?: $Enums.AssetStatus
    assetResponsible?: string | null
    moves?: MoveUncheckedCreateNestedManyWithoutMaterialInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutMaterialInput
    quoteItems?: QuotationItemUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type MaterialCreateOrConnectWithoutBaseQuotesInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutBaseQuotesInput, MaterialUncheckedCreateWithoutBaseQuotesInput>
  }

  export type QuotationItemCreateWithoutBaselineItemInput = {
    sourceRow?: number | null
    itemCode?: string | null
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    normalizedPrice?: Decimal | DecimalJsLike | number | string | null
    matchScore?: number | null
    extraAttributes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    quotation: QuotationCreateNestedOneWithoutItemsInput
    material?: MaterialCreateNestedOneWithoutQuoteItemsInput
  }

  export type QuotationItemUncheckedCreateWithoutBaselineItemInput = {
    id?: number
    quotationId: number
    materialId?: number | null
    sourceRow?: number | null
    itemCode?: string | null
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    normalizedPrice?: Decimal | DecimalJsLike | number | string | null
    matchScore?: number | null
    extraAttributes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuotationItemCreateOrConnectWithoutBaselineItemInput = {
    where: QuotationItemWhereUniqueInput
    create: XOR<QuotationItemCreateWithoutBaselineItemInput, QuotationItemUncheckedCreateWithoutBaselineItemInput>
  }

  export type QuotationItemCreateManyBaselineItemInputEnvelope = {
    data: QuotationItemCreateManyBaselineItemInput | QuotationItemCreateManyBaselineItemInput[]
  }

  export type PurchaseOrderLineCreateWithoutBaselineInput = {
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    order: PurchaseOrderLogCreateNestedOneWithoutLinesInput
    deliveries?: PurchaseDeliveryItemCreateNestedManyWithoutOrderLineInput
  }

  export type PurchaseOrderLineUncheckedCreateWithoutBaselineInput = {
    id?: number
    orderId: number
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: PurchaseDeliveryItemUncheckedCreateNestedManyWithoutOrderLineInput
  }

  export type PurchaseOrderLineCreateOrConnectWithoutBaselineInput = {
    where: PurchaseOrderLineWhereUniqueInput
    create: XOR<PurchaseOrderLineCreateWithoutBaselineInput, PurchaseOrderLineUncheckedCreateWithoutBaselineInput>
  }

  export type PurchaseOrderLineCreateManyBaselineInputEnvelope = {
    data: PurchaseOrderLineCreateManyBaselineInput | PurchaseOrderLineCreateManyBaselineInput[]
  }

  export type PurchaseDeliveryItemCreateWithoutBaselineInput = {
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    delivery: PurchaseDeliveryLogCreateNestedOneWithoutItemsInput
    orderLine?: PurchaseOrderLineCreateNestedOneWithoutDeliveriesInput
  }

  export type PurchaseDeliveryItemUncheckedCreateWithoutBaselineInput = {
    id?: number
    deliveryId: number
    orderLineId?: number | null
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseDeliveryItemCreateOrConnectWithoutBaselineInput = {
    where: PurchaseDeliveryItemWhereUniqueInput
    create: XOR<PurchaseDeliveryItemCreateWithoutBaselineInput, PurchaseDeliveryItemUncheckedCreateWithoutBaselineInput>
  }

  export type PurchaseDeliveryItemCreateManyBaselineInputEnvelope = {
    data: PurchaseDeliveryItemCreateManyBaselineInput | PurchaseDeliveryItemCreateManyBaselineInput[]
  }

  export type QuotationProcessUpsertWithoutBaselinesInput = {
    update: XOR<QuotationProcessUpdateWithoutBaselinesInput, QuotationProcessUncheckedUpdateWithoutBaselinesInput>
    create: XOR<QuotationProcessCreateWithoutBaselinesInput, QuotationProcessUncheckedCreateWithoutBaselinesInput>
    where?: QuotationProcessWhereInput
  }

  export type QuotationProcessUpdateToOneWithWhereWithoutBaselinesInput = {
    where?: QuotationProcessWhereInput
    data: XOR<QuotationProcessUpdateWithoutBaselinesInput, QuotationProcessUncheckedUpdateWithoutBaselinesInput>
  }

  export type QuotationProcessUpdateWithoutBaselinesInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuotationProcessStatusFieldUpdateOperationsInput | $Enums.QuotationProcessStatus
    baseCurrency?: StringFieldUpdateOperationsInput | string
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    targetMarginPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baselineFile?: QuotationAttachmentUpdateOneWithoutProcessNestedInput
    quotations?: QuotationUpdateManyWithoutProcessNestedInput
    purchaseOrders?: PurchaseOrderLogUpdateManyWithoutProcessNestedInput
    deliveryLogs?: PurchaseDeliveryLogUpdateManyWithoutProcessNestedInput
  }

  export type QuotationProcessUncheckedUpdateWithoutBaselinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuotationProcessStatusFieldUpdateOperationsInput | $Enums.QuotationProcessStatus
    baseCurrency?: StringFieldUpdateOperationsInput | string
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    targetMarginPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baselineFileId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotations?: QuotationUncheckedUpdateManyWithoutProcessNestedInput
    purchaseOrders?: PurchaseOrderLogUncheckedUpdateManyWithoutProcessNestedInput
    deliveryLogs?: PurchaseDeliveryLogUncheckedUpdateManyWithoutProcessNestedInput
  }

  export type MaterialUpsertWithoutBaseQuotesInput = {
    update: XOR<MaterialUpdateWithoutBaseQuotesInput, MaterialUncheckedUpdateWithoutBaseQuotesInput>
    create: XOR<MaterialCreateWithoutBaseQuotesInput, MaterialUncheckedCreateWithoutBaseQuotesInput>
    where?: MaterialWhereInput
  }

  export type MaterialUpdateToOneWithWhereWithoutBaseQuotesInput = {
    where?: MaterialWhereInput
    data: XOR<MaterialUpdateWithoutBaseQuotesInput, MaterialUncheckedUpdateWithoutBaseQuotesInput>
  }

  export type MaterialUpdateWithoutBaseQuotesInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowNegative?: BoolFieldUpdateOperationsInput | boolean
    isCompanyAsset?: BoolFieldUpdateOperationsInput | boolean
    assetStatus?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    assetResponsible?: NullableStringFieldUpdateOperationsInput | string | null
    group?: MaterialGroupUpdateOneWithoutMaterialsNestedInput
    moves?: MoveUpdateManyWithoutMaterialNestedInput
    expenses?: ExpenseUpdateManyWithoutMaterialNestedInput
    quoteItems?: QuotationItemUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateWithoutBaseQuotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: NullableIntFieldUpdateOperationsInput | number | null
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowNegative?: BoolFieldUpdateOperationsInput | boolean
    isCompanyAsset?: BoolFieldUpdateOperationsInput | boolean
    assetStatus?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    assetResponsible?: NullableStringFieldUpdateOperationsInput | string | null
    moves?: MoveUncheckedUpdateManyWithoutMaterialNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutMaterialNestedInput
    quoteItems?: QuotationItemUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type QuotationItemUpsertWithWhereUniqueWithoutBaselineItemInput = {
    where: QuotationItemWhereUniqueInput
    update: XOR<QuotationItemUpdateWithoutBaselineItemInput, QuotationItemUncheckedUpdateWithoutBaselineItemInput>
    create: XOR<QuotationItemCreateWithoutBaselineItemInput, QuotationItemUncheckedCreateWithoutBaselineItemInput>
  }

  export type QuotationItemUpdateWithWhereUniqueWithoutBaselineItemInput = {
    where: QuotationItemWhereUniqueInput
    data: XOR<QuotationItemUpdateWithoutBaselineItemInput, QuotationItemUncheckedUpdateWithoutBaselineItemInput>
  }

  export type QuotationItemUpdateManyWithWhereWithoutBaselineItemInput = {
    where: QuotationItemScalarWhereInput
    data: XOR<QuotationItemUpdateManyMutationInput, QuotationItemUncheckedUpdateManyWithoutBaselineItemInput>
  }

  export type PurchaseOrderLineUpsertWithWhereUniqueWithoutBaselineInput = {
    where: PurchaseOrderLineWhereUniqueInput
    update: XOR<PurchaseOrderLineUpdateWithoutBaselineInput, PurchaseOrderLineUncheckedUpdateWithoutBaselineInput>
    create: XOR<PurchaseOrderLineCreateWithoutBaselineInput, PurchaseOrderLineUncheckedCreateWithoutBaselineInput>
  }

  export type PurchaseOrderLineUpdateWithWhereUniqueWithoutBaselineInput = {
    where: PurchaseOrderLineWhereUniqueInput
    data: XOR<PurchaseOrderLineUpdateWithoutBaselineInput, PurchaseOrderLineUncheckedUpdateWithoutBaselineInput>
  }

  export type PurchaseOrderLineUpdateManyWithWhereWithoutBaselineInput = {
    where: PurchaseOrderLineScalarWhereInput
    data: XOR<PurchaseOrderLineUpdateManyMutationInput, PurchaseOrderLineUncheckedUpdateManyWithoutBaselineInput>
  }

  export type PurchaseOrderLineScalarWhereInput = {
    AND?: PurchaseOrderLineScalarWhereInput | PurchaseOrderLineScalarWhereInput[]
    OR?: PurchaseOrderLineScalarWhereInput[]
    NOT?: PurchaseOrderLineScalarWhereInput | PurchaseOrderLineScalarWhereInput[]
    id?: IntFilter<"PurchaseOrderLine"> | number
    orderId?: IntFilter<"PurchaseOrderLine"> | number
    baselineId?: IntNullableFilter<"PurchaseOrderLine"> | number | null
    description?: StringFilter<"PurchaseOrderLine"> | string
    unit?: StringNullableFilter<"PurchaseOrderLine"> | string | null
    quantity?: DecimalNullableFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string | null
    unitPrice?: DecimalNullableFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string | null
    totalPrice?: DecimalNullableFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string | null
    metadata?: JsonNullableFilter<"PurchaseOrderLine">
    createdAt?: DateTimeFilter<"PurchaseOrderLine"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrderLine"> | Date | string
  }

  export type PurchaseDeliveryItemUpsertWithWhereUniqueWithoutBaselineInput = {
    where: PurchaseDeliveryItemWhereUniqueInput
    update: XOR<PurchaseDeliveryItemUpdateWithoutBaselineInput, PurchaseDeliveryItemUncheckedUpdateWithoutBaselineInput>
    create: XOR<PurchaseDeliveryItemCreateWithoutBaselineInput, PurchaseDeliveryItemUncheckedCreateWithoutBaselineInput>
  }

  export type PurchaseDeliveryItemUpdateWithWhereUniqueWithoutBaselineInput = {
    where: PurchaseDeliveryItemWhereUniqueInput
    data: XOR<PurchaseDeliveryItemUpdateWithoutBaselineInput, PurchaseDeliveryItemUncheckedUpdateWithoutBaselineInput>
  }

  export type PurchaseDeliveryItemUpdateManyWithWhereWithoutBaselineInput = {
    where: PurchaseDeliveryItemScalarWhereInput
    data: XOR<PurchaseDeliveryItemUpdateManyMutationInput, PurchaseDeliveryItemUncheckedUpdateManyWithoutBaselineInput>
  }

  export type PurchaseDeliveryItemScalarWhereInput = {
    AND?: PurchaseDeliveryItemScalarWhereInput | PurchaseDeliveryItemScalarWhereInput[]
    OR?: PurchaseDeliveryItemScalarWhereInput[]
    NOT?: PurchaseDeliveryItemScalarWhereInput | PurchaseDeliveryItemScalarWhereInput[]
    id?: IntFilter<"PurchaseDeliveryItem"> | number
    deliveryId?: IntFilter<"PurchaseDeliveryItem"> | number
    orderLineId?: IntNullableFilter<"PurchaseDeliveryItem"> | number | null
    baselineId?: IntNullableFilter<"PurchaseDeliveryItem"> | number | null
    description?: StringFilter<"PurchaseDeliveryItem"> | string
    unit?: StringNullableFilter<"PurchaseDeliveryItem"> | string | null
    quantity?: DecimalNullableFilter<"PurchaseDeliveryItem"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"PurchaseDeliveryItem"> | string | null
    createdAt?: DateTimeFilter<"PurchaseDeliveryItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseDeliveryItem"> | Date | string
  }

  export type QuotationProcessCreateWithoutQuotationsInput = {
    name: string
    code?: string | null
    status?: $Enums.QuotationProcessStatus
    baseCurrency?: string
    targetCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    targetMarginPct?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    baselineFile?: QuotationAttachmentCreateNestedOneWithoutProcessInput
    baselines?: QuotationBaselineItemCreateNestedManyWithoutProcessInput
    purchaseOrders?: PurchaseOrderLogCreateNestedManyWithoutProcessInput
    deliveryLogs?: PurchaseDeliveryLogCreateNestedManyWithoutProcessInput
  }

  export type QuotationProcessUncheckedCreateWithoutQuotationsInput = {
    id?: number
    name: string
    code?: string | null
    status?: $Enums.QuotationProcessStatus
    baseCurrency?: string
    targetCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    targetMarginPct?: Decimal | DecimalJsLike | number | string | null
    baselineFileId?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    baselines?: QuotationBaselineItemUncheckedCreateNestedManyWithoutProcessInput
    purchaseOrders?: PurchaseOrderLogUncheckedCreateNestedManyWithoutProcessInput
    deliveryLogs?: PurchaseDeliveryLogUncheckedCreateNestedManyWithoutProcessInput
  }

  export type QuotationProcessCreateOrConnectWithoutQuotationsInput = {
    where: QuotationProcessWhereUniqueInput
    create: XOR<QuotationProcessCreateWithoutQuotationsInput, QuotationProcessUncheckedCreateWithoutQuotationsInput>
  }

  export type ProveedorCreateWithoutQuotationsInput = {
    name: string
    ruc?: string | null
    phone?: string | null
    moves?: MoveCreateNestedManyWithoutProveedorInput
    expenses?: ExpenseCreateNestedManyWithoutProveedorInput
    deliveries?: PurchaseDeliveryLogCreateNestedManyWithoutProveedorInput
  }

  export type ProveedorUncheckedCreateWithoutQuotationsInput = {
    id?: number
    name: string
    ruc?: string | null
    phone?: string | null
    moves?: MoveUncheckedCreateNestedManyWithoutProveedorInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutProveedorInput
    deliveries?: PurchaseDeliveryLogUncheckedCreateNestedManyWithoutProveedorInput
  }

  export type ProveedorCreateOrConnectWithoutQuotationsInput = {
    where: ProveedorWhereUniqueInput
    create: XOR<ProveedorCreateWithoutQuotationsInput, ProveedorUncheckedCreateWithoutQuotationsInput>
  }

  export type QuotationItemCreateWithoutQuotationInput = {
    sourceRow?: number | null
    itemCode?: string | null
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    normalizedPrice?: Decimal | DecimalJsLike | number | string | null
    matchScore?: number | null
    extraAttributes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    baselineItem?: QuotationBaselineItemCreateNestedOneWithoutQuoteItemsInput
    material?: MaterialCreateNestedOneWithoutQuoteItemsInput
  }

  export type QuotationItemUncheckedCreateWithoutQuotationInput = {
    id?: number
    baselineItemId?: number | null
    materialId?: number | null
    sourceRow?: number | null
    itemCode?: string | null
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    normalizedPrice?: Decimal | DecimalJsLike | number | string | null
    matchScore?: number | null
    extraAttributes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuotationItemCreateOrConnectWithoutQuotationInput = {
    where: QuotationItemWhereUniqueInput
    create: XOR<QuotationItemCreateWithoutQuotationInput, QuotationItemUncheckedCreateWithoutQuotationInput>
  }

  export type QuotationItemCreateManyQuotationInputEnvelope = {
    data: QuotationItemCreateManyQuotationInput | QuotationItemCreateManyQuotationInput[]
  }

  export type QuotationAttachmentCreateWithoutQuotationInput = {
    type?: $Enums.QuotationAttachmentType
    originalName: string
    storagePath: string
    mimeType?: string | null
    sizeBytes?: number | null
    checksum?: string | null
    parsed?: boolean
    parsedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    process?: QuotationProcessCreateNestedOneWithoutBaselineFileInput
  }

  export type QuotationAttachmentUncheckedCreateWithoutQuotationInput = {
    id?: number
    type?: $Enums.QuotationAttachmentType
    originalName: string
    storagePath: string
    mimeType?: string | null
    sizeBytes?: number | null
    checksum?: string | null
    parsed?: boolean
    parsedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    process?: QuotationProcessUncheckedCreateNestedOneWithoutBaselineFileInput
  }

  export type QuotationAttachmentCreateOrConnectWithoutQuotationInput = {
    where: QuotationAttachmentWhereUniqueInput
    create: XOR<QuotationAttachmentCreateWithoutQuotationInput, QuotationAttachmentUncheckedCreateWithoutQuotationInput>
  }

  export type QuotationAttachmentCreateManyQuotationInputEnvelope = {
    data: QuotationAttachmentCreateManyQuotationInput | QuotationAttachmentCreateManyQuotationInput[]
  }

  export type PurchaseOrderLogCreateWithoutQuotationInput = {
    supplierId?: number | null
    supplierName: string
    orderNumber: string
    sequence?: number
    issueDate?: Date | string
    currency?: string
    subtotal?: Decimal | DecimalJsLike | number | string | null
    discount?: Decimal | DecimalJsLike | number | string | null
    netSubtotal?: Decimal | DecimalJsLike | number | string | null
    igv?: Decimal | DecimalJsLike | number | string | null
    total?: Decimal | DecimalJsLike | number | string | null
    totalsJson?: NullableJsonNullValueInput | InputJsonValue
    itemsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    process: QuotationProcessCreateNestedOneWithoutPurchaseOrdersInput
    lines?: PurchaseOrderLineCreateNestedManyWithoutOrderInput
    deliveries?: PurchaseDeliveryLogCreateNestedManyWithoutOrderInput
  }

  export type PurchaseOrderLogUncheckedCreateWithoutQuotationInput = {
    id?: number
    processId: number
    supplierId?: number | null
    supplierName: string
    orderNumber: string
    sequence?: number
    issueDate?: Date | string
    currency?: string
    subtotal?: Decimal | DecimalJsLike | number | string | null
    discount?: Decimal | DecimalJsLike | number | string | null
    netSubtotal?: Decimal | DecimalJsLike | number | string | null
    igv?: Decimal | DecimalJsLike | number | string | null
    total?: Decimal | DecimalJsLike | number | string | null
    totalsJson?: NullableJsonNullValueInput | InputJsonValue
    itemsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutOrderInput
    deliveries?: PurchaseDeliveryLogUncheckedCreateNestedManyWithoutOrderInput
  }

  export type PurchaseOrderLogCreateOrConnectWithoutQuotationInput = {
    where: PurchaseOrderLogWhereUniqueInput
    create: XOR<PurchaseOrderLogCreateWithoutQuotationInput, PurchaseOrderLogUncheckedCreateWithoutQuotationInput>
  }

  export type PurchaseOrderLogCreateManyQuotationInputEnvelope = {
    data: PurchaseOrderLogCreateManyQuotationInput | PurchaseOrderLogCreateManyQuotationInput[]
  }

  export type QuotationProcessUpsertWithoutQuotationsInput = {
    update: XOR<QuotationProcessUpdateWithoutQuotationsInput, QuotationProcessUncheckedUpdateWithoutQuotationsInput>
    create: XOR<QuotationProcessCreateWithoutQuotationsInput, QuotationProcessUncheckedCreateWithoutQuotationsInput>
    where?: QuotationProcessWhereInput
  }

  export type QuotationProcessUpdateToOneWithWhereWithoutQuotationsInput = {
    where?: QuotationProcessWhereInput
    data: XOR<QuotationProcessUpdateWithoutQuotationsInput, QuotationProcessUncheckedUpdateWithoutQuotationsInput>
  }

  export type QuotationProcessUpdateWithoutQuotationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuotationProcessStatusFieldUpdateOperationsInput | $Enums.QuotationProcessStatus
    baseCurrency?: StringFieldUpdateOperationsInput | string
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    targetMarginPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baselineFile?: QuotationAttachmentUpdateOneWithoutProcessNestedInput
    baselines?: QuotationBaselineItemUpdateManyWithoutProcessNestedInput
    purchaseOrders?: PurchaseOrderLogUpdateManyWithoutProcessNestedInput
    deliveryLogs?: PurchaseDeliveryLogUpdateManyWithoutProcessNestedInput
  }

  export type QuotationProcessUncheckedUpdateWithoutQuotationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuotationProcessStatusFieldUpdateOperationsInput | $Enums.QuotationProcessStatus
    baseCurrency?: StringFieldUpdateOperationsInput | string
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    targetMarginPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baselineFileId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baselines?: QuotationBaselineItemUncheckedUpdateManyWithoutProcessNestedInput
    purchaseOrders?: PurchaseOrderLogUncheckedUpdateManyWithoutProcessNestedInput
    deliveryLogs?: PurchaseDeliveryLogUncheckedUpdateManyWithoutProcessNestedInput
  }

  export type ProveedorUpsertWithoutQuotationsInput = {
    update: XOR<ProveedorUpdateWithoutQuotationsInput, ProveedorUncheckedUpdateWithoutQuotationsInput>
    create: XOR<ProveedorCreateWithoutQuotationsInput, ProveedorUncheckedCreateWithoutQuotationsInput>
    where?: ProveedorWhereInput
  }

  export type ProveedorUpdateToOneWithWhereWithoutQuotationsInput = {
    where?: ProveedorWhereInput
    data: XOR<ProveedorUpdateWithoutQuotationsInput, ProveedorUncheckedUpdateWithoutQuotationsInput>
  }

  export type ProveedorUpdateWithoutQuotationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    moves?: MoveUpdateManyWithoutProveedorNestedInput
    expenses?: ExpenseUpdateManyWithoutProveedorNestedInput
    deliveries?: PurchaseDeliveryLogUpdateManyWithoutProveedorNestedInput
  }

  export type ProveedorUncheckedUpdateWithoutQuotationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    moves?: MoveUncheckedUpdateManyWithoutProveedorNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutProveedorNestedInput
    deliveries?: PurchaseDeliveryLogUncheckedUpdateManyWithoutProveedorNestedInput
  }

  export type QuotationItemUpsertWithWhereUniqueWithoutQuotationInput = {
    where: QuotationItemWhereUniqueInput
    update: XOR<QuotationItemUpdateWithoutQuotationInput, QuotationItemUncheckedUpdateWithoutQuotationInput>
    create: XOR<QuotationItemCreateWithoutQuotationInput, QuotationItemUncheckedCreateWithoutQuotationInput>
  }

  export type QuotationItemUpdateWithWhereUniqueWithoutQuotationInput = {
    where: QuotationItemWhereUniqueInput
    data: XOR<QuotationItemUpdateWithoutQuotationInput, QuotationItemUncheckedUpdateWithoutQuotationInput>
  }

  export type QuotationItemUpdateManyWithWhereWithoutQuotationInput = {
    where: QuotationItemScalarWhereInput
    data: XOR<QuotationItemUpdateManyMutationInput, QuotationItemUncheckedUpdateManyWithoutQuotationInput>
  }

  export type QuotationAttachmentUpsertWithWhereUniqueWithoutQuotationInput = {
    where: QuotationAttachmentWhereUniqueInput
    update: XOR<QuotationAttachmentUpdateWithoutQuotationInput, QuotationAttachmentUncheckedUpdateWithoutQuotationInput>
    create: XOR<QuotationAttachmentCreateWithoutQuotationInput, QuotationAttachmentUncheckedCreateWithoutQuotationInput>
  }

  export type QuotationAttachmentUpdateWithWhereUniqueWithoutQuotationInput = {
    where: QuotationAttachmentWhereUniqueInput
    data: XOR<QuotationAttachmentUpdateWithoutQuotationInput, QuotationAttachmentUncheckedUpdateWithoutQuotationInput>
  }

  export type QuotationAttachmentUpdateManyWithWhereWithoutQuotationInput = {
    where: QuotationAttachmentScalarWhereInput
    data: XOR<QuotationAttachmentUpdateManyMutationInput, QuotationAttachmentUncheckedUpdateManyWithoutQuotationInput>
  }

  export type QuotationAttachmentScalarWhereInput = {
    AND?: QuotationAttachmentScalarWhereInput | QuotationAttachmentScalarWhereInput[]
    OR?: QuotationAttachmentScalarWhereInput[]
    NOT?: QuotationAttachmentScalarWhereInput | QuotationAttachmentScalarWhereInput[]
    id?: IntFilter<"QuotationAttachment"> | number
    quotationId?: IntNullableFilter<"QuotationAttachment"> | number | null
    type?: EnumQuotationAttachmentTypeFilter<"QuotationAttachment"> | $Enums.QuotationAttachmentType
    originalName?: StringFilter<"QuotationAttachment"> | string
    storagePath?: StringFilter<"QuotationAttachment"> | string
    mimeType?: StringNullableFilter<"QuotationAttachment"> | string | null
    sizeBytes?: IntNullableFilter<"QuotationAttachment"> | number | null
    checksum?: StringNullableFilter<"QuotationAttachment"> | string | null
    parsed?: BoolFilter<"QuotationAttachment"> | boolean
    parsedAt?: DateTimeNullableFilter<"QuotationAttachment"> | Date | string | null
    metadata?: JsonNullableFilter<"QuotationAttachment">
    createdAt?: DateTimeFilter<"QuotationAttachment"> | Date | string
    updatedAt?: DateTimeFilter<"QuotationAttachment"> | Date | string
  }

  export type PurchaseOrderLogUpsertWithWhereUniqueWithoutQuotationInput = {
    where: PurchaseOrderLogWhereUniqueInput
    update: XOR<PurchaseOrderLogUpdateWithoutQuotationInput, PurchaseOrderLogUncheckedUpdateWithoutQuotationInput>
    create: XOR<PurchaseOrderLogCreateWithoutQuotationInput, PurchaseOrderLogUncheckedCreateWithoutQuotationInput>
  }

  export type PurchaseOrderLogUpdateWithWhereUniqueWithoutQuotationInput = {
    where: PurchaseOrderLogWhereUniqueInput
    data: XOR<PurchaseOrderLogUpdateWithoutQuotationInput, PurchaseOrderLogUncheckedUpdateWithoutQuotationInput>
  }

  export type PurchaseOrderLogUpdateManyWithWhereWithoutQuotationInput = {
    where: PurchaseOrderLogScalarWhereInput
    data: XOR<PurchaseOrderLogUpdateManyMutationInput, PurchaseOrderLogUncheckedUpdateManyWithoutQuotationInput>
  }

  export type QuotationCreateWithoutItemsInput = {
    supplierName?: string | null
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    submittedAt?: Date | string | null
    status?: $Enums.QuotationStatus
    totalAmount?: Decimal | DecimalJsLike | number | string | null
    totalAmountPen?: Decimal | DecimalJsLike | number | string | null
    qualityScore?: number | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    process: QuotationProcessCreateNestedOneWithoutQuotationsInput
    proveedor?: ProveedorCreateNestedOneWithoutQuotationsInput
    attachments?: QuotationAttachmentCreateNestedManyWithoutQuotationInput
    purchaseOrders?: PurchaseOrderLogCreateNestedManyWithoutQuotationInput
  }

  export type QuotationUncheckedCreateWithoutItemsInput = {
    id?: number
    processId: number
    proveedorId?: number | null
    supplierName?: string | null
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    submittedAt?: Date | string | null
    status?: $Enums.QuotationStatus
    totalAmount?: Decimal | DecimalJsLike | number | string | null
    totalAmountPen?: Decimal | DecimalJsLike | number | string | null
    qualityScore?: number | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: QuotationAttachmentUncheckedCreateNestedManyWithoutQuotationInput
    purchaseOrders?: PurchaseOrderLogUncheckedCreateNestedManyWithoutQuotationInput
  }

  export type QuotationCreateOrConnectWithoutItemsInput = {
    where: QuotationWhereUniqueInput
    create: XOR<QuotationCreateWithoutItemsInput, QuotationUncheckedCreateWithoutItemsInput>
  }

  export type QuotationBaselineItemCreateWithoutQuoteItemsInput = {
    sheetName?: string | null
    sectionPath?: string | null
    itemCode?: string | null
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    process: QuotationProcessCreateNestedOneWithoutBaselinesInput
    material?: MaterialCreateNestedOneWithoutBaseQuotesInput
    orderLines?: PurchaseOrderLineCreateNestedManyWithoutBaselineInput
    deliveryItems?: PurchaseDeliveryItemCreateNestedManyWithoutBaselineInput
  }

  export type QuotationBaselineItemUncheckedCreateWithoutQuoteItemsInput = {
    id?: number
    processId: number
    materialId?: number | null
    sheetName?: string | null
    sectionPath?: string | null
    itemCode?: string | null
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    orderLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutBaselineInput
    deliveryItems?: PurchaseDeliveryItemUncheckedCreateNestedManyWithoutBaselineInput
  }

  export type QuotationBaselineItemCreateOrConnectWithoutQuoteItemsInput = {
    where: QuotationBaselineItemWhereUniqueInput
    create: XOR<QuotationBaselineItemCreateWithoutQuoteItemsInput, QuotationBaselineItemUncheckedCreateWithoutQuoteItemsInput>
  }

  export type MaterialCreateWithoutQuoteItemsInput = {
    code?: string | null
    name: string
    unit?: string | null
    minStock?: Decimal | DecimalJsLike | number | string
    reorderQuantity?: Decimal | DecimalJsLike | number | string
    allowNegative?: boolean
    isCompanyAsset?: boolean
    assetStatus?: $Enums.AssetStatus
    assetResponsible?: string | null
    group?: MaterialGroupCreateNestedOneWithoutMaterialsInput
    moves?: MoveCreateNestedManyWithoutMaterialInput
    expenses?: ExpenseCreateNestedManyWithoutMaterialInput
    baseQuotes?: QuotationBaselineItemCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUncheckedCreateWithoutQuoteItemsInput = {
    id?: number
    code?: string | null
    name: string
    unit?: string | null
    groupId?: number | null
    minStock?: Decimal | DecimalJsLike | number | string
    reorderQuantity?: Decimal | DecimalJsLike | number | string
    allowNegative?: boolean
    isCompanyAsset?: boolean
    assetStatus?: $Enums.AssetStatus
    assetResponsible?: string | null
    moves?: MoveUncheckedCreateNestedManyWithoutMaterialInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutMaterialInput
    baseQuotes?: QuotationBaselineItemUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type MaterialCreateOrConnectWithoutQuoteItemsInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutQuoteItemsInput, MaterialUncheckedCreateWithoutQuoteItemsInput>
  }

  export type QuotationUpsertWithoutItemsInput = {
    update: XOR<QuotationUpdateWithoutItemsInput, QuotationUncheckedUpdateWithoutItemsInput>
    create: XOR<QuotationCreateWithoutItemsInput, QuotationUncheckedCreateWithoutItemsInput>
    where?: QuotationWhereInput
  }

  export type QuotationUpdateToOneWithWhereWithoutItemsInput = {
    where?: QuotationWhereInput
    data: XOR<QuotationUpdateWithoutItemsInput, QuotationUncheckedUpdateWithoutItemsInput>
  }

  export type QuotationUpdateWithoutItemsInput = {
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    totalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAmountPen?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    process?: QuotationProcessUpdateOneRequiredWithoutQuotationsNestedInput
    proveedor?: ProveedorUpdateOneWithoutQuotationsNestedInput
    attachments?: QuotationAttachmentUpdateManyWithoutQuotationNestedInput
    purchaseOrders?: PurchaseOrderLogUpdateManyWithoutQuotationNestedInput
  }

  export type QuotationUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    processId?: IntFieldUpdateOperationsInput | number
    proveedorId?: NullableIntFieldUpdateOperationsInput | number | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    totalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAmountPen?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: QuotationAttachmentUncheckedUpdateManyWithoutQuotationNestedInput
    purchaseOrders?: PurchaseOrderLogUncheckedUpdateManyWithoutQuotationNestedInput
  }

  export type QuotationBaselineItemUpsertWithoutQuoteItemsInput = {
    update: XOR<QuotationBaselineItemUpdateWithoutQuoteItemsInput, QuotationBaselineItemUncheckedUpdateWithoutQuoteItemsInput>
    create: XOR<QuotationBaselineItemCreateWithoutQuoteItemsInput, QuotationBaselineItemUncheckedCreateWithoutQuoteItemsInput>
    where?: QuotationBaselineItemWhereInput
  }

  export type QuotationBaselineItemUpdateToOneWithWhereWithoutQuoteItemsInput = {
    where?: QuotationBaselineItemWhereInput
    data: XOR<QuotationBaselineItemUpdateWithoutQuoteItemsInput, QuotationBaselineItemUncheckedUpdateWithoutQuoteItemsInput>
  }

  export type QuotationBaselineItemUpdateWithoutQuoteItemsInput = {
    sheetName?: NullableStringFieldUpdateOperationsInput | string | null
    sectionPath?: NullableStringFieldUpdateOperationsInput | string | null
    itemCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    process?: QuotationProcessUpdateOneRequiredWithoutBaselinesNestedInput
    material?: MaterialUpdateOneWithoutBaseQuotesNestedInput
    orderLines?: PurchaseOrderLineUpdateManyWithoutBaselineNestedInput
    deliveryItems?: PurchaseDeliveryItemUpdateManyWithoutBaselineNestedInput
  }

  export type QuotationBaselineItemUncheckedUpdateWithoutQuoteItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    processId?: IntFieldUpdateOperationsInput | number
    materialId?: NullableIntFieldUpdateOperationsInput | number | null
    sheetName?: NullableStringFieldUpdateOperationsInput | string | null
    sectionPath?: NullableStringFieldUpdateOperationsInput | string | null
    itemCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderLines?: PurchaseOrderLineUncheckedUpdateManyWithoutBaselineNestedInput
    deliveryItems?: PurchaseDeliveryItemUncheckedUpdateManyWithoutBaselineNestedInput
  }

  export type MaterialUpsertWithoutQuoteItemsInput = {
    update: XOR<MaterialUpdateWithoutQuoteItemsInput, MaterialUncheckedUpdateWithoutQuoteItemsInput>
    create: XOR<MaterialCreateWithoutQuoteItemsInput, MaterialUncheckedCreateWithoutQuoteItemsInput>
    where?: MaterialWhereInput
  }

  export type MaterialUpdateToOneWithWhereWithoutQuoteItemsInput = {
    where?: MaterialWhereInput
    data: XOR<MaterialUpdateWithoutQuoteItemsInput, MaterialUncheckedUpdateWithoutQuoteItemsInput>
  }

  export type MaterialUpdateWithoutQuoteItemsInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowNegative?: BoolFieldUpdateOperationsInput | boolean
    isCompanyAsset?: BoolFieldUpdateOperationsInput | boolean
    assetStatus?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    assetResponsible?: NullableStringFieldUpdateOperationsInput | string | null
    group?: MaterialGroupUpdateOneWithoutMaterialsNestedInput
    moves?: MoveUpdateManyWithoutMaterialNestedInput
    expenses?: ExpenseUpdateManyWithoutMaterialNestedInput
    baseQuotes?: QuotationBaselineItemUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateWithoutQuoteItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: NullableIntFieldUpdateOperationsInput | number | null
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowNegative?: BoolFieldUpdateOperationsInput | boolean
    isCompanyAsset?: BoolFieldUpdateOperationsInput | boolean
    assetStatus?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    assetResponsible?: NullableStringFieldUpdateOperationsInput | string | null
    moves?: MoveUncheckedUpdateManyWithoutMaterialNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutMaterialNestedInput
    baseQuotes?: QuotationBaselineItemUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type QuotationCreateWithoutAttachmentsInput = {
    supplierName?: string | null
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    submittedAt?: Date | string | null
    status?: $Enums.QuotationStatus
    totalAmount?: Decimal | DecimalJsLike | number | string | null
    totalAmountPen?: Decimal | DecimalJsLike | number | string | null
    qualityScore?: number | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    process: QuotationProcessCreateNestedOneWithoutQuotationsInput
    proveedor?: ProveedorCreateNestedOneWithoutQuotationsInput
    items?: QuotationItemCreateNestedManyWithoutQuotationInput
    purchaseOrders?: PurchaseOrderLogCreateNestedManyWithoutQuotationInput
  }

  export type QuotationUncheckedCreateWithoutAttachmentsInput = {
    id?: number
    processId: number
    proveedorId?: number | null
    supplierName?: string | null
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    submittedAt?: Date | string | null
    status?: $Enums.QuotationStatus
    totalAmount?: Decimal | DecimalJsLike | number | string | null
    totalAmountPen?: Decimal | DecimalJsLike | number | string | null
    qualityScore?: number | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: QuotationItemUncheckedCreateNestedManyWithoutQuotationInput
    purchaseOrders?: PurchaseOrderLogUncheckedCreateNestedManyWithoutQuotationInput
  }

  export type QuotationCreateOrConnectWithoutAttachmentsInput = {
    where: QuotationWhereUniqueInput
    create: XOR<QuotationCreateWithoutAttachmentsInput, QuotationUncheckedCreateWithoutAttachmentsInput>
  }

  export type QuotationProcessCreateWithoutBaselineFileInput = {
    name: string
    code?: string | null
    status?: $Enums.QuotationProcessStatus
    baseCurrency?: string
    targetCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    targetMarginPct?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    baselines?: QuotationBaselineItemCreateNestedManyWithoutProcessInput
    quotations?: QuotationCreateNestedManyWithoutProcessInput
    purchaseOrders?: PurchaseOrderLogCreateNestedManyWithoutProcessInput
    deliveryLogs?: PurchaseDeliveryLogCreateNestedManyWithoutProcessInput
  }

  export type QuotationProcessUncheckedCreateWithoutBaselineFileInput = {
    id?: number
    name: string
    code?: string | null
    status?: $Enums.QuotationProcessStatus
    baseCurrency?: string
    targetCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    targetMarginPct?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    baselines?: QuotationBaselineItemUncheckedCreateNestedManyWithoutProcessInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutProcessInput
    purchaseOrders?: PurchaseOrderLogUncheckedCreateNestedManyWithoutProcessInput
    deliveryLogs?: PurchaseDeliveryLogUncheckedCreateNestedManyWithoutProcessInput
  }

  export type QuotationProcessCreateOrConnectWithoutBaselineFileInput = {
    where: QuotationProcessWhereUniqueInput
    create: XOR<QuotationProcessCreateWithoutBaselineFileInput, QuotationProcessUncheckedCreateWithoutBaselineFileInput>
  }

  export type QuotationUpsertWithoutAttachmentsInput = {
    update: XOR<QuotationUpdateWithoutAttachmentsInput, QuotationUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<QuotationCreateWithoutAttachmentsInput, QuotationUncheckedCreateWithoutAttachmentsInput>
    where?: QuotationWhereInput
  }

  export type QuotationUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: QuotationWhereInput
    data: XOR<QuotationUpdateWithoutAttachmentsInput, QuotationUncheckedUpdateWithoutAttachmentsInput>
  }

  export type QuotationUpdateWithoutAttachmentsInput = {
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    totalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAmountPen?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    process?: QuotationProcessUpdateOneRequiredWithoutQuotationsNestedInput
    proveedor?: ProveedorUpdateOneWithoutQuotationsNestedInput
    items?: QuotationItemUpdateManyWithoutQuotationNestedInput
    purchaseOrders?: PurchaseOrderLogUpdateManyWithoutQuotationNestedInput
  }

  export type QuotationUncheckedUpdateWithoutAttachmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    processId?: IntFieldUpdateOperationsInput | number
    proveedorId?: NullableIntFieldUpdateOperationsInput | number | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    totalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAmountPen?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: QuotationItemUncheckedUpdateManyWithoutQuotationNestedInput
    purchaseOrders?: PurchaseOrderLogUncheckedUpdateManyWithoutQuotationNestedInput
  }

  export type QuotationProcessUpsertWithoutBaselineFileInput = {
    update: XOR<QuotationProcessUpdateWithoutBaselineFileInput, QuotationProcessUncheckedUpdateWithoutBaselineFileInput>
    create: XOR<QuotationProcessCreateWithoutBaselineFileInput, QuotationProcessUncheckedCreateWithoutBaselineFileInput>
    where?: QuotationProcessWhereInput
  }

  export type QuotationProcessUpdateToOneWithWhereWithoutBaselineFileInput = {
    where?: QuotationProcessWhereInput
    data: XOR<QuotationProcessUpdateWithoutBaselineFileInput, QuotationProcessUncheckedUpdateWithoutBaselineFileInput>
  }

  export type QuotationProcessUpdateWithoutBaselineFileInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuotationProcessStatusFieldUpdateOperationsInput | $Enums.QuotationProcessStatus
    baseCurrency?: StringFieldUpdateOperationsInput | string
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    targetMarginPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baselines?: QuotationBaselineItemUpdateManyWithoutProcessNestedInput
    quotations?: QuotationUpdateManyWithoutProcessNestedInput
    purchaseOrders?: PurchaseOrderLogUpdateManyWithoutProcessNestedInput
    deliveryLogs?: PurchaseDeliveryLogUpdateManyWithoutProcessNestedInput
  }

  export type QuotationProcessUncheckedUpdateWithoutBaselineFileInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuotationProcessStatusFieldUpdateOperationsInput | $Enums.QuotationProcessStatus
    baseCurrency?: StringFieldUpdateOperationsInput | string
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    targetMarginPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baselines?: QuotationBaselineItemUncheckedUpdateManyWithoutProcessNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutProcessNestedInput
    purchaseOrders?: PurchaseOrderLogUncheckedUpdateManyWithoutProcessNestedInput
    deliveryLogs?: PurchaseDeliveryLogUncheckedUpdateManyWithoutProcessNestedInput
  }

  export type QuotationProcessCreateWithoutPurchaseOrdersInput = {
    name: string
    code?: string | null
    status?: $Enums.QuotationProcessStatus
    baseCurrency?: string
    targetCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    targetMarginPct?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    baselineFile?: QuotationAttachmentCreateNestedOneWithoutProcessInput
    baselines?: QuotationBaselineItemCreateNestedManyWithoutProcessInput
    quotations?: QuotationCreateNestedManyWithoutProcessInput
    deliveryLogs?: PurchaseDeliveryLogCreateNestedManyWithoutProcessInput
  }

  export type QuotationProcessUncheckedCreateWithoutPurchaseOrdersInput = {
    id?: number
    name: string
    code?: string | null
    status?: $Enums.QuotationProcessStatus
    baseCurrency?: string
    targetCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    targetMarginPct?: Decimal | DecimalJsLike | number | string | null
    baselineFileId?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    baselines?: QuotationBaselineItemUncheckedCreateNestedManyWithoutProcessInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutProcessInput
    deliveryLogs?: PurchaseDeliveryLogUncheckedCreateNestedManyWithoutProcessInput
  }

  export type QuotationProcessCreateOrConnectWithoutPurchaseOrdersInput = {
    where: QuotationProcessWhereUniqueInput
    create: XOR<QuotationProcessCreateWithoutPurchaseOrdersInput, QuotationProcessUncheckedCreateWithoutPurchaseOrdersInput>
  }

  export type QuotationCreateWithoutPurchaseOrdersInput = {
    supplierName?: string | null
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    submittedAt?: Date | string | null
    status?: $Enums.QuotationStatus
    totalAmount?: Decimal | DecimalJsLike | number | string | null
    totalAmountPen?: Decimal | DecimalJsLike | number | string | null
    qualityScore?: number | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    process: QuotationProcessCreateNestedOneWithoutQuotationsInput
    proveedor?: ProveedorCreateNestedOneWithoutQuotationsInput
    items?: QuotationItemCreateNestedManyWithoutQuotationInput
    attachments?: QuotationAttachmentCreateNestedManyWithoutQuotationInput
  }

  export type QuotationUncheckedCreateWithoutPurchaseOrdersInput = {
    id?: number
    processId: number
    proveedorId?: number | null
    supplierName?: string | null
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    submittedAt?: Date | string | null
    status?: $Enums.QuotationStatus
    totalAmount?: Decimal | DecimalJsLike | number | string | null
    totalAmountPen?: Decimal | DecimalJsLike | number | string | null
    qualityScore?: number | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: QuotationItemUncheckedCreateNestedManyWithoutQuotationInput
    attachments?: QuotationAttachmentUncheckedCreateNestedManyWithoutQuotationInput
  }

  export type QuotationCreateOrConnectWithoutPurchaseOrdersInput = {
    where: QuotationWhereUniqueInput
    create: XOR<QuotationCreateWithoutPurchaseOrdersInput, QuotationUncheckedCreateWithoutPurchaseOrdersInput>
  }

  export type PurchaseOrderLineCreateWithoutOrderInput = {
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    baseline?: QuotationBaselineItemCreateNestedOneWithoutOrderLinesInput
    deliveries?: PurchaseDeliveryItemCreateNestedManyWithoutOrderLineInput
  }

  export type PurchaseOrderLineUncheckedCreateWithoutOrderInput = {
    id?: number
    baselineId?: number | null
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: PurchaseDeliveryItemUncheckedCreateNestedManyWithoutOrderLineInput
  }

  export type PurchaseOrderLineCreateOrConnectWithoutOrderInput = {
    where: PurchaseOrderLineWhereUniqueInput
    create: XOR<PurchaseOrderLineCreateWithoutOrderInput, PurchaseOrderLineUncheckedCreateWithoutOrderInput>
  }

  export type PurchaseOrderLineCreateManyOrderInputEnvelope = {
    data: PurchaseOrderLineCreateManyOrderInput | PurchaseOrderLineCreateManyOrderInput[]
  }

  export type PurchaseDeliveryLogCreateWithoutOrderInput = {
    supplierName?: string | null
    guideNumber?: string | null
    date?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    process: QuotationProcessCreateNestedOneWithoutDeliveryLogsInput
    proveedor?: ProveedorCreateNestedOneWithoutDeliveriesInput
    items?: PurchaseDeliveryItemCreateNestedManyWithoutDeliveryInput
  }

  export type PurchaseDeliveryLogUncheckedCreateWithoutOrderInput = {
    id?: number
    processId: number
    proveedorId?: number | null
    supplierName?: string | null
    guideNumber?: string | null
    date?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseDeliveryItemUncheckedCreateNestedManyWithoutDeliveryInput
  }

  export type PurchaseDeliveryLogCreateOrConnectWithoutOrderInput = {
    where: PurchaseDeliveryLogWhereUniqueInput
    create: XOR<PurchaseDeliveryLogCreateWithoutOrderInput, PurchaseDeliveryLogUncheckedCreateWithoutOrderInput>
  }

  export type PurchaseDeliveryLogCreateManyOrderInputEnvelope = {
    data: PurchaseDeliveryLogCreateManyOrderInput | PurchaseDeliveryLogCreateManyOrderInput[]
  }

  export type QuotationProcessUpsertWithoutPurchaseOrdersInput = {
    update: XOR<QuotationProcessUpdateWithoutPurchaseOrdersInput, QuotationProcessUncheckedUpdateWithoutPurchaseOrdersInput>
    create: XOR<QuotationProcessCreateWithoutPurchaseOrdersInput, QuotationProcessUncheckedCreateWithoutPurchaseOrdersInput>
    where?: QuotationProcessWhereInput
  }

  export type QuotationProcessUpdateToOneWithWhereWithoutPurchaseOrdersInput = {
    where?: QuotationProcessWhereInput
    data: XOR<QuotationProcessUpdateWithoutPurchaseOrdersInput, QuotationProcessUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type QuotationProcessUpdateWithoutPurchaseOrdersInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuotationProcessStatusFieldUpdateOperationsInput | $Enums.QuotationProcessStatus
    baseCurrency?: StringFieldUpdateOperationsInput | string
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    targetMarginPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baselineFile?: QuotationAttachmentUpdateOneWithoutProcessNestedInput
    baselines?: QuotationBaselineItemUpdateManyWithoutProcessNestedInput
    quotations?: QuotationUpdateManyWithoutProcessNestedInput
    deliveryLogs?: PurchaseDeliveryLogUpdateManyWithoutProcessNestedInput
  }

  export type QuotationProcessUncheckedUpdateWithoutPurchaseOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuotationProcessStatusFieldUpdateOperationsInput | $Enums.QuotationProcessStatus
    baseCurrency?: StringFieldUpdateOperationsInput | string
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    targetMarginPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baselineFileId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baselines?: QuotationBaselineItemUncheckedUpdateManyWithoutProcessNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutProcessNestedInput
    deliveryLogs?: PurchaseDeliveryLogUncheckedUpdateManyWithoutProcessNestedInput
  }

  export type QuotationUpsertWithoutPurchaseOrdersInput = {
    update: XOR<QuotationUpdateWithoutPurchaseOrdersInput, QuotationUncheckedUpdateWithoutPurchaseOrdersInput>
    create: XOR<QuotationCreateWithoutPurchaseOrdersInput, QuotationUncheckedCreateWithoutPurchaseOrdersInput>
    where?: QuotationWhereInput
  }

  export type QuotationUpdateToOneWithWhereWithoutPurchaseOrdersInput = {
    where?: QuotationWhereInput
    data: XOR<QuotationUpdateWithoutPurchaseOrdersInput, QuotationUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type QuotationUpdateWithoutPurchaseOrdersInput = {
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    totalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAmountPen?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    process?: QuotationProcessUpdateOneRequiredWithoutQuotationsNestedInput
    proveedor?: ProveedorUpdateOneWithoutQuotationsNestedInput
    items?: QuotationItemUpdateManyWithoutQuotationNestedInput
    attachments?: QuotationAttachmentUpdateManyWithoutQuotationNestedInput
  }

  export type QuotationUncheckedUpdateWithoutPurchaseOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    processId?: IntFieldUpdateOperationsInput | number
    proveedorId?: NullableIntFieldUpdateOperationsInput | number | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    totalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAmountPen?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: QuotationItemUncheckedUpdateManyWithoutQuotationNestedInput
    attachments?: QuotationAttachmentUncheckedUpdateManyWithoutQuotationNestedInput
  }

  export type PurchaseOrderLineUpsertWithWhereUniqueWithoutOrderInput = {
    where: PurchaseOrderLineWhereUniqueInput
    update: XOR<PurchaseOrderLineUpdateWithoutOrderInput, PurchaseOrderLineUncheckedUpdateWithoutOrderInput>
    create: XOR<PurchaseOrderLineCreateWithoutOrderInput, PurchaseOrderLineUncheckedCreateWithoutOrderInput>
  }

  export type PurchaseOrderLineUpdateWithWhereUniqueWithoutOrderInput = {
    where: PurchaseOrderLineWhereUniqueInput
    data: XOR<PurchaseOrderLineUpdateWithoutOrderInput, PurchaseOrderLineUncheckedUpdateWithoutOrderInput>
  }

  export type PurchaseOrderLineUpdateManyWithWhereWithoutOrderInput = {
    where: PurchaseOrderLineScalarWhereInput
    data: XOR<PurchaseOrderLineUpdateManyMutationInput, PurchaseOrderLineUncheckedUpdateManyWithoutOrderInput>
  }

  export type PurchaseDeliveryLogUpsertWithWhereUniqueWithoutOrderInput = {
    where: PurchaseDeliveryLogWhereUniqueInput
    update: XOR<PurchaseDeliveryLogUpdateWithoutOrderInput, PurchaseDeliveryLogUncheckedUpdateWithoutOrderInput>
    create: XOR<PurchaseDeliveryLogCreateWithoutOrderInput, PurchaseDeliveryLogUncheckedCreateWithoutOrderInput>
  }

  export type PurchaseDeliveryLogUpdateWithWhereUniqueWithoutOrderInput = {
    where: PurchaseDeliveryLogWhereUniqueInput
    data: XOR<PurchaseDeliveryLogUpdateWithoutOrderInput, PurchaseDeliveryLogUncheckedUpdateWithoutOrderInput>
  }

  export type PurchaseDeliveryLogUpdateManyWithWhereWithoutOrderInput = {
    where: PurchaseDeliveryLogScalarWhereInput
    data: XOR<PurchaseDeliveryLogUpdateManyMutationInput, PurchaseDeliveryLogUncheckedUpdateManyWithoutOrderInput>
  }

  export type PurchaseOrderLogCreateWithoutLinesInput = {
    supplierId?: number | null
    supplierName: string
    orderNumber: string
    sequence?: number
    issueDate?: Date | string
    currency?: string
    subtotal?: Decimal | DecimalJsLike | number | string | null
    discount?: Decimal | DecimalJsLike | number | string | null
    netSubtotal?: Decimal | DecimalJsLike | number | string | null
    igv?: Decimal | DecimalJsLike | number | string | null
    total?: Decimal | DecimalJsLike | number | string | null
    totalsJson?: NullableJsonNullValueInput | InputJsonValue
    itemsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    process: QuotationProcessCreateNestedOneWithoutPurchaseOrdersInput
    quotation?: QuotationCreateNestedOneWithoutPurchaseOrdersInput
    deliveries?: PurchaseDeliveryLogCreateNestedManyWithoutOrderInput
  }

  export type PurchaseOrderLogUncheckedCreateWithoutLinesInput = {
    id?: number
    processId: number
    quotationId?: number | null
    supplierId?: number | null
    supplierName: string
    orderNumber: string
    sequence?: number
    issueDate?: Date | string
    currency?: string
    subtotal?: Decimal | DecimalJsLike | number | string | null
    discount?: Decimal | DecimalJsLike | number | string | null
    netSubtotal?: Decimal | DecimalJsLike | number | string | null
    igv?: Decimal | DecimalJsLike | number | string | null
    total?: Decimal | DecimalJsLike | number | string | null
    totalsJson?: NullableJsonNullValueInput | InputJsonValue
    itemsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: PurchaseDeliveryLogUncheckedCreateNestedManyWithoutOrderInput
  }

  export type PurchaseOrderLogCreateOrConnectWithoutLinesInput = {
    where: PurchaseOrderLogWhereUniqueInput
    create: XOR<PurchaseOrderLogCreateWithoutLinesInput, PurchaseOrderLogUncheckedCreateWithoutLinesInput>
  }

  export type QuotationBaselineItemCreateWithoutOrderLinesInput = {
    sheetName?: string | null
    sectionPath?: string | null
    itemCode?: string | null
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    process: QuotationProcessCreateNestedOneWithoutBaselinesInput
    material?: MaterialCreateNestedOneWithoutBaseQuotesInput
    quoteItems?: QuotationItemCreateNestedManyWithoutBaselineItemInput
    deliveryItems?: PurchaseDeliveryItemCreateNestedManyWithoutBaselineInput
  }

  export type QuotationBaselineItemUncheckedCreateWithoutOrderLinesInput = {
    id?: number
    processId: number
    materialId?: number | null
    sheetName?: string | null
    sectionPath?: string | null
    itemCode?: string | null
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    quoteItems?: QuotationItemUncheckedCreateNestedManyWithoutBaselineItemInput
    deliveryItems?: PurchaseDeliveryItemUncheckedCreateNestedManyWithoutBaselineInput
  }

  export type QuotationBaselineItemCreateOrConnectWithoutOrderLinesInput = {
    where: QuotationBaselineItemWhereUniqueInput
    create: XOR<QuotationBaselineItemCreateWithoutOrderLinesInput, QuotationBaselineItemUncheckedCreateWithoutOrderLinesInput>
  }

  export type PurchaseDeliveryItemCreateWithoutOrderLineInput = {
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    delivery: PurchaseDeliveryLogCreateNestedOneWithoutItemsInput
    baseline?: QuotationBaselineItemCreateNestedOneWithoutDeliveryItemsInput
  }

  export type PurchaseDeliveryItemUncheckedCreateWithoutOrderLineInput = {
    id?: number
    deliveryId: number
    baselineId?: number | null
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseDeliveryItemCreateOrConnectWithoutOrderLineInput = {
    where: PurchaseDeliveryItemWhereUniqueInput
    create: XOR<PurchaseDeliveryItemCreateWithoutOrderLineInput, PurchaseDeliveryItemUncheckedCreateWithoutOrderLineInput>
  }

  export type PurchaseDeliveryItemCreateManyOrderLineInputEnvelope = {
    data: PurchaseDeliveryItemCreateManyOrderLineInput | PurchaseDeliveryItemCreateManyOrderLineInput[]
  }

  export type PurchaseOrderLogUpsertWithoutLinesInput = {
    update: XOR<PurchaseOrderLogUpdateWithoutLinesInput, PurchaseOrderLogUncheckedUpdateWithoutLinesInput>
    create: XOR<PurchaseOrderLogCreateWithoutLinesInput, PurchaseOrderLogUncheckedCreateWithoutLinesInput>
    where?: PurchaseOrderLogWhereInput
  }

  export type PurchaseOrderLogUpdateToOneWithWhereWithoutLinesInput = {
    where?: PurchaseOrderLogWhereInput
    data: XOR<PurchaseOrderLogUpdateWithoutLinesInput, PurchaseOrderLogUncheckedUpdateWithoutLinesInput>
  }

  export type PurchaseOrderLogUpdateWithoutLinesInput = {
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    supplierName?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netSubtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    igv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalsJson?: NullableJsonNullValueInput | InputJsonValue
    itemsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    process?: QuotationProcessUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    quotation?: QuotationUpdateOneWithoutPurchaseOrdersNestedInput
    deliveries?: PurchaseDeliveryLogUpdateManyWithoutOrderNestedInput
  }

  export type PurchaseOrderLogUncheckedUpdateWithoutLinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    processId?: IntFieldUpdateOperationsInput | number
    quotationId?: NullableIntFieldUpdateOperationsInput | number | null
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    supplierName?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netSubtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    igv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalsJson?: NullableJsonNullValueInput | InputJsonValue
    itemsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: PurchaseDeliveryLogUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type QuotationBaselineItemUpsertWithoutOrderLinesInput = {
    update: XOR<QuotationBaselineItemUpdateWithoutOrderLinesInput, QuotationBaselineItemUncheckedUpdateWithoutOrderLinesInput>
    create: XOR<QuotationBaselineItemCreateWithoutOrderLinesInput, QuotationBaselineItemUncheckedCreateWithoutOrderLinesInput>
    where?: QuotationBaselineItemWhereInput
  }

  export type QuotationBaselineItemUpdateToOneWithWhereWithoutOrderLinesInput = {
    where?: QuotationBaselineItemWhereInput
    data: XOR<QuotationBaselineItemUpdateWithoutOrderLinesInput, QuotationBaselineItemUncheckedUpdateWithoutOrderLinesInput>
  }

  export type QuotationBaselineItemUpdateWithoutOrderLinesInput = {
    sheetName?: NullableStringFieldUpdateOperationsInput | string | null
    sectionPath?: NullableStringFieldUpdateOperationsInput | string | null
    itemCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    process?: QuotationProcessUpdateOneRequiredWithoutBaselinesNestedInput
    material?: MaterialUpdateOneWithoutBaseQuotesNestedInput
    quoteItems?: QuotationItemUpdateManyWithoutBaselineItemNestedInput
    deliveryItems?: PurchaseDeliveryItemUpdateManyWithoutBaselineNestedInput
  }

  export type QuotationBaselineItemUncheckedUpdateWithoutOrderLinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    processId?: IntFieldUpdateOperationsInput | number
    materialId?: NullableIntFieldUpdateOperationsInput | number | null
    sheetName?: NullableStringFieldUpdateOperationsInput | string | null
    sectionPath?: NullableStringFieldUpdateOperationsInput | string | null
    itemCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quoteItems?: QuotationItemUncheckedUpdateManyWithoutBaselineItemNestedInput
    deliveryItems?: PurchaseDeliveryItemUncheckedUpdateManyWithoutBaselineNestedInput
  }

  export type PurchaseDeliveryItemUpsertWithWhereUniqueWithoutOrderLineInput = {
    where: PurchaseDeliveryItemWhereUniqueInput
    update: XOR<PurchaseDeliveryItemUpdateWithoutOrderLineInput, PurchaseDeliveryItemUncheckedUpdateWithoutOrderLineInput>
    create: XOR<PurchaseDeliveryItemCreateWithoutOrderLineInput, PurchaseDeliveryItemUncheckedCreateWithoutOrderLineInput>
  }

  export type PurchaseDeliveryItemUpdateWithWhereUniqueWithoutOrderLineInput = {
    where: PurchaseDeliveryItemWhereUniqueInput
    data: XOR<PurchaseDeliveryItemUpdateWithoutOrderLineInput, PurchaseDeliveryItemUncheckedUpdateWithoutOrderLineInput>
  }

  export type PurchaseDeliveryItemUpdateManyWithWhereWithoutOrderLineInput = {
    where: PurchaseDeliveryItemScalarWhereInput
    data: XOR<PurchaseDeliveryItemUpdateManyMutationInput, PurchaseDeliveryItemUncheckedUpdateManyWithoutOrderLineInput>
  }

  export type QuotationProcessCreateWithoutDeliveryLogsInput = {
    name: string
    code?: string | null
    status?: $Enums.QuotationProcessStatus
    baseCurrency?: string
    targetCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    targetMarginPct?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    baselineFile?: QuotationAttachmentCreateNestedOneWithoutProcessInput
    baselines?: QuotationBaselineItemCreateNestedManyWithoutProcessInput
    quotations?: QuotationCreateNestedManyWithoutProcessInput
    purchaseOrders?: PurchaseOrderLogCreateNestedManyWithoutProcessInput
  }

  export type QuotationProcessUncheckedCreateWithoutDeliveryLogsInput = {
    id?: number
    name: string
    code?: string | null
    status?: $Enums.QuotationProcessStatus
    baseCurrency?: string
    targetCurrency?: string | null
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    targetMarginPct?: Decimal | DecimalJsLike | number | string | null
    baselineFileId?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    baselines?: QuotationBaselineItemUncheckedCreateNestedManyWithoutProcessInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutProcessInput
    purchaseOrders?: PurchaseOrderLogUncheckedCreateNestedManyWithoutProcessInput
  }

  export type QuotationProcessCreateOrConnectWithoutDeliveryLogsInput = {
    where: QuotationProcessWhereUniqueInput
    create: XOR<QuotationProcessCreateWithoutDeliveryLogsInput, QuotationProcessUncheckedCreateWithoutDeliveryLogsInput>
  }

  export type PurchaseOrderLogCreateWithoutDeliveriesInput = {
    supplierId?: number | null
    supplierName: string
    orderNumber: string
    sequence?: number
    issueDate?: Date | string
    currency?: string
    subtotal?: Decimal | DecimalJsLike | number | string | null
    discount?: Decimal | DecimalJsLike | number | string | null
    netSubtotal?: Decimal | DecimalJsLike | number | string | null
    igv?: Decimal | DecimalJsLike | number | string | null
    total?: Decimal | DecimalJsLike | number | string | null
    totalsJson?: NullableJsonNullValueInput | InputJsonValue
    itemsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    process: QuotationProcessCreateNestedOneWithoutPurchaseOrdersInput
    quotation?: QuotationCreateNestedOneWithoutPurchaseOrdersInput
    lines?: PurchaseOrderLineCreateNestedManyWithoutOrderInput
  }

  export type PurchaseOrderLogUncheckedCreateWithoutDeliveriesInput = {
    id?: number
    processId: number
    quotationId?: number | null
    supplierId?: number | null
    supplierName: string
    orderNumber: string
    sequence?: number
    issueDate?: Date | string
    currency?: string
    subtotal?: Decimal | DecimalJsLike | number | string | null
    discount?: Decimal | DecimalJsLike | number | string | null
    netSubtotal?: Decimal | DecimalJsLike | number | string | null
    igv?: Decimal | DecimalJsLike | number | string | null
    total?: Decimal | DecimalJsLike | number | string | null
    totalsJson?: NullableJsonNullValueInput | InputJsonValue
    itemsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutOrderInput
  }

  export type PurchaseOrderLogCreateOrConnectWithoutDeliveriesInput = {
    where: PurchaseOrderLogWhereUniqueInput
    create: XOR<PurchaseOrderLogCreateWithoutDeliveriesInput, PurchaseOrderLogUncheckedCreateWithoutDeliveriesInput>
  }

  export type ProveedorCreateWithoutDeliveriesInput = {
    name: string
    ruc?: string | null
    phone?: string | null
    moves?: MoveCreateNestedManyWithoutProveedorInput
    expenses?: ExpenseCreateNestedManyWithoutProveedorInput
    quotations?: QuotationCreateNestedManyWithoutProveedorInput
  }

  export type ProveedorUncheckedCreateWithoutDeliveriesInput = {
    id?: number
    name: string
    ruc?: string | null
    phone?: string | null
    moves?: MoveUncheckedCreateNestedManyWithoutProveedorInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutProveedorInput
    quotations?: QuotationUncheckedCreateNestedManyWithoutProveedorInput
  }

  export type ProveedorCreateOrConnectWithoutDeliveriesInput = {
    where: ProveedorWhereUniqueInput
    create: XOR<ProveedorCreateWithoutDeliveriesInput, ProveedorUncheckedCreateWithoutDeliveriesInput>
  }

  export type PurchaseDeliveryItemCreateWithoutDeliveryInput = {
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderLine?: PurchaseOrderLineCreateNestedOneWithoutDeliveriesInput
    baseline?: QuotationBaselineItemCreateNestedOneWithoutDeliveryItemsInput
  }

  export type PurchaseDeliveryItemUncheckedCreateWithoutDeliveryInput = {
    id?: number
    orderLineId?: number | null
    baselineId?: number | null
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseDeliveryItemCreateOrConnectWithoutDeliveryInput = {
    where: PurchaseDeliveryItemWhereUniqueInput
    create: XOR<PurchaseDeliveryItemCreateWithoutDeliveryInput, PurchaseDeliveryItemUncheckedCreateWithoutDeliveryInput>
  }

  export type PurchaseDeliveryItemCreateManyDeliveryInputEnvelope = {
    data: PurchaseDeliveryItemCreateManyDeliveryInput | PurchaseDeliveryItemCreateManyDeliveryInput[]
  }

  export type QuotationProcessUpsertWithoutDeliveryLogsInput = {
    update: XOR<QuotationProcessUpdateWithoutDeliveryLogsInput, QuotationProcessUncheckedUpdateWithoutDeliveryLogsInput>
    create: XOR<QuotationProcessCreateWithoutDeliveryLogsInput, QuotationProcessUncheckedCreateWithoutDeliveryLogsInput>
    where?: QuotationProcessWhereInput
  }

  export type QuotationProcessUpdateToOneWithWhereWithoutDeliveryLogsInput = {
    where?: QuotationProcessWhereInput
    data: XOR<QuotationProcessUpdateWithoutDeliveryLogsInput, QuotationProcessUncheckedUpdateWithoutDeliveryLogsInput>
  }

  export type QuotationProcessUpdateWithoutDeliveryLogsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuotationProcessStatusFieldUpdateOperationsInput | $Enums.QuotationProcessStatus
    baseCurrency?: StringFieldUpdateOperationsInput | string
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    targetMarginPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baselineFile?: QuotationAttachmentUpdateOneWithoutProcessNestedInput
    baselines?: QuotationBaselineItemUpdateManyWithoutProcessNestedInput
    quotations?: QuotationUpdateManyWithoutProcessNestedInput
    purchaseOrders?: PurchaseOrderLogUpdateManyWithoutProcessNestedInput
  }

  export type QuotationProcessUncheckedUpdateWithoutDeliveryLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuotationProcessStatusFieldUpdateOperationsInput | $Enums.QuotationProcessStatus
    baseCurrency?: StringFieldUpdateOperationsInput | string
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    targetMarginPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baselineFileId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baselines?: QuotationBaselineItemUncheckedUpdateManyWithoutProcessNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutProcessNestedInput
    purchaseOrders?: PurchaseOrderLogUncheckedUpdateManyWithoutProcessNestedInput
  }

  export type PurchaseOrderLogUpsertWithoutDeliveriesInput = {
    update: XOR<PurchaseOrderLogUpdateWithoutDeliveriesInput, PurchaseOrderLogUncheckedUpdateWithoutDeliveriesInput>
    create: XOR<PurchaseOrderLogCreateWithoutDeliveriesInput, PurchaseOrderLogUncheckedCreateWithoutDeliveriesInput>
    where?: PurchaseOrderLogWhereInput
  }

  export type PurchaseOrderLogUpdateToOneWithWhereWithoutDeliveriesInput = {
    where?: PurchaseOrderLogWhereInput
    data: XOR<PurchaseOrderLogUpdateWithoutDeliveriesInput, PurchaseOrderLogUncheckedUpdateWithoutDeliveriesInput>
  }

  export type PurchaseOrderLogUpdateWithoutDeliveriesInput = {
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    supplierName?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netSubtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    igv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalsJson?: NullableJsonNullValueInput | InputJsonValue
    itemsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    process?: QuotationProcessUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    quotation?: QuotationUpdateOneWithoutPurchaseOrdersNestedInput
    lines?: PurchaseOrderLineUpdateManyWithoutOrderNestedInput
  }

  export type PurchaseOrderLogUncheckedUpdateWithoutDeliveriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    processId?: IntFieldUpdateOperationsInput | number
    quotationId?: NullableIntFieldUpdateOperationsInput | number | null
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    supplierName?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netSubtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    igv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalsJson?: NullableJsonNullValueInput | InputJsonValue
    itemsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: PurchaseOrderLineUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type ProveedorUpsertWithoutDeliveriesInput = {
    update: XOR<ProveedorUpdateWithoutDeliveriesInput, ProveedorUncheckedUpdateWithoutDeliveriesInput>
    create: XOR<ProveedorCreateWithoutDeliveriesInput, ProveedorUncheckedCreateWithoutDeliveriesInput>
    where?: ProveedorWhereInput
  }

  export type ProveedorUpdateToOneWithWhereWithoutDeliveriesInput = {
    where?: ProveedorWhereInput
    data: XOR<ProveedorUpdateWithoutDeliveriesInput, ProveedorUncheckedUpdateWithoutDeliveriesInput>
  }

  export type ProveedorUpdateWithoutDeliveriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    moves?: MoveUpdateManyWithoutProveedorNestedInput
    expenses?: ExpenseUpdateManyWithoutProveedorNestedInput
    quotations?: QuotationUpdateManyWithoutProveedorNestedInput
  }

  export type ProveedorUncheckedUpdateWithoutDeliveriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    moves?: MoveUncheckedUpdateManyWithoutProveedorNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutProveedorNestedInput
    quotations?: QuotationUncheckedUpdateManyWithoutProveedorNestedInput
  }

  export type PurchaseDeliveryItemUpsertWithWhereUniqueWithoutDeliveryInput = {
    where: PurchaseDeliveryItemWhereUniqueInput
    update: XOR<PurchaseDeliveryItemUpdateWithoutDeliveryInput, PurchaseDeliveryItemUncheckedUpdateWithoutDeliveryInput>
    create: XOR<PurchaseDeliveryItemCreateWithoutDeliveryInput, PurchaseDeliveryItemUncheckedCreateWithoutDeliveryInput>
  }

  export type PurchaseDeliveryItemUpdateWithWhereUniqueWithoutDeliveryInput = {
    where: PurchaseDeliveryItemWhereUniqueInput
    data: XOR<PurchaseDeliveryItemUpdateWithoutDeliveryInput, PurchaseDeliveryItemUncheckedUpdateWithoutDeliveryInput>
  }

  export type PurchaseDeliveryItemUpdateManyWithWhereWithoutDeliveryInput = {
    where: PurchaseDeliveryItemScalarWhereInput
    data: XOR<PurchaseDeliveryItemUpdateManyMutationInput, PurchaseDeliveryItemUncheckedUpdateManyWithoutDeliveryInput>
  }

  export type PurchaseDeliveryLogCreateWithoutItemsInput = {
    supplierName?: string | null
    guideNumber?: string | null
    date?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    process: QuotationProcessCreateNestedOneWithoutDeliveryLogsInput
    order?: PurchaseOrderLogCreateNestedOneWithoutDeliveriesInput
    proveedor?: ProveedorCreateNestedOneWithoutDeliveriesInput
  }

  export type PurchaseDeliveryLogUncheckedCreateWithoutItemsInput = {
    id?: number
    processId: number
    orderId?: number | null
    proveedorId?: number | null
    supplierName?: string | null
    guideNumber?: string | null
    date?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseDeliveryLogCreateOrConnectWithoutItemsInput = {
    where: PurchaseDeliveryLogWhereUniqueInput
    create: XOR<PurchaseDeliveryLogCreateWithoutItemsInput, PurchaseDeliveryLogUncheckedCreateWithoutItemsInput>
  }

  export type PurchaseOrderLineCreateWithoutDeliveriesInput = {
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    order: PurchaseOrderLogCreateNestedOneWithoutLinesInput
    baseline?: QuotationBaselineItemCreateNestedOneWithoutOrderLinesInput
  }

  export type PurchaseOrderLineUncheckedCreateWithoutDeliveriesInput = {
    id?: number
    orderId: number
    baselineId?: number | null
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderLineCreateOrConnectWithoutDeliveriesInput = {
    where: PurchaseOrderLineWhereUniqueInput
    create: XOR<PurchaseOrderLineCreateWithoutDeliveriesInput, PurchaseOrderLineUncheckedCreateWithoutDeliveriesInput>
  }

  export type QuotationBaselineItemCreateWithoutDeliveryItemsInput = {
    sheetName?: string | null
    sectionPath?: string | null
    itemCode?: string | null
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    process: QuotationProcessCreateNestedOneWithoutBaselinesInput
    material?: MaterialCreateNestedOneWithoutBaseQuotesInput
    quoteItems?: QuotationItemCreateNestedManyWithoutBaselineItemInput
    orderLines?: PurchaseOrderLineCreateNestedManyWithoutBaselineInput
  }

  export type QuotationBaselineItemUncheckedCreateWithoutDeliveryItemsInput = {
    id?: number
    processId: number
    materialId?: number | null
    sheetName?: string | null
    sectionPath?: string | null
    itemCode?: string | null
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    quoteItems?: QuotationItemUncheckedCreateNestedManyWithoutBaselineItemInput
    orderLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutBaselineInput
  }

  export type QuotationBaselineItemCreateOrConnectWithoutDeliveryItemsInput = {
    where: QuotationBaselineItemWhereUniqueInput
    create: XOR<QuotationBaselineItemCreateWithoutDeliveryItemsInput, QuotationBaselineItemUncheckedCreateWithoutDeliveryItemsInput>
  }

  export type PurchaseDeliveryLogUpsertWithoutItemsInput = {
    update: XOR<PurchaseDeliveryLogUpdateWithoutItemsInput, PurchaseDeliveryLogUncheckedUpdateWithoutItemsInput>
    create: XOR<PurchaseDeliveryLogCreateWithoutItemsInput, PurchaseDeliveryLogUncheckedCreateWithoutItemsInput>
    where?: PurchaseDeliveryLogWhereInput
  }

  export type PurchaseDeliveryLogUpdateToOneWithWhereWithoutItemsInput = {
    where?: PurchaseDeliveryLogWhereInput
    data: XOR<PurchaseDeliveryLogUpdateWithoutItemsInput, PurchaseDeliveryLogUncheckedUpdateWithoutItemsInput>
  }

  export type PurchaseDeliveryLogUpdateWithoutItemsInput = {
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    guideNumber?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    process?: QuotationProcessUpdateOneRequiredWithoutDeliveryLogsNestedInput
    order?: PurchaseOrderLogUpdateOneWithoutDeliveriesNestedInput
    proveedor?: ProveedorUpdateOneWithoutDeliveriesNestedInput
  }

  export type PurchaseDeliveryLogUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    processId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    proveedorId?: NullableIntFieldUpdateOperationsInput | number | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    guideNumber?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderLineUpsertWithoutDeliveriesInput = {
    update: XOR<PurchaseOrderLineUpdateWithoutDeliveriesInput, PurchaseOrderLineUncheckedUpdateWithoutDeliveriesInput>
    create: XOR<PurchaseOrderLineCreateWithoutDeliveriesInput, PurchaseOrderLineUncheckedCreateWithoutDeliveriesInput>
    where?: PurchaseOrderLineWhereInput
  }

  export type PurchaseOrderLineUpdateToOneWithWhereWithoutDeliveriesInput = {
    where?: PurchaseOrderLineWhereInput
    data: XOR<PurchaseOrderLineUpdateWithoutDeliveriesInput, PurchaseOrderLineUncheckedUpdateWithoutDeliveriesInput>
  }

  export type PurchaseOrderLineUpdateWithoutDeliveriesInput = {
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: PurchaseOrderLogUpdateOneRequiredWithoutLinesNestedInput
    baseline?: QuotationBaselineItemUpdateOneWithoutOrderLinesNestedInput
  }

  export type PurchaseOrderLineUncheckedUpdateWithoutDeliveriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    baselineId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotationBaselineItemUpsertWithoutDeliveryItemsInput = {
    update: XOR<QuotationBaselineItemUpdateWithoutDeliveryItemsInput, QuotationBaselineItemUncheckedUpdateWithoutDeliveryItemsInput>
    create: XOR<QuotationBaselineItemCreateWithoutDeliveryItemsInput, QuotationBaselineItemUncheckedCreateWithoutDeliveryItemsInput>
    where?: QuotationBaselineItemWhereInput
  }

  export type QuotationBaselineItemUpdateToOneWithWhereWithoutDeliveryItemsInput = {
    where?: QuotationBaselineItemWhereInput
    data: XOR<QuotationBaselineItemUpdateWithoutDeliveryItemsInput, QuotationBaselineItemUncheckedUpdateWithoutDeliveryItemsInput>
  }

  export type QuotationBaselineItemUpdateWithoutDeliveryItemsInput = {
    sheetName?: NullableStringFieldUpdateOperationsInput | string | null
    sectionPath?: NullableStringFieldUpdateOperationsInput | string | null
    itemCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    process?: QuotationProcessUpdateOneRequiredWithoutBaselinesNestedInput
    material?: MaterialUpdateOneWithoutBaseQuotesNestedInput
    quoteItems?: QuotationItemUpdateManyWithoutBaselineItemNestedInput
    orderLines?: PurchaseOrderLineUpdateManyWithoutBaselineNestedInput
  }

  export type QuotationBaselineItemUncheckedUpdateWithoutDeliveryItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    processId?: IntFieldUpdateOperationsInput | number
    materialId?: NullableIntFieldUpdateOperationsInput | number | null
    sheetName?: NullableStringFieldUpdateOperationsInput | string | null
    sectionPath?: NullableStringFieldUpdateOperationsInput | string | null
    itemCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quoteItems?: QuotationItemUncheckedUpdateManyWithoutBaselineItemNestedInput
    orderLines?: PurchaseOrderLineUncheckedUpdateManyWithoutBaselineNestedInput
  }

  export type FrenteCreateManyObraInput = {
    id?: number
    name: string
  }

  export type MoveCreateManyObraInput = {
    id?: number
    frenteId?: number | null
    materialId: number
    proveedorId?: number | null
    type: $Enums.MoveType
    quantity: number
    unitCost?: number | null
    totalCost?: number | null
    date?: Date | string
    note?: string | null
    docType?: $Enums.DocType | null
    docSerie?: string | null
    docNumero?: string | null
    igvRate?: Decimal | DecimalJsLike | number | string | null
    isTaxable?: boolean | null
    responsible?: string | null
    assetStatus?: $Enums.AssetStatus | null
  }

  export type IncomeCreateManyObraInput = {
    id?: number
    frenteId?: number | null
    date?: Date | string
    description?: string | null
    docType?: $Enums.DocType
    docSerie?: string | null
    docNumero?: string | null
    status?: $Enums.IncomeStatus
    igvRate?: Decimal | DecimalJsLike | number | string
    isTaxable?: boolean
    base: Decimal | DecimalJsLike | number | string
    igv: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCreateManyObraInput = {
    id?: number
    frenteId?: number | null
    proveedorId?: number | null
    materialId?: number | null
    categoryId?: number | null
    moveId?: number | null
    docType?: $Enums.DocType
    docSerie?: string | null
    docNumero?: string | null
    date?: Date | string
    description?: string | null
    spentBy?: string | null
    type?: $Enums.ExpenseType
    variableType?: $Enums.VariableType
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
    igvRate?: Decimal | DecimalJsLike | number | string
    isTaxable?: boolean
    base: Decimal | DecimalJsLike | number | string
    igv: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paymentMethod?: $Enums.PaymentMethod
    paidAt?: Date | string | null
    status?: string
    reminderIntervalDays?: number | null
    reminderNextDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeCreateManyObraInput = {
    id?: number
    code?: string | null
    firstName: string
    lastName: string
    documentType?: $Enums.DocumentType | null
    documentNumber?: string | null
    position?: string | null
    phone?: string | null
    email?: string | null
    bankType?: $Enums.BankType
    accountNumber?: string | null
    cci?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    baseSalary?: Decimal | DecimalJsLike | number | string
    dailyHours?: Decimal | DecimalJsLike | number | string
    pensionSystem?: $Enums.PensionSystem
    pensionRate?: Decimal | DecimalJsLike | number | string
    healthRate?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    area?: $Enums.EmployeeArea
    notes?: string | null
    absenceSundayPenalty?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollPeriodCreateManyObraInput = {
    id?: number
    month: number
    year: number
    startDate: Date | string
    endDate: Date | string
    workingDays: number
    status?: $Enums.PayrollPeriodStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyCashRenditionCreateManyObraInput = {
    id?: number
    date?: Date | string
    openingBalance?: Decimal | DecimalJsLike | number | string
    received?: Decimal | DecimalJsLike | number | string
    spent?: Decimal | DecimalJsLike | number | string
    personalContribution?: Decimal | DecimalJsLike | number | string
    balance?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FrenteUpdateWithoutObraInput = {
    name?: StringFieldUpdateOperationsInput | string
    moves?: MoveUpdateManyWithoutFrenteNestedInput
    incomes?: IncomeUpdateManyWithoutFrenteNestedInput
    expenses?: ExpenseUpdateManyWithoutFrenteNestedInput
  }

  export type FrenteUncheckedUpdateWithoutObraInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    moves?: MoveUncheckedUpdateManyWithoutFrenteNestedInput
    incomes?: IncomeUncheckedUpdateManyWithoutFrenteNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutFrenteNestedInput
  }

  export type FrenteUncheckedUpdateManyWithoutObraInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MoveUpdateWithoutObraInput = {
    type?: EnumMoveTypeFieldUpdateOperationsInput | $Enums.MoveType
    quantity?: FloatFieldUpdateOperationsInput | number
    unitCost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableEnumDocTypeFieldUpdateOperationsInput | $Enums.DocType | null
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    igvRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isTaxable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    responsible?: NullableStringFieldUpdateOperationsInput | string | null
    assetStatus?: NullableEnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus | null
    frente?: FrenteUpdateOneWithoutMovesNestedInput
    material?: MaterialUpdateOneRequiredWithoutMovesNestedInput
    proveedor?: ProveedorUpdateOneWithoutMovesNestedInput
    expense?: ExpenseUpdateOneWithoutMoveNestedInput
  }

  export type MoveUncheckedUpdateWithoutObraInput = {
    id?: IntFieldUpdateOperationsInput | number
    frenteId?: NullableIntFieldUpdateOperationsInput | number | null
    materialId?: IntFieldUpdateOperationsInput | number
    proveedorId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumMoveTypeFieldUpdateOperationsInput | $Enums.MoveType
    quantity?: FloatFieldUpdateOperationsInput | number
    unitCost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableEnumDocTypeFieldUpdateOperationsInput | $Enums.DocType | null
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    igvRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isTaxable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    responsible?: NullableStringFieldUpdateOperationsInput | string | null
    assetStatus?: NullableEnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus | null
    expense?: ExpenseUncheckedUpdateOneWithoutMoveNestedInput
  }

  export type MoveUncheckedUpdateManyWithoutObraInput = {
    id?: IntFieldUpdateOperationsInput | number
    frenteId?: NullableIntFieldUpdateOperationsInput | number | null
    materialId?: IntFieldUpdateOperationsInput | number
    proveedorId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumMoveTypeFieldUpdateOperationsInput | $Enums.MoveType
    quantity?: FloatFieldUpdateOperationsInput | number
    unitCost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableEnumDocTypeFieldUpdateOperationsInput | $Enums.DocType | null
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    igvRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isTaxable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    responsible?: NullableStringFieldUpdateOperationsInput | string | null
    assetStatus?: NullableEnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus | null
  }

  export type IncomeUpdateWithoutObraInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: EnumDocTypeFieldUpdateOperationsInput | $Enums.DocType
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumIncomeStatusFieldUpdateOperationsInput | $Enums.IncomeStatus
    igvRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    base?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    igv?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    frente?: FrenteUpdateOneWithoutIncomesNestedInput
  }

  export type IncomeUncheckedUpdateWithoutObraInput = {
    id?: IntFieldUpdateOperationsInput | number
    frenteId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: EnumDocTypeFieldUpdateOperationsInput | $Enums.DocType
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumIncomeStatusFieldUpdateOperationsInput | $Enums.IncomeStatus
    igvRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    base?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    igv?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncomeUncheckedUpdateManyWithoutObraInput = {
    id?: IntFieldUpdateOperationsInput | number
    frenteId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: EnumDocTypeFieldUpdateOperationsInput | $Enums.DocType
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumIncomeStatusFieldUpdateOperationsInput | $Enums.IncomeStatus
    igvRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    base?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    igv?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUpdateWithoutObraInput = {
    docType?: EnumDocTypeFieldUpdateOperationsInput | $Enums.DocType
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    spentBy?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExpenseTypeFieldUpdateOperationsInput | $Enums.ExpenseType
    variableType?: EnumVariableTypeFieldUpdateOperationsInput | $Enums.VariableType
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    igvRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    base?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    igv?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    reminderIntervalDays?: NullableIntFieldUpdateOperationsInput | number | null
    reminderNextDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    frente?: FrenteUpdateOneWithoutExpensesNestedInput
    proveedor?: ProveedorUpdateOneWithoutExpensesNestedInput
    material?: MaterialUpdateOneWithoutExpensesNestedInput
    category?: ExpenseCategoryUpdateOneWithoutExpensesNestedInput
    move?: MoveUpdateOneWithoutExpenseNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutObraInput = {
    id?: IntFieldUpdateOperationsInput | number
    frenteId?: NullableIntFieldUpdateOperationsInput | number | null
    proveedorId?: NullableIntFieldUpdateOperationsInput | number | null
    materialId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    moveId?: NullableIntFieldUpdateOperationsInput | number | null
    docType?: EnumDocTypeFieldUpdateOperationsInput | $Enums.DocType
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    spentBy?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExpenseTypeFieldUpdateOperationsInput | $Enums.ExpenseType
    variableType?: EnumVariableTypeFieldUpdateOperationsInput | $Enums.VariableType
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    igvRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    base?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    igv?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    reminderIntervalDays?: NullableIntFieldUpdateOperationsInput | number | null
    reminderNextDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyWithoutObraInput = {
    id?: IntFieldUpdateOperationsInput | number
    frenteId?: NullableIntFieldUpdateOperationsInput | number | null
    proveedorId?: NullableIntFieldUpdateOperationsInput | number | null
    materialId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    moveId?: NullableIntFieldUpdateOperationsInput | number | null
    docType?: EnumDocTypeFieldUpdateOperationsInput | $Enums.DocType
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    spentBy?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExpenseTypeFieldUpdateOperationsInput | $Enums.ExpenseType
    variableType?: EnumVariableTypeFieldUpdateOperationsInput | $Enums.VariableType
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    igvRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    base?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    igv?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    reminderIntervalDays?: NullableIntFieldUpdateOperationsInput | number | null
    reminderNextDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUpdateWithoutObraInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    documentType?: NullableEnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    bankType?: EnumBankTypeFieldUpdateOperationsInput | $Enums.BankType
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cci?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dailyHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pensionSystem?: EnumPensionSystemFieldUpdateOperationsInput | $Enums.PensionSystem
    pensionRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    healthRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    area?: EnumEmployeeAreaFieldUpdateOperationsInput | $Enums.EmployeeArea
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    absenceSundayPenalty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: AttendanceRecordUpdateManyWithoutEmployeeNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutEmployeeNestedInput
    accumulationPayment?: EmployeeAccumulationPaymentUpdateOneWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutObraInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    documentType?: NullableEnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    bankType?: EnumBankTypeFieldUpdateOperationsInput | $Enums.BankType
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cci?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dailyHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pensionSystem?: EnumPensionSystemFieldUpdateOperationsInput | $Enums.PensionSystem
    pensionRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    healthRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    area?: EnumEmployeeAreaFieldUpdateOperationsInput | $Enums.EmployeeArea
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    absenceSundayPenalty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: AttendanceRecordUncheckedUpdateManyWithoutEmployeeNestedInput
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    accumulationPayment?: EmployeeAccumulationPaymentUncheckedUpdateOneWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutObraInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    documentType?: NullableEnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    bankType?: EnumBankTypeFieldUpdateOperationsInput | $Enums.BankType
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cci?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dailyHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pensionSystem?: EnumPensionSystemFieldUpdateOperationsInput | $Enums.PensionSystem
    pensionRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    healthRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    area?: EnumEmployeeAreaFieldUpdateOperationsInput | $Enums.EmployeeArea
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    absenceSundayPenalty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollPeriodUpdateWithoutObraInput = {
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    workingDays?: IntFieldUpdateOperationsInput | number
    status?: EnumPayrollPeriodStatusFieldUpdateOperationsInput | $Enums.PayrollPeriodStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entries?: PayrollEntryUpdateManyWithoutPeriodNestedInput
  }

  export type PayrollPeriodUncheckedUpdateWithoutObraInput = {
    id?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    workingDays?: IntFieldUpdateOperationsInput | number
    status?: EnumPayrollPeriodStatusFieldUpdateOperationsInput | $Enums.PayrollPeriodStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entries?: PayrollEntryUncheckedUpdateManyWithoutPeriodNestedInput
  }

  export type PayrollPeriodUncheckedUpdateManyWithoutObraInput = {
    id?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    workingDays?: IntFieldUpdateOperationsInput | number
    status?: EnumPayrollPeriodStatusFieldUpdateOperationsInput | $Enums.PayrollPeriodStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyCashRenditionUpdateWithoutObraInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    received?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    spent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personalContribution?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expenses?: DailyCashExpenseUpdateManyWithoutRenditionNestedInput
  }

  export type DailyCashRenditionUncheckedUpdateWithoutObraInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    received?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    spent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personalContribution?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expenses?: DailyCashExpenseUncheckedUpdateManyWithoutRenditionNestedInput
  }

  export type DailyCashRenditionUncheckedUpdateManyWithoutObraInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    received?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    spent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personalContribution?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoveCreateManyMaterialInput = {
    id?: number
    obraId: number
    frenteId?: number | null
    proveedorId?: number | null
    type: $Enums.MoveType
    quantity: number
    unitCost?: number | null
    totalCost?: number | null
    date?: Date | string
    note?: string | null
    docType?: $Enums.DocType | null
    docSerie?: string | null
    docNumero?: string | null
    igvRate?: Decimal | DecimalJsLike | number | string | null
    isTaxable?: boolean | null
    responsible?: string | null
    assetStatus?: $Enums.AssetStatus | null
  }

  export type ExpenseCreateManyMaterialInput = {
    id?: number
    obraId: number
    frenteId?: number | null
    proveedorId?: number | null
    categoryId?: number | null
    moveId?: number | null
    docType?: $Enums.DocType
    docSerie?: string | null
    docNumero?: string | null
    date?: Date | string
    description?: string | null
    spentBy?: string | null
    type?: $Enums.ExpenseType
    variableType?: $Enums.VariableType
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
    igvRate?: Decimal | DecimalJsLike | number | string
    isTaxable?: boolean
    base: Decimal | DecimalJsLike | number | string
    igv: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paymentMethod?: $Enums.PaymentMethod
    paidAt?: Date | string | null
    status?: string
    reminderIntervalDays?: number | null
    reminderNextDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuotationBaselineItemCreateManyMaterialInput = {
    id?: number
    processId: number
    sheetName?: string | null
    sectionPath?: string | null
    itemCode?: string | null
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuotationItemCreateManyMaterialInput = {
    id?: number
    quotationId: number
    baselineItemId?: number | null
    sourceRow?: number | null
    itemCode?: string | null
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    normalizedPrice?: Decimal | DecimalJsLike | number | string | null
    matchScore?: number | null
    extraAttributes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MoveUpdateWithoutMaterialInput = {
    type?: EnumMoveTypeFieldUpdateOperationsInput | $Enums.MoveType
    quantity?: FloatFieldUpdateOperationsInput | number
    unitCost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableEnumDocTypeFieldUpdateOperationsInput | $Enums.DocType | null
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    igvRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isTaxable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    responsible?: NullableStringFieldUpdateOperationsInput | string | null
    assetStatus?: NullableEnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus | null
    obra?: ObraUpdateOneRequiredWithoutMovesNestedInput
    frente?: FrenteUpdateOneWithoutMovesNestedInput
    proveedor?: ProveedorUpdateOneWithoutMovesNestedInput
    expense?: ExpenseUpdateOneWithoutMoveNestedInput
  }

  export type MoveUncheckedUpdateWithoutMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    obraId?: IntFieldUpdateOperationsInput | number
    frenteId?: NullableIntFieldUpdateOperationsInput | number | null
    proveedorId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumMoveTypeFieldUpdateOperationsInput | $Enums.MoveType
    quantity?: FloatFieldUpdateOperationsInput | number
    unitCost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableEnumDocTypeFieldUpdateOperationsInput | $Enums.DocType | null
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    igvRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isTaxable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    responsible?: NullableStringFieldUpdateOperationsInput | string | null
    assetStatus?: NullableEnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus | null
    expense?: ExpenseUncheckedUpdateOneWithoutMoveNestedInput
  }

  export type MoveUncheckedUpdateManyWithoutMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    obraId?: IntFieldUpdateOperationsInput | number
    frenteId?: NullableIntFieldUpdateOperationsInput | number | null
    proveedorId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumMoveTypeFieldUpdateOperationsInput | $Enums.MoveType
    quantity?: FloatFieldUpdateOperationsInput | number
    unitCost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableEnumDocTypeFieldUpdateOperationsInput | $Enums.DocType | null
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    igvRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isTaxable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    responsible?: NullableStringFieldUpdateOperationsInput | string | null
    assetStatus?: NullableEnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus | null
  }

  export type ExpenseUpdateWithoutMaterialInput = {
    docType?: EnumDocTypeFieldUpdateOperationsInput | $Enums.DocType
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    spentBy?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExpenseTypeFieldUpdateOperationsInput | $Enums.ExpenseType
    variableType?: EnumVariableTypeFieldUpdateOperationsInput | $Enums.VariableType
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    igvRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    base?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    igv?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    reminderIntervalDays?: NullableIntFieldUpdateOperationsInput | number | null
    reminderNextDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    obra?: ObraUpdateOneRequiredWithoutExpensesNestedInput
    frente?: FrenteUpdateOneWithoutExpensesNestedInput
    proveedor?: ProveedorUpdateOneWithoutExpensesNestedInput
    category?: ExpenseCategoryUpdateOneWithoutExpensesNestedInput
    move?: MoveUpdateOneWithoutExpenseNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    obraId?: IntFieldUpdateOperationsInput | number
    frenteId?: NullableIntFieldUpdateOperationsInput | number | null
    proveedorId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    moveId?: NullableIntFieldUpdateOperationsInput | number | null
    docType?: EnumDocTypeFieldUpdateOperationsInput | $Enums.DocType
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    spentBy?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExpenseTypeFieldUpdateOperationsInput | $Enums.ExpenseType
    variableType?: EnumVariableTypeFieldUpdateOperationsInput | $Enums.VariableType
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    igvRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    base?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    igv?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    reminderIntervalDays?: NullableIntFieldUpdateOperationsInput | number | null
    reminderNextDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyWithoutMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    obraId?: IntFieldUpdateOperationsInput | number
    frenteId?: NullableIntFieldUpdateOperationsInput | number | null
    proveedorId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    moveId?: NullableIntFieldUpdateOperationsInput | number | null
    docType?: EnumDocTypeFieldUpdateOperationsInput | $Enums.DocType
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    spentBy?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExpenseTypeFieldUpdateOperationsInput | $Enums.ExpenseType
    variableType?: EnumVariableTypeFieldUpdateOperationsInput | $Enums.VariableType
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    igvRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    base?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    igv?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    reminderIntervalDays?: NullableIntFieldUpdateOperationsInput | number | null
    reminderNextDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotationBaselineItemUpdateWithoutMaterialInput = {
    sheetName?: NullableStringFieldUpdateOperationsInput | string | null
    sectionPath?: NullableStringFieldUpdateOperationsInput | string | null
    itemCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    process?: QuotationProcessUpdateOneRequiredWithoutBaselinesNestedInput
    quoteItems?: QuotationItemUpdateManyWithoutBaselineItemNestedInput
    orderLines?: PurchaseOrderLineUpdateManyWithoutBaselineNestedInput
    deliveryItems?: PurchaseDeliveryItemUpdateManyWithoutBaselineNestedInput
  }

  export type QuotationBaselineItemUncheckedUpdateWithoutMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    processId?: IntFieldUpdateOperationsInput | number
    sheetName?: NullableStringFieldUpdateOperationsInput | string | null
    sectionPath?: NullableStringFieldUpdateOperationsInput | string | null
    itemCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quoteItems?: QuotationItemUncheckedUpdateManyWithoutBaselineItemNestedInput
    orderLines?: PurchaseOrderLineUncheckedUpdateManyWithoutBaselineNestedInput
    deliveryItems?: PurchaseDeliveryItemUncheckedUpdateManyWithoutBaselineNestedInput
  }

  export type QuotationBaselineItemUncheckedUpdateManyWithoutMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    processId?: IntFieldUpdateOperationsInput | number
    sheetName?: NullableStringFieldUpdateOperationsInput | string | null
    sectionPath?: NullableStringFieldUpdateOperationsInput | string | null
    itemCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotationItemUpdateWithoutMaterialInput = {
    sourceRow?: NullableIntFieldUpdateOperationsInput | number | null
    itemCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    normalizedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matchScore?: NullableFloatFieldUpdateOperationsInput | number | null
    extraAttributes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotation?: QuotationUpdateOneRequiredWithoutItemsNestedInput
    baselineItem?: QuotationBaselineItemUpdateOneWithoutQuoteItemsNestedInput
  }

  export type QuotationItemUncheckedUpdateWithoutMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    quotationId?: IntFieldUpdateOperationsInput | number
    baselineItemId?: NullableIntFieldUpdateOperationsInput | number | null
    sourceRow?: NullableIntFieldUpdateOperationsInput | number | null
    itemCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    normalizedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matchScore?: NullableFloatFieldUpdateOperationsInput | number | null
    extraAttributes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotationItemUncheckedUpdateManyWithoutMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    quotationId?: IntFieldUpdateOperationsInput | number
    baselineItemId?: NullableIntFieldUpdateOperationsInput | number | null
    sourceRow?: NullableIntFieldUpdateOperationsInput | number | null
    itemCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    normalizedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matchScore?: NullableFloatFieldUpdateOperationsInput | number | null
    extraAttributes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoveCreateManyProveedorInput = {
    id?: number
    obraId: number
    frenteId?: number | null
    materialId: number
    type: $Enums.MoveType
    quantity: number
    unitCost?: number | null
    totalCost?: number | null
    date?: Date | string
    note?: string | null
    docType?: $Enums.DocType | null
    docSerie?: string | null
    docNumero?: string | null
    igvRate?: Decimal | DecimalJsLike | number | string | null
    isTaxable?: boolean | null
    responsible?: string | null
    assetStatus?: $Enums.AssetStatus | null
  }

  export type ExpenseCreateManyProveedorInput = {
    id?: number
    obraId: number
    frenteId?: number | null
    materialId?: number | null
    categoryId?: number | null
    moveId?: number | null
    docType?: $Enums.DocType
    docSerie?: string | null
    docNumero?: string | null
    date?: Date | string
    description?: string | null
    spentBy?: string | null
    type?: $Enums.ExpenseType
    variableType?: $Enums.VariableType
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
    igvRate?: Decimal | DecimalJsLike | number | string
    isTaxable?: boolean
    base: Decimal | DecimalJsLike | number | string
    igv: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paymentMethod?: $Enums.PaymentMethod
    paidAt?: Date | string | null
    status?: string
    reminderIntervalDays?: number | null
    reminderNextDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuotationCreateManyProveedorInput = {
    id?: number
    processId: number
    supplierName?: string | null
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    submittedAt?: Date | string | null
    status?: $Enums.QuotationStatus
    totalAmount?: Decimal | DecimalJsLike | number | string | null
    totalAmountPen?: Decimal | DecimalJsLike | number | string | null
    qualityScore?: number | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseDeliveryLogCreateManyProveedorInput = {
    id?: number
    processId: number
    orderId?: number | null
    supplierName?: string | null
    guideNumber?: string | null
    date?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MoveUpdateWithoutProveedorInput = {
    type?: EnumMoveTypeFieldUpdateOperationsInput | $Enums.MoveType
    quantity?: FloatFieldUpdateOperationsInput | number
    unitCost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableEnumDocTypeFieldUpdateOperationsInput | $Enums.DocType | null
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    igvRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isTaxable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    responsible?: NullableStringFieldUpdateOperationsInput | string | null
    assetStatus?: NullableEnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus | null
    obra?: ObraUpdateOneRequiredWithoutMovesNestedInput
    frente?: FrenteUpdateOneWithoutMovesNestedInput
    material?: MaterialUpdateOneRequiredWithoutMovesNestedInput
    expense?: ExpenseUpdateOneWithoutMoveNestedInput
  }

  export type MoveUncheckedUpdateWithoutProveedorInput = {
    id?: IntFieldUpdateOperationsInput | number
    obraId?: IntFieldUpdateOperationsInput | number
    frenteId?: NullableIntFieldUpdateOperationsInput | number | null
    materialId?: IntFieldUpdateOperationsInput | number
    type?: EnumMoveTypeFieldUpdateOperationsInput | $Enums.MoveType
    quantity?: FloatFieldUpdateOperationsInput | number
    unitCost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableEnumDocTypeFieldUpdateOperationsInput | $Enums.DocType | null
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    igvRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isTaxable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    responsible?: NullableStringFieldUpdateOperationsInput | string | null
    assetStatus?: NullableEnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus | null
    expense?: ExpenseUncheckedUpdateOneWithoutMoveNestedInput
  }

  export type MoveUncheckedUpdateManyWithoutProveedorInput = {
    id?: IntFieldUpdateOperationsInput | number
    obraId?: IntFieldUpdateOperationsInput | number
    frenteId?: NullableIntFieldUpdateOperationsInput | number | null
    materialId?: IntFieldUpdateOperationsInput | number
    type?: EnumMoveTypeFieldUpdateOperationsInput | $Enums.MoveType
    quantity?: FloatFieldUpdateOperationsInput | number
    unitCost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableEnumDocTypeFieldUpdateOperationsInput | $Enums.DocType | null
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    igvRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isTaxable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    responsible?: NullableStringFieldUpdateOperationsInput | string | null
    assetStatus?: NullableEnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus | null
  }

  export type ExpenseUpdateWithoutProveedorInput = {
    docType?: EnumDocTypeFieldUpdateOperationsInput | $Enums.DocType
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    spentBy?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExpenseTypeFieldUpdateOperationsInput | $Enums.ExpenseType
    variableType?: EnumVariableTypeFieldUpdateOperationsInput | $Enums.VariableType
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    igvRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    base?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    igv?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    reminderIntervalDays?: NullableIntFieldUpdateOperationsInput | number | null
    reminderNextDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    obra?: ObraUpdateOneRequiredWithoutExpensesNestedInput
    frente?: FrenteUpdateOneWithoutExpensesNestedInput
    material?: MaterialUpdateOneWithoutExpensesNestedInput
    category?: ExpenseCategoryUpdateOneWithoutExpensesNestedInput
    move?: MoveUpdateOneWithoutExpenseNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutProveedorInput = {
    id?: IntFieldUpdateOperationsInput | number
    obraId?: IntFieldUpdateOperationsInput | number
    frenteId?: NullableIntFieldUpdateOperationsInput | number | null
    materialId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    moveId?: NullableIntFieldUpdateOperationsInput | number | null
    docType?: EnumDocTypeFieldUpdateOperationsInput | $Enums.DocType
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    spentBy?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExpenseTypeFieldUpdateOperationsInput | $Enums.ExpenseType
    variableType?: EnumVariableTypeFieldUpdateOperationsInput | $Enums.VariableType
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    igvRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    base?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    igv?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    reminderIntervalDays?: NullableIntFieldUpdateOperationsInput | number | null
    reminderNextDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyWithoutProveedorInput = {
    id?: IntFieldUpdateOperationsInput | number
    obraId?: IntFieldUpdateOperationsInput | number
    frenteId?: NullableIntFieldUpdateOperationsInput | number | null
    materialId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    moveId?: NullableIntFieldUpdateOperationsInput | number | null
    docType?: EnumDocTypeFieldUpdateOperationsInput | $Enums.DocType
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    spentBy?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExpenseTypeFieldUpdateOperationsInput | $Enums.ExpenseType
    variableType?: EnumVariableTypeFieldUpdateOperationsInput | $Enums.VariableType
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    igvRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    base?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    igv?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    reminderIntervalDays?: NullableIntFieldUpdateOperationsInput | number | null
    reminderNextDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotationUpdateWithoutProveedorInput = {
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    totalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAmountPen?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    process?: QuotationProcessUpdateOneRequiredWithoutQuotationsNestedInput
    items?: QuotationItemUpdateManyWithoutQuotationNestedInput
    attachments?: QuotationAttachmentUpdateManyWithoutQuotationNestedInput
    purchaseOrders?: PurchaseOrderLogUpdateManyWithoutQuotationNestedInput
  }

  export type QuotationUncheckedUpdateWithoutProveedorInput = {
    id?: IntFieldUpdateOperationsInput | number
    processId?: IntFieldUpdateOperationsInput | number
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    totalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAmountPen?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: QuotationItemUncheckedUpdateManyWithoutQuotationNestedInput
    attachments?: QuotationAttachmentUncheckedUpdateManyWithoutQuotationNestedInput
    purchaseOrders?: PurchaseOrderLogUncheckedUpdateManyWithoutQuotationNestedInput
  }

  export type QuotationUncheckedUpdateManyWithoutProveedorInput = {
    id?: IntFieldUpdateOperationsInput | number
    processId?: IntFieldUpdateOperationsInput | number
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    totalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAmountPen?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseDeliveryLogUpdateWithoutProveedorInput = {
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    guideNumber?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    process?: QuotationProcessUpdateOneRequiredWithoutDeliveryLogsNestedInput
    order?: PurchaseOrderLogUpdateOneWithoutDeliveriesNestedInput
    items?: PurchaseDeliveryItemUpdateManyWithoutDeliveryNestedInput
  }

  export type PurchaseDeliveryLogUncheckedUpdateWithoutProveedorInput = {
    id?: IntFieldUpdateOperationsInput | number
    processId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    guideNumber?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseDeliveryItemUncheckedUpdateManyWithoutDeliveryNestedInput
  }

  export type PurchaseDeliveryLogUncheckedUpdateManyWithoutProveedorInput = {
    id?: IntFieldUpdateOperationsInput | number
    processId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    guideNumber?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoveCreateManyFrenteInput = {
    id?: number
    obraId: number
    materialId: number
    proveedorId?: number | null
    type: $Enums.MoveType
    quantity: number
    unitCost?: number | null
    totalCost?: number | null
    date?: Date | string
    note?: string | null
    docType?: $Enums.DocType | null
    docSerie?: string | null
    docNumero?: string | null
    igvRate?: Decimal | DecimalJsLike | number | string | null
    isTaxable?: boolean | null
    responsible?: string | null
    assetStatus?: $Enums.AssetStatus | null
  }

  export type IncomeCreateManyFrenteInput = {
    id?: number
    obraId: number
    date?: Date | string
    description?: string | null
    docType?: $Enums.DocType
    docSerie?: string | null
    docNumero?: string | null
    status?: $Enums.IncomeStatus
    igvRate?: Decimal | DecimalJsLike | number | string
    isTaxable?: boolean
    base: Decimal | DecimalJsLike | number | string
    igv: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCreateManyFrenteInput = {
    id?: number
    obraId: number
    proveedorId?: number | null
    materialId?: number | null
    categoryId?: number | null
    moveId?: number | null
    docType?: $Enums.DocType
    docSerie?: string | null
    docNumero?: string | null
    date?: Date | string
    description?: string | null
    spentBy?: string | null
    type?: $Enums.ExpenseType
    variableType?: $Enums.VariableType
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
    igvRate?: Decimal | DecimalJsLike | number | string
    isTaxable?: boolean
    base: Decimal | DecimalJsLike | number | string
    igv: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paymentMethod?: $Enums.PaymentMethod
    paidAt?: Date | string | null
    status?: string
    reminderIntervalDays?: number | null
    reminderNextDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MoveUpdateWithoutFrenteInput = {
    type?: EnumMoveTypeFieldUpdateOperationsInput | $Enums.MoveType
    quantity?: FloatFieldUpdateOperationsInput | number
    unitCost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableEnumDocTypeFieldUpdateOperationsInput | $Enums.DocType | null
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    igvRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isTaxable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    responsible?: NullableStringFieldUpdateOperationsInput | string | null
    assetStatus?: NullableEnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus | null
    obra?: ObraUpdateOneRequiredWithoutMovesNestedInput
    material?: MaterialUpdateOneRequiredWithoutMovesNestedInput
    proveedor?: ProveedorUpdateOneWithoutMovesNestedInput
    expense?: ExpenseUpdateOneWithoutMoveNestedInput
  }

  export type MoveUncheckedUpdateWithoutFrenteInput = {
    id?: IntFieldUpdateOperationsInput | number
    obraId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    proveedorId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumMoveTypeFieldUpdateOperationsInput | $Enums.MoveType
    quantity?: FloatFieldUpdateOperationsInput | number
    unitCost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableEnumDocTypeFieldUpdateOperationsInput | $Enums.DocType | null
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    igvRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isTaxable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    responsible?: NullableStringFieldUpdateOperationsInput | string | null
    assetStatus?: NullableEnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus | null
    expense?: ExpenseUncheckedUpdateOneWithoutMoveNestedInput
  }

  export type MoveUncheckedUpdateManyWithoutFrenteInput = {
    id?: IntFieldUpdateOperationsInput | number
    obraId?: IntFieldUpdateOperationsInput | number
    materialId?: IntFieldUpdateOperationsInput | number
    proveedorId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumMoveTypeFieldUpdateOperationsInput | $Enums.MoveType
    quantity?: FloatFieldUpdateOperationsInput | number
    unitCost?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableEnumDocTypeFieldUpdateOperationsInput | $Enums.DocType | null
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    igvRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isTaxable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    responsible?: NullableStringFieldUpdateOperationsInput | string | null
    assetStatus?: NullableEnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus | null
  }

  export type IncomeUpdateWithoutFrenteInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: EnumDocTypeFieldUpdateOperationsInput | $Enums.DocType
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumIncomeStatusFieldUpdateOperationsInput | $Enums.IncomeStatus
    igvRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    base?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    igv?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    obra?: ObraUpdateOneRequiredWithoutIncomesNestedInput
  }

  export type IncomeUncheckedUpdateWithoutFrenteInput = {
    id?: IntFieldUpdateOperationsInput | number
    obraId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: EnumDocTypeFieldUpdateOperationsInput | $Enums.DocType
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumIncomeStatusFieldUpdateOperationsInput | $Enums.IncomeStatus
    igvRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    base?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    igv?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncomeUncheckedUpdateManyWithoutFrenteInput = {
    id?: IntFieldUpdateOperationsInput | number
    obraId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: EnumDocTypeFieldUpdateOperationsInput | $Enums.DocType
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumIncomeStatusFieldUpdateOperationsInput | $Enums.IncomeStatus
    igvRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    base?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    igv?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUpdateWithoutFrenteInput = {
    docType?: EnumDocTypeFieldUpdateOperationsInput | $Enums.DocType
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    spentBy?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExpenseTypeFieldUpdateOperationsInput | $Enums.ExpenseType
    variableType?: EnumVariableTypeFieldUpdateOperationsInput | $Enums.VariableType
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    igvRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    base?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    igv?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    reminderIntervalDays?: NullableIntFieldUpdateOperationsInput | number | null
    reminderNextDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    obra?: ObraUpdateOneRequiredWithoutExpensesNestedInput
    proveedor?: ProveedorUpdateOneWithoutExpensesNestedInput
    material?: MaterialUpdateOneWithoutExpensesNestedInput
    category?: ExpenseCategoryUpdateOneWithoutExpensesNestedInput
    move?: MoveUpdateOneWithoutExpenseNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutFrenteInput = {
    id?: IntFieldUpdateOperationsInput | number
    obraId?: IntFieldUpdateOperationsInput | number
    proveedorId?: NullableIntFieldUpdateOperationsInput | number | null
    materialId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    moveId?: NullableIntFieldUpdateOperationsInput | number | null
    docType?: EnumDocTypeFieldUpdateOperationsInput | $Enums.DocType
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    spentBy?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExpenseTypeFieldUpdateOperationsInput | $Enums.ExpenseType
    variableType?: EnumVariableTypeFieldUpdateOperationsInput | $Enums.VariableType
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    igvRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    base?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    igv?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    reminderIntervalDays?: NullableIntFieldUpdateOperationsInput | number | null
    reminderNextDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyWithoutFrenteInput = {
    id?: IntFieldUpdateOperationsInput | number
    obraId?: IntFieldUpdateOperationsInput | number
    proveedorId?: NullableIntFieldUpdateOperationsInput | number | null
    materialId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    moveId?: NullableIntFieldUpdateOperationsInput | number | null
    docType?: EnumDocTypeFieldUpdateOperationsInput | $Enums.DocType
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    spentBy?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExpenseTypeFieldUpdateOperationsInput | $Enums.ExpenseType
    variableType?: EnumVariableTypeFieldUpdateOperationsInput | $Enums.VariableType
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    igvRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    base?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    igv?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    reminderIntervalDays?: NullableIntFieldUpdateOperationsInput | number | null
    reminderNextDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialGroupCreateManyParentInput = {
    id?: number
    name: string
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialCreateManyGroupInput = {
    id?: number
    code?: string | null
    name: string
    unit?: string | null
    minStock?: Decimal | DecimalJsLike | number | string
    reorderQuantity?: Decimal | DecimalJsLike | number | string
    allowNegative?: boolean
    isCompanyAsset?: boolean
    assetStatus?: $Enums.AssetStatus
    assetResponsible?: string | null
  }

  export type MaterialGroupUpdateWithoutParentInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: MaterialGroupUpdateManyWithoutParentNestedInput
    materials?: MaterialUpdateManyWithoutGroupNestedInput
  }

  export type MaterialGroupUncheckedUpdateWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: MaterialGroupUncheckedUpdateManyWithoutParentNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type MaterialGroupUncheckedUpdateManyWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialUpdateWithoutGroupInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowNegative?: BoolFieldUpdateOperationsInput | boolean
    isCompanyAsset?: BoolFieldUpdateOperationsInput | boolean
    assetStatus?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    assetResponsible?: NullableStringFieldUpdateOperationsInput | string | null
    moves?: MoveUpdateManyWithoutMaterialNestedInput
    expenses?: ExpenseUpdateManyWithoutMaterialNestedInput
    baseQuotes?: QuotationBaselineItemUpdateManyWithoutMaterialNestedInput
    quoteItems?: QuotationItemUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowNegative?: BoolFieldUpdateOperationsInput | boolean
    isCompanyAsset?: BoolFieldUpdateOperationsInput | boolean
    assetStatus?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    assetResponsible?: NullableStringFieldUpdateOperationsInput | string | null
    moves?: MoveUncheckedUpdateManyWithoutMaterialNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutMaterialNestedInput
    baseQuotes?: QuotationBaselineItemUncheckedUpdateManyWithoutMaterialNestedInput
    quoteItems?: QuotationItemUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateManyWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reorderQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowNegative?: BoolFieldUpdateOperationsInput | boolean
    isCompanyAsset?: BoolFieldUpdateOperationsInput | boolean
    assetStatus?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    assetResponsible?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExpenseCreateManyCategoryInput = {
    id?: number
    obraId: number
    frenteId?: number | null
    proveedorId?: number | null
    materialId?: number | null
    moveId?: number | null
    docType?: $Enums.DocType
    docSerie?: string | null
    docNumero?: string | null
    date?: Date | string
    description?: string | null
    spentBy?: string | null
    type?: $Enums.ExpenseType
    variableType?: $Enums.VariableType
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
    igvRate?: Decimal | DecimalJsLike | number | string
    isTaxable?: boolean
    base: Decimal | DecimalJsLike | number | string
    igv: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paymentMethod?: $Enums.PaymentMethod
    paidAt?: Date | string | null
    status?: string
    reminderIntervalDays?: number | null
    reminderNextDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseUpdateWithoutCategoryInput = {
    docType?: EnumDocTypeFieldUpdateOperationsInput | $Enums.DocType
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    spentBy?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExpenseTypeFieldUpdateOperationsInput | $Enums.ExpenseType
    variableType?: EnumVariableTypeFieldUpdateOperationsInput | $Enums.VariableType
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    igvRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    base?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    igv?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    reminderIntervalDays?: NullableIntFieldUpdateOperationsInput | number | null
    reminderNextDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    obra?: ObraUpdateOneRequiredWithoutExpensesNestedInput
    frente?: FrenteUpdateOneWithoutExpensesNestedInput
    proveedor?: ProveedorUpdateOneWithoutExpensesNestedInput
    material?: MaterialUpdateOneWithoutExpensesNestedInput
    move?: MoveUpdateOneWithoutExpenseNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    obraId?: IntFieldUpdateOperationsInput | number
    frenteId?: NullableIntFieldUpdateOperationsInput | number | null
    proveedorId?: NullableIntFieldUpdateOperationsInput | number | null
    materialId?: NullableIntFieldUpdateOperationsInput | number | null
    moveId?: NullableIntFieldUpdateOperationsInput | number | null
    docType?: EnumDocTypeFieldUpdateOperationsInput | $Enums.DocType
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    spentBy?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExpenseTypeFieldUpdateOperationsInput | $Enums.ExpenseType
    variableType?: EnumVariableTypeFieldUpdateOperationsInput | $Enums.VariableType
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    igvRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    base?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    igv?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    reminderIntervalDays?: NullableIntFieldUpdateOperationsInput | number | null
    reminderNextDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    obraId?: IntFieldUpdateOperationsInput | number
    frenteId?: NullableIntFieldUpdateOperationsInput | number | null
    proveedorId?: NullableIntFieldUpdateOperationsInput | number | null
    materialId?: NullableIntFieldUpdateOperationsInput | number | null
    moveId?: NullableIntFieldUpdateOperationsInput | number | null
    docType?: EnumDocTypeFieldUpdateOperationsInput | $Enums.DocType
    docSerie?: NullableStringFieldUpdateOperationsInput | string | null
    docNumero?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    spentBy?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumExpenseTypeFieldUpdateOperationsInput | $Enums.ExpenseType
    variableType?: EnumVariableTypeFieldUpdateOperationsInput | $Enums.VariableType
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    igvRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isTaxable?: BoolFieldUpdateOperationsInput | boolean
    base?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    igv?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    reminderIntervalDays?: NullableIntFieldUpdateOperationsInput | number | null
    reminderNextDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyCashExpenseCreateManyRenditionInput = {
    id?: number
    description: string
    amount: Decimal | DecimalJsLike | number | string
    personalAmount?: Decimal | DecimalJsLike | number | string
    paidWithPersonal?: boolean
    createdAt?: Date | string
  }

  export type DailyCashExpenseUpdateWithoutRenditionInput = {
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidWithPersonal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyCashExpenseUncheckedUpdateWithoutRenditionInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidWithPersonal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyCashExpenseUncheckedUpdateManyWithoutRenditionInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidWithPersonal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceRecordCreateManyEmployeeInput = {
    id?: number
    date: Date | string
    status?: $Enums.AttendanceStatus
    minutesLate?: number | null
    permissionHours?: Decimal | DecimalJsLike | number | string | null
    extraHours?: Decimal | DecimalJsLike | number | string | null
    permissionPaid?: boolean | null
    holidayWorked?: boolean
    holidayCount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollEntryCreateManyEmployeeInput = {
    id?: number
    periodId: number
    baseSalary: Decimal | DecimalJsLike | number | string
    dailyRate: Decimal | DecimalJsLike | number | string
    hourlyRate: Decimal | DecimalJsLike | number | string
    workedDays?: number
    absenceDays?: number
    tardinessMinutes?: number
    permissionHours?: Decimal | DecimalJsLike | number | string
    overtimeHours?: Decimal | DecimalJsLike | number | string
    bonusesTotal?: Decimal | DecimalJsLike | number | string
    deductionsTotal?: Decimal | DecimalJsLike | number | string
    pensionAmount?: Decimal | DecimalJsLike | number | string
    healthAmount?: Decimal | DecimalJsLike | number | string
    grossEarnings?: Decimal | DecimalJsLike | number | string
    netPay?: Decimal | DecimalJsLike | number | string
    permissionDays?: number
    holidayDays?: number
    holidayBonus?: Decimal | DecimalJsLike | number | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceRecordUpdateWithoutEmployeeInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    minutesLate?: NullableIntFieldUpdateOperationsInput | number | null
    permissionHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    extraHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    permissionPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    holidayWorked?: BoolFieldUpdateOperationsInput | boolean
    holidayCount?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceRecordUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    minutesLate?: NullableIntFieldUpdateOperationsInput | number | null
    permissionHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    extraHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    permissionPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    holidayWorked?: BoolFieldUpdateOperationsInput | boolean
    holidayCount?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceRecordUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    minutesLate?: NullableIntFieldUpdateOperationsInput | number | null
    permissionHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    extraHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    permissionPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    holidayWorked?: BoolFieldUpdateOperationsInput | boolean
    holidayCount?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollEntryUpdateWithoutEmployeeInput = {
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dailyRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hourlyRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    workedDays?: IntFieldUpdateOperationsInput | number
    absenceDays?: IntFieldUpdateOperationsInput | number
    tardinessMinutes?: IntFieldUpdateOperationsInput | number
    permissionHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusesTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductionsTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pensionAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    healthAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossEarnings?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    permissionDays?: IntFieldUpdateOperationsInput | number
    holidayDays?: IntFieldUpdateOperationsInput | number
    holidayBonus?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    period?: PayrollPeriodUpdateOneRequiredWithoutEntriesNestedInput
    adjustments?: PayrollAdjustmentUpdateManyWithoutEntryNestedInput
  }

  export type PayrollEntryUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    periodId?: IntFieldUpdateOperationsInput | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dailyRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hourlyRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    workedDays?: IntFieldUpdateOperationsInput | number
    absenceDays?: IntFieldUpdateOperationsInput | number
    tardinessMinutes?: IntFieldUpdateOperationsInput | number
    permissionHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusesTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductionsTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pensionAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    healthAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossEarnings?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    permissionDays?: IntFieldUpdateOperationsInput | number
    holidayDays?: IntFieldUpdateOperationsInput | number
    holidayBonus?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adjustments?: PayrollAdjustmentUncheckedUpdateManyWithoutEntryNestedInput
  }

  export type PayrollEntryUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    periodId?: IntFieldUpdateOperationsInput | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dailyRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hourlyRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    workedDays?: IntFieldUpdateOperationsInput | number
    absenceDays?: IntFieldUpdateOperationsInput | number
    tardinessMinutes?: IntFieldUpdateOperationsInput | number
    permissionHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusesTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductionsTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pensionAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    healthAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossEarnings?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    permissionDays?: IntFieldUpdateOperationsInput | number
    holidayDays?: IntFieldUpdateOperationsInput | number
    holidayBonus?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollEntryCreateManyPeriodInput = {
    id?: number
    employeeId: number
    baseSalary: Decimal | DecimalJsLike | number | string
    dailyRate: Decimal | DecimalJsLike | number | string
    hourlyRate: Decimal | DecimalJsLike | number | string
    workedDays?: number
    absenceDays?: number
    tardinessMinutes?: number
    permissionHours?: Decimal | DecimalJsLike | number | string
    overtimeHours?: Decimal | DecimalJsLike | number | string
    bonusesTotal?: Decimal | DecimalJsLike | number | string
    deductionsTotal?: Decimal | DecimalJsLike | number | string
    pensionAmount?: Decimal | DecimalJsLike | number | string
    healthAmount?: Decimal | DecimalJsLike | number | string
    grossEarnings?: Decimal | DecimalJsLike | number | string
    netPay?: Decimal | DecimalJsLike | number | string
    permissionDays?: number
    holidayDays?: number
    holidayBonus?: Decimal | DecimalJsLike | number | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollEntryUpdateWithoutPeriodInput = {
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dailyRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hourlyRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    workedDays?: IntFieldUpdateOperationsInput | number
    absenceDays?: IntFieldUpdateOperationsInput | number
    tardinessMinutes?: IntFieldUpdateOperationsInput | number
    permissionHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusesTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductionsTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pensionAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    healthAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossEarnings?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    permissionDays?: IntFieldUpdateOperationsInput | number
    holidayDays?: IntFieldUpdateOperationsInput | number
    holidayBonus?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutPayrollEntriesNestedInput
    adjustments?: PayrollAdjustmentUpdateManyWithoutEntryNestedInput
  }

  export type PayrollEntryUncheckedUpdateWithoutPeriodInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dailyRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hourlyRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    workedDays?: IntFieldUpdateOperationsInput | number
    absenceDays?: IntFieldUpdateOperationsInput | number
    tardinessMinutes?: IntFieldUpdateOperationsInput | number
    permissionHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusesTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductionsTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pensionAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    healthAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossEarnings?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    permissionDays?: IntFieldUpdateOperationsInput | number
    holidayDays?: IntFieldUpdateOperationsInput | number
    holidayBonus?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adjustments?: PayrollAdjustmentUncheckedUpdateManyWithoutEntryNestedInput
  }

  export type PayrollEntryUncheckedUpdateManyWithoutPeriodInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dailyRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hourlyRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    workedDays?: IntFieldUpdateOperationsInput | number
    absenceDays?: IntFieldUpdateOperationsInput | number
    tardinessMinutes?: IntFieldUpdateOperationsInput | number
    permissionHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusesTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductionsTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pensionAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    healthAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossEarnings?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    permissionDays?: IntFieldUpdateOperationsInput | number
    holidayDays?: IntFieldUpdateOperationsInput | number
    holidayBonus?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollAdjustmentCreateManyEntryInput = {
    id?: number
    type: $Enums.PayrollAdjustmentType
    concept: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollAdjustmentUpdateWithoutEntryInput = {
    type?: EnumPayrollAdjustmentTypeFieldUpdateOperationsInput | $Enums.PayrollAdjustmentType
    concept?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollAdjustmentUncheckedUpdateWithoutEntryInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumPayrollAdjustmentTypeFieldUpdateOperationsInput | $Enums.PayrollAdjustmentType
    concept?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollAdjustmentUncheckedUpdateManyWithoutEntryInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumPayrollAdjustmentTypeFieldUpdateOperationsInput | $Enums.PayrollAdjustmentType
    concept?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerLoanCreateManyGiverInput = {
    id?: number
    date: Date | string
    receiverId: number
    amount: Decimal | DecimalJsLike | number | string
    note?: string | null
    status?: $Enums.PartnerLoanStatus
    financeRefs?: NullableJsonNullValueInput | InputJsonValue
    closeDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PartnerLoanCreateManyReceiverInput = {
    id?: number
    date: Date | string
    giverId: number
    amount: Decimal | DecimalJsLike | number | string
    note?: string | null
    status?: $Enums.PartnerLoanStatus
    financeRefs?: NullableJsonNullValueInput | InputJsonValue
    closeDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PartnerLoanUpdateWithoutGiverInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPartnerLoanStatusFieldUpdateOperationsInput | $Enums.PartnerLoanStatus
    financeRefs?: NullableJsonNullValueInput | InputJsonValue
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: PartnerUpdateOneRequiredWithoutLoansReceivedNestedInput
  }

  export type PartnerLoanUncheckedUpdateWithoutGiverInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPartnerLoanStatusFieldUpdateOperationsInput | $Enums.PartnerLoanStatus
    financeRefs?: NullableJsonNullValueInput | InputJsonValue
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerLoanUncheckedUpdateManyWithoutGiverInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPartnerLoanStatusFieldUpdateOperationsInput | $Enums.PartnerLoanStatus
    financeRefs?: NullableJsonNullValueInput | InputJsonValue
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerLoanUpdateWithoutReceiverInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPartnerLoanStatusFieldUpdateOperationsInput | $Enums.PartnerLoanStatus
    financeRefs?: NullableJsonNullValueInput | InputJsonValue
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    giver?: PartnerUpdateOneRequiredWithoutLoansGivenNestedInput
  }

  export type PartnerLoanUncheckedUpdateWithoutReceiverInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    giverId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPartnerLoanStatusFieldUpdateOperationsInput | $Enums.PartnerLoanStatus
    financeRefs?: NullableJsonNullValueInput | InputJsonValue
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerLoanUncheckedUpdateManyWithoutReceiverInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    giverId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPartnerLoanStatusFieldUpdateOperationsInput | $Enums.PartnerLoanStatus
    financeRefs?: NullableJsonNullValueInput | InputJsonValue
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodIngredientCostCreateManyIngredientInput = {
    id?: number
    unitCost: Decimal | DecimalJsLike | number | string
    effectiveDate?: Date | string | null
    source?: string | null
    createdAt?: Date | string
  }

  export type FoodRecipeItemCreateManyIngredientInput = {
    id?: number
    recipeId: number
    childRecipeId?: number | null
    quantity?: Decimal | DecimalJsLike | number | string
    unit?: string | null
    wastePct?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type FoodIngredientCostUpdateWithoutIngredientInput = {
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodIngredientCostUncheckedUpdateWithoutIngredientInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodIngredientCostUncheckedUpdateManyWithoutIngredientInput = {
    id?: IntFieldUpdateOperationsInput | number
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodRecipeItemUpdateWithoutIngredientInput = {
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    wastePct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipe?: FoodRecipeUpdateOneRequiredWithoutItemsNestedInput
    childRecipe?: FoodRecipeUpdateOneWithoutChildItemsNestedInput
  }

  export type FoodRecipeItemUncheckedUpdateWithoutIngredientInput = {
    id?: IntFieldUpdateOperationsInput | number
    recipeId?: IntFieldUpdateOperationsInput | number
    childRecipeId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    wastePct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodRecipeItemUncheckedUpdateManyWithoutIngredientInput = {
    id?: IntFieldUpdateOperationsInput | number
    recipeId?: IntFieldUpdateOperationsInput | number
    childRecipeId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    wastePct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodRecipeItemCreateManyRecipeInput = {
    id?: number
    ingredientId?: number | null
    childRecipeId?: number | null
    quantity?: Decimal | DecimalJsLike | number | string
    unit?: string | null
    wastePct?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type FoodRecipeItemCreateManyChildRecipeInput = {
    id?: number
    recipeId: number
    ingredientId?: number | null
    quantity?: Decimal | DecimalJsLike | number | string
    unit?: string | null
    wastePct?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type FoodRecipeCostCreateManyRecipeInput = {
    id?: number
    label: string
    amount?: Decimal | DecimalJsLike | number | string
    costType?: $Enums.FoodCostLineType
    period?: $Enums.FoodCostPeriod
    periodRations?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type FoodMealPlanEntryCreateManyRecipeInput = {
    id?: number
    planId: number
    dayIndex: number
    mealType: $Enums.FoodMealType
    servings?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoodRecipeItemUpdateWithoutRecipeInput = {
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    wastePct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ingredient?: FoodIngredientUpdateOneWithoutItemsNestedInput
    childRecipe?: FoodRecipeUpdateOneWithoutChildItemsNestedInput
  }

  export type FoodRecipeItemUncheckedUpdateWithoutRecipeInput = {
    id?: IntFieldUpdateOperationsInput | number
    ingredientId?: NullableIntFieldUpdateOperationsInput | number | null
    childRecipeId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    wastePct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodRecipeItemUncheckedUpdateManyWithoutRecipeInput = {
    id?: IntFieldUpdateOperationsInput | number
    ingredientId?: NullableIntFieldUpdateOperationsInput | number | null
    childRecipeId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    wastePct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodRecipeItemUpdateWithoutChildRecipeInput = {
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    wastePct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipe?: FoodRecipeUpdateOneRequiredWithoutItemsNestedInput
    ingredient?: FoodIngredientUpdateOneWithoutItemsNestedInput
  }

  export type FoodRecipeItemUncheckedUpdateWithoutChildRecipeInput = {
    id?: IntFieldUpdateOperationsInput | number
    recipeId?: IntFieldUpdateOperationsInput | number
    ingredientId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    wastePct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodRecipeItemUncheckedUpdateManyWithoutChildRecipeInput = {
    id?: IntFieldUpdateOperationsInput | number
    recipeId?: IntFieldUpdateOperationsInput | number
    ingredientId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    wastePct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodRecipeCostUpdateWithoutRecipeInput = {
    label?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costType?: EnumFoodCostLineTypeFieldUpdateOperationsInput | $Enums.FoodCostLineType
    period?: EnumFoodCostPeriodFieldUpdateOperationsInput | $Enums.FoodCostPeriod
    periodRations?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodRecipeCostUncheckedUpdateWithoutRecipeInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costType?: EnumFoodCostLineTypeFieldUpdateOperationsInput | $Enums.FoodCostLineType
    period?: EnumFoodCostPeriodFieldUpdateOperationsInput | $Enums.FoodCostPeriod
    periodRations?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodRecipeCostUncheckedUpdateManyWithoutRecipeInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costType?: EnumFoodCostLineTypeFieldUpdateOperationsInput | $Enums.FoodCostLineType
    period?: EnumFoodCostPeriodFieldUpdateOperationsInput | $Enums.FoodCostPeriod
    periodRations?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodMealPlanEntryUpdateWithoutRecipeInput = {
    dayIndex?: IntFieldUpdateOperationsInput | number
    mealType?: EnumFoodMealTypeFieldUpdateOperationsInput | $Enums.FoodMealType
    servings?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: FoodMealPlanUpdateOneRequiredWithoutEntriesNestedInput
  }

  export type FoodMealPlanEntryUncheckedUpdateWithoutRecipeInput = {
    id?: IntFieldUpdateOperationsInput | number
    planId?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    mealType?: EnumFoodMealTypeFieldUpdateOperationsInput | $Enums.FoodMealType
    servings?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodMealPlanEntryUncheckedUpdateManyWithoutRecipeInput = {
    id?: IntFieldUpdateOperationsInput | number
    planId?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    mealType?: EnumFoodMealTypeFieldUpdateOperationsInput | $Enums.FoodMealType
    servings?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodMealPlanEntryCreateManyPlanInput = {
    id?: number
    dayIndex: number
    mealType: $Enums.FoodMealType
    recipeId: number
    servings?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoodMealPlanEntryUpdateWithoutPlanInput = {
    dayIndex?: IntFieldUpdateOperationsInput | number
    mealType?: EnumFoodMealTypeFieldUpdateOperationsInput | $Enums.FoodMealType
    servings?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipe?: FoodRecipeUpdateOneRequiredWithoutMealPlanEntriesNestedInput
  }

  export type FoodMealPlanEntryUncheckedUpdateWithoutPlanInput = {
    id?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    mealType?: EnumFoodMealTypeFieldUpdateOperationsInput | $Enums.FoodMealType
    recipeId?: IntFieldUpdateOperationsInput | number
    servings?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodMealPlanEntryUncheckedUpdateManyWithoutPlanInput = {
    id?: IntFieldUpdateOperationsInput | number
    dayIndex?: IntFieldUpdateOperationsInput | number
    mealType?: EnumFoodMealTypeFieldUpdateOperationsInput | $Enums.FoodMealType
    recipeId?: IntFieldUpdateOperationsInput | number
    servings?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotationBaselineItemCreateManyProcessInput = {
    id?: number
    materialId?: number | null
    sheetName?: string | null
    sectionPath?: string | null
    itemCode?: string | null
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuotationCreateManyProcessInput = {
    id?: number
    proveedorId?: number | null
    supplierName?: string | null
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string | null
    submittedAt?: Date | string | null
    status?: $Enums.QuotationStatus
    totalAmount?: Decimal | DecimalJsLike | number | string | null
    totalAmountPen?: Decimal | DecimalJsLike | number | string | null
    qualityScore?: number | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderLogCreateManyProcessInput = {
    id?: number
    quotationId?: number | null
    supplierId?: number | null
    supplierName: string
    orderNumber: string
    sequence?: number
    issueDate?: Date | string
    currency?: string
    subtotal?: Decimal | DecimalJsLike | number | string | null
    discount?: Decimal | DecimalJsLike | number | string | null
    netSubtotal?: Decimal | DecimalJsLike | number | string | null
    igv?: Decimal | DecimalJsLike | number | string | null
    total?: Decimal | DecimalJsLike | number | string | null
    totalsJson?: NullableJsonNullValueInput | InputJsonValue
    itemsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseDeliveryLogCreateManyProcessInput = {
    id?: number
    orderId?: number | null
    proveedorId?: number | null
    supplierName?: string | null
    guideNumber?: string | null
    date?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuotationBaselineItemUpdateWithoutProcessInput = {
    sheetName?: NullableStringFieldUpdateOperationsInput | string | null
    sectionPath?: NullableStringFieldUpdateOperationsInput | string | null
    itemCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    material?: MaterialUpdateOneWithoutBaseQuotesNestedInput
    quoteItems?: QuotationItemUpdateManyWithoutBaselineItemNestedInput
    orderLines?: PurchaseOrderLineUpdateManyWithoutBaselineNestedInput
    deliveryItems?: PurchaseDeliveryItemUpdateManyWithoutBaselineNestedInput
  }

  export type QuotationBaselineItemUncheckedUpdateWithoutProcessInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialId?: NullableIntFieldUpdateOperationsInput | number | null
    sheetName?: NullableStringFieldUpdateOperationsInput | string | null
    sectionPath?: NullableStringFieldUpdateOperationsInput | string | null
    itemCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quoteItems?: QuotationItemUncheckedUpdateManyWithoutBaselineItemNestedInput
    orderLines?: PurchaseOrderLineUncheckedUpdateManyWithoutBaselineNestedInput
    deliveryItems?: PurchaseDeliveryItemUncheckedUpdateManyWithoutBaselineNestedInput
  }

  export type QuotationBaselineItemUncheckedUpdateManyWithoutProcessInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialId?: NullableIntFieldUpdateOperationsInput | number | null
    sheetName?: NullableStringFieldUpdateOperationsInput | string | null
    sectionPath?: NullableStringFieldUpdateOperationsInput | string | null
    itemCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotationUpdateWithoutProcessInput = {
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    totalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAmountPen?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proveedor?: ProveedorUpdateOneWithoutQuotationsNestedInput
    items?: QuotationItemUpdateManyWithoutQuotationNestedInput
    attachments?: QuotationAttachmentUpdateManyWithoutQuotationNestedInput
    purchaseOrders?: PurchaseOrderLogUpdateManyWithoutQuotationNestedInput
  }

  export type QuotationUncheckedUpdateWithoutProcessInput = {
    id?: IntFieldUpdateOperationsInput | number
    proveedorId?: NullableIntFieldUpdateOperationsInput | number | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    totalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAmountPen?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: QuotationItemUncheckedUpdateManyWithoutQuotationNestedInput
    attachments?: QuotationAttachmentUncheckedUpdateManyWithoutQuotationNestedInput
    purchaseOrders?: PurchaseOrderLogUncheckedUpdateManyWithoutQuotationNestedInput
  }

  export type QuotationUncheckedUpdateManyWithoutProcessInput = {
    id?: IntFieldUpdateOperationsInput | number
    proveedorId?: NullableIntFieldUpdateOperationsInput | number | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    totalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAmountPen?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderLogUpdateWithoutProcessInput = {
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    supplierName?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netSubtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    igv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalsJson?: NullableJsonNullValueInput | InputJsonValue
    itemsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotation?: QuotationUpdateOneWithoutPurchaseOrdersNestedInput
    lines?: PurchaseOrderLineUpdateManyWithoutOrderNestedInput
    deliveries?: PurchaseDeliveryLogUpdateManyWithoutOrderNestedInput
  }

  export type PurchaseOrderLogUncheckedUpdateWithoutProcessInput = {
    id?: IntFieldUpdateOperationsInput | number
    quotationId?: NullableIntFieldUpdateOperationsInput | number | null
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    supplierName?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netSubtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    igv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalsJson?: NullableJsonNullValueInput | InputJsonValue
    itemsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: PurchaseOrderLineUncheckedUpdateManyWithoutOrderNestedInput
    deliveries?: PurchaseDeliveryLogUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type PurchaseOrderLogUncheckedUpdateManyWithoutProcessInput = {
    id?: IntFieldUpdateOperationsInput | number
    quotationId?: NullableIntFieldUpdateOperationsInput | number | null
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    supplierName?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netSubtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    igv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalsJson?: NullableJsonNullValueInput | InputJsonValue
    itemsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseDeliveryLogUpdateWithoutProcessInput = {
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    guideNumber?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: PurchaseOrderLogUpdateOneWithoutDeliveriesNestedInput
    proveedor?: ProveedorUpdateOneWithoutDeliveriesNestedInput
    items?: PurchaseDeliveryItemUpdateManyWithoutDeliveryNestedInput
  }

  export type PurchaseDeliveryLogUncheckedUpdateWithoutProcessInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    proveedorId?: NullableIntFieldUpdateOperationsInput | number | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    guideNumber?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseDeliveryItemUncheckedUpdateManyWithoutDeliveryNestedInput
  }

  export type PurchaseDeliveryLogUncheckedUpdateManyWithoutProcessInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    proveedorId?: NullableIntFieldUpdateOperationsInput | number | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    guideNumber?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotationItemCreateManyBaselineItemInput = {
    id?: number
    quotationId: number
    materialId?: number | null
    sourceRow?: number | null
    itemCode?: string | null
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    normalizedPrice?: Decimal | DecimalJsLike | number | string | null
    matchScore?: number | null
    extraAttributes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderLineCreateManyBaselineInput = {
    id?: number
    orderId: number
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseDeliveryItemCreateManyBaselineInput = {
    id?: number
    deliveryId: number
    orderLineId?: number | null
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuotationItemUpdateWithoutBaselineItemInput = {
    sourceRow?: NullableIntFieldUpdateOperationsInput | number | null
    itemCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    normalizedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matchScore?: NullableFloatFieldUpdateOperationsInput | number | null
    extraAttributes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotation?: QuotationUpdateOneRequiredWithoutItemsNestedInput
    material?: MaterialUpdateOneWithoutQuoteItemsNestedInput
  }

  export type QuotationItemUncheckedUpdateWithoutBaselineItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    quotationId?: IntFieldUpdateOperationsInput | number
    materialId?: NullableIntFieldUpdateOperationsInput | number | null
    sourceRow?: NullableIntFieldUpdateOperationsInput | number | null
    itemCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    normalizedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matchScore?: NullableFloatFieldUpdateOperationsInput | number | null
    extraAttributes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotationItemUncheckedUpdateManyWithoutBaselineItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    quotationId?: IntFieldUpdateOperationsInput | number
    materialId?: NullableIntFieldUpdateOperationsInput | number | null
    sourceRow?: NullableIntFieldUpdateOperationsInput | number | null
    itemCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    normalizedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matchScore?: NullableFloatFieldUpdateOperationsInput | number | null
    extraAttributes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderLineUpdateWithoutBaselineInput = {
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: PurchaseOrderLogUpdateOneRequiredWithoutLinesNestedInput
    deliveries?: PurchaseDeliveryItemUpdateManyWithoutOrderLineNestedInput
  }

  export type PurchaseOrderLineUncheckedUpdateWithoutBaselineInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: PurchaseDeliveryItemUncheckedUpdateManyWithoutOrderLineNestedInput
  }

  export type PurchaseOrderLineUncheckedUpdateManyWithoutBaselineInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseDeliveryItemUpdateWithoutBaselineInput = {
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    delivery?: PurchaseDeliveryLogUpdateOneRequiredWithoutItemsNestedInput
    orderLine?: PurchaseOrderLineUpdateOneWithoutDeliveriesNestedInput
  }

  export type PurchaseDeliveryItemUncheckedUpdateWithoutBaselineInput = {
    id?: IntFieldUpdateOperationsInput | number
    deliveryId?: IntFieldUpdateOperationsInput | number
    orderLineId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseDeliveryItemUncheckedUpdateManyWithoutBaselineInput = {
    id?: IntFieldUpdateOperationsInput | number
    deliveryId?: IntFieldUpdateOperationsInput | number
    orderLineId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotationItemCreateManyQuotationInput = {
    id?: number
    baselineItemId?: number | null
    materialId?: number | null
    sourceRow?: number | null
    itemCode?: string | null
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    normalizedPrice?: Decimal | DecimalJsLike | number | string | null
    matchScore?: number | null
    extraAttributes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuotationAttachmentCreateManyQuotationInput = {
    id?: number
    type?: $Enums.QuotationAttachmentType
    originalName: string
    storagePath: string
    mimeType?: string | null
    sizeBytes?: number | null
    checksum?: string | null
    parsed?: boolean
    parsedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderLogCreateManyQuotationInput = {
    id?: number
    processId: number
    supplierId?: number | null
    supplierName: string
    orderNumber: string
    sequence?: number
    issueDate?: Date | string
    currency?: string
    subtotal?: Decimal | DecimalJsLike | number | string | null
    discount?: Decimal | DecimalJsLike | number | string | null
    netSubtotal?: Decimal | DecimalJsLike | number | string | null
    igv?: Decimal | DecimalJsLike | number | string | null
    total?: Decimal | DecimalJsLike | number | string | null
    totalsJson?: NullableJsonNullValueInput | InputJsonValue
    itemsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuotationItemUpdateWithoutQuotationInput = {
    sourceRow?: NullableIntFieldUpdateOperationsInput | number | null
    itemCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    normalizedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matchScore?: NullableFloatFieldUpdateOperationsInput | number | null
    extraAttributes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baselineItem?: QuotationBaselineItemUpdateOneWithoutQuoteItemsNestedInput
    material?: MaterialUpdateOneWithoutQuoteItemsNestedInput
  }

  export type QuotationItemUncheckedUpdateWithoutQuotationInput = {
    id?: IntFieldUpdateOperationsInput | number
    baselineItemId?: NullableIntFieldUpdateOperationsInput | number | null
    materialId?: NullableIntFieldUpdateOperationsInput | number | null
    sourceRow?: NullableIntFieldUpdateOperationsInput | number | null
    itemCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    normalizedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matchScore?: NullableFloatFieldUpdateOperationsInput | number | null
    extraAttributes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotationItemUncheckedUpdateManyWithoutQuotationInput = {
    id?: IntFieldUpdateOperationsInput | number
    baselineItemId?: NullableIntFieldUpdateOperationsInput | number | null
    materialId?: NullableIntFieldUpdateOperationsInput | number | null
    sourceRow?: NullableIntFieldUpdateOperationsInput | number | null
    itemCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    normalizedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matchScore?: NullableFloatFieldUpdateOperationsInput | number | null
    extraAttributes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotationAttachmentUpdateWithoutQuotationInput = {
    type?: EnumQuotationAttachmentTypeFieldUpdateOperationsInput | $Enums.QuotationAttachmentType
    originalName?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    parsed?: BoolFieldUpdateOperationsInput | boolean
    parsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    process?: QuotationProcessUpdateOneWithoutBaselineFileNestedInput
  }

  export type QuotationAttachmentUncheckedUpdateWithoutQuotationInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumQuotationAttachmentTypeFieldUpdateOperationsInput | $Enums.QuotationAttachmentType
    originalName?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    parsed?: BoolFieldUpdateOperationsInput | boolean
    parsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    process?: QuotationProcessUncheckedUpdateOneWithoutBaselineFileNestedInput
  }

  export type QuotationAttachmentUncheckedUpdateManyWithoutQuotationInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumQuotationAttachmentTypeFieldUpdateOperationsInput | $Enums.QuotationAttachmentType
    originalName?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    parsed?: BoolFieldUpdateOperationsInput | boolean
    parsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderLogUpdateWithoutQuotationInput = {
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    supplierName?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netSubtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    igv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalsJson?: NullableJsonNullValueInput | InputJsonValue
    itemsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    process?: QuotationProcessUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    lines?: PurchaseOrderLineUpdateManyWithoutOrderNestedInput
    deliveries?: PurchaseDeliveryLogUpdateManyWithoutOrderNestedInput
  }

  export type PurchaseOrderLogUncheckedUpdateWithoutQuotationInput = {
    id?: IntFieldUpdateOperationsInput | number
    processId?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    supplierName?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netSubtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    igv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalsJson?: NullableJsonNullValueInput | InputJsonValue
    itemsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: PurchaseOrderLineUncheckedUpdateManyWithoutOrderNestedInput
    deliveries?: PurchaseDeliveryLogUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type PurchaseOrderLogUncheckedUpdateManyWithoutQuotationInput = {
    id?: IntFieldUpdateOperationsInput | number
    processId?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    supplierName?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netSubtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    igv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalsJson?: NullableJsonNullValueInput | InputJsonValue
    itemsJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderLineCreateManyOrderInput = {
    id?: number
    baselineId?: number | null
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    unitPrice?: Decimal | DecimalJsLike | number | string | null
    totalPrice?: Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseDeliveryLogCreateManyOrderInput = {
    id?: number
    processId: number
    proveedorId?: number | null
    supplierName?: string | null
    guideNumber?: string | null
    date?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderLineUpdateWithoutOrderInput = {
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseline?: QuotationBaselineItemUpdateOneWithoutOrderLinesNestedInput
    deliveries?: PurchaseDeliveryItemUpdateManyWithoutOrderLineNestedInput
  }

  export type PurchaseOrderLineUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    baselineId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: PurchaseDeliveryItemUncheckedUpdateManyWithoutOrderLineNestedInput
  }

  export type PurchaseOrderLineUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    baselineId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseDeliveryLogUpdateWithoutOrderInput = {
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    guideNumber?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    process?: QuotationProcessUpdateOneRequiredWithoutDeliveryLogsNestedInput
    proveedor?: ProveedorUpdateOneWithoutDeliveriesNestedInput
    items?: PurchaseDeliveryItemUpdateManyWithoutDeliveryNestedInput
  }

  export type PurchaseDeliveryLogUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    processId?: IntFieldUpdateOperationsInput | number
    proveedorId?: NullableIntFieldUpdateOperationsInput | number | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    guideNumber?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseDeliveryItemUncheckedUpdateManyWithoutDeliveryNestedInput
  }

  export type PurchaseDeliveryLogUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    processId?: IntFieldUpdateOperationsInput | number
    proveedorId?: NullableIntFieldUpdateOperationsInput | number | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    guideNumber?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseDeliveryItemCreateManyOrderLineInput = {
    id?: number
    deliveryId: number
    baselineId?: number | null
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseDeliveryItemUpdateWithoutOrderLineInput = {
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    delivery?: PurchaseDeliveryLogUpdateOneRequiredWithoutItemsNestedInput
    baseline?: QuotationBaselineItemUpdateOneWithoutDeliveryItemsNestedInput
  }

  export type PurchaseDeliveryItemUncheckedUpdateWithoutOrderLineInput = {
    id?: IntFieldUpdateOperationsInput | number
    deliveryId?: IntFieldUpdateOperationsInput | number
    baselineId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseDeliveryItemUncheckedUpdateManyWithoutOrderLineInput = {
    id?: IntFieldUpdateOperationsInput | number
    deliveryId?: IntFieldUpdateOperationsInput | number
    baselineId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseDeliveryItemCreateManyDeliveryInput = {
    id?: number
    orderLineId?: number | null
    baselineId?: number | null
    description: string
    unit?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseDeliveryItemUpdateWithoutDeliveryInput = {
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderLine?: PurchaseOrderLineUpdateOneWithoutDeliveriesNestedInput
    baseline?: QuotationBaselineItemUpdateOneWithoutDeliveryItemsNestedInput
  }

  export type PurchaseDeliveryItemUncheckedUpdateWithoutDeliveryInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderLineId?: NullableIntFieldUpdateOperationsInput | number | null
    baselineId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseDeliveryItemUncheckedUpdateManyWithoutDeliveryInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderLineId?: NullableIntFieldUpdateOperationsInput | number | null
    baselineId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}